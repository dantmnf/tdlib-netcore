require 'zlib'
require_relative 'common'
require_relative 'crc32c'

def hashfn(x)
  CRC32c.checksum(x)
end

def fnv1a(x)
  hash = 2166136261
  x.each_byte do |octet|
    hash ^= octet
    hash *= 16777619
    hash &= 0xFFFFFFFF
  end
  hash
end

def hashof(name)
  sprintf("0x%08Xu", hashfn(name.to_s))
end

def readerof(type)
  type = TDLibTLTypeInfo::LazyResolver.resolve(type)
  case
  when type == "string"
    "reader.ReadString()"
  when type == "bool"
    "reader.ReadBool()"
  when type == "int"
    "reader.ReadInt()"
  when type == "long"
    "reader.ReadLong()"
  when type == "double"
    "reader.ReadDouble()"
  when type == "Memory<byte>"
    "reader.ReadBase64String()"
  when type == TDLibTLTypeInfo::Int64
    "reader.ReadInt64String()"
  when type == TDLibTLTypeInfo::Vector["string"]
    "reader.ReadStringArray()"
  when type == TDLibTLTypeInfo::Vector["Memory<byte>"]
    "reader.ReadBytesArray()"
  when type == TDLibTLTypeInfo::Vector["int"]
    "reader.ReadInt32Array()"
  when type == TDLibTLTypeInfo::Vector["long"]
    "reader.ReadInt53Array()"
  when type == TDLibTLTypeInfo::Vector[TDLibTLTypeInfo::Int64]
    "reader.ReadInt64Array()"
  when type.is_a?(Class) && type <= TDLibTLTypeInfo::Vector
    st, level = type.nestinfo
    st = TDLibTLTypeInfo::LazyResolver.resolve(st)
    raise RuntimeError.new(st) unless st.is_a?(TDLibTLTypeInfo::Type) || st.is_a?(TDLibTLTypeInfo::TLClass)
    case level
    when 1
      "reader.ReadObjectArray<#{st.to_s}>()"
    when 2
      "reader.ReadNestedObjectArray<#{st.to_s}>()"
    else
      raise NotImplementedError
    end
  else
    "reader.ReadTLObject<#{type}>()"
  end
end

def emit_type(io, type)
  csname = check_csharp_keyword type.name
  io.puts %Q{[TLType(#{type.realname.to_s.inspect})]}
  io.puts "partial class #{csname}Converter : TLObjectConverter<#{csname}>"
  io.puts "{"
  io.push
  io.puts "public static BaseConverter CreateConverterInstance() => new #{csname}Converter();"
  io.puts "public override TLObject CreateObjectInstance() => new #{csname}();"
  unless type.props.empty?
    io.puts "public override bool TdJsonReadItem(ref TdJsonReader reader, TLObject tlobj, ReadOnlySpan<byte> name)"
    io.puts "{"
    io.block do
      # io.puts "if (base.TdJsonReadItem(ref reader, tlobj, hash)) return true;"
      io.puts "var obj = (#{csname})tlobj;"
      propcount = type.props.length
      setters = type.props.map do |prop|
        propname = prop.capname
        if propname == type.name
          propname = "#{propname}_"
        end
        propname = check_csharp_keyword propname
        "obj.#{propname} = " + readerof(prop.type) + ";"
      end
      if propcount > 3
        io.puts "var keyhash = BaseConverter.GetHashCodeForPropertyName(name);"
        io.puts "switch (keyhash)"
        io.puts "{"
        io.block do
          type.props.zip(setters).each do |(prop, setter)|
            io.puts "case #{hashof(prop.name)} when name.SequenceEqual(propName_#{prop.name}):"
            io.block do
              io.puts setter
              io.puts "return true;"
            end
          end
        end
        io.puts "}"
      else
        type.props.zip(setters).each do |(prop, setter)|
          io.puts "if (name.SequenceEqual(propName_#{prop.name}))"
          io.puts "{"
          io.block do
            io.puts setter
            io.puts "return true;"
          end
          io.puts "}"
        end
      end
      io.puts "return false;"
    end
    io.puts "}"
  end
  io.pop
  io.puts "}"
  io.puts ""
end

def emit(out=STDOUT)
  io = IndentedOutput.new(out)
  io.puts "// generated by codegen/genreader.rb"
  io.puts "using System;"
  io.puts "using System.Text.Json;"
  io.puts "using TDLibCore.Api;"
  io.puts ""
  io.puts "namespace TDLibCore.JsonClient.ObjectConverter"
  io.puts "{"
  io.push
  
  TDLibTLTypeInfo::Types.each_value do |type|
    emit_type(io, type)
  end

  TDLibTLTypeInfo::Functions.each_value do |type|
    emit_type(io, type)
  end
  
  io.pop
  io.puts "}"
end

TDLibTLTypeInfo.load ARGV[0]
emit File.open(ARGV[1], 'wb')
