require_relative 'common'


def emit_type(io, pool, type)
  csname = check_csharp_keyword type.name
  io.puts "partial class #{csname}Converter"
  io.puts "{"
  io.block do
    io.puts "private static readonly JsonEncodedText JsonTypeName = JsonEncodedText.Encode(#{type.realname.to_s.inspect});"
    type.props.each do |prop|
      io.puts "private static readonly JsonEncodedText PropName_#{prop.name} = JsonEncodedText.Encode(#{prop.name.to_s.inspect});"
    end
    io.puts "internal override void TdJsonWriteUnclosedObject(Utf8JsonWriter writer, TLObject tlobj)"
    io.puts "{"
    io.block do
      io.puts "writer.WriteStartObject();"
      io.puts "writer.WriteString(TdJsonWriter.TypePropertyName, JsonTypeName);"
      unless type.props.empty?
        io.puts "var obj = (#{csname})tlobj;"
      end
      type.props.each do |prop|

        propname = prop.capname
        if propname == type.name
          propname = "#{propname}_"
        end
        csname = check_csharp_keyword propname

        case 
        when prop.type == "byte[]"
          io.puts "if (obj.#{csname} != null)"
          io.puts "{"
          io.block do
            io.puts "writer.WritePropertyName(PropName_#{prop.name});"
            io.puts "writer.WriteBase64StringValue(obj.#{csname});"
          end
          io.puts "}"
        when prop.type == 'int' || prop.type == 'long' || prop.type == 'double'
          io.puts "writer.WritePropertyName(PropName_#{prop.name});"
          io.puts "writer.WriteNumberValue(obj.#{csname});"
        when prop.type == 'string'
          io.puts "writer.WritePropertyName(PropName_#{prop.name});"
          io.puts "writer.WriteStringValue(obj.#{csname});"
        when prop.type == 'bool'
          io.puts "writer.WritePropertyName(PropName_#{prop.name});"
          io.puts "writer.WriteBooleanValue(obj.#{csname});"
        when prop.type == TDLibTLTypeInfo::Int64
          io.puts "writer.WritePropertyName(PropName_#{prop.name});"
          io.puts "writer.WriteInt64String(obj.#{csname});"
        when prop.type == TDLibTLTypeInfo::Vector[TDLibTLTypeInfo::Int64]
          io.puts "if (obj.#{csname} != null)"
          io.puts "{"
          io.block do
            io.puts "writer.WritePropertyName(PropName_#{prop.name});"
            io.puts "writer.WriteInt64Array(obj.#{csname});"
          end
          io.puts "}"
        when prop.type.is_a?(Class) && prop.type <= TDLibTLTypeInfo::Vector
          io.puts "if (obj.#{csname} != null)"
          io.puts "{"
          io.block do
            io.puts "writer.WritePropertyName(PropName_#{prop.name});"
            io.puts "writer.WriteArray(obj.#{csname});"
          end
          io.puts "}"
        else
          io.puts "if (obj.#{csname} != null)"
          io.puts "{"
          io.block do
            io.puts "writer.WritePropertyName(PropName_#{prop.name});"
            io.puts "writer.WriteTLObjectValue(obj.#{csname});"
          end
          io.puts "}"
        end
      end
      # io.puts "TdJsonWriteExtra(writer, ref tlobj);"
      # io.puts "writer.WriteEndObject();"

    end
    io.puts "}"
  end
  io.puts "}"
  io.puts ""
end

def emit(codeout)
  io = IndentedOutput.new(codeout)
  pool = StringPool.new(8)
  io.puts "// generated by codegen/genwriter.rb"
  io.puts "using System;"
  io.puts "using System.Text.Json;"
  io.puts "using TDLib.Api;"
  io.puts ""
  io.puts "namespace TDLib.JsonClient"
  io.puts "{"
  io.block do
    io.puts "namespace ObjectConverter"
    io.puts "{"
    io.block do
      TDLibTLTypeInfo::Types.each_value do |type|
        emit_type(io, pool, type)
      end
      
      TDLibTLTypeInfo::Functions.each_value do |type|
        emit_type(io, pool, type)
      end
    end
    io.puts "}"
    io.puts ""
    
  end
  io.puts "}"
end

TDLibTLTypeInfo.load ARGV[0]
emit File.open(ARGV[1], 'wb')
