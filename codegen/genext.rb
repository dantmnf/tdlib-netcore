require_relative 'common'


DefaultValue = {
  "int" => "0",
  "long" => "0",
  "double" => "0.0",
  "bool" => "false",
}
DefaultValue.default = "default"

def emit_function(io, type)
  return unless type.type == :function
  hascomment = type.comment && !type.comment.empty?
  sync = type.comment&.include?('Can be called synchronously')
  
  emit_doc = lambda do
    if hascomment
      io.puts "/// <summary>"
      io.puts "/// " + type.comment.encode(xml: :text)
      io.puts "/// </summary>"
    end
    type.props.each do |prop|
      unless prop.comment.empty?
        argname = prop.capname.sub(/[A-Z]/, &:downcase)
        io.puts "/// <param name=#{argname.to_s.encode(xml: :attr)}>" + prop.comment.encode(xml: :text) + "</param>"
      end
    end
  end
  emit_doc.call

  props = type.props.map do |prop|
    proptype = prop.type.to_s
    propname = prop.capname
    if propname == type.name
      propname = "#{propname}_"
    end
    [check_csharp_keyword(proptype), check_csharp_keyword(propname)]
  end

  arglist = props.map do |type, name|
    argname = check_csharp_keyword name.sub(/[A-Z]/, &:downcase)
    "#{type} #{argname} = #{DefaultValue[type]}"
  end

  restype = type.tl_class == :Ok ? 'void' : check_csharp_keyword(type.tl_class)
  asyncrestype = restype == 'void' ? 'Task' : "Task<#{restype}>"
  arglist2 = ["this Client client"] + arglist
  io.puts "public static async #{asyncrestype} #{check_csharp_keyword type.name}(#{arglist2.join(", ")})"

  io.puts "{"
  io.push

  emit_factory = lambda do
    if props.empty?
      io.puts "var obj = new #{check_csharp_keyword type.name}();"
    else
      io.puts "var obj = new #{check_csharp_keyword type.name}"
      io.puts "{"
      io.push
      props.each do |type, name|
        argname = check_csharp_keyword name.sub(/[A-Z]/, &:downcase)
        io.puts "#{name} = #{argname},"
      end
      io.pop
      io.puts "};"
    end
  end
  emit_factory.call

  if restype == 'void'
    io.puts "_ = await client.InvokeAsync<Ok>(obj);"
  else
    io.puts "return await client.InvokeAsync(obj);"
  end

  io.pop
  io.puts "}"
  io.puts ""

  if sync
    emit_doc.call
    io.puts "/// <remarks>This extension method is synchronous.</remarks>"
    arglist3 = ["this Client client"] + arglist
    io.puts "public static #{restype} #{check_csharp_keyword type.name}Sync(#{arglist3.join(", ")})"
    io.puts "{"
    io.push
    emit_factory.call
    if restype == 'void'
      io.puts "_ = client.Execute<Ok>(obj);"
    else
      io.puts "return client.Execute(obj);"
    end
    io.pop
    io.puts "}"
    io.puts ""
end

end

def emit(out=STDOUT)
  io = IndentedOutput.new(out)
  io.puts "// Generated by codegen/genext.rb"
  io.puts "using System;"
  io.puts "using System.Threading.Tasks;"
  io.puts "using TDLib;"
  io.puts "using TDLib.Api;"
  io.puts ""
  io.puts "namespace TDLib.ClientExtensions"
  io.puts "{"
  io.push
  io.puts "public static partial class ClientExtensions"
  io.puts "{"
  io.push
  TDLibTLTypeInfo::Functions.each_value do |type|
    emit_function(io, type)
  end
  io.pop
  io.puts "}"
  io.pop
  io.puts "}"
end

TDLibTLTypeInfo.load ARGV[0]
emit File.open(ARGV[1], 'wb')
