require_relative 'common'

def pinvoketype(type)
  case
  when type == "string"
    "CxxString"
  when type == "bool"
    "CxxBool"
  when type == "int"
    "CxxInt32"
  when type == "long"
    "CxxInt64"
  when type == "double"
    "CxxFloat64"
  when type == "Memory<byte>"
    "CxxBytes"
  when type.is_a?(Class) && type == TDLibTLTypeInfo::Int64
    "CxxInt64"
  when type == TDLibTLTypeInfo::Vector["int"]
    "CxxVectorInt32"
  when type == TDLibTLTypeInfo::Vector["long"]
    "CxxVectorInt64"
  when type == TDLibTLTypeInfo::Vector[TDLibTLTypeInfo::Int64]
    "CxxVectorInt64"
  when type == TDLibTLTypeInfo::Vector["Memory<byte>"]
    "CxxVectorBytes"
  when type == TDLibTLTypeInfo::Vector["string"]
    "CxxVectorString"
  when type.is_a?(Class) && type <= TDLibTLTypeInfo::Vector
    st, level = type.nestinfo
    case level
    when 1
      "CxxVectorObject<#{st.to_s}>"
    when 2
      "CxxVectorVectorObject<#{st.to_s}>"
    else
      raise NotImplementedError
    end
  else
    "CxxTLObject<#{type}>"
  end
end

def emit_type(io, type)
  cstype = check_csharp_keyword type.name
  io.puts "[TLTypeID(#{type.type_id})]"
  io.puts "internal unsafe class #{cstype}CxxBridge : ObjectBridge<#{cstype}>"
  io.puts "{"
  io.block do
    # we need a method to create delegate (fast) instead of Activator.CreateInstance or ConstructorInfo (slow)
    io.puts "public static BaseCxxBridge CreateInstance() => new #{cstype}CxxBridge();"
    supsec = "[SuppressUnmanagedCodeSecurity]"
    dllimport = '[DllImport(Native.LibraryName, CallingConvention = CallingConvention.Cdecl)]'
    # io.puts supsec
    io.puts dllimport
    io.puts "private static extern IntPtr td_bridge_newobj_#{type.realname}();"
    # type.props.each do |prop|
    #   # io.puts supsec
    #   io.puts dllimport
    #   wraptype = pinvoketype(prop.type)
    #   pitype = wraptype.include?('<') ? 'IntPtr' : wraptype
    #   io.puts "private static extern #{pitype} td_bridge_obj_#{type.realname}_#{prop.name}(IntPtr obj);"
    # end

    io.puts "public override IntPtr CreateCxxObject(TLObject obj)"
    io.puts "{"
    io.block do
      io.puts "var specobj = (#{cstype})obj;"
      io.puts "var cxxobj = td_bridge_newobj_#{type.realname}();"
      type.props.each do |prop|
        propname = prop.capname
        if propname == type.name
          propname = "#{propname}_"
        end
        csname = check_csharp_keyword propname
        wraptype = pinvoketype(prop.type)
        io.puts "new #{wraptype}(_MemberOffsets.GetMemberAddress(cxxobj, _MemberOffsetIndex.#{type.realname}_#{prop.name})).Set(specobj.#{csname});"
      end
      io.puts "return cxxobj;"
    end
    io.puts "}"

    
    io.puts "public override TLObject FetchCxxObject(IntPtr cxxobj)"
    io.puts "{"
    io.block do
      io.puts "var obj = new #{cstype}();"
      type.props.each do |prop|
        propname = prop.capname
        if propname == type.name
          propname = "#{propname}_"
        end
        csname = check_csharp_keyword propname
        wraptype = pinvoketype(prop.type)
        io.puts "obj.#{csname} = new #{wraptype}(_MemberOffsets.GetMemberAddress(cxxobj, _MemberOffsetIndex.#{type.realname}_#{prop.name})).Fetch();"
      end
      io.puts "return obj;"
    end
    io.puts "}"
  end
  io.puts "}"
  io.puts ""
end

def emit(out=STDOUT)
  io = IndentedOutput.new(out)
  io.puts "// Generated by codegen/gencxxbridge.rb"
  io.puts "using System;"
  io.puts "using System.Security;"
  io.puts "using System.Runtime.InteropServices;"
  io.puts "using TDLibCore.Api;"
  io.puts "using TDLibCore.NativeClient.CxxInterop;"
  io.puts ""
  io.puts "#pragma warning disable IDE1006 // Naming Styles"
  io.puts ""
  io.puts "namespace TDLibCore.NativeClient.ObjectBridge"
  io.puts "{"
  io.push

  TDLibTLTypeInfo::Types.each_value do |type|
    emit_type(io, type)
  end

  TDLibTLTypeInfo::Functions.each_value do |type|
    emit_type(io, type)
  end

  io.pop
  io.puts "}"

end

TDLibTLTypeInfo.load ARGV[0]
emit File.open(ARGV[1], 'wb')
