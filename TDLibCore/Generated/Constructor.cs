// Generated by codegen/genctor.rb
using System;
using System.Threading.Tasks;
using TDLibCore;

namespace TDLibCore.Api
{
    public partial class Error
    {
        /// <summary>
        /// An object of this type can be returned on every function call, in case of an error
        /// </summary>
        public Error() { }
        /// <summary>
        /// An object of this type can be returned on every function call, in case of an error
        /// </summary>
        /// <param name="code">Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user</param>
        /// <param name="message">Error message; subject to future changes</param>
        public Error(int code = default, string message = default)
        {
            this.Code = code;
            this.Message = message;
        }
    }

    public partial class Ok
    {
        /// <summary>
        /// An object of this type is returned on a successful function call for certain functions
        /// </summary>
        public Ok() { }
    }

    public partial class TdlibParameters
    {
        /// <summary>
        /// Contains parameters for TDLib initialization
        /// </summary>
        public TdlibParameters() { }
        /// <summary>
        /// Contains parameters for TDLib initialization
        /// </summary>
        /// <param name="useTestDc">If set to true, the Telegram test environment will be used instead of the production environment</param>
        /// <param name="databaseDirectory">The path to the directory for the persistent database; if empty, the current working directory will be used</param>
        /// <param name="filesDirectory">The path to the directory for storing files; if empty, database_directory will be used</param>
        /// <param name="useFileDatabase">If set to true, information about downloaded and uploaded files will be saved between application restarts</param>
        /// <param name="useChatInfoDatabase">If set to true, the library will maintain a cache of users, basic groups, supergroups, channels and secret chats. Implies use_file_database</param>
        /// <param name="useMessageDatabase">If set to true, the library will maintain a cache of chats and messages. Implies use_chat_info_database</param>
        /// <param name="useSecretChats">If set to true, support for secret chats will be enabled</param>
        /// <param name="apiId">Application identifier for Telegram API access, which can be obtained at https://my.telegram.org</param>
        /// <param name="apiHash">Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org</param>
        /// <param name="systemLanguageCode">IETF language tag of the user's operating system language; must be non-empty</param>
        /// <param name="deviceModel">Model of the device the application is being run on; must be non-empty</param>
        /// <param name="systemVersion">Version of the operating system the application is being run on. If empty, the version is automatically detected by TDLib</param>
        /// <param name="applicationVersion">Application version; must be non-empty</param>
        /// <param name="enableStorageOptimizer">If set to true, old files will automatically be deleted</param>
        /// <param name="ignoreFileNames">If set to true, original file names will be ignored. Otherwise, downloaded files will be saved under names as close as possible to the original name</param>
        public TdlibParameters(bool useTestDc = default, string databaseDirectory = default, string filesDirectory = default, bool useFileDatabase = default, bool useChatInfoDatabase = default, bool useMessageDatabase = default, bool useSecretChats = default, int apiId = default, string apiHash = default, string systemLanguageCode = default, string deviceModel = default, string systemVersion = default, string applicationVersion = default, bool enableStorageOptimizer = default, bool ignoreFileNames = default)
        {
            this.UseTestDc = useTestDc;
            this.DatabaseDirectory = databaseDirectory;
            this.FilesDirectory = filesDirectory;
            this.UseFileDatabase = useFileDatabase;
            this.UseChatInfoDatabase = useChatInfoDatabase;
            this.UseMessageDatabase = useMessageDatabase;
            this.UseSecretChats = useSecretChats;
            this.ApiId = apiId;
            this.ApiHash = apiHash;
            this.SystemLanguageCode = systemLanguageCode;
            this.DeviceModel = deviceModel;
            this.SystemVersion = systemVersion;
            this.ApplicationVersion = applicationVersion;
            this.EnableStorageOptimizer = enableStorageOptimizer;
            this.IgnoreFileNames = ignoreFileNames;
        }
    }

    public partial class AuthenticationCodeTypeTelegramMessage
    {
        /// <summary>
        /// An authentication code is delivered via a private Telegram message, which can be viewed from another active session
        /// </summary>
        public AuthenticationCodeTypeTelegramMessage() { }
        /// <summary>
        /// An authentication code is delivered via a private Telegram message, which can be viewed from another active session
        /// </summary>
        /// <param name="length">Length of the code</param>
        public AuthenticationCodeTypeTelegramMessage(int length = default)
        {
            this.Length = length;
        }
    }

    public partial class AuthenticationCodeTypeSms
    {
        /// <summary>
        /// An authentication code is delivered via an SMS message to the specified phone number
        /// </summary>
        public AuthenticationCodeTypeSms() { }
        /// <summary>
        /// An authentication code is delivered via an SMS message to the specified phone number
        /// </summary>
        /// <param name="length">Length of the code</param>
        public AuthenticationCodeTypeSms(int length = default)
        {
            this.Length = length;
        }
    }

    public partial class AuthenticationCodeTypeCall
    {
        /// <summary>
        /// An authentication code is delivered via a phone call to the specified phone number
        /// </summary>
        public AuthenticationCodeTypeCall() { }
        /// <summary>
        /// An authentication code is delivered via a phone call to the specified phone number
        /// </summary>
        /// <param name="length">Length of the code</param>
        public AuthenticationCodeTypeCall(int length = default)
        {
            this.Length = length;
        }
    }

    public partial class AuthenticationCodeTypeFlashCall
    {
        /// <summary>
        /// An authentication code is delivered by an immediately cancelled call to the specified phone number. The number from which the call was made is the code
        /// </summary>
        public AuthenticationCodeTypeFlashCall() { }
        /// <summary>
        /// An authentication code is delivered by an immediately cancelled call to the specified phone number. The number from which the call was made is the code
        /// </summary>
        /// <param name="pattern">Pattern of the phone number from which the call will be made</param>
        public AuthenticationCodeTypeFlashCall(string pattern = default)
        {
            this.Pattern = pattern;
        }
    }

    public partial class AuthenticationCodeInfo
    {
        /// <summary>
        /// Information about the authentication code that was sent
        /// </summary>
        public AuthenticationCodeInfo() { }
        /// <summary>
        /// Information about the authentication code that was sent
        /// </summary>
        /// <param name="phoneNumber">A phone number that is being authenticated</param>
        /// <param name="type">Describes the way the code was sent to the user</param>
        /// <param name="nextType">Describes the way the next code will be sent to the user; may be null</param>
        /// <param name="timeout">Timeout before the code should be re-sent, in seconds</param>
        public AuthenticationCodeInfo(string phoneNumber = default, AuthenticationCodeType type = default, AuthenticationCodeType nextType = default, int timeout = default)
        {
            this.PhoneNumber = phoneNumber;
            this.Type = type;
            this.NextType = nextType;
            this.Timeout = timeout;
        }
    }

    public partial class EmailAddressAuthenticationCodeInfo
    {
        /// <summary>
        /// Information about the email address authentication code that was sent
        /// </summary>
        public EmailAddressAuthenticationCodeInfo() { }
        /// <summary>
        /// Information about the email address authentication code that was sent
        /// </summary>
        /// <param name="emailAddressPattern">Pattern of the email address to which an authentication code was sent</param>
        /// <param name="length">Length of the code; 0 if unknown</param>
        public EmailAddressAuthenticationCodeInfo(string emailAddressPattern = default, int length = default)
        {
            this.EmailAddressPattern = emailAddressPattern;
            this.Length = length;
        }
    }

    public partial class TextEntity
    {
        /// <summary>
        /// Represents a part of the text that needs to be formatted in some unusual way
        /// </summary>
        public TextEntity() { }
        /// <summary>
        /// Represents a part of the text that needs to be formatted in some unusual way
        /// </summary>
        /// <param name="offset">Offset of the entity, in UTF-16 code units</param>
        /// <param name="length">Length of the entity, in UTF-16 code units</param>
        /// <param name="type">Type of the entity</param>
        public TextEntity(int offset = default, int length = default, TextEntityType type = default)
        {
            this.Offset = offset;
            this.Length = length;
            this.Type = type;
        }
    }

    public partial class TextEntities
    {
        /// <summary>
        /// Contains a list of text entities
        /// </summary>
        public TextEntities() { }
        /// <summary>
        /// Contains a list of text entities
        /// </summary>
        /// <param name="entities">List of text entities</param>
        public TextEntities(TextEntity[] entities = default)
        {
            this.Entities = entities;
        }
    }

    public partial class FormattedText
    {
        /// <summary>
        /// A text with some entities
        /// </summary>
        public FormattedText() { }
        /// <summary>
        /// A text with some entities
        /// </summary>
        /// <param name="text">The text</param>
        /// <param name="entities">Entities contained in the text. Entities can be nested, but must not mutually intersect with each other. -Pre, Code and PreCode entities can't contain other entities. Bold, Italic, Underline and Strikethrough entities can contain and to be contained in all other entities. All other entities can't contain each other</param>
        public FormattedText(string text = default, TextEntity[] entities = default)
        {
            this.Text = text;
            this.Entities = entities;
        }
    }

    public partial class TermsOfService
    {
        /// <summary>
        /// Contains Telegram terms of service
        /// </summary>
        public TermsOfService() { }
        /// <summary>
        /// Contains Telegram terms of service
        /// </summary>
        /// <param name="text">Text of the terms of service</param>
        /// <param name="minUserAge">The minimum age of a user to be able to accept the terms; 0 if any</param>
        /// <param name="showPopup">True, if a blocking popup with terms of service must be shown to the user</param>
        public TermsOfService(FormattedText text = default, int minUserAge = default, bool showPopup = default)
        {
            this.Text = text;
            this.MinUserAge = minUserAge;
            this.ShowPopup = showPopup;
        }
    }

    public partial class AuthorizationStateWaitTdlibParameters
    {
        /// <summary>
        /// TDLib needs TdlibParameters for initialization
        /// </summary>
        public AuthorizationStateWaitTdlibParameters() { }
    }

    public partial class AuthorizationStateWaitEncryptionKey
    {
        /// <summary>
        /// TDLib needs an encryption key to decrypt the local database
        /// </summary>
        public AuthorizationStateWaitEncryptionKey() { }
        /// <summary>
        /// TDLib needs an encryption key to decrypt the local database
        /// </summary>
        /// <param name="isEncrypted">True, if the database is currently encrypted</param>
        public AuthorizationStateWaitEncryptionKey(bool isEncrypted = default)
        {
            this.IsEncrypted = isEncrypted;
        }
    }

    public partial class AuthorizationStateWaitPhoneNumber
    {
        /// <summary>
        /// TDLib needs the user's phone number to authorize. Call `setAuthenticationPhoneNumber` to provide the phone number, or use `requestQrCodeAuthentication`, or `checkAuthenticationBotToken` for other authentication options
        /// </summary>
        public AuthorizationStateWaitPhoneNumber() { }
    }

    public partial class AuthorizationStateWaitCode
    {
        /// <summary>
        /// TDLib needs the user's authentication code to authorize
        /// </summary>
        public AuthorizationStateWaitCode() { }
        /// <summary>
        /// TDLib needs the user's authentication code to authorize
        /// </summary>
        /// <param name="codeInfo">Information about the authorization code that was sent</param>
        public AuthorizationStateWaitCode(AuthenticationCodeInfo codeInfo = default)
        {
            this.CodeInfo = codeInfo;
        }
    }

    public partial class AuthorizationStateWaitOtherDeviceConfirmation
    {
        /// <summary>
        /// The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link
        /// </summary>
        public AuthorizationStateWaitOtherDeviceConfirmation() { }
        /// <summary>
        /// The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link
        /// </summary>
        /// <param name="link">A tg:// URL for the QR code. The link will be updated frequently</param>
        public AuthorizationStateWaitOtherDeviceConfirmation(string link = default)
        {
            this.Link = link;
        }
    }

    public partial class AuthorizationStateWaitRegistration
    {
        /// <summary>
        /// The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration
        /// </summary>
        public AuthorizationStateWaitRegistration() { }
        /// <summary>
        /// The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration
        /// </summary>
        /// <param name="termsOfService">Telegram terms of service</param>
        public AuthorizationStateWaitRegistration(TermsOfService termsOfService = default)
        {
            this.TermsOfService = termsOfService;
        }
    }

    public partial class AuthorizationStateWaitPassword
    {
        /// <summary>
        /// The user has been authorized, but needs to enter a password to start using the application
        /// </summary>
        public AuthorizationStateWaitPassword() { }
        /// <summary>
        /// The user has been authorized, but needs to enter a password to start using the application
        /// </summary>
        /// <param name="passwordHint">Hint for the password; may be empty</param>
        /// <param name="hasRecoveryEmailAddress">True, if a recovery email address has been set up</param>
        /// <param name="recoveryEmailAddressPattern">Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent</param>
        public AuthorizationStateWaitPassword(string passwordHint = default, bool hasRecoveryEmailAddress = default, string recoveryEmailAddressPattern = default)
        {
            this.PasswordHint = passwordHint;
            this.HasRecoveryEmailAddress = hasRecoveryEmailAddress;
            this.RecoveryEmailAddressPattern = recoveryEmailAddressPattern;
        }
    }

    public partial class AuthorizationStateReady
    {
        /// <summary>
        /// The user has been successfully authorized. TDLib is now ready to answer queries
        /// </summary>
        public AuthorizationStateReady() { }
    }

    public partial class AuthorizationStateLoggingOut
    {
        /// <summary>
        /// The user is currently logging out
        /// </summary>
        public AuthorizationStateLoggingOut() { }
    }

    public partial class AuthorizationStateClosing
    {
        /// <summary>
        /// TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received
        /// </summary>
        public AuthorizationStateClosing() { }
    }

    public partial class AuthorizationStateClosed
    {
        /// <summary>
        /// TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to -with error code 500. To continue working, one should create a new instance of the TDLib client
        /// </summary>
        public AuthorizationStateClosed() { }
    }

    public partial class PasswordState
    {
        /// <summary>
        /// Represents the current state of 2-step verification
        /// </summary>
        public PasswordState() { }
        /// <summary>
        /// Represents the current state of 2-step verification
        /// </summary>
        /// <param name="hasPassword">True, if a 2-step verification password is set</param>
        /// <param name="passwordHint">Hint for the password; may be empty</param>
        /// <param name="hasRecoveryEmailAddress">True, if a recovery email is set</param>
        /// <param name="hasPassportData">True, if some Telegram Passport elements were saved</param>
        /// <param name="recoveryEmailAddressCodeInfo">Information about the recovery email address to which the confirmation email was sent; may be null</param>
        public PasswordState(bool hasPassword = default, string passwordHint = default, bool hasRecoveryEmailAddress = default, bool hasPassportData = default, EmailAddressAuthenticationCodeInfo recoveryEmailAddressCodeInfo = default)
        {
            this.HasPassword = hasPassword;
            this.PasswordHint = passwordHint;
            this.HasRecoveryEmailAddress = hasRecoveryEmailAddress;
            this.HasPassportData = hasPassportData;
            this.RecoveryEmailAddressCodeInfo = recoveryEmailAddressCodeInfo;
        }
    }

    public partial class RecoveryEmailAddress
    {
        /// <summary>
        /// Contains information about the current recovery email address
        /// </summary>
        public RecoveryEmailAddress() { }
        /// <summary>
        /// Contains information about the current recovery email address
        /// </summary>
        /// <param name="recoveryEmailAddress">Recovery email address</param>
        public RecoveryEmailAddress(string recoveryEmailAddress_ = default)
        {
            this.RecoveryEmailAddress_ = recoveryEmailAddress_;
        }
    }

    public partial class TemporaryPasswordState
    {
        /// <summary>
        /// Returns information about the availability of a temporary password, which can be used for payments
        /// </summary>
        public TemporaryPasswordState() { }
        /// <summary>
        /// Returns information about the availability of a temporary password, which can be used for payments
        /// </summary>
        /// <param name="hasPassword">True, if a temporary password is available</param>
        /// <param name="validFor">Time left before the temporary password expires, in seconds</param>
        public TemporaryPasswordState(bool hasPassword = default, int validFor = default)
        {
            this.HasPassword = hasPassword;
            this.ValidFor = validFor;
        }
    }

    public partial class LocalFile
    {
        /// <summary>
        /// Represents a local file
        /// </summary>
        public LocalFile() { }
        /// <summary>
        /// Represents a local file
        /// </summary>
        /// <param name="path">Local path to the locally available file part; may be empty</param>
        /// <param name="canBeDownloaded">True, if it is possible to try to download or generate the file</param>
        /// <param name="canBeDeleted">True, if the file can be deleted</param>
        /// <param name="isDownloadingActive">True, if the file is currently being downloaded (or a local copy is being generated by some other means)</param>
        /// <param name="isDownloadingCompleted">True, if the local copy is fully available</param>
        /// <param name="downloadOffset">Download will be started from this offset. downloaded_prefix_size is calculated from this offset</param>
        /// <param name="downloadedPrefixSize">If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix</param>
        /// <param name="downloadedSize">Total downloaded file bytes. Should be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage</param>
        public LocalFile(string path = default, bool canBeDownloaded = default, bool canBeDeleted = default, bool isDownloadingActive = default, bool isDownloadingCompleted = default, int downloadOffset = default, int downloadedPrefixSize = default, int downloadedSize = default)
        {
            this.Path = path;
            this.CanBeDownloaded = canBeDownloaded;
            this.CanBeDeleted = canBeDeleted;
            this.IsDownloadingActive = isDownloadingActive;
            this.IsDownloadingCompleted = isDownloadingCompleted;
            this.DownloadOffset = downloadOffset;
            this.DownloadedPrefixSize = downloadedPrefixSize;
            this.DownloadedSize = downloadedSize;
        }
    }

    public partial class RemoteFile
    {
        /// <summary>
        /// Represents a remote file
        /// </summary>
        public RemoteFile() { }
        /// <summary>
        /// Represents a remote file
        /// </summary>
        /// <param name="id">Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers. -If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. -If downloadFile is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application should generate the file by downloading it to the specified location</param>
        /// <param name="uniqueId">Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time</param>
        /// <param name="isUploadingActive">True, if the file is currently being uploaded (or a remote copy is being generated by some other means)</param>
        /// <param name="isUploadingCompleted">True, if a remote copy is fully available</param>
        /// <param name="uploadedSize">Size of the remote available part of the file; 0 if unknown</param>
        public RemoteFile(string id = default, string uniqueId = default, bool isUploadingActive = default, bool isUploadingCompleted = default, int uploadedSize = default)
        {
            this.Id = id;
            this.UniqueId = uniqueId;
            this.IsUploadingActive = isUploadingActive;
            this.IsUploadingCompleted = isUploadingCompleted;
            this.UploadedSize = uploadedSize;
        }
    }

    public partial class File
    {
        /// <summary>
        /// Represents a file
        /// </summary>
        public File() { }
        /// <summary>
        /// Represents a file
        /// </summary>
        /// <param name="id">Unique file identifier</param>
        /// <param name="size">File size; 0 if unknown</param>
        /// <param name="expectedSize">Expected file size in case the exact file size is unknown, but an approximate size is known. Can be used to show download/upload progress</param>
        /// <param name="local">Information about the local copy of the file</param>
        /// <param name="remote">Information about the remote copy of the file</param>
        public File(int id = default, int size = default, int expectedSize = default, LocalFile local = default, RemoteFile remote = default)
        {
            this.Id = id;
            this.Size = size;
            this.ExpectedSize = expectedSize;
            this.Local = local;
            this.Remote = remote;
        }
    }

    public partial class InputFileId
    {
        /// <summary>
        /// A file defined by its unique ID
        /// </summary>
        public InputFileId() { }
        /// <summary>
        /// A file defined by its unique ID
        /// </summary>
        /// <param name="id">Unique file identifier</param>
        public InputFileId(int id = default)
        {
            this.Id = id;
        }
    }

    public partial class InputFileRemote
    {
        /// <summary>
        /// A file defined by its remote ID. The remote ID is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib. -For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
        /// </summary>
        public InputFileRemote() { }
        /// <summary>
        /// A file defined by its remote ID. The remote ID is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib. -For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
        /// </summary>
        /// <param name="id">Remote file identifier</param>
        public InputFileRemote(string id = default)
        {
            this.Id = id;
        }
    }

    public partial class InputFileLocal
    {
        /// <summary>
        /// A file defined by a local path
        /// </summary>
        public InputFileLocal() { }
        /// <summary>
        /// A file defined by a local path
        /// </summary>
        /// <param name="path">Local path to the file</param>
        public InputFileLocal(string path = default)
        {
            this.Path = path;
        }
    }

    public partial class InputFileGenerated
    {
        /// <summary>
        /// A file generated by the application
        /// </summary>
        public InputFileGenerated() { }
        /// <summary>
        /// A file generated by the application
        /// </summary>
        /// <param name="originalPath">Local path to a file from which the file is generated; may be empty if there is no such file</param>
        /// <param name="conversion">String specifying the conversion applied to the original file; should be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage</param>
        /// <param name="expectedSize">Expected size of the generated file; 0 if unknown</param>
        public InputFileGenerated(string originalPath = default, string conversion = default, int expectedSize = default)
        {
            this.OriginalPath = originalPath;
            this.Conversion = conversion;
            this.ExpectedSize = expectedSize;
        }
    }

    public partial class PhotoSize
    {
        /// <summary>
        /// Describes an image in JPEG format
        /// </summary>
        public PhotoSize() { }
        /// <summary>
        /// Describes an image in JPEG format
        /// </summary>
        /// <param name="type">Image type (see https://core.telegram.org/constructor/photoSize)</param>
        /// <param name="photo">Information about the image file</param>
        /// <param name="width">Image width</param>
        /// <param name="height">Image height</param>
        /// <param name="progressiveSizes">Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image</param>
        public PhotoSize(string type = default, File photo = default, int width = default, int height = default, int[] progressiveSizes = default)
        {
            this.Type = type;
            this.Photo = photo;
            this.Width = width;
            this.Height = height;
            this.ProgressiveSizes = progressiveSizes;
        }
    }

    public partial class Minithumbnail
    {
        /// <summary>
        /// Thumbnail image of a very poor quality and low resolution
        /// </summary>
        public Minithumbnail() { }
        /// <summary>
        /// Thumbnail image of a very poor quality and low resolution
        /// </summary>
        /// <param name="width">Thumbnail width, usually doesn't exceed 40</param>
        /// <param name="height">Thumbnail height, usually doesn't exceed 40</param>
        /// <param name="data">The thumbnail in JPEG format</param>
        public Minithumbnail(int width = default, int height = default, Memory<byte> data = default)
        {
            this.Width = width;
            this.Height = height;
            this.Data = data;
        }
    }

    public partial class ThumbnailFormatJpeg
    {
        /// <summary>
        /// The thumbnail is in JPEG format
        /// </summary>
        public ThumbnailFormatJpeg() { }
    }

    public partial class ThumbnailFormatPng
    {
        /// <summary>
        /// The thumbnail is in PNG format. It will be used only for background patterns
        /// </summary>
        public ThumbnailFormatPng() { }
    }

    public partial class ThumbnailFormatWebp
    {
        /// <summary>
        /// The thumbnail is in WEBP format. It will be used only for some stickers
        /// </summary>
        public ThumbnailFormatWebp() { }
    }

    public partial class ThumbnailFormatGif
    {
        /// <summary>
        /// The thumbnail is in static GIF format. It will be used only for some bot inline results
        /// </summary>
        public ThumbnailFormatGif() { }
    }

    public partial class ThumbnailFormatTgs
    {
        /// <summary>
        /// The thumbnail is in TGS format. It will be used only for animated sticker sets
        /// </summary>
        public ThumbnailFormatTgs() { }
    }

    public partial class ThumbnailFormatMpeg4
    {
        /// <summary>
        /// The thumbnail is in MPEG4 format. It will be used only for some animations and videos
        /// </summary>
        public ThumbnailFormatMpeg4() { }
    }

    public partial class Thumbnail
    {
        /// <summary>
        /// Represents a thumbnail
        /// </summary>
        public Thumbnail() { }
        /// <summary>
        /// Represents a thumbnail
        /// </summary>
        /// <param name="format">Thumbnail format</param>
        /// <param name="width">Thumbnail width</param>
        /// <param name="height">Thumbnail height</param>
        /// <param name="file">The thumbnail</param>
        public Thumbnail(ThumbnailFormat format = default, int width = default, int height = default, File file = default)
        {
            this.Format = format;
            this.Width = width;
            this.Height = height;
            this.File = file;
        }
    }

    public partial class MaskPointForehead
    {
        /// <summary>
        /// A mask should be placed relatively to the forehead
        /// </summary>
        public MaskPointForehead() { }
    }

    public partial class MaskPointEyes
    {
        /// <summary>
        /// A mask should be placed relatively to the eyes
        /// </summary>
        public MaskPointEyes() { }
    }

    public partial class MaskPointMouth
    {
        /// <summary>
        /// A mask should be placed relatively to the mouth
        /// </summary>
        public MaskPointMouth() { }
    }

    public partial class MaskPointChin
    {
        /// <summary>
        /// A mask should be placed relatively to the chin
        /// </summary>
        public MaskPointChin() { }
    }

    public partial class MaskPosition
    {
        /// <summary>
        /// Position on a photo where a mask should be placed
        /// </summary>
        public MaskPosition() { }
        /// <summary>
        /// Position on a photo where a mask should be placed
        /// </summary>
        /// <param name="point">Part of the face, relative to which the mask should be placed</param>
        /// <param name="xShift">Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)</param>
        /// <param name="yShift">Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)</param>
        /// <param name="scale">Mask scaling coefficient. (For example, 2.0 means a doubled size)</param>
        public MaskPosition(MaskPoint point = default, double xShift = default, double yShift = default, double scale = default)
        {
            this.Point = point;
            this.XShift = xShift;
            this.YShift = yShift;
            this.Scale = scale;
        }
    }

    public partial class PollOption
    {
        /// <summary>
        /// Describes one answer option of a poll
        /// </summary>
        public PollOption() { }
        /// <summary>
        /// Describes one answer option of a poll
        /// </summary>
        /// <param name="text">Option text, 1-100 characters</param>
        /// <param name="voterCount">Number of voters for this option, available only for closed or voted polls</param>
        /// <param name="votePercentage">The percentage of votes for this option, 0-100</param>
        /// <param name="isChosen">True, if the option was chosen by the user</param>
        /// <param name="isBeingChosen">True, if the option is being chosen by a pending setPollAnswer request</param>
        public PollOption(string text = default, int voterCount = default, int votePercentage = default, bool isChosen = default, bool isBeingChosen = default)
        {
            this.Text = text;
            this.VoterCount = voterCount;
            this.VotePercentage = votePercentage;
            this.IsChosen = isChosen;
            this.IsBeingChosen = isBeingChosen;
        }
    }

    public partial class PollTypeRegular
    {
        /// <summary>
        /// A regular poll
        /// </summary>
        public PollTypeRegular() { }
        /// <summary>
        /// A regular poll
        /// </summary>
        /// <param name="allowMultipleAnswers">True, if multiple answer options can be chosen simultaneously</param>
        public PollTypeRegular(bool allowMultipleAnswers = default)
        {
            this.AllowMultipleAnswers = allowMultipleAnswers;
        }
    }

    public partial class PollTypeQuiz
    {
        /// <summary>
        /// A poll in quiz mode, which has exactly one correct answer option and can be answered only once
        /// </summary>
        public PollTypeQuiz() { }
        /// <summary>
        /// A poll in quiz mode, which has exactly one correct answer option and can be answered only once
        /// </summary>
        /// <param name="correctOptionId">0-based identifier of the correct answer option; -1 for a yet unanswered poll</param>
        /// <param name="explanation">Text that is shown when the user chooses an incorrect answer or taps on the lamp icon, 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll</param>
        public PollTypeQuiz(int correctOptionId = default, FormattedText explanation = default)
        {
            this.CorrectOptionId = correctOptionId;
            this.Explanation = explanation;
        }
    }

    public partial class Animation
    {
        /// <summary>
        /// Describes an animation file. The animation must be encoded in GIF or MPEG4 format
        /// </summary>
        public Animation() { }
        /// <summary>
        /// Describes an animation file. The animation must be encoded in GIF or MPEG4 format
        /// </summary>
        /// <param name="duration">Duration of the animation, in seconds; as defined by the sender</param>
        /// <param name="width">Width of the animation</param>
        /// <param name="height">Height of the animation</param>
        /// <param name="fileName">Original name of the file; as defined by the sender</param>
        /// <param name="mimeType">MIME type of the file, usually "image/gif" or "video/mp4"</param>
        /// <param name="hasStickers">True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets</param>
        /// <param name="minithumbnail">Animation minithumbnail; may be null</param>
        /// <param name="thumbnail">Animation thumbnail in JPEG or MPEG4 format; may be null</param>
        /// <param name="animation">File containing the animation</param>
        public Animation(int duration = default, int width = default, int height = default, string fileName = default, string mimeType = default, bool hasStickers = default, Minithumbnail minithumbnail = default, Thumbnail thumbnail = default, File animation_ = default)
        {
            this.Duration = duration;
            this.Width = width;
            this.Height = height;
            this.FileName = fileName;
            this.MimeType = mimeType;
            this.HasStickers = hasStickers;
            this.Minithumbnail = minithumbnail;
            this.Thumbnail = thumbnail;
            this.Animation_ = animation_;
        }
    }

    public partial class Audio
    {
        /// <summary>
        /// Describes an audio file. Audio is usually in MP3 or M4A format
        /// </summary>
        public Audio() { }
        /// <summary>
        /// Describes an audio file. Audio is usually in MP3 or M4A format
        /// </summary>
        /// <param name="duration">Duration of the audio, in seconds; as defined by the sender</param>
        /// <param name="title">Title of the audio; as defined by the sender</param>
        /// <param name="performer">Performer of the audio; as defined by the sender</param>
        /// <param name="fileName">Original name of the file; as defined by the sender</param>
        /// <param name="mimeType">The MIME type of the file; as defined by the sender</param>
        /// <param name="albumCoverMinithumbnail">The minithumbnail of the album cover; may be null</param>
        /// <param name="albumCoverThumbnail">The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail should be extracted from the downloaded file; may be null</param>
        /// <param name="audio">File containing the audio</param>
        public Audio(int duration = default, string title = default, string performer = default, string fileName = default, string mimeType = default, Minithumbnail albumCoverMinithumbnail = default, Thumbnail albumCoverThumbnail = default, File audio_ = default)
        {
            this.Duration = duration;
            this.Title = title;
            this.Performer = performer;
            this.FileName = fileName;
            this.MimeType = mimeType;
            this.AlbumCoverMinithumbnail = albumCoverMinithumbnail;
            this.AlbumCoverThumbnail = albumCoverThumbnail;
            this.Audio_ = audio_;
        }
    }

    public partial class Document
    {
        /// <summary>
        /// Describes a document of any type
        /// </summary>
        public Document() { }
        /// <summary>
        /// Describes a document of any type
        /// </summary>
        /// <param name="fileName">Original name of the file; as defined by the sender</param>
        /// <param name="mimeType">MIME type of the file; as defined by the sender</param>
        /// <param name="minithumbnail">Document minithumbnail; may be null</param>
        /// <param name="thumbnail">Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null</param>
        /// <param name="document">File containing the document</param>
        public Document(string fileName = default, string mimeType = default, Minithumbnail minithumbnail = default, Thumbnail thumbnail = default, File document_ = default)
        {
            this.FileName = fileName;
            this.MimeType = mimeType;
            this.Minithumbnail = minithumbnail;
            this.Thumbnail = thumbnail;
            this.Document_ = document_;
        }
    }

    public partial class Photo
    {
        /// <summary>
        /// Describes a photo
        /// </summary>
        public Photo() { }
        /// <summary>
        /// Describes a photo
        /// </summary>
        /// <param name="hasStickers">True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets</param>
        /// <param name="minithumbnail">Photo minithumbnail; may be null</param>
        /// <param name="sizes">Available variants of the photo, in different sizes</param>
        public Photo(bool hasStickers = default, Minithumbnail minithumbnail = default, PhotoSize[] sizes = default)
        {
            this.HasStickers = hasStickers;
            this.Minithumbnail = minithumbnail;
            this.Sizes = sizes;
        }
    }

    public partial class Sticker
    {
        /// <summary>
        /// Describes a sticker
        /// </summary>
        public Sticker() { }
        /// <summary>
        /// Describes a sticker
        /// </summary>
        /// <param name="setId">The identifier of the sticker set to which the sticker belongs; 0 if none</param>
        /// <param name="width">Sticker width; as defined by the sender</param>
        /// <param name="height">Sticker height; as defined by the sender</param>
        /// <param name="emoji">Emoji corresponding to the sticker</param>
        /// <param name="isAnimated">True, if the sticker is an animated sticker in TGS format</param>
        /// <param name="isMask">True, if the sticker is a mask</param>
        /// <param name="maskPosition">Position where the mask should be placed; may be null</param>
        /// <param name="thumbnail">Sticker thumbnail in WEBP or JPEG format; may be null</param>
        /// <param name="sticker">File containing the sticker</param>
        public Sticker(long setId = default, int width = default, int height = default, string emoji = default, bool isAnimated = default, bool isMask = default, MaskPosition maskPosition = default, Thumbnail thumbnail = default, File sticker_ = default)
        {
            this.SetId = setId;
            this.Width = width;
            this.Height = height;
            this.Emoji = emoji;
            this.IsAnimated = isAnimated;
            this.IsMask = isMask;
            this.MaskPosition = maskPosition;
            this.Thumbnail = thumbnail;
            this.Sticker_ = sticker_;
        }
    }

    public partial class Video
    {
        /// <summary>
        /// Describes a video file
        /// </summary>
        public Video() { }
        /// <summary>
        /// Describes a video file
        /// </summary>
        /// <param name="duration">Duration of the video, in seconds; as defined by the sender</param>
        /// <param name="width">Video width; as defined by the sender</param>
        /// <param name="height">Video height; as defined by the sender</param>
        /// <param name="fileName">Original name of the file; as defined by the sender</param>
        /// <param name="mimeType">MIME type of the file; as defined by the sender</param>
        /// <param name="hasStickers">True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets</param>
        /// <param name="supportsStreaming">True, if the video should be tried to be streamed</param>
        /// <param name="minithumbnail">Video minithumbnail; may be null</param>
        /// <param name="thumbnail">Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null</param>
        /// <param name="video">File containing the video</param>
        public Video(int duration = default, int width = default, int height = default, string fileName = default, string mimeType = default, bool hasStickers = default, bool supportsStreaming = default, Minithumbnail minithumbnail = default, Thumbnail thumbnail = default, File video_ = default)
        {
            this.Duration = duration;
            this.Width = width;
            this.Height = height;
            this.FileName = fileName;
            this.MimeType = mimeType;
            this.HasStickers = hasStickers;
            this.SupportsStreaming = supportsStreaming;
            this.Minithumbnail = minithumbnail;
            this.Thumbnail = thumbnail;
            this.Video_ = video_;
        }
    }

    public partial class VideoNote
    {
        /// <summary>
        /// Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format
        /// </summary>
        public VideoNote() { }
        /// <summary>
        /// Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format
        /// </summary>
        /// <param name="duration">Duration of the video, in seconds; as defined by the sender</param>
        /// <param name="length">Video width and height; as defined by the sender</param>
        /// <param name="minithumbnail">Video minithumbnail; may be null</param>
        /// <param name="thumbnail">Video thumbnail in JPEG format; as defined by the sender; may be null</param>
        /// <param name="video">File containing the video</param>
        public VideoNote(int duration = default, int length = default, Minithumbnail minithumbnail = default, Thumbnail thumbnail = default, File video = default)
        {
            this.Duration = duration;
            this.Length = length;
            this.Minithumbnail = minithumbnail;
            this.Thumbnail = thumbnail;
            this.Video = video;
        }
    }

    public partial class VoiceNote
    {
        /// <summary>
        /// Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel
        /// </summary>
        public VoiceNote() { }
        /// <summary>
        /// Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel
        /// </summary>
        /// <param name="duration">Duration of the voice note, in seconds; as defined by the sender</param>
        /// <param name="waveform">A waveform representation of the voice note in 5-bit format</param>
        /// <param name="mimeType">MIME type of the file; as defined by the sender</param>
        /// <param name="voice">File containing the voice note</param>
        public VoiceNote(int duration = default, Memory<byte> waveform = default, string mimeType = default, File voice = default)
        {
            this.Duration = duration;
            this.Waveform = waveform;
            this.MimeType = mimeType;
            this.Voice = voice;
        }
    }

    public partial class Contact
    {
        /// <summary>
        /// Describes a user contact
        /// </summary>
        public Contact() { }
        /// <summary>
        /// Describes a user contact
        /// </summary>
        /// <param name="phoneNumber">Phone number of the user</param>
        /// <param name="firstName">First name of the user; 1-255 characters in length</param>
        /// <param name="lastName">Last name of the user</param>
        /// <param name="vcard">Additional data about the user in a form of vCard; 0-2048 bytes in length</param>
        /// <param name="userId">Identifier of the user, if known; otherwise 0</param>
        public Contact(string phoneNumber = default, string firstName = default, string lastName = default, string vcard = default, int userId = default)
        {
            this.PhoneNumber = phoneNumber;
            this.FirstName = firstName;
            this.LastName = lastName;
            this.Vcard = vcard;
            this.UserId = userId;
        }
    }

    public partial class Location
    {
        /// <summary>
        /// Describes a location on planet Earth
        /// </summary>
        public Location() { }
        /// <summary>
        /// Describes a location on planet Earth
        /// </summary>
        /// <param name="latitude">Latitude of the location in degrees; as defined by the sender</param>
        /// <param name="longitude">Longitude of the location, in degrees; as defined by the sender</param>
        public Location(double latitude = default, double longitude = default)
        {
            this.Latitude = latitude;
            this.Longitude = longitude;
        }
    }

    public partial class Venue
    {
        /// <summary>
        /// Describes a venue
        /// </summary>
        public Venue() { }
        /// <summary>
        /// Describes a venue
        /// </summary>
        /// <param name="location">Venue location; as defined by the sender</param>
        /// <param name="title">Venue name; as defined by the sender</param>
        /// <param name="address">Venue address; as defined by the sender</param>
        /// <param name="provider">Provider of the venue database; as defined by the sender. Currently only "foursquare" and "gplaces" (Google Places) need to be supported</param>
        /// <param name="id">Identifier of the venue in the provider database; as defined by the sender</param>
        /// <param name="type">Type of the venue in the provider database; as defined by the sender</param>
        public Venue(Location location = default, string title = default, string address = default, string provider = default, string id = default, string type = default)
        {
            this.Location = location;
            this.Title = title;
            this.Address = address;
            this.Provider = provider;
            this.Id = id;
            this.Type = type;
        }
    }

    public partial class Game
    {
        /// <summary>
        /// Describes a game
        /// </summary>
        public Game() { }
        /// <summary>
        /// Describes a game
        /// </summary>
        /// <param name="id">Game ID</param>
        /// <param name="shortName">Game short name. To share a game use the URL https://t.me/{bot_username}?game={game_short_name}</param>
        /// <param name="title">Game title</param>
        /// <param name="text">Game text, usually containing scoreboards for a game</param>
        /// <param name="description">Describes a game</param>
        /// <param name="photo">Game photo</param>
        /// <param name="animation">Game animation; may be null</param>
        public Game(long id = default, string shortName = default, string title = default, FormattedText text = default, string description = default, Photo photo = default, Animation animation = default)
        {
            this.Id = id;
            this.ShortName = shortName;
            this.Title = title;
            this.Text = text;
            this.Description = description;
            this.Photo = photo;
            this.Animation = animation;
        }
    }

    public partial class Poll
    {
        /// <summary>
        /// Describes a poll
        /// </summary>
        public Poll() { }
        /// <summary>
        /// Describes a poll
        /// </summary>
        /// <param name="id">Unique poll identifier</param>
        /// <param name="question">Poll question, 1-300 characters</param>
        /// <param name="options">List of poll answer options</param>
        /// <param name="totalVoterCount">Total number of voters, participating in the poll</param>
        /// <param name="recentVoterUserIds">User identifiers of recent voters, if the poll is non-anonymous</param>
        /// <param name="isAnonymous">True, if the poll is anonymous</param>
        /// <param name="type">Type of the poll</param>
        /// <param name="openPeriod">Amount of time the poll will be active after creation, in seconds</param>
        /// <param name="closeDate">Point in time (Unix timestamp) when the poll will be automatically closed</param>
        /// <param name="isClosed">True, if the poll is closed</param>
        public Poll(long id = default, string question = default, PollOption[] options = default, int totalVoterCount = default, int[] recentVoterUserIds = default, bool isAnonymous = default, PollType type = default, int openPeriod = default, int closeDate = default, bool isClosed = default)
        {
            this.Id = id;
            this.Question = question;
            this.Options = options;
            this.TotalVoterCount = totalVoterCount;
            this.RecentVoterUserIds = recentVoterUserIds;
            this.IsAnonymous = isAnonymous;
            this.Type = type;
            this.OpenPeriod = openPeriod;
            this.CloseDate = closeDate;
            this.IsClosed = isClosed;
        }
    }

    public partial class ProfilePhoto
    {
        /// <summary>
        /// Describes a user profile photo
        /// </summary>
        public ProfilePhoto() { }
        /// <summary>
        /// Describes a user profile photo
        /// </summary>
        /// <param name="id">Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos</param>
        /// <param name="small">A small (160x160) user profile photo. The file can be downloaded only before the photo is changed</param>
        /// <param name="big">A big (640x640) user profile photo. The file can be downloaded only before the photo is changed</param>
        /// <param name="hasAnimation">True, if the photo has animated variant</param>
        public ProfilePhoto(long id = default, File small = default, File big = default, bool hasAnimation = default)
        {
            this.Id = id;
            this.Small = small;
            this.Big = big;
            this.HasAnimation = hasAnimation;
        }
    }

    public partial class ChatPhotoInfo
    {
        /// <summary>
        /// Contains basic information about the photo of a chat
        /// </summary>
        public ChatPhotoInfo() { }
        /// <summary>
        /// Contains basic information about the photo of a chat
        /// </summary>
        /// <param name="small">A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed</param>
        /// <param name="big">A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed</param>
        /// <param name="hasAnimation">True, if the photo has animated variant</param>
        public ChatPhotoInfo(File small = default, File big = default, bool hasAnimation = default)
        {
            this.Small = small;
            this.Big = big;
            this.HasAnimation = hasAnimation;
        }
    }

    public partial class UserTypeRegular
    {
        /// <summary>
        /// A regular user
        /// </summary>
        public UserTypeRegular() { }
    }

    public partial class UserTypeDeleted
    {
        /// <summary>
        /// A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user
        /// </summary>
        public UserTypeDeleted() { }
    }

    public partial class UserTypeBot
    {
        /// <summary>
        /// A bot (see https://core.telegram.org/bots)
        /// </summary>
        public UserTypeBot() { }
        /// <summary>
        /// A bot (see https://core.telegram.org/bots)
        /// </summary>
        /// <param name="canJoinGroups">True, if the bot can be invited to basic group and supergroup chats</param>
        /// <param name="canReadAllGroupMessages">True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages</param>
        /// <param name="isInline">True, if the bot supports inline queries</param>
        /// <param name="inlineQueryPlaceholder">Placeholder for inline queries (displayed on the application input field)</param>
        /// <param name="needLocation">True, if the location of the user should be sent with every inline query to this bot</param>
        public UserTypeBot(bool canJoinGroups = default, bool canReadAllGroupMessages = default, bool isInline = default, string inlineQueryPlaceholder = default, bool needLocation = default)
        {
            this.CanJoinGroups = canJoinGroups;
            this.CanReadAllGroupMessages = canReadAllGroupMessages;
            this.IsInline = isInline;
            this.InlineQueryPlaceholder = inlineQueryPlaceholder;
            this.NeedLocation = needLocation;
        }
    }

    public partial class UserTypeUnknown
    {
        /// <summary>
        /// No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type
        /// </summary>
        public UserTypeUnknown() { }
    }

    public partial class BotCommand
    {
        /// <summary>
        /// Represents a command supported by a bot
        /// </summary>
        public BotCommand() { }
        /// <summary>
        /// Represents a command supported by a bot
        /// </summary>
        /// <param name="command">Text of the bot command</param>
        /// <param name="description">Represents a command supported by a bot</param>
        public BotCommand(string command = default, string description = default)
        {
            this.Command = command;
            this.Description = description;
        }
    }

    public partial class BotInfo
    {
        /// <summary>
        /// Provides information about a bot and its supported commands
        /// </summary>
        public BotInfo() { }
        /// <summary>
        /// Provides information about a bot and its supported commands
        /// </summary>
        /// <param name="description">Provides information about a bot and its supported commands</param>
        /// <param name="commands">A list of commands supported by the bot</param>
        public BotInfo(string description = default, BotCommand[] commands = default)
        {
            this.Description = description;
            this.Commands = commands;
        }
    }

    public partial class ChatLocation
    {
        /// <summary>
        /// Represents a location to which a chat is connected
        /// </summary>
        public ChatLocation() { }
        /// <summary>
        /// Represents a location to which a chat is connected
        /// </summary>
        /// <param name="location">The location</param>
        /// <param name="address">Location address; 1-64 characters, as defined by the chat owner</param>
        public ChatLocation(Location location = default, string address = default)
        {
            this.Location = location;
            this.Address = address;
        }
    }

    public partial class AnimatedChatPhoto
    {
        /// <summary>
        /// Animated variant of a chat photo in MPEG4 format
        /// </summary>
        public AnimatedChatPhoto() { }
        /// <summary>
        /// Animated variant of a chat photo in MPEG4 format
        /// </summary>
        /// <param name="length">Animation width and height</param>
        /// <param name="file">Information about the animation file</param>
        /// <param name="mainFrameTimestamp">Timestamp of the frame, used as a static chat photo</param>
        public AnimatedChatPhoto(int length = default, File file = default, double mainFrameTimestamp = default)
        {
            this.Length = length;
            this.File = file;
            this.MainFrameTimestamp = mainFrameTimestamp;
        }
    }

    public partial class ChatPhoto
    {
        /// <summary>
        /// Describes a chat or user profile photo
        /// </summary>
        public ChatPhoto() { }
        /// <summary>
        /// Describes a chat or user profile photo
        /// </summary>
        /// <param name="id">Unique photo identifier</param>
        /// <param name="addedDate">Point in time (Unix timestamp) when the photo has been added</param>
        /// <param name="minithumbnail">Photo minithumbnail; may be null</param>
        /// <param name="sizes">Available variants of the photo in JPEG format, in different size</param>
        /// <param name="animation">Animated variant of the photo in MPEG4 format; may be null</param>
        public ChatPhoto(long id = default, int addedDate = default, Minithumbnail minithumbnail = default, PhotoSize[] sizes = default, AnimatedChatPhoto animation = default)
        {
            this.Id = id;
            this.AddedDate = addedDate;
            this.Minithumbnail = minithumbnail;
            this.Sizes = sizes;
            this.Animation = animation;
        }
    }

    public partial class ChatPhotos
    {
        /// <summary>
        /// Contains a list of chat or user profile photos
        /// </summary>
        public ChatPhotos() { }
        /// <summary>
        /// Contains a list of chat or user profile photos
        /// </summary>
        /// <param name="totalCount">Total number of photos</param>
        /// <param name="photos">List of photos</param>
        public ChatPhotos(int totalCount = default, ChatPhoto[] photos = default)
        {
            this.TotalCount = totalCount;
            this.Photos = photos;
        }
    }

    public partial class InputChatPhotoPrevious
    {
        /// <summary>
        /// A previously used profile photo of the current user
        /// </summary>
        public InputChatPhotoPrevious() { }
        /// <summary>
        /// A previously used profile photo of the current user
        /// </summary>
        /// <param name="chatPhotoId">Identifier of the profile photo to reuse</param>
        public InputChatPhotoPrevious(long chatPhotoId = default)
        {
            this.ChatPhotoId = chatPhotoId;
        }
    }

    public partial class InputChatPhotoStatic
    {
        /// <summary>
        /// A static photo in JPEG format
        /// </summary>
        public InputChatPhotoStatic() { }
        /// <summary>
        /// A static photo in JPEG format
        /// </summary>
        /// <param name="photo">Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed</param>
        public InputChatPhotoStatic(InputFile photo = default)
        {
            this.Photo = photo;
        }
    }

    public partial class InputChatPhotoAnimation
    {
        /// <summary>
        /// An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 800 and be at most 2MB in size
        /// </summary>
        public InputChatPhotoAnimation() { }
        /// <summary>
        /// An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 800 and be at most 2MB in size
        /// </summary>
        /// <param name="animation">Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed</param>
        /// <param name="mainFrameTimestamp">Timestamp of the frame, which will be used as static chat photo</param>
        public InputChatPhotoAnimation(InputFile animation = default, double mainFrameTimestamp = default)
        {
            this.Animation = animation;
            this.MainFrameTimestamp = mainFrameTimestamp;
        }
    }

    public partial class User
    {
        /// <summary>
        /// Represents a user
        /// </summary>
        public User() { }
        /// <summary>
        /// Represents a user
        /// </summary>
        /// <param name="id">User identifier</param>
        /// <param name="firstName">First name of the user</param>
        /// <param name="lastName">Last name of the user</param>
        /// <param name="username">Username of the user</param>
        /// <param name="phoneNumber">Phone number of the user</param>
        /// <param name="status">Current online status of the user</param>
        /// <param name="profilePhoto">Profile photo of the user; may be null</param>
        /// <param name="isContact">The user is a contact of the current user</param>
        /// <param name="isMutualContact">The user is a contact of the current user and the current user is a contact of the user</param>
        /// <param name="isVerified">True, if the user is verified</param>
        /// <param name="isSupport">True, if the user is Telegram support account</param>
        /// <param name="restrictionReason">If non-empty, it contains a human-readable description of the reason why access to this user must be restricted</param>
        /// <param name="isScam">True, if many users reported this user as a scam</param>
        /// <param name="haveAccess">If false, the user is inaccessible, and the only information known about the user is inside this class. It can't be passed to any method except GetUser</param>
        /// <param name="type">Type of the user</param>
        /// <param name="languageCode">IETF language tag of the user's language; only available to bots</param>
        public User(int id = default, string firstName = default, string lastName = default, string username = default, string phoneNumber = default, UserStatus status = default, ProfilePhoto profilePhoto = default, bool isContact = default, bool isMutualContact = default, bool isVerified = default, bool isSupport = default, string restrictionReason = default, bool isScam = default, bool haveAccess = default, UserType type = default, string languageCode = default)
        {
            this.Id = id;
            this.FirstName = firstName;
            this.LastName = lastName;
            this.Username = username;
            this.PhoneNumber = phoneNumber;
            this.Status = status;
            this.ProfilePhoto = profilePhoto;
            this.IsContact = isContact;
            this.IsMutualContact = isMutualContact;
            this.IsVerified = isVerified;
            this.IsSupport = isSupport;
            this.RestrictionReason = restrictionReason;
            this.IsScam = isScam;
            this.HaveAccess = haveAccess;
            this.Type = type;
            this.LanguageCode = languageCode;
        }
    }

    public partial class UserFullInfo
    {
        /// <summary>
        /// Contains full information about a user
        /// </summary>
        public UserFullInfo() { }
        /// <summary>
        /// Contains full information about a user
        /// </summary>
        /// <param name="photo">User profile photo; may be null</param>
        /// <param name="canBeCalled">True, if the user can be called</param>
        /// <param name="supportsVideoCalls">True, if a video call can be created with the user</param>
        /// <param name="hasPrivateCalls">True, if the user can't be called due to their privacy settings</param>
        /// <param name="needPhoneNumberPrivacyException">True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used</param>
        /// <param name="bio">A short user bio</param>
        /// <param name="shareText">For bots, the text that is included with the link when users share the bot</param>
        /// <param name="groupInCommonCount">Number of group chats where both the other user and the current user are a member; 0 for the current user</param>
        /// <param name="botInfo">If the user is a bot, information about the bot; may be null</param>
        public UserFullInfo(ChatPhoto photo = default, bool canBeCalled = default, bool supportsVideoCalls = default, bool hasPrivateCalls = default, bool needPhoneNumberPrivacyException = default, string bio = default, string shareText = default, int groupInCommonCount = default, BotInfo botInfo = default)
        {
            this.Photo = photo;
            this.CanBeCalled = canBeCalled;
            this.SupportsVideoCalls = supportsVideoCalls;
            this.HasPrivateCalls = hasPrivateCalls;
            this.NeedPhoneNumberPrivacyException = needPhoneNumberPrivacyException;
            this.Bio = bio;
            this.ShareText = shareText;
            this.GroupInCommonCount = groupInCommonCount;
            this.BotInfo = botInfo;
        }
    }

    public partial class Users
    {
        /// <summary>
        /// Represents a list of users
        /// </summary>
        public Users() { }
        /// <summary>
        /// Represents a list of users
        /// </summary>
        /// <param name="totalCount">Approximate total count of users found</param>
        /// <param name="userIds">A list of user identifiers</param>
        public Users(int totalCount = default, int[] userIds = default)
        {
            this.TotalCount = totalCount;
            this.UserIds = userIds;
        }
    }

    public partial class ChatAdministrator
    {
        /// <summary>
        /// Contains information about a chat administrator
        /// </summary>
        public ChatAdministrator() { }
        /// <summary>
        /// Contains information about a chat administrator
        /// </summary>
        /// <param name="userId">User identifier of the administrator</param>
        /// <param name="customTitle">Custom title of the administrator</param>
        /// <param name="isOwner">True, if the user is the owner of the chat</param>
        public ChatAdministrator(int userId = default, string customTitle = default, bool isOwner = default)
        {
            this.UserId = userId;
            this.CustomTitle = customTitle;
            this.IsOwner = isOwner;
        }
    }

    public partial class ChatAdministrators
    {
        /// <summary>
        /// Represents a list of chat administrators
        /// </summary>
        public ChatAdministrators() { }
        /// <summary>
        /// Represents a list of chat administrators
        /// </summary>
        /// <param name="administrators">A list of chat administrators</param>
        public ChatAdministrators(ChatAdministrator[] administrators = default)
        {
            this.Administrators = administrators;
        }
    }

    public partial class ChatPermissions
    {
        /// <summary>
        /// Describes actions that a user is allowed to take in a chat
        /// </summary>
        public ChatPermissions() { }
        /// <summary>
        /// Describes actions that a user is allowed to take in a chat
        /// </summary>
        /// <param name="canSendMessages">True, if the user can send text messages, contacts, locations, and venues</param>
        /// <param name="canSendMediaMessages">True, if the user can send audio files, documents, photos, videos, video notes, and voice notes. Implies can_send_messages permissions</param>
        /// <param name="canSendPolls">True, if the user can send polls. Implies can_send_messages permissions</param>
        /// <param name="canSendOtherMessages">True, if the user can send animations, games, stickers, and dice and use inline bots. Implies can_send_messages permissions</param>
        /// <param name="canAddWebPagePreviews">True, if the user may add a web page preview to their messages. Implies can_send_messages permissions</param>
        /// <param name="canChangeInfo">True, if the user can change the chat title, photo, and other settings</param>
        /// <param name="canInviteUsers">True, if the user can invite new users to the chat</param>
        /// <param name="canPinMessages">True, if the user can pin messages</param>
        public ChatPermissions(bool canSendMessages = default, bool canSendMediaMessages = default, bool canSendPolls = default, bool canSendOtherMessages = default, bool canAddWebPagePreviews = default, bool canChangeInfo = default, bool canInviteUsers = default, bool canPinMessages = default)
        {
            this.CanSendMessages = canSendMessages;
            this.CanSendMediaMessages = canSendMediaMessages;
            this.CanSendPolls = canSendPolls;
            this.CanSendOtherMessages = canSendOtherMessages;
            this.CanAddWebPagePreviews = canAddWebPagePreviews;
            this.CanChangeInfo = canChangeInfo;
            this.CanInviteUsers = canInviteUsers;
            this.CanPinMessages = canPinMessages;
        }
    }

    public partial class ChatMemberStatusCreator
    {
        /// <summary>
        /// The user is the owner of a chat and has all the administrator privileges
        /// </summary>
        public ChatMemberStatusCreator() { }
        /// <summary>
        /// The user is the owner of a chat and has all the administrator privileges
        /// </summary>
        /// <param name="customTitle">A custom title of the owner; 0-16 characters without emojis; applicable to supergroups only</param>
        /// <param name="isAnonymous">True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only</param>
        /// <param name="isMember">True, if the user is a member of the chat</param>
        public ChatMemberStatusCreator(string customTitle = default, bool isAnonymous = default, bool isMember = default)
        {
            this.CustomTitle = customTitle;
            this.IsAnonymous = isAnonymous;
            this.IsMember = isMember;
        }
    }

    public partial class ChatMemberStatusAdministrator
    {
        /// <summary>
        /// The user is a member of a chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, and ban unprivileged members. In supergroups and channels, there are more detailed options for administrator privileges
        /// </summary>
        public ChatMemberStatusAdministrator() { }
        /// <summary>
        /// The user is a member of a chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, and ban unprivileged members. In supergroups and channels, there are more detailed options for administrator privileges
        /// </summary>
        /// <param name="customTitle">A custom title of the administrator; 0-16 characters without emojis; applicable to supergroups only</param>
        /// <param name="canBeEdited">True, if the current user can edit the administrator privileges for the called user</param>
        /// <param name="canChangeInfo">True, if the administrator can change the chat title, photo, and other settings</param>
        /// <param name="canPostMessages">True, if the administrator can create channel posts; applicable to channels only</param>
        /// <param name="canEditMessages">True, if the administrator can edit messages of other users and pin messages; applicable to channels only</param>
        /// <param name="canDeleteMessages">True, if the administrator can delete messages of other users</param>
        /// <param name="canInviteUsers">True, if the administrator can invite new users to the chat</param>
        /// <param name="canRestrictMembers">True, if the administrator can restrict, ban, or unban chat members</param>
        /// <param name="canPinMessages">True, if the administrator can pin messages; applicable to groups only</param>
        /// <param name="canPromoteMembers">True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them</param>
        /// <param name="isAnonymous">True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only</param>
        public ChatMemberStatusAdministrator(string customTitle = default, bool canBeEdited = default, bool canChangeInfo = default, bool canPostMessages = default, bool canEditMessages = default, bool canDeleteMessages = default, bool canInviteUsers = default, bool canRestrictMembers = default, bool canPinMessages = default, bool canPromoteMembers = default, bool isAnonymous = default)
        {
            this.CustomTitle = customTitle;
            this.CanBeEdited = canBeEdited;
            this.CanChangeInfo = canChangeInfo;
            this.CanPostMessages = canPostMessages;
            this.CanEditMessages = canEditMessages;
            this.CanDeleteMessages = canDeleteMessages;
            this.CanInviteUsers = canInviteUsers;
            this.CanRestrictMembers = canRestrictMembers;
            this.CanPinMessages = canPinMessages;
            this.CanPromoteMembers = canPromoteMembers;
            this.IsAnonymous = isAnonymous;
        }
    }

    public partial class ChatMemberStatusMember
    {
        /// <summary>
        /// The user is a member of a chat, without any additional privileges or restrictions
        /// </summary>
        public ChatMemberStatusMember() { }
    }

    public partial class ChatMemberStatusRestricted
    {
        /// <summary>
        /// The user is under certain restrictions in the chat. Not supported in basic groups and channels
        /// </summary>
        public ChatMemberStatusRestricted() { }
        /// <summary>
        /// The user is under certain restrictions in the chat. Not supported in basic groups and channels
        /// </summary>
        /// <param name="isMember">True, if the user is a member of the chat</param>
        /// <param name="restrictedUntilDate">Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever</param>
        /// <param name="permissions">User permissions in the chat</param>
        public ChatMemberStatusRestricted(bool isMember = default, int restrictedUntilDate = default, ChatPermissions permissions = default)
        {
            this.IsMember = isMember;
            this.RestrictedUntilDate = restrictedUntilDate;
            this.Permissions = permissions;
        }
    }

    public partial class ChatMemberStatusLeft
    {
        /// <summary>
        /// The user is not a chat member
        /// </summary>
        public ChatMemberStatusLeft() { }
    }

    public partial class ChatMemberStatusBanned
    {
        /// <summary>
        /// The user was banned (and hence is not a member of the chat). Implies the user can't return to the chat or view messages
        /// </summary>
        public ChatMemberStatusBanned() { }
        /// <summary>
        /// The user was banned (and hence is not a member of the chat). Implies the user can't return to the chat or view messages
        /// </summary>
        /// <param name="bannedUntilDate">Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever</param>
        public ChatMemberStatusBanned(int bannedUntilDate = default)
        {
            this.BannedUntilDate = bannedUntilDate;
        }
    }

    public partial class ChatMember
    {
        /// <summary>
        /// A user with information about joining/leaving a chat
        /// </summary>
        public ChatMember() { }
        /// <summary>
        /// A user with information about joining/leaving a chat
        /// </summary>
        /// <param name="userId">User identifier of the chat member</param>
        /// <param name="inviterUserId">Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown</param>
        /// <param name="joinedChatDate">Point in time (Unix timestamp) when the user joined the chat</param>
        /// <param name="status">Status of the member in the chat</param>
        /// <param name="botInfo">If the user is a bot, information about the bot; may be null. Can be null even for a bot if the bot is not the chat member</param>
        public ChatMember(int userId = default, int inviterUserId = default, int joinedChatDate = default, ChatMemberStatus status = default, BotInfo botInfo = default)
        {
            this.UserId = userId;
            this.InviterUserId = inviterUserId;
            this.JoinedChatDate = joinedChatDate;
            this.Status = status;
            this.BotInfo = botInfo;
        }
    }

    public partial class ChatMembers
    {
        /// <summary>
        /// Contains a list of chat members
        /// </summary>
        public ChatMembers() { }
        /// <summary>
        /// Contains a list of chat members
        /// </summary>
        /// <param name="totalCount">Approximate total count of chat members found</param>
        /// <param name="members">A list of chat members</param>
        public ChatMembers(int totalCount = default, ChatMember[] members = default)
        {
            this.TotalCount = totalCount;
            this.Members = members;
        }
    }

    public partial class ChatMembersFilterContacts
    {
        /// <summary>
        /// Returns contacts of the user
        /// </summary>
        public ChatMembersFilterContacts() { }
    }

    public partial class ChatMembersFilterAdministrators
    {
        /// <summary>
        /// Returns the owner and administrators
        /// </summary>
        public ChatMembersFilterAdministrators() { }
    }

    public partial class ChatMembersFilterMembers
    {
        /// <summary>
        /// Returns all chat members, including restricted chat members
        /// </summary>
        public ChatMembersFilterMembers() { }
    }

    public partial class ChatMembersFilterRestricted
    {
        /// <summary>
        /// Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup
        /// </summary>
        public ChatMembersFilterRestricted() { }
    }

    public partial class ChatMembersFilterBanned
    {
        /// <summary>
        /// Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel
        /// </summary>
        public ChatMembersFilterBanned() { }
    }

    public partial class ChatMembersFilterBots
    {
        /// <summary>
        /// Returns bot members of the chat
        /// </summary>
        public ChatMembersFilterBots() { }
    }

    public partial class SupergroupMembersFilterRecent
    {
        /// <summary>
        /// Returns recently active users in reverse chronological order
        /// </summary>
        public SupergroupMembersFilterRecent() { }
    }

    public partial class SupergroupMembersFilterContacts
    {
        /// <summary>
        /// Returns contacts of the user, which are members of the supergroup or channel
        /// </summary>
        public SupergroupMembersFilterContacts() { }
        /// <summary>
        /// Returns contacts of the user, which are members of the supergroup or channel
        /// </summary>
        /// <param name="query">Query to search for</param>
        public SupergroupMembersFilterContacts(string query = default)
        {
            this.Query = query;
        }
    }

    public partial class SupergroupMembersFilterAdministrators
    {
        /// <summary>
        /// Returns the owner and administrators
        /// </summary>
        public SupergroupMembersFilterAdministrators() { }
    }

    public partial class SupergroupMembersFilterSearch
    {
        /// <summary>
        /// Used to search for supergroup or channel members via a (string) query
        /// </summary>
        public SupergroupMembersFilterSearch() { }
        /// <summary>
        /// Used to search for supergroup or channel members via a (string) query
        /// </summary>
        /// <param name="query">Query to search for</param>
        public SupergroupMembersFilterSearch(string query = default)
        {
            this.Query = query;
        }
    }

    public partial class SupergroupMembersFilterRestricted
    {
        /// <summary>
        /// Returns restricted supergroup members; can be used only by administrators
        /// </summary>
        public SupergroupMembersFilterRestricted() { }
        /// <summary>
        /// Returns restricted supergroup members; can be used only by administrators
        /// </summary>
        /// <param name="query">Query to search for</param>
        public SupergroupMembersFilterRestricted(string query = default)
        {
            this.Query = query;
        }
    }

    public partial class SupergroupMembersFilterBanned
    {
        /// <summary>
        /// Returns users banned from the supergroup or channel; can be used only by administrators
        /// </summary>
        public SupergroupMembersFilterBanned() { }
        /// <summary>
        /// Returns users banned from the supergroup or channel; can be used only by administrators
        /// </summary>
        /// <param name="query">Query to search for</param>
        public SupergroupMembersFilterBanned(string query = default)
        {
            this.Query = query;
        }
    }

    public partial class SupergroupMembersFilterBots
    {
        /// <summary>
        /// Returns bot members of the supergroup or channel
        /// </summary>
        public SupergroupMembersFilterBots() { }
    }

    public partial class BasicGroup
    {
        /// <summary>
        /// Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users)
        /// </summary>
        public BasicGroup() { }
        /// <summary>
        /// Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users)
        /// </summary>
        /// <param name="id">Group identifier</param>
        /// <param name="memberCount">Number of members in the group</param>
        /// <param name="status">Status of the current user in the group</param>
        /// <param name="isActive">True, if the group is active</param>
        /// <param name="upgradedToSupergroupId">Identifier of the supergroup to which this group was upgraded; 0 if none</param>
        public BasicGroup(int id = default, int memberCount = default, ChatMemberStatus status = default, bool isActive = default, int upgradedToSupergroupId = default)
        {
            this.Id = id;
            this.MemberCount = memberCount;
            this.Status = status;
            this.IsActive = isActive;
            this.UpgradedToSupergroupId = upgradedToSupergroupId;
        }
    }

    public partial class BasicGroupFullInfo
    {
        /// <summary>
        /// Contains full information about a basic group
        /// </summary>
        public BasicGroupFullInfo() { }
        /// <summary>
        /// Contains full information about a basic group
        /// </summary>
        /// <param name="photo">Chat photo; may be null</param>
        /// <param name="description">Contains full information about a basic group</param>
        /// <param name="creatorUserId">User identifier of the creator of the group; 0 if unknown</param>
        /// <param name="members">Group members</param>
        /// <param name="inviteLink">Invite link for this group; available only after it has been generated at least once and only for the group creator</param>
        public BasicGroupFullInfo(ChatPhoto photo = default, string description = default, int creatorUserId = default, ChatMember[] members = default, string inviteLink = default)
        {
            this.Photo = photo;
            this.Description = description;
            this.CreatorUserId = creatorUserId;
            this.Members = members;
            this.InviteLink = inviteLink;
        }
    }

    public partial class Supergroup
    {
        /// <summary>
        /// Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers
        /// </summary>
        public Supergroup() { }
        /// <summary>
        /// Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers
        /// </summary>
        /// <param name="id">Supergroup or channel identifier</param>
        /// <param name="username">Username of the supergroup or channel; empty for private supergroups or channels</param>
        /// <param name="date">Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member</param>
        /// <param name="status">Status of the current user in the supergroup or channel; custom title will be always empty</param>
        /// <param name="memberCount">Number of members in the supergroup or channel; 0 if unknown. Currently it is guaranteed to be known only if the supergroup or channel was received through searchPublicChats, searchChatsNearby, getInactiveSupergroupChats, getSuitableDiscussionChats, getGroupsInCommon, or getUserPrivacySettingRules</param>
        /// <param name="hasLinkedChat">True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel</param>
        /// <param name="hasLocation">True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup</param>
        /// <param name="signMessages">True, if messages sent to the channel should contain information about the sender. This field is only applicable to channels</param>
        /// <param name="isSlowModeEnabled">True, if the slow mode is enabled in the supergroup</param>
        /// <param name="isChannel">True, if the supergroup is a channel</param>
        /// <param name="isVerified">True, if the supergroup or channel is verified</param>
        /// <param name="restrictionReason">If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted</param>
        /// <param name="isScam">True, if many users reported this supergroup as a scam</param>
        public Supergroup(int id = default, string username = default, int date = default, ChatMemberStatus status = default, int memberCount = default, bool hasLinkedChat = default, bool hasLocation = default, bool signMessages = default, bool isSlowModeEnabled = default, bool isChannel = default, bool isVerified = default, string restrictionReason = default, bool isScam = default)
        {
            this.Id = id;
            this.Username = username;
            this.Date = date;
            this.Status = status;
            this.MemberCount = memberCount;
            this.HasLinkedChat = hasLinkedChat;
            this.HasLocation = hasLocation;
            this.SignMessages = signMessages;
            this.IsSlowModeEnabled = isSlowModeEnabled;
            this.IsChannel = isChannel;
            this.IsVerified = isVerified;
            this.RestrictionReason = restrictionReason;
            this.IsScam = isScam;
        }
    }

    public partial class SupergroupFullInfo
    {
        /// <summary>
        /// Contains full information about a supergroup or channel
        /// </summary>
        public SupergroupFullInfo() { }
        /// <summary>
        /// Contains full information about a supergroup or channel
        /// </summary>
        /// <param name="photo">Chat photo; may be null</param>
        /// <param name="description">Contains full information about a supergroup or channel</param>
        /// <param name="memberCount">Number of members in the supergroup or channel; 0 if unknown</param>
        /// <param name="administratorCount">Number of privileged users in the supergroup or channel; 0 if unknown</param>
        /// <param name="restrictedCount">Number of restricted users in the supergroup; 0 if unknown</param>
        /// <param name="bannedCount">Number of users banned from chat; 0 if unknown</param>
        /// <param name="linkedChatId">Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown</param>
        /// <param name="slowModeDelay">Delay between consecutive sent messages for non-administrator supergroup members, in seconds</param>
        /// <param name="slowModeDelayExpiresIn">Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero</param>
        /// <param name="canGetMembers">True, if members of the chat can be retrieved</param>
        /// <param name="canSetUsername">True, if the chat username can be changed</param>
        /// <param name="canSetStickerSet">True, if the supergroup sticker set can be changed</param>
        /// <param name="canSetLocation">True, if the supergroup location can be changed</param>
        /// <param name="canGetStatistics">True, if the supergroup or channel statistics are available</param>
        /// <param name="isAllHistoryAvailable">True, if new chat members will have access to old messages. In public or discussion groups and both public and private channels, old messages are always available, so this option affects only private supergroups without a linked chat. The value of this field is only available for chat administrators</param>
        /// <param name="stickerSetId">Identifier of the supergroup sticker set; 0 if none</param>
        /// <param name="location">Location to which the supergroup is connected; may be null</param>
        /// <param name="inviteLink">Invite link for this chat</param>
        /// <param name="upgradedFromBasicGroupId">Identifier of the basic group from which supergroup was upgraded; 0 if none</param>
        /// <param name="upgradedFromMaxMessageId">Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none</param>
        public SupergroupFullInfo(ChatPhoto photo = default, string description = default, int memberCount = default, int administratorCount = default, int restrictedCount = default, int bannedCount = default, long linkedChatId = default, int slowModeDelay = default, double slowModeDelayExpiresIn = default, bool canGetMembers = default, bool canSetUsername = default, bool canSetStickerSet = default, bool canSetLocation = default, bool canGetStatistics = default, bool isAllHistoryAvailable = default, long stickerSetId = default, ChatLocation location = default, string inviteLink = default, int upgradedFromBasicGroupId = default, long upgradedFromMaxMessageId = default)
        {
            this.Photo = photo;
            this.Description = description;
            this.MemberCount = memberCount;
            this.AdministratorCount = administratorCount;
            this.RestrictedCount = restrictedCount;
            this.BannedCount = bannedCount;
            this.LinkedChatId = linkedChatId;
            this.SlowModeDelay = slowModeDelay;
            this.SlowModeDelayExpiresIn = slowModeDelayExpiresIn;
            this.CanGetMembers = canGetMembers;
            this.CanSetUsername = canSetUsername;
            this.CanSetStickerSet = canSetStickerSet;
            this.CanSetLocation = canSetLocation;
            this.CanGetStatistics = canGetStatistics;
            this.IsAllHistoryAvailable = isAllHistoryAvailable;
            this.StickerSetId = stickerSetId;
            this.Location = location;
            this.InviteLink = inviteLink;
            this.UpgradedFromBasicGroupId = upgradedFromBasicGroupId;
            this.UpgradedFromMaxMessageId = upgradedFromMaxMessageId;
        }
    }

    public partial class SecretChatStatePending
    {
        /// <summary>
        /// The secret chat is not yet created; waiting for the other user to get online
        /// </summary>
        public SecretChatStatePending() { }
    }

    public partial class SecretChatStateReady
    {
        /// <summary>
        /// The secret chat is ready to use
        /// </summary>
        public SecretChatStateReady() { }
    }

    public partial class SecretChatStateClosed
    {
        /// <summary>
        /// The secret chat is closed
        /// </summary>
        public SecretChatStateClosed() { }
    }

    public partial class SecretChat
    {
        /// <summary>
        /// Represents a secret chat
        /// </summary>
        public SecretChat() { }
        /// <summary>
        /// Represents a secret chat
        /// </summary>
        /// <param name="id">Secret chat identifier</param>
        /// <param name="userId">Identifier of the chat partner</param>
        /// <param name="state">State of the secret chat</param>
        /// <param name="isOutbound">True, if the chat was created by the current user; otherwise false</param>
        /// <param name="ttl">Current message Time To Live setting (self-destruct timer) for the chat, in seconds</param>
        /// <param name="keyHash">Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9. -The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers</param>
        /// <param name="layer">Secret chat layer; determines features supported by the chat partner's application. Video notes are supported if the layer &gt;= 66; nested text entities and underline and strikethrough entities are supported if the layer &gt;= 101</param>
        public SecretChat(int id = default, int userId = default, SecretChatState state = default, bool isOutbound = default, int ttl = default, Memory<byte> keyHash = default, int layer = default)
        {
            this.Id = id;
            this.UserId = userId;
            this.State = state;
            this.IsOutbound = isOutbound;
            this.Ttl = ttl;
            this.KeyHash = keyHash;
            this.Layer = layer;
        }
    }

    public partial class MessageForwardOriginUser
    {
        /// <summary>
        /// The message was originally written by a known user
        /// </summary>
        public MessageForwardOriginUser() { }
        /// <summary>
        /// The message was originally written by a known user
        /// </summary>
        /// <param name="senderUserId">Identifier of the user that originally sent the message</param>
        public MessageForwardOriginUser(int senderUserId = default)
        {
            this.SenderUserId = senderUserId;
        }
    }

    public partial class MessageForwardOriginChat
    {
        /// <summary>
        /// The message was originally written by an anonymous chat administrator on behalf of the chat
        /// </summary>
        public MessageForwardOriginChat() { }
        /// <summary>
        /// The message was originally written by an anonymous chat administrator on behalf of the chat
        /// </summary>
        /// <param name="senderChatId">Identifier of the chat that originally sent the message</param>
        public MessageForwardOriginChat(long senderChatId = default)
        {
            this.SenderChatId = senderChatId;
        }
    }

    public partial class MessageForwardOriginHiddenUser
    {
        /// <summary>
        /// The message was originally written by a user, which is hidden by their privacy settings
        /// </summary>
        public MessageForwardOriginHiddenUser() { }
        /// <summary>
        /// The message was originally written by a user, which is hidden by their privacy settings
        /// </summary>
        /// <param name="senderName">Name of the sender</param>
        public MessageForwardOriginHiddenUser(string senderName = default)
        {
            this.SenderName = senderName;
        }
    }

    public partial class MessageForwardOriginChannel
    {
        /// <summary>
        /// The message was originally a post in a channel
        /// </summary>
        public MessageForwardOriginChannel() { }
        /// <summary>
        /// The message was originally a post in a channel
        /// </summary>
        /// <param name="chatId">Identifier of the chat from which the message was originally forwarded</param>
        /// <param name="messageId">Message identifier of the original message; 0 if unknown</param>
        /// <param name="authorSignature">Original post author signature</param>
        public MessageForwardOriginChannel(long chatId = default, long messageId = default, string authorSignature = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.AuthorSignature = authorSignature;
        }
    }

    public partial class MessageForwardInfo
    {
        /// <summary>
        /// Contains information about a forwarded message
        /// </summary>
        public MessageForwardInfo() { }
        /// <summary>
        /// Contains information about a forwarded message
        /// </summary>
        /// <param name="origin">Origin of a forwarded message</param>
        /// <param name="date">Point in time (Unix timestamp) when the message was originally sent</param>
        /// <param name="publicServiceAnnouncementType">The type of a public service announcement for the forwarded message</param>
        /// <param name="fromChatId">For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the chat from which the message was forwarded last time; 0 if unknown</param>
        /// <param name="fromMessageId">For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the original message from which the new message was forwarded last time; 0 if unknown</param>
        public MessageForwardInfo(MessageForwardOrigin origin = default, int date = default, string publicServiceAnnouncementType = default, long fromChatId = default, long fromMessageId = default)
        {
            this.Origin = origin;
            this.Date = date;
            this.PublicServiceAnnouncementType = publicServiceAnnouncementType;
            this.FromChatId = fromChatId;
            this.FromMessageId = fromMessageId;
        }
    }

    public partial class MessageReplyInfo
    {
        /// <summary>
        /// Contains information about message replies
        /// </summary>
        public MessageReplyInfo() { }
        /// <summary>
        /// Contains information about message replies
        /// </summary>
        /// <param name="replyCount">Number of times the message was directly or indirectly replied</param>
        /// <param name="recentReplierUserIds">User identifiers of the recent repliers to the message; available in channels with a discussion supergroup</param>
        /// <param name="lastReadInboxMessageId">Identifier of the last read incoming reply to the message</param>
        /// <param name="lastReadOutboxMessageId">Identifier of the last read outgoing reply to the message</param>
        /// <param name="lastMessageId">Identifier of the last reply to the message</param>
        public MessageReplyInfo(int replyCount = default, int[] recentReplierUserIds = default, long lastReadInboxMessageId = default, long lastReadOutboxMessageId = default, long lastMessageId = default)
        {
            this.ReplyCount = replyCount;
            this.RecentReplierUserIds = recentReplierUserIds;
            this.LastReadInboxMessageId = lastReadInboxMessageId;
            this.LastReadOutboxMessageId = lastReadOutboxMessageId;
            this.LastMessageId = lastMessageId;
        }
    }

    public partial class MessageInteractionInfo
    {
        /// <summary>
        /// Contains information about interactions with a message
        /// </summary>
        public MessageInteractionInfo() { }
        /// <summary>
        /// Contains information about interactions with a message
        /// </summary>
        /// <param name="viewCount">Number of times the message was viewed</param>
        /// <param name="forwardCount">Number of times the message was forwarded</param>
        /// <param name="replyInfo">Contains information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself</param>
        public MessageInteractionInfo(int viewCount = default, int forwardCount = default, MessageReplyInfo replyInfo = default)
        {
            this.ViewCount = viewCount;
            this.ForwardCount = forwardCount;
            this.ReplyInfo = replyInfo;
        }
    }

    public partial class MessageSendingStatePending
    {
        /// <summary>
        /// The message is being sent now, but has not yet been delivered to the server
        /// </summary>
        public MessageSendingStatePending() { }
    }

    public partial class MessageSendingStateFailed
    {
        /// <summary>
        /// The message failed to be sent
        /// </summary>
        public MessageSendingStateFailed() { }
        /// <summary>
        /// The message failed to be sent
        /// </summary>
        /// <param name="errorCode">An error code; 0 if unknown</param>
        /// <param name="errorMessage">Error message</param>
        /// <param name="canRetry">True, if the message can be re-sent</param>
        /// <param name="retryAfter">Time left before the message can be re-sent, in seconds. No update is sent when this field changes</param>
        public MessageSendingStateFailed(int errorCode = default, string errorMessage = default, bool canRetry = default, double retryAfter = default)
        {
            this.ErrorCode = errorCode;
            this.ErrorMessage = errorMessage;
            this.CanRetry = canRetry;
            this.RetryAfter = retryAfter;
        }
    }

    public partial class Message
    {
        /// <summary>
        /// Describes a message
        /// </summary>
        public Message() { }
        /// <summary>
        /// Describes a message
        /// </summary>
        /// <param name="id">Message identifier; unique for the chat to which the message belongs</param>
        /// <param name="senderUserId">Identifier of the user who sent the message; 0 if unknown. Currently, it is unknown for channel posts, for channel posts automatically forwarded to discussion group and for anonymously sent supergroup messages</param>
        /// <param name="senderChatId">Identifier of the chat on behalf of which the message was sent; 0 if none</param>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="sendingState">Information about the sending state of the message; may be null</param>
        /// <param name="schedulingState">Information about the scheduling state of the message; may be null</param>
        /// <param name="isOutgoing">True, if the message is outgoing</param>
        /// <param name="canBeEdited">True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application</param>
        /// <param name="canBeForwarded">True, if the message can be forwarded</param>
        /// <param name="canBeDeletedOnlyForSelf">True, if the message can be deleted only for the current user while other users will continue to see it</param>
        /// <param name="canBeDeletedForAllUsers">True, if the message can be deleted for all users</param>
        /// <param name="canGetStatistics">True, if the message statistics are available</param>
        /// <param name="canGetMessageThread">True, if the message thread info is available</param>
        /// <param name="isChannelPost">True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts</param>
        /// <param name="containsUnreadMention">True, if the message contains an unread mention for the current user</param>
        /// <param name="date">Point in time (Unix timestamp) when the message was sent</param>
        /// <param name="editDate">Point in time (Unix timestamp) when the message was last edited</param>
        /// <param name="forwardInfo">Information about the initial message sender; may be null</param>
        /// <param name="interactionInfo">Information about interactions with the message; may be null</param>
        /// <param name="replyInChatId">If non-zero, the identifier of the chat to which the replied message belongs; Currently, only messages in the Replies chat can have different reply_in_chat_id and chat_id</param>
        /// <param name="replyToMessageId">If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message</param>
        /// <param name="messageThreadId">If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs</param>
        /// <param name="ttl">For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires</param>
        /// <param name="ttlExpiresIn">Time left before the message expires, in seconds</param>
        /// <param name="viaBotUserId">If non-zero, the user identifier of the bot through which this message was sent</param>
        /// <param name="authorSignature">For channel posts, optional author signature</param>
        /// <param name="mediaAlbumId">Unique identifier of an album this message belongs to. Only photos and videos can be grouped together in albums</param>
        /// <param name="restrictionReason">If non-empty, contains a human-readable description of the reason why access to this message must be restricted</param>
        /// <param name="content">Content of the message</param>
        /// <param name="replyMarkup">Reply markup for the message; may be null</param>
        public Message(long id = default, int senderUserId = default, long senderChatId = default, long chatId = default, MessageSendingState sendingState = default, MessageSchedulingState schedulingState = default, bool isOutgoing = default, bool canBeEdited = default, bool canBeForwarded = default, bool canBeDeletedOnlyForSelf = default, bool canBeDeletedForAllUsers = default, bool canGetStatistics = default, bool canGetMessageThread = default, bool isChannelPost = default, bool containsUnreadMention = default, int date = default, int editDate = default, MessageForwardInfo forwardInfo = default, MessageInteractionInfo interactionInfo = default, long replyInChatId = default, long replyToMessageId = default, long messageThreadId = default, int ttl = default, double ttlExpiresIn = default, int viaBotUserId = default, string authorSignature = default, long mediaAlbumId = default, string restrictionReason = default, MessageContent content = default, ReplyMarkup replyMarkup = default)
        {
            this.Id = id;
            this.SenderUserId = senderUserId;
            this.SenderChatId = senderChatId;
            this.ChatId = chatId;
            this.SendingState = sendingState;
            this.SchedulingState = schedulingState;
            this.IsOutgoing = isOutgoing;
            this.CanBeEdited = canBeEdited;
            this.CanBeForwarded = canBeForwarded;
            this.CanBeDeletedOnlyForSelf = canBeDeletedOnlyForSelf;
            this.CanBeDeletedForAllUsers = canBeDeletedForAllUsers;
            this.CanGetStatistics = canGetStatistics;
            this.CanGetMessageThread = canGetMessageThread;
            this.IsChannelPost = isChannelPost;
            this.ContainsUnreadMention = containsUnreadMention;
            this.Date = date;
            this.EditDate = editDate;
            this.ForwardInfo = forwardInfo;
            this.InteractionInfo = interactionInfo;
            this.ReplyInChatId = replyInChatId;
            this.ReplyToMessageId = replyToMessageId;
            this.MessageThreadId = messageThreadId;
            this.Ttl = ttl;
            this.TtlExpiresIn = ttlExpiresIn;
            this.ViaBotUserId = viaBotUserId;
            this.AuthorSignature = authorSignature;
            this.MediaAlbumId = mediaAlbumId;
            this.RestrictionReason = restrictionReason;
            this.Content = content;
            this.ReplyMarkup = replyMarkup;
        }
    }

    public partial class Messages
    {
        /// <summary>
        /// Contains a list of messages
        /// </summary>
        public Messages() { }
        /// <summary>
        /// Contains a list of messages
        /// </summary>
        /// <param name="totalCount">Approximate total count of messages found</param>
        /// <param name="messages">List of messages; messages may be null</param>
        public Messages(int totalCount = default, Message[] messages_ = default)
        {
            this.TotalCount = totalCount;
            this.Messages_ = messages_;
        }
    }

    public partial class FoundMessages
    {
        /// <summary>
        /// Contains a list of messages found by a search
        /// </summary>
        public FoundMessages() { }
        /// <summary>
        /// Contains a list of messages found by a search
        /// </summary>
        /// <param name="totalCount">Approximate total count of messages found; -1 if unknown</param>
        /// <param name="messages">List of messages</param>
        /// <param name="nextOffset">The offset for the next request. If empty, there are no more results</param>
        public FoundMessages(int totalCount = default, Message[] messages = default, string nextOffset = default)
        {
            this.TotalCount = totalCount;
            this.Messages = messages;
            this.NextOffset = nextOffset;
        }
    }

    public partial class NotificationSettingsScopePrivateChats
    {
        /// <summary>
        /// Notification settings applied to all private and secret chats when the corresponding chat setting has a default value
        /// </summary>
        public NotificationSettingsScopePrivateChats() { }
    }

    public partial class NotificationSettingsScopeGroupChats
    {
        /// <summary>
        /// Notification settings applied to all basic groups and supergroups when the corresponding chat setting has a default value
        /// </summary>
        public NotificationSettingsScopeGroupChats() { }
    }

    public partial class NotificationSettingsScopeChannelChats
    {
        /// <summary>
        /// Notification settings applied to all channels when the corresponding chat setting has a default value
        /// </summary>
        public NotificationSettingsScopeChannelChats() { }
    }

    public partial class ChatNotificationSettings
    {
        /// <summary>
        /// Contains information about notification settings for a chat
        /// </summary>
        public ChatNotificationSettings() { }
        /// <summary>
        /// Contains information about notification settings for a chat
        /// </summary>
        /// <param name="useDefaultMuteFor">If true, mute_for is ignored and the value for the relevant type of chat is used instead</param>
        /// <param name="muteFor">Time left before notifications will be unmuted, in seconds</param>
        /// <param name="useDefaultSound">If true, sound is ignored and the value for the relevant type of chat is used instead</param>
        /// <param name="sound">The name of an audio file to be used for notification sounds; only applies to iOS applications</param>
        /// <param name="useDefaultShowPreview">If true, show_preview is ignored and the value for the relevant type of chat is used instead</param>
        /// <param name="showPreview">True, if message content should be displayed in notifications</param>
        /// <param name="useDefaultDisablePinnedMessageNotifications">If true, disable_pinned_message_notifications is ignored and the value for the relevant type of chat is used instead</param>
        /// <param name="disablePinnedMessageNotifications">If true, notifications for incoming pinned messages will be created as for an ordinary unread message</param>
        /// <param name="useDefaultDisableMentionNotifications">If true, disable_mention_notifications is ignored and the value for the relevant type of chat is used instead</param>
        /// <param name="disableMentionNotifications">If true, notifications for messages with mentions will be created as for an ordinary unread message</param>
        public ChatNotificationSettings(bool useDefaultMuteFor = default, int muteFor = default, bool useDefaultSound = default, string sound = default, bool useDefaultShowPreview = default, bool showPreview = default, bool useDefaultDisablePinnedMessageNotifications = default, bool disablePinnedMessageNotifications = default, bool useDefaultDisableMentionNotifications = default, bool disableMentionNotifications = default)
        {
            this.UseDefaultMuteFor = useDefaultMuteFor;
            this.MuteFor = muteFor;
            this.UseDefaultSound = useDefaultSound;
            this.Sound = sound;
            this.UseDefaultShowPreview = useDefaultShowPreview;
            this.ShowPreview = showPreview;
            this.UseDefaultDisablePinnedMessageNotifications = useDefaultDisablePinnedMessageNotifications;
            this.DisablePinnedMessageNotifications = disablePinnedMessageNotifications;
            this.UseDefaultDisableMentionNotifications = useDefaultDisableMentionNotifications;
            this.DisableMentionNotifications = disableMentionNotifications;
        }
    }

    public partial class ScopeNotificationSettings
    {
        /// <summary>
        /// Contains information about notification settings for several chats
        /// </summary>
        public ScopeNotificationSettings() { }
        /// <summary>
        /// Contains information about notification settings for several chats
        /// </summary>
        /// <param name="muteFor">Time left before notifications will be unmuted, in seconds</param>
        /// <param name="sound">The name of an audio file to be used for notification sounds; only applies to iOS applications</param>
        /// <param name="showPreview">True, if message content should be displayed in notifications</param>
        /// <param name="disablePinnedMessageNotifications">True, if notifications for incoming pinned messages will be created as for an ordinary unread message</param>
        /// <param name="disableMentionNotifications">True, if notifications for messages with mentions will be created as for an ordinary unread message</param>
        public ScopeNotificationSettings(int muteFor = default, string sound = default, bool showPreview = default, bool disablePinnedMessageNotifications = default, bool disableMentionNotifications = default)
        {
            this.MuteFor = muteFor;
            this.Sound = sound;
            this.ShowPreview = showPreview;
            this.DisablePinnedMessageNotifications = disablePinnedMessageNotifications;
            this.DisableMentionNotifications = disableMentionNotifications;
        }
    }

    public partial class DraftMessage
    {
        /// <summary>
        /// Contains information about a message draft
        /// </summary>
        public DraftMessage() { }
        /// <summary>
        /// Contains information about a message draft
        /// </summary>
        /// <param name="replyToMessageId">Identifier of the message to reply to; 0 if none</param>
        /// <param name="date">Point in time (Unix timestamp) when the draft was created</param>
        /// <param name="inputMessageText">Content of the message draft; this should always be of type inputMessageText</param>
        public DraftMessage(long replyToMessageId = default, int date = default, InputMessageContent inputMessageText = default)
        {
            this.ReplyToMessageId = replyToMessageId;
            this.Date = date;
            this.InputMessageText = inputMessageText;
        }
    }

    public partial class ChatTypePrivate
    {
        /// <summary>
        /// An ordinary chat with a user
        /// </summary>
        public ChatTypePrivate() { }
        /// <summary>
        /// An ordinary chat with a user
        /// </summary>
        /// <param name="userId">User identifier</param>
        public ChatTypePrivate(int userId = default)
        {
            this.UserId = userId;
        }
    }

    public partial class ChatTypeBasicGroup
    {
        /// <summary>
        /// A basic group (i.e., a chat with 0-200 other users)
        /// </summary>
        public ChatTypeBasicGroup() { }
        /// <summary>
        /// A basic group (i.e., a chat with 0-200 other users)
        /// </summary>
        /// <param name="basicGroupId">Basic group identifier</param>
        public ChatTypeBasicGroup(int basicGroupId = default)
        {
            this.BasicGroupId = basicGroupId;
        }
    }

    public partial class ChatTypeSupergroup
    {
        /// <summary>
        /// A supergroup (i.e. a chat with up to GetOption("supergroup_max_size") other users), or channel (with unlimited members)
        /// </summary>
        public ChatTypeSupergroup() { }
        /// <summary>
        /// A supergroup (i.e. a chat with up to GetOption("supergroup_max_size") other users), or channel (with unlimited members)
        /// </summary>
        /// <param name="supergroupId">Supergroup or channel identifier</param>
        /// <param name="isChannel">True, if the supergroup is a channel</param>
        public ChatTypeSupergroup(int supergroupId = default, bool isChannel = default)
        {
            this.SupergroupId = supergroupId;
            this.IsChannel = isChannel;
        }
    }

    public partial class ChatTypeSecret
    {
        /// <summary>
        /// A secret chat with a user
        /// </summary>
        public ChatTypeSecret() { }
        /// <summary>
        /// A secret chat with a user
        /// </summary>
        /// <param name="secretChatId">Secret chat identifier</param>
        /// <param name="userId">User identifier of the secret chat peer</param>
        public ChatTypeSecret(int secretChatId = default, int userId = default)
        {
            this.SecretChatId = secretChatId;
            this.UserId = userId;
        }
    }

    public partial class ChatFilter
    {
        /// <summary>
        /// Represents a filter of user chats
        /// </summary>
        public ChatFilter() { }
        /// <summary>
        /// Represents a filter of user chats
        /// </summary>
        /// <param name="title">The title of the filter; 1-12 characters without line feeds</param>
        /// <param name="iconName">The icon name for short filter representation. If non-empty, must be one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work". -If empty, use getChatFilterDefaultIconName to get default icon name for the filter</param>
        /// <param name="pinnedChatIds">The chat identifiers of pinned chats in the filtered chat list</param>
        /// <param name="includedChatIds">The chat identifiers of always included chats in the filtered chat list</param>
        /// <param name="excludedChatIds">The chat identifiers of always excluded chats in the filtered chat list</param>
        /// <param name="excludeMuted">True, if the muted chats need to be excluded</param>
        /// <param name="excludeRead">True, if read chats need to be excluded</param>
        /// <param name="excludeArchived">True, if archived chats need to be excluded</param>
        /// <param name="includeContacts">True, if contacts need to be included</param>
        /// <param name="includeNonContacts">True, if non-contact users need to be included</param>
        /// <param name="includeBots">True, if bots need to be included</param>
        /// <param name="includeGroups">True, if basic groups and supergroups need to be included</param>
        /// <param name="includeChannels">True, if channels need to be included</param>
        public ChatFilter(string title = default, string iconName = default, long[] pinnedChatIds = default, long[] includedChatIds = default, long[] excludedChatIds = default, bool excludeMuted = default, bool excludeRead = default, bool excludeArchived = default, bool includeContacts = default, bool includeNonContacts = default, bool includeBots = default, bool includeGroups = default, bool includeChannels = default)
        {
            this.Title = title;
            this.IconName = iconName;
            this.PinnedChatIds = pinnedChatIds;
            this.IncludedChatIds = includedChatIds;
            this.ExcludedChatIds = excludedChatIds;
            this.ExcludeMuted = excludeMuted;
            this.ExcludeRead = excludeRead;
            this.ExcludeArchived = excludeArchived;
            this.IncludeContacts = includeContacts;
            this.IncludeNonContacts = includeNonContacts;
            this.IncludeBots = includeBots;
            this.IncludeGroups = includeGroups;
            this.IncludeChannels = includeChannels;
        }
    }

    public partial class ChatFilterInfo
    {
        /// <summary>
        /// Contains basic information about a chat filter
        /// </summary>
        public ChatFilterInfo() { }
        /// <summary>
        /// Contains basic information about a chat filter
        /// </summary>
        /// <param name="id">Unique chat filter identifier</param>
        /// <param name="title">The title of the filter; 1-12 characters without line feeds</param>
        /// <param name="iconName">The icon name for short filter representation. One of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work"</param>
        public ChatFilterInfo(int id = default, string title = default, string iconName = default)
        {
            this.Id = id;
            this.Title = title;
            this.IconName = iconName;
        }
    }

    public partial class RecommendedChatFilter
    {
        /// <summary>
        /// Describes a recommended chat filter
        /// </summary>
        public RecommendedChatFilter() { }
        /// <summary>
        /// Describes a recommended chat filter
        /// </summary>
        /// <param name="filter">The chat filter</param>
        /// <param name="description">Describes a recommended chat filter</param>
        public RecommendedChatFilter(ChatFilter filter = default, string description = default)
        {
            this.Filter = filter;
            this.Description = description;
        }
    }

    public partial class RecommendedChatFilters
    {
        /// <summary>
        /// Contains a list of recommended chat filters
        /// </summary>
        public RecommendedChatFilters() { }
        /// <summary>
        /// Contains a list of recommended chat filters
        /// </summary>
        /// <param name="chatFilters">List of recommended chat filters</param>
        public RecommendedChatFilters(RecommendedChatFilter[] chatFilters = default)
        {
            this.ChatFilters = chatFilters;
        }
    }

    public partial class ChatListMain
    {
        /// <summary>
        /// A main list of chats
        /// </summary>
        public ChatListMain() { }
    }

    public partial class ChatListArchive
    {
        /// <summary>
        /// A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives
        /// </summary>
        public ChatListArchive() { }
    }

    public partial class ChatListFilter
    {
        /// <summary>
        /// A list of chats belonging to a chat filter
        /// </summary>
        public ChatListFilter() { }
        /// <summary>
        /// A list of chats belonging to a chat filter
        /// </summary>
        /// <param name="chatFilterId">Chat filter identifier</param>
        public ChatListFilter(int chatFilterId = default)
        {
            this.ChatFilterId = chatFilterId;
        }
    }

    public partial class ChatLists
    {
        /// <summary>
        /// Contains a list of chat lists
        /// </summary>
        public ChatLists() { }
        /// <summary>
        /// Contains a list of chat lists
        /// </summary>
        /// <param name="chatLists">List of chat lists</param>
        public ChatLists(ChatList[] chatLists_ = default)
        {
            this.ChatLists_ = chatLists_;
        }
    }

    public partial class ChatSourceMtprotoProxy
    {
        /// <summary>
        /// The chat is sponsored by the user's MTProxy server
        /// </summary>
        public ChatSourceMtprotoProxy() { }
    }

    public partial class ChatSourcePublicServiceAnnouncement
    {
        /// <summary>
        /// The chat contains a public service announcement
        /// </summary>
        public ChatSourcePublicServiceAnnouncement() { }
        /// <summary>
        /// The chat contains a public service announcement
        /// </summary>
        /// <param name="type">The type of the announcement</param>
        /// <param name="text">The text of the announcement</param>
        public ChatSourcePublicServiceAnnouncement(string type = default, string text = default)
        {
            this.Type = type;
            this.Text = text;
        }
    }

    public partial class ChatPosition
    {
        /// <summary>
        /// Describes a position of a chat in a chat list
        /// </summary>
        public ChatPosition() { }
        /// <summary>
        /// Describes a position of a chat in a chat list
        /// </summary>
        /// <param name="list">The chat list</param>
        /// <param name="order">A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order</param>
        /// <param name="isPinned">True, if the chat is pinned in the chat list</param>
        /// <param name="source">Source of the chat in the chat list; may be null</param>
        public ChatPosition(ChatList list = default, long order = default, bool isPinned = default, ChatSource source = default)
        {
            this.List = list;
            this.Order = order;
            this.IsPinned = isPinned;
            this.Source = source;
        }
    }

    public partial class Chat
    {
        /// <summary>
        /// A chat. (Can be a private chat, basic group, supergroup, or secret chat)
        /// </summary>
        public Chat() { }
        /// <summary>
        /// A chat. (Can be a private chat, basic group, supergroup, or secret chat)
        /// </summary>
        /// <param name="id">Chat unique identifier</param>
        /// <param name="type">Type of the chat</param>
        /// <param name="title">Chat title</param>
        /// <param name="photo">Chat photo; may be null</param>
        /// <param name="permissions">Actions that non-administrator chat members are allowed to take in the chat</param>
        /// <param name="lastMessage">Last message in the chat; may be null</param>
        /// <param name="positions">Positions of the chat in chat lists</param>
        /// <param name="isMarkedAsUnread">True, if the chat is marked as unread</param>
        /// <param name="isBlocked">True, if the chat is blocked by the current user and private messages from the chat can't be received</param>
        /// <param name="hasScheduledMessages">True, if the chat has scheduled messages</param>
        /// <param name="canBeDeletedOnlyForSelf">True, if the chat messages can be deleted only for the current user while other users will continue to see the messages</param>
        /// <param name="canBeDeletedForAllUsers">True, if the chat messages can be deleted for all users</param>
        /// <param name="canBeReported">True, if the chat can be reported to Telegram moderators through reportChat</param>
        /// <param name="defaultDisableNotification">Default value of the disable_notification parameter, used when a message is sent to the chat</param>
        /// <param name="unreadCount">Number of unread messages in the chat</param>
        /// <param name="lastReadInboxMessageId">Identifier of the last read incoming message</param>
        /// <param name="lastReadOutboxMessageId">Identifier of the last read outgoing message</param>
        /// <param name="unreadMentionCount">Number of unread messages with a mention/reply in the chat</param>
        /// <param name="notificationSettings">Notification settings for this chat</param>
        /// <param name="actionBar">Describes actions which should be possible to do through a chat action bar; may be null</param>
        /// <param name="pinnedMessageId">Identifier of the pinned message in the chat; 0 if none</param>
        /// <param name="replyMarkupMessageId">Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat</param>
        /// <param name="draftMessage">A draft of a message in the chat; may be null</param>
        /// <param name="clientData">Contains application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used</param>
        public Chat(long id = default, ChatType type = default, string title = default, ChatPhotoInfo photo = default, ChatPermissions permissions = default, Message lastMessage = default, ChatPosition[] positions = default, bool isMarkedAsUnread = default, bool isBlocked = default, bool hasScheduledMessages = default, bool canBeDeletedOnlyForSelf = default, bool canBeDeletedForAllUsers = default, bool canBeReported = default, bool defaultDisableNotification = default, int unreadCount = default, long lastReadInboxMessageId = default, long lastReadOutboxMessageId = default, int unreadMentionCount = default, ChatNotificationSettings notificationSettings = default, ChatActionBar actionBar = default, long pinnedMessageId = default, long replyMarkupMessageId = default, DraftMessage draftMessage = default, string clientData = default)
        {
            this.Id = id;
            this.Type = type;
            this.Title = title;
            this.Photo = photo;
            this.Permissions = permissions;
            this.LastMessage = lastMessage;
            this.Positions = positions;
            this.IsMarkedAsUnread = isMarkedAsUnread;
            this.IsBlocked = isBlocked;
            this.HasScheduledMessages = hasScheduledMessages;
            this.CanBeDeletedOnlyForSelf = canBeDeletedOnlyForSelf;
            this.CanBeDeletedForAllUsers = canBeDeletedForAllUsers;
            this.CanBeReported = canBeReported;
            this.DefaultDisableNotification = defaultDisableNotification;
            this.UnreadCount = unreadCount;
            this.LastReadInboxMessageId = lastReadInboxMessageId;
            this.LastReadOutboxMessageId = lastReadOutboxMessageId;
            this.UnreadMentionCount = unreadMentionCount;
            this.NotificationSettings = notificationSettings;
            this.ActionBar = actionBar;
            this.PinnedMessageId = pinnedMessageId;
            this.ReplyMarkupMessageId = replyMarkupMessageId;
            this.DraftMessage = draftMessage;
            this.ClientData = clientData;
        }
    }

    public partial class Chats
    {
        /// <summary>
        /// Represents a list of chats
        /// </summary>
        public Chats() { }
        /// <summary>
        /// Represents a list of chats
        /// </summary>
        /// <param name="totalCount">Approximate total count of chats found</param>
        /// <param name="chatIds">List of chat identifiers</param>
        public Chats(int totalCount = default, long[] chatIds = default)
        {
            this.TotalCount = totalCount;
            this.ChatIds = chatIds;
        }
    }

    public partial class ChatNearby
    {
        /// <summary>
        /// Describes a chat located nearby
        /// </summary>
        public ChatNearby() { }
        /// <summary>
        /// Describes a chat located nearby
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="distance">Distance to the chat location in meters</param>
        public ChatNearby(long chatId = default, int distance = default)
        {
            this.ChatId = chatId;
            this.Distance = distance;
        }
    }

    public partial class ChatsNearby
    {
        /// <summary>
        /// Represents a list of chats located nearby
        /// </summary>
        public ChatsNearby() { }
        /// <summary>
        /// Represents a list of chats located nearby
        /// </summary>
        /// <param name="usersNearby">List of users nearby</param>
        /// <param name="supergroupsNearby">List of location-based supergroups nearby</param>
        public ChatsNearby(ChatNearby[] usersNearby = default, ChatNearby[] supergroupsNearby = default)
        {
            this.UsersNearby = usersNearby;
            this.SupergroupsNearby = supergroupsNearby;
        }
    }

    public partial class ChatInviteLink
    {
        /// <summary>
        /// Contains a chat invite link
        /// </summary>
        public ChatInviteLink() { }
        /// <summary>
        /// Contains a chat invite link
        /// </summary>
        /// <param name="inviteLink">Chat invite link</param>
        public ChatInviteLink(string inviteLink = default)
        {
            this.InviteLink = inviteLink;
        }
    }

    public partial class ChatInviteLinkInfo
    {
        /// <summary>
        /// Contains information about a chat invite link
        /// </summary>
        public ChatInviteLinkInfo() { }
        /// <summary>
        /// Contains information about a chat invite link
        /// </summary>
        /// <param name="chatId">Chat identifier of the invite link; 0 if the user has no access to the chat before joining</param>
        /// <param name="accessibleFor">If non-zero, the remaining time for which read access is granted to the chat, in seconds</param>
        /// <param name="type">Contains information about the type of the chat</param>
        /// <param name="title">Title of the chat</param>
        /// <param name="photo">Chat photo; may be null</param>
        /// <param name="memberCount">Number of members in the chat</param>
        /// <param name="memberUserIds">User identifiers of some chat members that may be known to the current user</param>
        /// <param name="isPublic">True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup</param>
        public ChatInviteLinkInfo(long chatId = default, int accessibleFor = default, ChatType type = default, string title = default, ChatPhotoInfo photo = default, int memberCount = default, int[] memberUserIds = default, bool isPublic = default)
        {
            this.ChatId = chatId;
            this.AccessibleFor = accessibleFor;
            this.Type = type;
            this.Title = title;
            this.Photo = photo;
            this.MemberCount = memberCount;
            this.MemberUserIds = memberUserIds;
            this.IsPublic = isPublic;
        }
    }

    public partial class PublicChatTypeHasUsername
    {
        /// <summary>
        /// The chat is public, because it has username
        /// </summary>
        public PublicChatTypeHasUsername() { }
    }

    public partial class PublicChatTypeIsLocationBased
    {
        /// <summary>
        /// The chat is public, because it is a location-based supergroup
        /// </summary>
        public PublicChatTypeIsLocationBased() { }
    }

    public partial class ChatActionBarReportSpam
    {
        /// <summary>
        /// The chat can be reported as spam using the method reportChat with the reason chatReportReasonSpam
        /// </summary>
        public ChatActionBarReportSpam() { }
        /// <summary>
        /// The chat can be reported as spam using the method reportChat with the reason chatReportReasonSpam
        /// </summary>
        /// <param name="canUnarchive">If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings</param>
        public ChatActionBarReportSpam(bool canUnarchive = default)
        {
            this.CanUnarchive = canUnarchive;
        }
    }

    public partial class ChatActionBarReportUnrelatedLocation
    {
        /// <summary>
        /// The chat is a location-based supergroup, which can be reported as having unrelated location using the method reportChat with the reason chatReportReasonUnrelatedLocation
        /// </summary>
        public ChatActionBarReportUnrelatedLocation() { }
    }

    public partial class ChatActionBarReportAddBlock
    {
        /// <summary>
        /// The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method blockUser, or the other user can be added to the contact list using the method addContact
        /// </summary>
        public ChatActionBarReportAddBlock() { }
        /// <summary>
        /// The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method blockUser, or the other user can be added to the contact list using the method addContact
        /// </summary>
        /// <param name="canUnarchive">If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings</param>
        /// <param name="distance">If non-negative, the current user was found by the peer through searchChatsNearby and this is the distance between the users</param>
        public ChatActionBarReportAddBlock(bool canUnarchive = default, int distance = default)
        {
            this.CanUnarchive = canUnarchive;
            this.Distance = distance;
        }
    }

    public partial class ChatActionBarAddContact
    {
        /// <summary>
        /// The chat is a private or secret chat and the other user can be added to the contact list using the method addContact
        /// </summary>
        public ChatActionBarAddContact() { }
    }

    public partial class ChatActionBarSharePhoneNumber
    {
        /// <summary>
        /// The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber
        /// </summary>
        public ChatActionBarSharePhoneNumber() { }
    }

    public partial class KeyboardButtonTypeText
    {
        /// <summary>
        /// A simple button, with text that should be sent when the button is pressed
        /// </summary>
        public KeyboardButtonTypeText() { }
    }

    public partial class KeyboardButtonTypeRequestPhoneNumber
    {
        /// <summary>
        /// A button that sends the user's phone number when pressed; available only in private chats
        /// </summary>
        public KeyboardButtonTypeRequestPhoneNumber() { }
    }

    public partial class KeyboardButtonTypeRequestLocation
    {
        /// <summary>
        /// A button that sends the user's location when pressed; available only in private chats
        /// </summary>
        public KeyboardButtonTypeRequestLocation() { }
    }

    public partial class KeyboardButtonTypeRequestPoll
    {
        /// <summary>
        /// A button that allows the user to create and send a poll when pressed; available only in private chats
        /// </summary>
        public KeyboardButtonTypeRequestPoll() { }
        /// <summary>
        /// A button that allows the user to create and send a poll when pressed; available only in private chats
        /// </summary>
        /// <param name="forceRegular">If true, only regular polls must be allowed to create</param>
        /// <param name="forceQuiz">If true, only polls in quiz mode must be allowed to create</param>
        public KeyboardButtonTypeRequestPoll(bool forceRegular = default, bool forceQuiz = default)
        {
            this.ForceRegular = forceRegular;
            this.ForceQuiz = forceQuiz;
        }
    }

    public partial class KeyboardButton
    {
        /// <summary>
        /// Represents a single button in a bot keyboard
        /// </summary>
        public KeyboardButton() { }
        /// <summary>
        /// Represents a single button in a bot keyboard
        /// </summary>
        /// <param name="text">Text of the button</param>
        /// <param name="type">Type of the button</param>
        public KeyboardButton(string text = default, KeyboardButtonType type = default)
        {
            this.Text = text;
            this.Type = type;
        }
    }

    public partial class InlineKeyboardButtonTypeUrl
    {
        /// <summary>
        /// A button that opens a specified URL
        /// </summary>
        public InlineKeyboardButtonTypeUrl() { }
        /// <summary>
        /// A button that opens a specified URL
        /// </summary>
        /// <param name="url">HTTP or tg:// URL to open</param>
        public InlineKeyboardButtonTypeUrl(string url = default)
        {
            this.Url = url;
        }
    }

    public partial class InlineKeyboardButtonTypeLoginUrl
    {
        /// <summary>
        /// A button that opens a specified URL and automatically logs in in current user if they allowed to do that
        /// </summary>
        public InlineKeyboardButtonTypeLoginUrl() { }
        /// <summary>
        /// A button that opens a specified URL and automatically logs in in current user if they allowed to do that
        /// </summary>
        /// <param name="url">An HTTP URL to open</param>
        /// <param name="id">Unique button identifier</param>
        /// <param name="forwardText">If non-empty, new text of the button in forwarded messages</param>
        public InlineKeyboardButtonTypeLoginUrl(string url = default, int id = default, string forwardText = default)
        {
            this.Url = url;
            this.Id = id;
            this.ForwardText = forwardText;
        }
    }

    public partial class InlineKeyboardButtonTypeCallback
    {
        /// <summary>
        /// A button that sends a callback query to a bot
        /// </summary>
        public InlineKeyboardButtonTypeCallback() { }
        /// <summary>
        /// A button that sends a callback query to a bot
        /// </summary>
        /// <param name="data">Data to be sent to the bot via a callback query</param>
        public InlineKeyboardButtonTypeCallback(Memory<byte> data = default)
        {
            this.Data = data;
        }
    }

    public partial class InlineKeyboardButtonTypeCallbackWithPassword
    {
        /// <summary>
        /// A button that asks for password of the current user and then sends a callback query to a bot
        /// </summary>
        public InlineKeyboardButtonTypeCallbackWithPassword() { }
        /// <summary>
        /// A button that asks for password of the current user and then sends a callback query to a bot
        /// </summary>
        /// <param name="data">Data to be sent to the bot via a callback query</param>
        public InlineKeyboardButtonTypeCallbackWithPassword(Memory<byte> data = default)
        {
            this.Data = data;
        }
    }

    public partial class InlineKeyboardButtonTypeCallbackGame
    {
        /// <summary>
        /// A button with a game that sends a callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame
        /// </summary>
        public InlineKeyboardButtonTypeCallbackGame() { }
    }

    public partial class InlineKeyboardButtonTypeSwitchInline
    {
        /// <summary>
        /// A button that forces an inline query to the bot to be inserted in the input field
        /// </summary>
        public InlineKeyboardButtonTypeSwitchInline() { }
        /// <summary>
        /// A button that forces an inline query to the bot to be inserted in the input field
        /// </summary>
        /// <param name="query">Inline query to be sent to the bot</param>
        /// <param name="inCurrentChat">True, if the inline query should be sent from the current chat</param>
        public InlineKeyboardButtonTypeSwitchInline(string query = default, bool inCurrentChat = default)
        {
            this.Query = query;
            this.InCurrentChat = inCurrentChat;
        }
    }

    public partial class InlineKeyboardButtonTypeBuy
    {
        /// <summary>
        /// A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice
        /// </summary>
        public InlineKeyboardButtonTypeBuy() { }
    }

    public partial class InlineKeyboardButton
    {
        /// <summary>
        /// Represents a single button in an inline keyboard
        /// </summary>
        public InlineKeyboardButton() { }
        /// <summary>
        /// Represents a single button in an inline keyboard
        /// </summary>
        /// <param name="text">Text of the button</param>
        /// <param name="type">Type of the button</param>
        public InlineKeyboardButton(string text = default, InlineKeyboardButtonType type = default)
        {
            this.Text = text;
            this.Type = type;
        }
    }

    public partial class ReplyMarkupRemoveKeyboard
    {
        /// <summary>
        /// Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup with message_id == 0 will be sent
        /// </summary>
        public ReplyMarkupRemoveKeyboard() { }
        /// <summary>
        /// Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup with message_id == 0 will be sent
        /// </summary>
        /// <param name="isPersonal">True, if the keyboard is removed only for the mentioned users or the target user of a reply</param>
        public ReplyMarkupRemoveKeyboard(bool isPersonal = default)
        {
            this.IsPersonal = isPersonal;
        }
    }

    public partial class ReplyMarkupForceReply
    {
        /// <summary>
        /// Instructs application to force a reply to this message
        /// </summary>
        public ReplyMarkupForceReply() { }
        /// <summary>
        /// Instructs application to force a reply to this message
        /// </summary>
        /// <param name="isPersonal">True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply</param>
        public ReplyMarkupForceReply(bool isPersonal = default)
        {
            this.IsPersonal = isPersonal;
        }
    }

    public partial class ReplyMarkupShowKeyboard
    {
        /// <summary>
        /// Contains a custom keyboard layout to quickly reply to bots
        /// </summary>
        public ReplyMarkupShowKeyboard() { }
        /// <summary>
        /// Contains a custom keyboard layout to quickly reply to bots
        /// </summary>
        /// <param name="rows">A list of rows of bot keyboard buttons</param>
        /// <param name="resizeKeyboard">True, if the application needs to resize the keyboard vertically</param>
        /// <param name="oneTime">True, if the application needs to hide the keyboard after use</param>
        /// <param name="isPersonal">True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply</param>
        public ReplyMarkupShowKeyboard(KeyboardButton[][] rows = default, bool resizeKeyboard = default, bool oneTime = default, bool isPersonal = default)
        {
            this.Rows = rows;
            this.ResizeKeyboard = resizeKeyboard;
            this.OneTime = oneTime;
            this.IsPersonal = isPersonal;
        }
    }

    public partial class ReplyMarkupInlineKeyboard
    {
        /// <summary>
        /// Contains an inline keyboard layout
        /// </summary>
        public ReplyMarkupInlineKeyboard() { }
        /// <summary>
        /// Contains an inline keyboard layout
        /// </summary>
        /// <param name="rows">A list of rows of inline keyboard buttons</param>
        public ReplyMarkupInlineKeyboard(InlineKeyboardButton[][] rows = default)
        {
            this.Rows = rows;
        }
    }

    public partial class LoginUrlInfoOpen
    {
        /// <summary>
        /// An HTTP url needs to be open
        /// </summary>
        public LoginUrlInfoOpen() { }
        /// <summary>
        /// An HTTP url needs to be open
        /// </summary>
        /// <param name="url">The URL to open</param>
        /// <param name="skipConfirm">True, if there is no need to show an ordinary open URL confirm</param>
        public LoginUrlInfoOpen(string url = default, bool skipConfirm = default)
        {
            this.Url = url;
            this.SkipConfirm = skipConfirm;
        }
    }

    public partial class LoginUrlInfoRequestConfirmation
    {
        /// <summary>
        /// An authorization confirmation dialog needs to be shown to the user
        /// </summary>
        public LoginUrlInfoRequestConfirmation() { }
        /// <summary>
        /// An authorization confirmation dialog needs to be shown to the user
        /// </summary>
        /// <param name="url">An HTTP URL to be opened</param>
        /// <param name="domain">A domain of the URL</param>
        /// <param name="botUserId">User identifier of a bot linked with the website</param>
        /// <param name="requestWriteAccess">True, if the user needs to be requested to give the permission to the bot to send them messages</param>
        public LoginUrlInfoRequestConfirmation(string url = default, string domain = default, int botUserId = default, bool requestWriteAccess = default)
        {
            this.Url = url;
            this.Domain = domain;
            this.BotUserId = botUserId;
            this.RequestWriteAccess = requestWriteAccess;
        }
    }

    public partial class MessageThreadInfo
    {
        /// <summary>
        /// Contains information about a message thread
        /// </summary>
        public MessageThreadInfo() { }
        /// <summary>
        /// Contains information about a message thread
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which the message thread belongs</param>
        /// <param name="messageThreadId">Message thread identifier, unique within the chat</param>
        /// <param name="replyInfo">Contains information about the message thread</param>
        /// <param name="messages">The messages from which the thread starts. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)</param>
        /// <param name="draftMessage">A draft of a message in the message thread; may be null</param>
        public MessageThreadInfo(long chatId = default, long messageThreadId = default, MessageReplyInfo replyInfo = default, Message[] messages = default, DraftMessage draftMessage = default)
        {
            this.ChatId = chatId;
            this.MessageThreadId = messageThreadId;
            this.ReplyInfo = replyInfo;
            this.Messages = messages;
            this.DraftMessage = draftMessage;
        }
    }

    public partial class RichTextPlain
    {
        /// <summary>
        /// A plain text
        /// </summary>
        public RichTextPlain() { }
        /// <summary>
        /// A plain text
        /// </summary>
        /// <param name="text">Text</param>
        public RichTextPlain(string text = default)
        {
            this.Text = text;
        }
    }

    public partial class RichTextBold
    {
        /// <summary>
        /// A bold rich text
        /// </summary>
        public RichTextBold() { }
        /// <summary>
        /// A bold rich text
        /// </summary>
        /// <param name="text">Text</param>
        public RichTextBold(RichText text = default)
        {
            this.Text = text;
        }
    }

    public partial class RichTextItalic
    {
        /// <summary>
        /// An italicized rich text
        /// </summary>
        public RichTextItalic() { }
        /// <summary>
        /// An italicized rich text
        /// </summary>
        /// <param name="text">Text</param>
        public RichTextItalic(RichText text = default)
        {
            this.Text = text;
        }
    }

    public partial class RichTextUnderline
    {
        /// <summary>
        /// An underlined rich text
        /// </summary>
        public RichTextUnderline() { }
        /// <summary>
        /// An underlined rich text
        /// </summary>
        /// <param name="text">Text</param>
        public RichTextUnderline(RichText text = default)
        {
            this.Text = text;
        }
    }

    public partial class RichTextStrikethrough
    {
        /// <summary>
        /// A strikethrough rich text
        /// </summary>
        public RichTextStrikethrough() { }
        /// <summary>
        /// A strikethrough rich text
        /// </summary>
        /// <param name="text">Text</param>
        public RichTextStrikethrough(RichText text = default)
        {
            this.Text = text;
        }
    }

    public partial class RichTextFixed
    {
        /// <summary>
        /// A fixed-width rich text
        /// </summary>
        public RichTextFixed() { }
        /// <summary>
        /// A fixed-width rich text
        /// </summary>
        /// <param name="text">Text</param>
        public RichTextFixed(RichText text = default)
        {
            this.Text = text;
        }
    }

    public partial class RichTextUrl
    {
        /// <summary>
        /// A rich text URL link
        /// </summary>
        public RichTextUrl() { }
        /// <summary>
        /// A rich text URL link
        /// </summary>
        /// <param name="text">Text</param>
        /// <param name="url">URL</param>
        /// <param name="isCached">True, if the URL has cached instant view server-side</param>
        public RichTextUrl(RichText text = default, string url = default, bool isCached = default)
        {
            this.Text = text;
            this.Url = url;
            this.IsCached = isCached;
        }
    }

    public partial class RichTextEmailAddress
    {
        /// <summary>
        /// A rich text email link
        /// </summary>
        public RichTextEmailAddress() { }
        /// <summary>
        /// A rich text email link
        /// </summary>
        /// <param name="text">Text</param>
        /// <param name="emailAddress">Email address</param>
        public RichTextEmailAddress(RichText text = default, string emailAddress = default)
        {
            this.Text = text;
            this.EmailAddress = emailAddress;
        }
    }

    public partial class RichTextSubscript
    {
        /// <summary>
        /// A subscript rich text
        /// </summary>
        public RichTextSubscript() { }
        /// <summary>
        /// A subscript rich text
        /// </summary>
        /// <param name="text">Text</param>
        public RichTextSubscript(RichText text = default)
        {
            this.Text = text;
        }
    }

    public partial class RichTextSuperscript
    {
        /// <summary>
        /// A superscript rich text
        /// </summary>
        public RichTextSuperscript() { }
        /// <summary>
        /// A superscript rich text
        /// </summary>
        /// <param name="text">Text</param>
        public RichTextSuperscript(RichText text = default)
        {
            this.Text = text;
        }
    }

    public partial class RichTextMarked
    {
        /// <summary>
        /// A marked rich text
        /// </summary>
        public RichTextMarked() { }
        /// <summary>
        /// A marked rich text
        /// </summary>
        /// <param name="text">Text</param>
        public RichTextMarked(RichText text = default)
        {
            this.Text = text;
        }
    }

    public partial class RichTextPhoneNumber
    {
        /// <summary>
        /// A rich text phone number
        /// </summary>
        public RichTextPhoneNumber() { }
        /// <summary>
        /// A rich text phone number
        /// </summary>
        /// <param name="text">Text</param>
        /// <param name="phoneNumber">Phone number</param>
        public RichTextPhoneNumber(RichText text = default, string phoneNumber = default)
        {
            this.Text = text;
            this.PhoneNumber = phoneNumber;
        }
    }

    public partial class RichTextIcon
    {
        /// <summary>
        /// A small image inside the text
        /// </summary>
        public RichTextIcon() { }
        /// <summary>
        /// A small image inside the text
        /// </summary>
        /// <param name="document">The image represented as a document. The image can be in GIF, JPEG or PNG format</param>
        /// <param name="width">Width of a bounding box in which the image should be shown; 0 if unknown</param>
        /// <param name="height">Height of a bounding box in which the image should be shown; 0 if unknown</param>
        public RichTextIcon(Document document = default, int width = default, int height = default)
        {
            this.Document = document;
            this.Width = width;
            this.Height = height;
        }
    }

    public partial class RichTextReference
    {
        /// <summary>
        /// A rich text reference of a text on the same web page
        /// </summary>
        public RichTextReference() { }
        /// <summary>
        /// A rich text reference of a text on the same web page
        /// </summary>
        /// <param name="text">The text</param>
        /// <param name="referenceText">The text to show on click</param>
        /// <param name="url">An HTTP URL, opening the reference</param>
        public RichTextReference(RichText text = default, RichText referenceText = default, string url = default)
        {
            this.Text = text;
            this.ReferenceText = referenceText;
            this.Url = url;
        }
    }

    public partial class RichTextAnchor
    {
        /// <summary>
        /// An anchor
        /// </summary>
        public RichTextAnchor() { }
        /// <summary>
        /// An anchor
        /// </summary>
        /// <param name="name">Anchor name</param>
        public RichTextAnchor(string name = default)
        {
            this.Name = name;
        }
    }

    public partial class RichTextAnchorLink
    {
        /// <summary>
        /// A link to an anchor on the same web page
        /// </summary>
        public RichTextAnchorLink() { }
        /// <summary>
        /// A link to an anchor on the same web page
        /// </summary>
        /// <param name="text">The link text</param>
        /// <param name="name">The anchor name. If the name is empty, the link should bring back to top</param>
        /// <param name="url">An HTTP URL, opening the anchor</param>
        public RichTextAnchorLink(RichText text = default, string name = default, string url = default)
        {
            this.Text = text;
            this.Name = name;
            this.Url = url;
        }
    }

    public partial class RichTexts
    {
        /// <summary>
        /// A concatenation of rich texts
        /// </summary>
        public RichTexts() { }
        /// <summary>
        /// A concatenation of rich texts
        /// </summary>
        /// <param name="texts">Texts</param>
        public RichTexts(RichText[] texts = default)
        {
            this.Texts = texts;
        }
    }

    public partial class PageBlockCaption
    {
        /// <summary>
        /// Contains a caption of an instant view web page block, consisting of a text and a trailing credit
        /// </summary>
        public PageBlockCaption() { }
        /// <summary>
        /// Contains a caption of an instant view web page block, consisting of a text and a trailing credit
        /// </summary>
        /// <param name="text">Content of the caption</param>
        /// <param name="credit">Block credit (like HTML tag &lt;cite&gt;)</param>
        public PageBlockCaption(RichText text = default, RichText credit = default)
        {
            this.Text = text;
            this.Credit = credit;
        }
    }

    public partial class PageBlockListItem
    {
        /// <summary>
        /// Describes an item of a list page block
        /// </summary>
        public PageBlockListItem() { }
        /// <summary>
        /// Describes an item of a list page block
        /// </summary>
        /// <param name="label">Item label</param>
        /// <param name="pageBlocks">Item blocks</param>
        public PageBlockListItem(string label = default, PageBlock[] pageBlocks = default)
        {
            this.Label = label;
            this.PageBlocks = pageBlocks;
        }
    }

    public partial class PageBlockHorizontalAlignmentLeft
    {
        /// <summary>
        /// The content should be left-aligned
        /// </summary>
        public PageBlockHorizontalAlignmentLeft() { }
    }

    public partial class PageBlockHorizontalAlignmentCenter
    {
        /// <summary>
        /// The content should be center-aligned
        /// </summary>
        public PageBlockHorizontalAlignmentCenter() { }
    }

    public partial class PageBlockHorizontalAlignmentRight
    {
        /// <summary>
        /// The content should be right-aligned
        /// </summary>
        public PageBlockHorizontalAlignmentRight() { }
    }

    public partial class PageBlockVerticalAlignmentTop
    {
        /// <summary>
        /// The content should be top-aligned
        /// </summary>
        public PageBlockVerticalAlignmentTop() { }
    }

    public partial class PageBlockVerticalAlignmentMiddle
    {
        /// <summary>
        /// The content should be middle-aligned
        /// </summary>
        public PageBlockVerticalAlignmentMiddle() { }
    }

    public partial class PageBlockVerticalAlignmentBottom
    {
        /// <summary>
        /// The content should be bottom-aligned
        /// </summary>
        public PageBlockVerticalAlignmentBottom() { }
    }

    public partial class PageBlockTableCell
    {
        /// <summary>
        /// Represents a cell of a table
        /// </summary>
        public PageBlockTableCell() { }
        /// <summary>
        /// Represents a cell of a table
        /// </summary>
        /// <param name="text">Cell text; may be null. If the text is null, then the cell should be invisible</param>
        /// <param name="isHeader">True, if it is a header cell</param>
        /// <param name="colspan">The number of columns the cell should span</param>
        /// <param name="rowspan">The number of rows the cell should span</param>
        /// <param name="align">Horizontal cell content alignment</param>
        /// <param name="valign">Vertical cell content alignment</param>
        public PageBlockTableCell(RichText text = default, bool isHeader = default, int colspan = default, int rowspan = default, PageBlockHorizontalAlignment align = default, PageBlockVerticalAlignment valign = default)
        {
            this.Text = text;
            this.IsHeader = isHeader;
            this.Colspan = colspan;
            this.Rowspan = rowspan;
            this.Align = align;
            this.Valign = valign;
        }
    }

    public partial class PageBlockRelatedArticle
    {
        /// <summary>
        /// Contains information about a related article
        /// </summary>
        public PageBlockRelatedArticle() { }
        /// <summary>
        /// Contains information about a related article
        /// </summary>
        /// <param name="url">Related article URL</param>
        /// <param name="title">Article title; may be empty</param>
        /// <param name="description">Contains information about a related article</param>
        /// <param name="photo">Article photo; may be null</param>
        /// <param name="author">Article author; may be empty</param>
        /// <param name="publishDate">Point in time (Unix timestamp) when the article was published; 0 if unknown</param>
        public PageBlockRelatedArticle(string url = default, string title = default, string description = default, Photo photo = default, string author = default, int publishDate = default)
        {
            this.Url = url;
            this.Title = title;
            this.Description = description;
            this.Photo = photo;
            this.Author = author;
            this.PublishDate = publishDate;
        }
    }

    public partial class PageBlockTitle
    {
        /// <summary>
        /// The title of a page
        /// </summary>
        public PageBlockTitle() { }
        /// <summary>
        /// The title of a page
        /// </summary>
        /// <param name="title">Title</param>
        public PageBlockTitle(RichText title = default)
        {
            this.Title = title;
        }
    }

    public partial class PageBlockSubtitle
    {
        /// <summary>
        /// The subtitle of a page
        /// </summary>
        public PageBlockSubtitle() { }
        /// <summary>
        /// The subtitle of a page
        /// </summary>
        /// <param name="subtitle">Subtitle</param>
        public PageBlockSubtitle(RichText subtitle = default)
        {
            this.Subtitle = subtitle;
        }
    }

    public partial class PageBlockAuthorDate
    {
        /// <summary>
        /// The author and publishing date of a page
        /// </summary>
        public PageBlockAuthorDate() { }
        /// <summary>
        /// The author and publishing date of a page
        /// </summary>
        /// <param name="author">Author</param>
        /// <param name="publishDate">Point in time (Unix timestamp) when the article was published; 0 if unknown</param>
        public PageBlockAuthorDate(RichText author = default, int publishDate = default)
        {
            this.Author = author;
            this.PublishDate = publishDate;
        }
    }

    public partial class PageBlockHeader
    {
        /// <summary>
        /// A header
        /// </summary>
        public PageBlockHeader() { }
        /// <summary>
        /// A header
        /// </summary>
        /// <param name="header">Header</param>
        public PageBlockHeader(RichText header = default)
        {
            this.Header = header;
        }
    }

    public partial class PageBlockSubheader
    {
        /// <summary>
        /// A subheader
        /// </summary>
        public PageBlockSubheader() { }
        /// <summary>
        /// A subheader
        /// </summary>
        /// <param name="subheader">Subheader</param>
        public PageBlockSubheader(RichText subheader = default)
        {
            this.Subheader = subheader;
        }
    }

    public partial class PageBlockKicker
    {
        /// <summary>
        /// A kicker
        /// </summary>
        public PageBlockKicker() { }
        /// <summary>
        /// A kicker
        /// </summary>
        /// <param name="kicker">Kicker</param>
        public PageBlockKicker(RichText kicker = default)
        {
            this.Kicker = kicker;
        }
    }

    public partial class PageBlockParagraph
    {
        /// <summary>
        /// A text paragraph
        /// </summary>
        public PageBlockParagraph() { }
        /// <summary>
        /// A text paragraph
        /// </summary>
        /// <param name="text">Paragraph text</param>
        public PageBlockParagraph(RichText text = default)
        {
            this.Text = text;
        }
    }

    public partial class PageBlockPreformatted
    {
        /// <summary>
        /// A preformatted text paragraph
        /// </summary>
        public PageBlockPreformatted() { }
        /// <summary>
        /// A preformatted text paragraph
        /// </summary>
        /// <param name="text">Paragraph text</param>
        /// <param name="language">Programming language for which the text should be formatted</param>
        public PageBlockPreformatted(RichText text = default, string language = default)
        {
            this.Text = text;
            this.Language = language;
        }
    }

    public partial class PageBlockFooter
    {
        /// <summary>
        /// The footer of a page
        /// </summary>
        public PageBlockFooter() { }
        /// <summary>
        /// The footer of a page
        /// </summary>
        /// <param name="footer">Footer</param>
        public PageBlockFooter(RichText footer = default)
        {
            this.Footer = footer;
        }
    }

    public partial class PageBlockDivider
    {
        /// <summary>
        /// An empty block separating a page
        /// </summary>
        public PageBlockDivider() { }
    }

    public partial class PageBlockAnchor
    {
        /// <summary>
        /// An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor
        /// </summary>
        public PageBlockAnchor() { }
        /// <summary>
        /// An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor
        /// </summary>
        /// <param name="name">Name of the anchor</param>
        public PageBlockAnchor(string name = default)
        {
            this.Name = name;
        }
    }

    public partial class PageBlockList
    {
        /// <summary>
        /// A list of data blocks
        /// </summary>
        public PageBlockList() { }
        /// <summary>
        /// A list of data blocks
        /// </summary>
        /// <param name="items">The items of the list</param>
        public PageBlockList(PageBlockListItem[] items = default)
        {
            this.Items = items;
        }
    }

    public partial class PageBlockBlockQuote
    {
        /// <summary>
        /// A block quote
        /// </summary>
        public PageBlockBlockQuote() { }
        /// <summary>
        /// A block quote
        /// </summary>
        /// <param name="text">Quote text</param>
        /// <param name="credit">Quote credit</param>
        public PageBlockBlockQuote(RichText text = default, RichText credit = default)
        {
            this.Text = text;
            this.Credit = credit;
        }
    }

    public partial class PageBlockPullQuote
    {
        /// <summary>
        /// A pull quote
        /// </summary>
        public PageBlockPullQuote() { }
        /// <summary>
        /// A pull quote
        /// </summary>
        /// <param name="text">Quote text</param>
        /// <param name="credit">Quote credit</param>
        public PageBlockPullQuote(RichText text = default, RichText credit = default)
        {
            this.Text = text;
            this.Credit = credit;
        }
    }

    public partial class PageBlockAnimation
    {
        /// <summary>
        /// An animation
        /// </summary>
        public PageBlockAnimation() { }
        /// <summary>
        /// An animation
        /// </summary>
        /// <param name="animation">Animation file; may be null</param>
        /// <param name="caption">Animation caption</param>
        /// <param name="needAutoplay">True, if the animation should be played automatically</param>
        public PageBlockAnimation(Animation animation = default, PageBlockCaption caption = default, bool needAutoplay = default)
        {
            this.Animation = animation;
            this.Caption = caption;
            this.NeedAutoplay = needAutoplay;
        }
    }

    public partial class PageBlockAudio
    {
        /// <summary>
        /// An audio file
        /// </summary>
        public PageBlockAudio() { }
        /// <summary>
        /// An audio file
        /// </summary>
        /// <param name="audio">Audio file; may be null</param>
        /// <param name="caption">Audio file caption</param>
        public PageBlockAudio(Audio audio = default, PageBlockCaption caption = default)
        {
            this.Audio = audio;
            this.Caption = caption;
        }
    }

    public partial class PageBlockPhoto
    {
        /// <summary>
        /// A photo
        /// </summary>
        public PageBlockPhoto() { }
        /// <summary>
        /// A photo
        /// </summary>
        /// <param name="photo">Photo file; may be null</param>
        /// <param name="caption">Photo caption</param>
        /// <param name="url">URL that needs to be opened when the photo is clicked</param>
        public PageBlockPhoto(Photo photo = default, PageBlockCaption caption = default, string url = default)
        {
            this.Photo = photo;
            this.Caption = caption;
            this.Url = url;
        }
    }

    public partial class PageBlockVideo
    {
        /// <summary>
        /// A video
        /// </summary>
        public PageBlockVideo() { }
        /// <summary>
        /// A video
        /// </summary>
        /// <param name="video">Video file; may be null</param>
        /// <param name="caption">Video caption</param>
        /// <param name="needAutoplay">True, if the video should be played automatically</param>
        /// <param name="isLooped">True, if the video should be looped</param>
        public PageBlockVideo(Video video = default, PageBlockCaption caption = default, bool needAutoplay = default, bool isLooped = default)
        {
            this.Video = video;
            this.Caption = caption;
            this.NeedAutoplay = needAutoplay;
            this.IsLooped = isLooped;
        }
    }

    public partial class PageBlockVoiceNote
    {
        /// <summary>
        /// A voice note
        /// </summary>
        public PageBlockVoiceNote() { }
        /// <summary>
        /// A voice note
        /// </summary>
        /// <param name="voiceNote">Voice note; may be null</param>
        /// <param name="caption">Voice note caption</param>
        public PageBlockVoiceNote(VoiceNote voiceNote = default, PageBlockCaption caption = default)
        {
            this.VoiceNote = voiceNote;
            this.Caption = caption;
        }
    }

    public partial class PageBlockCover
    {
        /// <summary>
        /// A page cover
        /// </summary>
        public PageBlockCover() { }
        /// <summary>
        /// A page cover
        /// </summary>
        /// <param name="cover">Cover</param>
        public PageBlockCover(PageBlock cover = default)
        {
            this.Cover = cover;
        }
    }

    public partial class PageBlockEmbedded
    {
        /// <summary>
        /// An embedded web page
        /// </summary>
        public PageBlockEmbedded() { }
        /// <summary>
        /// An embedded web page
        /// </summary>
        /// <param name="url">Web page URL, if available</param>
        /// <param name="html">HTML-markup of the embedded page</param>
        /// <param name="posterPhoto">Poster photo, if available; may be null</param>
        /// <param name="width">Block width; 0 if unknown</param>
        /// <param name="height">Block height; 0 if unknown</param>
        /// <param name="caption">Block caption</param>
        /// <param name="isFullWidth">True, if the block should be full width</param>
        /// <param name="allowScrolling">True, if scrolling should be allowed</param>
        public PageBlockEmbedded(string url = default, string html = default, Photo posterPhoto = default, int width = default, int height = default, PageBlockCaption caption = default, bool isFullWidth = default, bool allowScrolling = default)
        {
            this.Url = url;
            this.Html = html;
            this.PosterPhoto = posterPhoto;
            this.Width = width;
            this.Height = height;
            this.Caption = caption;
            this.IsFullWidth = isFullWidth;
            this.AllowScrolling = allowScrolling;
        }
    }

    public partial class PageBlockEmbeddedPost
    {
        /// <summary>
        /// An embedded post
        /// </summary>
        public PageBlockEmbeddedPost() { }
        /// <summary>
        /// An embedded post
        /// </summary>
        /// <param name="url">Web page URL</param>
        /// <param name="author">Post author</param>
        /// <param name="authorPhoto">Post author photo; may be null</param>
        /// <param name="date">Point in time (Unix timestamp) when the post was created; 0 if unknown</param>
        /// <param name="pageBlocks">Post content</param>
        /// <param name="caption">Post caption</param>
        public PageBlockEmbeddedPost(string url = default, string author = default, Photo authorPhoto = default, int date = default, PageBlock[] pageBlocks = default, PageBlockCaption caption = default)
        {
            this.Url = url;
            this.Author = author;
            this.AuthorPhoto = authorPhoto;
            this.Date = date;
            this.PageBlocks = pageBlocks;
            this.Caption = caption;
        }
    }

    public partial class PageBlockCollage
    {
        /// <summary>
        /// A collage
        /// </summary>
        public PageBlockCollage() { }
        /// <summary>
        /// A collage
        /// </summary>
        /// <param name="pageBlocks">Collage item contents</param>
        /// <param name="caption">Block caption</param>
        public PageBlockCollage(PageBlock[] pageBlocks = default, PageBlockCaption caption = default)
        {
            this.PageBlocks = pageBlocks;
            this.Caption = caption;
        }
    }

    public partial class PageBlockSlideshow
    {
        /// <summary>
        /// A slideshow
        /// </summary>
        public PageBlockSlideshow() { }
        /// <summary>
        /// A slideshow
        /// </summary>
        /// <param name="pageBlocks">Slideshow item contents</param>
        /// <param name="caption">Block caption</param>
        public PageBlockSlideshow(PageBlock[] pageBlocks = default, PageBlockCaption caption = default)
        {
            this.PageBlocks = pageBlocks;
            this.Caption = caption;
        }
    }

    public partial class PageBlockChatLink
    {
        /// <summary>
        /// A link to a chat
        /// </summary>
        public PageBlockChatLink() { }
        /// <summary>
        /// A link to a chat
        /// </summary>
        /// <param name="title">Chat title</param>
        /// <param name="photo">Chat photo; may be null</param>
        /// <param name="username">Chat username, by which all other information about the chat should be resolved</param>
        public PageBlockChatLink(string title = default, ChatPhotoInfo photo = default, string username = default)
        {
            this.Title = title;
            this.Photo = photo;
            this.Username = username;
        }
    }

    public partial class PageBlockTable
    {
        /// <summary>
        /// A table
        /// </summary>
        public PageBlockTable() { }
        /// <summary>
        /// A table
        /// </summary>
        /// <param name="caption">Table caption</param>
        /// <param name="cells">Table cells</param>
        /// <param name="isBordered">True, if the table is bordered</param>
        /// <param name="isStriped">True, if the table is striped</param>
        public PageBlockTable(RichText caption = default, PageBlockTableCell[][] cells = default, bool isBordered = default, bool isStriped = default)
        {
            this.Caption = caption;
            this.Cells = cells;
            this.IsBordered = isBordered;
            this.IsStriped = isStriped;
        }
    }

    public partial class PageBlockDetails
    {
        /// <summary>
        /// A collapsible block
        /// </summary>
        public PageBlockDetails() { }
        /// <summary>
        /// A collapsible block
        /// </summary>
        /// <param name="header">Always visible heading for the block</param>
        /// <param name="pageBlocks">Block contents</param>
        /// <param name="isOpen">True, if the block is open by default</param>
        public PageBlockDetails(RichText header = default, PageBlock[] pageBlocks = default, bool isOpen = default)
        {
            this.Header = header;
            this.PageBlocks = pageBlocks;
            this.IsOpen = isOpen;
        }
    }

    public partial class PageBlockRelatedArticles
    {
        /// <summary>
        /// Related articles
        /// </summary>
        public PageBlockRelatedArticles() { }
        /// <summary>
        /// Related articles
        /// </summary>
        /// <param name="header">Block header</param>
        /// <param name="articles">List of related articles</param>
        public PageBlockRelatedArticles(RichText header = default, PageBlockRelatedArticle[] articles = default)
        {
            this.Header = header;
            this.Articles = articles;
        }
    }

    public partial class PageBlockMap
    {
        /// <summary>
        /// A map
        /// </summary>
        public PageBlockMap() { }
        /// <summary>
        /// A map
        /// </summary>
        /// <param name="location">Location of the map center</param>
        /// <param name="zoom">Map zoom level</param>
        /// <param name="width">Map width</param>
        /// <param name="height">Map height</param>
        /// <param name="caption">Block caption</param>
        public PageBlockMap(Location location = default, int zoom = default, int width = default, int height = default, PageBlockCaption caption = default)
        {
            this.Location = location;
            this.Zoom = zoom;
            this.Width = width;
            this.Height = height;
            this.Caption = caption;
        }
    }

    public partial class WebPageInstantView
    {
        /// <summary>
        /// Describes an instant view page for a web page
        /// </summary>
        public WebPageInstantView() { }
        /// <summary>
        /// Describes an instant view page for a web page
        /// </summary>
        /// <param name="pageBlocks">Content of the web page</param>
        /// <param name="viewCount">Number of the instant view views; 0 if unknown</param>
        /// <param name="version">Version of the instant view, currently can be 1 or 2</param>
        /// <param name="isRtl">True, if the instant view must be shown from right to left</param>
        /// <param name="isFull">True, if the instant view contains the full page. A network request might be needed to get the full web page instant view</param>
        public WebPageInstantView(PageBlock[] pageBlocks = default, int viewCount = default, int version = default, bool isRtl = default, bool isFull = default)
        {
            this.PageBlocks = pageBlocks;
            this.ViewCount = viewCount;
            this.Version = version;
            this.IsRtl = isRtl;
            this.IsFull = isFull;
        }
    }

    public partial class WebPage
    {
        /// <summary>
        /// Describes a web page preview
        /// </summary>
        public WebPage() { }
        /// <summary>
        /// Describes a web page preview
        /// </summary>
        /// <param name="url">Original URL of the link</param>
        /// <param name="displayUrl">URL to display</param>
        /// <param name="type">Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else</param>
        /// <param name="siteName">Short name of the site (e.g., Google Docs, App Store)</param>
        /// <param name="title">Title of the content</param>
        /// <param name="description">Describes a web page preview</param>
        /// <param name="photo">Image representing the content; may be null</param>
        /// <param name="embedUrl">URL to show in the embedded preview</param>
        /// <param name="embedType">MIME type of the embedded preview, (e.g., text/html or video/mp4)</param>
        /// <param name="embedWidth">Width of the embedded preview</param>
        /// <param name="embedHeight">Height of the embedded preview</param>
        /// <param name="duration">Duration of the content, in seconds</param>
        /// <param name="author">Author of the content</param>
        /// <param name="animation">Preview of the content as an animation, if available; may be null</param>
        /// <param name="audio">Preview of the content as an audio file, if available; may be null</param>
        /// <param name="document">Preview of the content as a document, if available (currently only available for small PDF files and ZIP archives); may be null</param>
        /// <param name="sticker">Preview of the content as a sticker for small WEBP files, if available; may be null</param>
        /// <param name="video">Preview of the content as a video, if available; may be null</param>
        /// <param name="videoNote">Preview of the content as a video note, if available; may be null</param>
        /// <param name="voiceNote">Preview of the content as a voice note, if available; may be null</param>
        /// <param name="instantViewVersion">Version of instant view, available for the web page (currently can be 1 or 2), 0 if none</param>
        public WebPage(string url = default, string displayUrl = default, string type = default, string siteName = default, string title = default, FormattedText description = default, Photo photo = default, string embedUrl = default, string embedType = default, int embedWidth = default, int embedHeight = default, int duration = default, string author = default, Animation animation = default, Audio audio = default, Document document = default, Sticker sticker = default, Video video = default, VideoNote videoNote = default, VoiceNote voiceNote = default, int instantViewVersion = default)
        {
            this.Url = url;
            this.DisplayUrl = displayUrl;
            this.Type = type;
            this.SiteName = siteName;
            this.Title = title;
            this.Description = description;
            this.Photo = photo;
            this.EmbedUrl = embedUrl;
            this.EmbedType = embedType;
            this.EmbedWidth = embedWidth;
            this.EmbedHeight = embedHeight;
            this.Duration = duration;
            this.Author = author;
            this.Animation = animation;
            this.Audio = audio;
            this.Document = document;
            this.Sticker = sticker;
            this.Video = video;
            this.VideoNote = videoNote;
            this.VoiceNote = voiceNote;
            this.InstantViewVersion = instantViewVersion;
        }
    }

    public partial class CountryInfo
    {
        /// <summary>
        /// Contains information about a country
        /// </summary>
        public CountryInfo() { }
        /// <summary>
        /// Contains information about a country
        /// </summary>
        /// <param name="countryCode">A two-letter ISO 3166-1 alpha-2 country code</param>
        /// <param name="name">Native name of the country</param>
        /// <param name="englishName">English name of the country</param>
        /// <param name="isHidden">True, if the country should be hidden from the list of all countries</param>
        /// <param name="callingCodes">List of country calling codes</param>
        public CountryInfo(string countryCode = default, string name = default, string englishName = default, bool isHidden = default, string[] callingCodes = default)
        {
            this.CountryCode = countryCode;
            this.Name = name;
            this.EnglishName = englishName;
            this.IsHidden = isHidden;
            this.CallingCodes = callingCodes;
        }
    }

    public partial class Countries
    {
        /// <summary>
        /// Contains information about countries
        /// </summary>
        public Countries() { }
        /// <summary>
        /// Contains information about countries
        /// </summary>
        /// <param name="countries">The list of countries</param>
        public Countries(CountryInfo[] countries_ = default)
        {
            this.Countries_ = countries_;
        }
    }

    public partial class PhoneNumberInfo
    {
        /// <summary>
        /// Contains information about a phone number
        /// </summary>
        public PhoneNumberInfo() { }
        /// <summary>
        /// Contains information about a phone number
        /// </summary>
        /// <param name="country">Information about the country to which the phone number belongs; may be null</param>
        /// <param name="countryCallingCode">The part of the phone number denoting country calling code or its part</param>
        /// <param name="formattedPhoneNumber">The phone number without country calling code formatted accordingly to local rules</param>
        public PhoneNumberInfo(CountryInfo country = default, string countryCallingCode = default, string formattedPhoneNumber = default)
        {
            this.Country = country;
            this.CountryCallingCode = countryCallingCode;
            this.FormattedPhoneNumber = formattedPhoneNumber;
        }
    }

    public partial class BankCardActionOpenUrl
    {
        /// <summary>
        /// Describes an action associated with a bank card number
        /// </summary>
        public BankCardActionOpenUrl() { }
        /// <summary>
        /// Describes an action associated with a bank card number
        /// </summary>
        /// <param name="text">Action text</param>
        /// <param name="url">The URL to be opened</param>
        public BankCardActionOpenUrl(string text = default, string url = default)
        {
            this.Text = text;
            this.Url = url;
        }
    }

    public partial class BankCardInfo
    {
        /// <summary>
        /// Information about a bank card
        /// </summary>
        public BankCardInfo() { }
        /// <summary>
        /// Information about a bank card
        /// </summary>
        /// <param name="title">Title of the bank card description</param>
        /// <param name="actions">Actions that can be done with the bank card number</param>
        public BankCardInfo(string title = default, BankCardActionOpenUrl[] actions = default)
        {
            this.Title = title;
            this.Actions = actions;
        }
    }

    public partial class Address
    {
        /// <summary>
        /// Describes an address
        /// </summary>
        public Address() { }
        /// <summary>
        /// Describes an address
        /// </summary>
        /// <param name="countryCode">A two-letter ISO 3166-1 alpha-2 country code</param>
        /// <param name="state">State, if applicable</param>
        /// <param name="city">City</param>
        /// <param name="streetLine1">First line of the address</param>
        /// <param name="streetLine2">Second line of the address</param>
        /// <param name="postalCode">Address postal code</param>
        public Address(string countryCode = default, string state = default, string city = default, string streetLine1 = default, string streetLine2 = default, string postalCode = default)
        {
            this.CountryCode = countryCode;
            this.State = state;
            this.City = city;
            this.StreetLine1 = streetLine1;
            this.StreetLine2 = streetLine2;
            this.PostalCode = postalCode;
        }
    }

    public partial class LabeledPricePart
    {
        /// <summary>
        /// Portion of the price of a product (e.g., "delivery cost", "tax amount")
        /// </summary>
        public LabeledPricePart() { }
        /// <summary>
        /// Portion of the price of a product (e.g., "delivery cost", "tax amount")
        /// </summary>
        /// <param name="label">Label for this portion of the product price</param>
        /// <param name="amount">Currency amount in minimal quantity of the currency</param>
        public LabeledPricePart(string label = default, long amount = default)
        {
            this.Label = label;
            this.Amount = amount;
        }
    }

    public partial class Invoice
    {
        /// <summary>
        /// Product invoice
        /// </summary>
        public Invoice() { }
        /// <summary>
        /// Product invoice
        /// </summary>
        /// <param name="currency">ISO 4217 currency code</param>
        /// <param name="priceParts">A list of objects used to calculate the total price of the product</param>
        /// <param name="isTest">True, if the payment is a test payment</param>
        /// <param name="needName">True, if the user's name is needed for payment</param>
        /// <param name="needPhoneNumber">True, if the user's phone number is needed for payment</param>
        /// <param name="needEmailAddress">True, if the user's email address is needed for payment</param>
        /// <param name="needShippingAddress">True, if the user's shipping address is needed for payment</param>
        /// <param name="sendPhoneNumberToProvider">True, if the user's phone number will be sent to the provider</param>
        /// <param name="sendEmailAddressToProvider">True, if the user's email address will be sent to the provider</param>
        /// <param name="isFlexible">True, if the total price depends on the shipping method</param>
        public Invoice(string currency = default, LabeledPricePart[] priceParts = default, bool isTest = default, bool needName = default, bool needPhoneNumber = default, bool needEmailAddress = default, bool needShippingAddress = default, bool sendPhoneNumberToProvider = default, bool sendEmailAddressToProvider = default, bool isFlexible = default)
        {
            this.Currency = currency;
            this.PriceParts = priceParts;
            this.IsTest = isTest;
            this.NeedName = needName;
            this.NeedPhoneNumber = needPhoneNumber;
            this.NeedEmailAddress = needEmailAddress;
            this.NeedShippingAddress = needShippingAddress;
            this.SendPhoneNumberToProvider = sendPhoneNumberToProvider;
            this.SendEmailAddressToProvider = sendEmailAddressToProvider;
            this.IsFlexible = isFlexible;
        }
    }

    public partial class OrderInfo
    {
        /// <summary>
        /// Order information
        /// </summary>
        public OrderInfo() { }
        /// <summary>
        /// Order information
        /// </summary>
        /// <param name="name">Name of the user</param>
        /// <param name="phoneNumber">Phone number of the user</param>
        /// <param name="emailAddress">Email address of the user</param>
        /// <param name="shippingAddress">Shipping address for this order; may be null</param>
        public OrderInfo(string name = default, string phoneNumber = default, string emailAddress = default, Address shippingAddress = default)
        {
            this.Name = name;
            this.PhoneNumber = phoneNumber;
            this.EmailAddress = emailAddress;
            this.ShippingAddress = shippingAddress;
        }
    }

    public partial class ShippingOption
    {
        /// <summary>
        /// One shipping option
        /// </summary>
        public ShippingOption() { }
        /// <summary>
        /// One shipping option
        /// </summary>
        /// <param name="id">Shipping option identifier</param>
        /// <param name="title">Option title</param>
        /// <param name="priceParts">A list of objects used to calculate the total shipping costs</param>
        public ShippingOption(string id = default, string title = default, LabeledPricePart[] priceParts = default)
        {
            this.Id = id;
            this.Title = title;
            this.PriceParts = priceParts;
        }
    }

    public partial class SavedCredentials
    {
        /// <summary>
        /// Contains information about saved card credentials
        /// </summary>
        public SavedCredentials() { }
        /// <summary>
        /// Contains information about saved card credentials
        /// </summary>
        /// <param name="id">Unique identifier of the saved credentials</param>
        /// <param name="title">Title of the saved credentials</param>
        public SavedCredentials(string id = default, string title = default)
        {
            this.Id = id;
            this.Title = title;
        }
    }

    public partial class InputCredentialsSaved
    {
        /// <summary>
        /// Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password
        /// </summary>
        public InputCredentialsSaved() { }
        /// <summary>
        /// Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password
        /// </summary>
        /// <param name="savedCredentialsId">Identifier of the saved credentials</param>
        public InputCredentialsSaved(string savedCredentialsId = default)
        {
            this.SavedCredentialsId = savedCredentialsId;
        }
    }

    public partial class InputCredentialsNew
    {
        /// <summary>
        /// Applies if a user enters new credentials on a payment provider website
        /// </summary>
        public InputCredentialsNew() { }
        /// <summary>
        /// Applies if a user enters new credentials on a payment provider website
        /// </summary>
        /// <param name="data">Contains JSON-encoded data with a credential identifier from the payment provider</param>
        /// <param name="allowSave">True, if the credential identifier can be saved on the server side</param>
        public InputCredentialsNew(string data = default, bool allowSave = default)
        {
            this.Data = data;
            this.AllowSave = allowSave;
        }
    }

    public partial class InputCredentialsAndroidPay
    {
        /// <summary>
        /// Applies if a user enters new credentials using Android Pay
        /// </summary>
        public InputCredentialsAndroidPay() { }
        /// <summary>
        /// Applies if a user enters new credentials using Android Pay
        /// </summary>
        /// <param name="data">JSON-encoded data with the credential identifier</param>
        public InputCredentialsAndroidPay(string data = default)
        {
            this.Data = data;
        }
    }

    public partial class InputCredentialsApplePay
    {
        /// <summary>
        /// Applies if a user enters new credentials using Apple Pay
        /// </summary>
        public InputCredentialsApplePay() { }
        /// <summary>
        /// Applies if a user enters new credentials using Apple Pay
        /// </summary>
        /// <param name="data">JSON-encoded data with the credential identifier</param>
        public InputCredentialsApplePay(string data = default)
        {
            this.Data = data;
        }
    }

    public partial class PaymentsProviderStripe
    {
        /// <summary>
        /// Stripe payment provider
        /// </summary>
        public PaymentsProviderStripe() { }
        /// <summary>
        /// Stripe payment provider
        /// </summary>
        /// <param name="publishableKey">Stripe API publishable key</param>
        /// <param name="needCountry">True, if the user country must be provided</param>
        /// <param name="needPostalCode">True, if the user ZIP/postal code must be provided</param>
        /// <param name="needCardholderName">True, if the cardholder name must be provided</param>
        public PaymentsProviderStripe(string publishableKey = default, bool needCountry = default, bool needPostalCode = default, bool needCardholderName = default)
        {
            this.PublishableKey = publishableKey;
            this.NeedCountry = needCountry;
            this.NeedPostalCode = needPostalCode;
            this.NeedCardholderName = needCardholderName;
        }
    }

    public partial class PaymentForm
    {
        /// <summary>
        /// Contains information about an invoice payment form
        /// </summary>
        public PaymentForm() { }
        /// <summary>
        /// Contains information about an invoice payment form
        /// </summary>
        /// <param name="invoice">Full information of the invoice</param>
        /// <param name="url">Payment form URL</param>
        /// <param name="paymentsProvider">Contains information about the payment provider, if available, to support it natively without the need for opening the URL; may be null</param>
        /// <param name="savedOrderInfo">Saved server-side order information; may be null</param>
        /// <param name="savedCredentials">Contains information about saved card credentials; may be null</param>
        /// <param name="canSaveCredentials">True, if the user can choose to save credentials</param>
        /// <param name="needPassword">True, if the user will be able to save credentials protected by a password they set up</param>
        public PaymentForm(Invoice invoice = default, string url = default, PaymentsProviderStripe paymentsProvider = default, OrderInfo savedOrderInfo = default, SavedCredentials savedCredentials = default, bool canSaveCredentials = default, bool needPassword = default)
        {
            this.Invoice = invoice;
            this.Url = url;
            this.PaymentsProvider = paymentsProvider;
            this.SavedOrderInfo = savedOrderInfo;
            this.SavedCredentials = savedCredentials;
            this.CanSaveCredentials = canSaveCredentials;
            this.NeedPassword = needPassword;
        }
    }

    public partial class ValidatedOrderInfo
    {
        /// <summary>
        /// Contains a temporary identifier of validated order information, which is stored for one hour. Also contains the available shipping options
        /// </summary>
        public ValidatedOrderInfo() { }
        /// <summary>
        /// Contains a temporary identifier of validated order information, which is stored for one hour. Also contains the available shipping options
        /// </summary>
        /// <param name="orderInfoId">Temporary identifier of the order information</param>
        /// <param name="shippingOptions">Available shipping options</param>
        public ValidatedOrderInfo(string orderInfoId = default, ShippingOption[] shippingOptions = default)
        {
            this.OrderInfoId = orderInfoId;
            this.ShippingOptions = shippingOptions;
        }
    }

    public partial class PaymentResult
    {
        /// <summary>
        /// Contains the result of a payment request
        /// </summary>
        public PaymentResult() { }
        /// <summary>
        /// Contains the result of a payment request
        /// </summary>
        /// <param name="success">True, if the payment request was successful; otherwise the verification_url will be not empty</param>
        /// <param name="verificationUrl">URL for additional payment credentials verification</param>
        public PaymentResult(bool success = default, string verificationUrl = default)
        {
            this.Success = success;
            this.VerificationUrl = verificationUrl;
        }
    }

    public partial class PaymentReceipt
    {
        /// <summary>
        /// Contains information about a successful payment
        /// </summary>
        public PaymentReceipt() { }
        /// <summary>
        /// Contains information about a successful payment
        /// </summary>
        /// <param name="date">Point in time (Unix timestamp) when the payment was made</param>
        /// <param name="paymentsProviderUserId">User identifier of the payment provider bot</param>
        /// <param name="invoice">Contains information about the invoice</param>
        /// <param name="orderInfo">Contains order information; may be null</param>
        /// <param name="shippingOption">Chosen shipping option; may be null</param>
        /// <param name="credentialsTitle">Title of the saved credentials</param>
        public PaymentReceipt(int date = default, int paymentsProviderUserId = default, Invoice invoice = default, OrderInfo orderInfo = default, ShippingOption shippingOption = default, string credentialsTitle = default)
        {
            this.Date = date;
            this.PaymentsProviderUserId = paymentsProviderUserId;
            this.Invoice = invoice;
            this.OrderInfo = orderInfo;
            this.ShippingOption = shippingOption;
            this.CredentialsTitle = credentialsTitle;
        }
    }

    public partial class DatedFile
    {
        /// <summary>
        /// File with the date it was uploaded
        /// </summary>
        public DatedFile() { }
        /// <summary>
        /// File with the date it was uploaded
        /// </summary>
        /// <param name="file">The file</param>
        /// <param name="date">Point in time (Unix timestamp) when the file was uploaded</param>
        public DatedFile(File file = default, int date = default)
        {
            this.File = file;
            this.Date = date;
        }
    }

    public partial class PassportElementTypePersonalDetails
    {
        /// <summary>
        /// A Telegram Passport element containing the user's personal details
        /// </summary>
        public PassportElementTypePersonalDetails() { }
    }

    public partial class PassportElementTypePassport
    {
        /// <summary>
        /// A Telegram Passport element containing the user's passport
        /// </summary>
        public PassportElementTypePassport() { }
    }

    public partial class PassportElementTypeDriverLicense
    {
        /// <summary>
        /// A Telegram Passport element containing the user's driver license
        /// </summary>
        public PassportElementTypeDriverLicense() { }
    }

    public partial class PassportElementTypeIdentityCard
    {
        /// <summary>
        /// A Telegram Passport element containing the user's identity card
        /// </summary>
        public PassportElementTypeIdentityCard() { }
    }

    public partial class PassportElementTypeInternalPassport
    {
        /// <summary>
        /// A Telegram Passport element containing the user's internal passport
        /// </summary>
        public PassportElementTypeInternalPassport() { }
    }

    public partial class PassportElementTypeAddress
    {
        /// <summary>
        /// A Telegram Passport element containing the user's address
        /// </summary>
        public PassportElementTypeAddress() { }
    }

    public partial class PassportElementTypeUtilityBill
    {
        /// <summary>
        /// A Telegram Passport element containing the user's utility bill
        /// </summary>
        public PassportElementTypeUtilityBill() { }
    }

    public partial class PassportElementTypeBankStatement
    {
        /// <summary>
        /// A Telegram Passport element containing the user's bank statement
        /// </summary>
        public PassportElementTypeBankStatement() { }
    }

    public partial class PassportElementTypeRentalAgreement
    {
        /// <summary>
        /// A Telegram Passport element containing the user's rental agreement
        /// </summary>
        public PassportElementTypeRentalAgreement() { }
    }

    public partial class PassportElementTypePassportRegistration
    {
        /// <summary>
        /// A Telegram Passport element containing the registration page of the user's passport
        /// </summary>
        public PassportElementTypePassportRegistration() { }
    }

    public partial class PassportElementTypeTemporaryRegistration
    {
        /// <summary>
        /// A Telegram Passport element containing the user's temporary registration
        /// </summary>
        public PassportElementTypeTemporaryRegistration() { }
    }

    public partial class PassportElementTypePhoneNumber
    {
        /// <summary>
        /// A Telegram Passport element containing the user's phone number
        /// </summary>
        public PassportElementTypePhoneNumber() { }
    }

    public partial class PassportElementTypeEmailAddress
    {
        /// <summary>
        /// A Telegram Passport element containing the user's email address
        /// </summary>
        public PassportElementTypeEmailAddress() { }
    }

    public partial class Date
    {
        /// <summary>
        /// Represents a date according to the Gregorian calendar
        /// </summary>
        public Date() { }
        /// <summary>
        /// Represents a date according to the Gregorian calendar
        /// </summary>
        /// <param name="day">Day of the month, 1-31</param>
        /// <param name="month">Month, 1-12</param>
        /// <param name="year">Year, 1-9999</param>
        public Date(int day = default, int month = default, int year = default)
        {
            this.Day = day;
            this.Month = month;
            this.Year = year;
        }
    }

    public partial class PersonalDetails
    {
        /// <summary>
        /// Contains the user's personal details
        /// </summary>
        public PersonalDetails() { }
        /// <summary>
        /// Contains the user's personal details
        /// </summary>
        /// <param name="firstName">First name of the user written in English; 1-255 characters</param>
        /// <param name="middleName">Middle name of the user written in English; 0-255 characters</param>
        /// <param name="lastName">Last name of the user written in English; 1-255 characters</param>
        /// <param name="nativeFirstName">Native first name of the user; 1-255 characters</param>
        /// <param name="nativeMiddleName">Native middle name of the user; 0-255 characters</param>
        /// <param name="nativeLastName">Native last name of the user; 1-255 characters</param>
        /// <param name="birthdate">Birthdate of the user</param>
        /// <param name="gender">Gender of the user, "male" or "female"</param>
        /// <param name="countryCode">A two-letter ISO 3166-1 alpha-2 country code of the user's country</param>
        /// <param name="residenceCountryCode">A two-letter ISO 3166-1 alpha-2 country code of the user's residence country</param>
        public PersonalDetails(string firstName = default, string middleName = default, string lastName = default, string nativeFirstName = default, string nativeMiddleName = default, string nativeLastName = default, Date birthdate = default, string gender = default, string countryCode = default, string residenceCountryCode = default)
        {
            this.FirstName = firstName;
            this.MiddleName = middleName;
            this.LastName = lastName;
            this.NativeFirstName = nativeFirstName;
            this.NativeMiddleName = nativeMiddleName;
            this.NativeLastName = nativeLastName;
            this.Birthdate = birthdate;
            this.Gender = gender;
            this.CountryCode = countryCode;
            this.ResidenceCountryCode = residenceCountryCode;
        }
    }

    public partial class IdentityDocument
    {
        /// <summary>
        /// An identity document
        /// </summary>
        public IdentityDocument() { }
        /// <summary>
        /// An identity document
        /// </summary>
        /// <param name="number">Document number; 1-24 characters</param>
        /// <param name="expiryDate">Document expiry date; may be null</param>
        /// <param name="frontSide">Front side of the document</param>
        /// <param name="reverseSide">Reverse side of the document; only for driver license and identity card</param>
        /// <param name="selfie">Selfie with the document; may be null</param>
        /// <param name="translation">List of files containing a certified English translation of the document</param>
        public IdentityDocument(string number = default, Date expiryDate = default, DatedFile frontSide = default, DatedFile reverseSide = default, DatedFile selfie = default, DatedFile[] translation = default)
        {
            this.Number = number;
            this.ExpiryDate = expiryDate;
            this.FrontSide = frontSide;
            this.ReverseSide = reverseSide;
            this.Selfie = selfie;
            this.Translation = translation;
        }
    }

    public partial class InputIdentityDocument
    {
        /// <summary>
        /// An identity document to be saved to Telegram Passport
        /// </summary>
        public InputIdentityDocument() { }
        /// <summary>
        /// An identity document to be saved to Telegram Passport
        /// </summary>
        /// <param name="number">Document number; 1-24 characters</param>
        /// <param name="expiryDate">Document expiry date, if available</param>
        /// <param name="frontSide">Front side of the document</param>
        /// <param name="reverseSide">Reverse side of the document; only for driver license and identity card</param>
        /// <param name="selfie">Selfie with the document, if available</param>
        /// <param name="translation">List of files containing a certified English translation of the document</param>
        public InputIdentityDocument(string number = default, Date expiryDate = default, InputFile frontSide = default, InputFile reverseSide = default, InputFile selfie = default, InputFile[] translation = default)
        {
            this.Number = number;
            this.ExpiryDate = expiryDate;
            this.FrontSide = frontSide;
            this.ReverseSide = reverseSide;
            this.Selfie = selfie;
            this.Translation = translation;
        }
    }

    public partial class PersonalDocument
    {
        /// <summary>
        /// A personal document, containing some information about a user
        /// </summary>
        public PersonalDocument() { }
        /// <summary>
        /// A personal document, containing some information about a user
        /// </summary>
        /// <param name="files">List of files containing the pages of the document</param>
        /// <param name="translation">List of files containing a certified English translation of the document</param>
        public PersonalDocument(DatedFile[] files = default, DatedFile[] translation = default)
        {
            this.Files = files;
            this.Translation = translation;
        }
    }

    public partial class InputPersonalDocument
    {
        /// <summary>
        /// A personal document to be saved to Telegram Passport
        /// </summary>
        public InputPersonalDocument() { }
        /// <summary>
        /// A personal document to be saved to Telegram Passport
        /// </summary>
        /// <param name="files">List of files containing the pages of the document</param>
        /// <param name="translation">List of files containing a certified English translation of the document</param>
        public InputPersonalDocument(InputFile[] files = default, InputFile[] translation = default)
        {
            this.Files = files;
            this.Translation = translation;
        }
    }

    public partial class PassportElementPersonalDetails
    {
        /// <summary>
        /// A Telegram Passport element containing the user's personal details
        /// </summary>
        public PassportElementPersonalDetails() { }
        /// <summary>
        /// A Telegram Passport element containing the user's personal details
        /// </summary>
        /// <param name="personalDetails">Personal details of the user</param>
        public PassportElementPersonalDetails(PersonalDetails personalDetails = default)
        {
            this.PersonalDetails = personalDetails;
        }
    }

    public partial class PassportElementPassport
    {
        /// <summary>
        /// A Telegram Passport element containing the user's passport
        /// </summary>
        public PassportElementPassport() { }
        /// <summary>
        /// A Telegram Passport element containing the user's passport
        /// </summary>
        /// <param name="passport">Passport</param>
        public PassportElementPassport(IdentityDocument passport = default)
        {
            this.Passport = passport;
        }
    }

    public partial class PassportElementDriverLicense
    {
        /// <summary>
        /// A Telegram Passport element containing the user's driver license
        /// </summary>
        public PassportElementDriverLicense() { }
        /// <summary>
        /// A Telegram Passport element containing the user's driver license
        /// </summary>
        /// <param name="driverLicense">Driver license</param>
        public PassportElementDriverLicense(IdentityDocument driverLicense = default)
        {
            this.DriverLicense = driverLicense;
        }
    }

    public partial class PassportElementIdentityCard
    {
        /// <summary>
        /// A Telegram Passport element containing the user's identity card
        /// </summary>
        public PassportElementIdentityCard() { }
        /// <summary>
        /// A Telegram Passport element containing the user's identity card
        /// </summary>
        /// <param name="identityCard">Identity card</param>
        public PassportElementIdentityCard(IdentityDocument identityCard = default)
        {
            this.IdentityCard = identityCard;
        }
    }

    public partial class PassportElementInternalPassport
    {
        /// <summary>
        /// A Telegram Passport element containing the user's internal passport
        /// </summary>
        public PassportElementInternalPassport() { }
        /// <summary>
        /// A Telegram Passport element containing the user's internal passport
        /// </summary>
        /// <param name="internalPassport">Internal passport</param>
        public PassportElementInternalPassport(IdentityDocument internalPassport = default)
        {
            this.InternalPassport = internalPassport;
        }
    }

    public partial class PassportElementAddress
    {
        /// <summary>
        /// A Telegram Passport element containing the user's address
        /// </summary>
        public PassportElementAddress() { }
        /// <summary>
        /// A Telegram Passport element containing the user's address
        /// </summary>
        /// <param name="address">Address</param>
        public PassportElementAddress(Address address = default)
        {
            this.Address = address;
        }
    }

    public partial class PassportElementUtilityBill
    {
        /// <summary>
        /// A Telegram Passport element containing the user's utility bill
        /// </summary>
        public PassportElementUtilityBill() { }
        /// <summary>
        /// A Telegram Passport element containing the user's utility bill
        /// </summary>
        /// <param name="utilityBill">Utility bill</param>
        public PassportElementUtilityBill(PersonalDocument utilityBill = default)
        {
            this.UtilityBill = utilityBill;
        }
    }

    public partial class PassportElementBankStatement
    {
        /// <summary>
        /// A Telegram Passport element containing the user's bank statement
        /// </summary>
        public PassportElementBankStatement() { }
        /// <summary>
        /// A Telegram Passport element containing the user's bank statement
        /// </summary>
        /// <param name="bankStatement">Bank statement</param>
        public PassportElementBankStatement(PersonalDocument bankStatement = default)
        {
            this.BankStatement = bankStatement;
        }
    }

    public partial class PassportElementRentalAgreement
    {
        /// <summary>
        /// A Telegram Passport element containing the user's rental agreement
        /// </summary>
        public PassportElementRentalAgreement() { }
        /// <summary>
        /// A Telegram Passport element containing the user's rental agreement
        /// </summary>
        /// <param name="rentalAgreement">Rental agreement</param>
        public PassportElementRentalAgreement(PersonalDocument rentalAgreement = default)
        {
            this.RentalAgreement = rentalAgreement;
        }
    }

    public partial class PassportElementPassportRegistration
    {
        /// <summary>
        /// A Telegram Passport element containing the user's passport registration pages
        /// </summary>
        public PassportElementPassportRegistration() { }
        /// <summary>
        /// A Telegram Passport element containing the user's passport registration pages
        /// </summary>
        /// <param name="passportRegistration">Passport registration pages</param>
        public PassportElementPassportRegistration(PersonalDocument passportRegistration = default)
        {
            this.PassportRegistration = passportRegistration;
        }
    }

    public partial class PassportElementTemporaryRegistration
    {
        /// <summary>
        /// A Telegram Passport element containing the user's temporary registration
        /// </summary>
        public PassportElementTemporaryRegistration() { }
        /// <summary>
        /// A Telegram Passport element containing the user's temporary registration
        /// </summary>
        /// <param name="temporaryRegistration">Temporary registration</param>
        public PassportElementTemporaryRegistration(PersonalDocument temporaryRegistration = default)
        {
            this.TemporaryRegistration = temporaryRegistration;
        }
    }

    public partial class PassportElementPhoneNumber
    {
        /// <summary>
        /// A Telegram Passport element containing the user's phone number
        /// </summary>
        public PassportElementPhoneNumber() { }
        /// <summary>
        /// A Telegram Passport element containing the user's phone number
        /// </summary>
        /// <param name="phoneNumber">Phone number</param>
        public PassportElementPhoneNumber(string phoneNumber = default)
        {
            this.PhoneNumber = phoneNumber;
        }
    }

    public partial class PassportElementEmailAddress
    {
        /// <summary>
        /// A Telegram Passport element containing the user's email address
        /// </summary>
        public PassportElementEmailAddress() { }
        /// <summary>
        /// A Telegram Passport element containing the user's email address
        /// </summary>
        /// <param name="emailAddress">Email address</param>
        public PassportElementEmailAddress(string emailAddress = default)
        {
            this.EmailAddress = emailAddress;
        }
    }

    public partial class InputPassportElementPersonalDetails
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's personal details
        /// </summary>
        public InputPassportElementPersonalDetails() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's personal details
        /// </summary>
        /// <param name="personalDetails">Personal details of the user</param>
        public InputPassportElementPersonalDetails(PersonalDetails personalDetails = default)
        {
            this.PersonalDetails = personalDetails;
        }
    }

    public partial class InputPassportElementPassport
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's passport
        /// </summary>
        public InputPassportElementPassport() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's passport
        /// </summary>
        /// <param name="passport">The passport to be saved</param>
        public InputPassportElementPassport(InputIdentityDocument passport = default)
        {
            this.Passport = passport;
        }
    }

    public partial class InputPassportElementDriverLicense
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's driver license
        /// </summary>
        public InputPassportElementDriverLicense() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's driver license
        /// </summary>
        /// <param name="driverLicense">The driver license to be saved</param>
        public InputPassportElementDriverLicense(InputIdentityDocument driverLicense = default)
        {
            this.DriverLicense = driverLicense;
        }
    }

    public partial class InputPassportElementIdentityCard
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's identity card
        /// </summary>
        public InputPassportElementIdentityCard() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's identity card
        /// </summary>
        /// <param name="identityCard">The identity card to be saved</param>
        public InputPassportElementIdentityCard(InputIdentityDocument identityCard = default)
        {
            this.IdentityCard = identityCard;
        }
    }

    public partial class InputPassportElementInternalPassport
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's internal passport
        /// </summary>
        public InputPassportElementInternalPassport() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's internal passport
        /// </summary>
        /// <param name="internalPassport">The internal passport to be saved</param>
        public InputPassportElementInternalPassport(InputIdentityDocument internalPassport = default)
        {
            this.InternalPassport = internalPassport;
        }
    }

    public partial class InputPassportElementAddress
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's address
        /// </summary>
        public InputPassportElementAddress() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's address
        /// </summary>
        /// <param name="address">The address to be saved</param>
        public InputPassportElementAddress(Address address = default)
        {
            this.Address = address;
        }
    }

    public partial class InputPassportElementUtilityBill
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's utility bill
        /// </summary>
        public InputPassportElementUtilityBill() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's utility bill
        /// </summary>
        /// <param name="utilityBill">The utility bill to be saved</param>
        public InputPassportElementUtilityBill(InputPersonalDocument utilityBill = default)
        {
            this.UtilityBill = utilityBill;
        }
    }

    public partial class InputPassportElementBankStatement
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's bank statement
        /// </summary>
        public InputPassportElementBankStatement() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's bank statement
        /// </summary>
        /// <param name="bankStatement">The bank statement to be saved</param>
        public InputPassportElementBankStatement(InputPersonalDocument bankStatement = default)
        {
            this.BankStatement = bankStatement;
        }
    }

    public partial class InputPassportElementRentalAgreement
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's rental agreement
        /// </summary>
        public InputPassportElementRentalAgreement() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's rental agreement
        /// </summary>
        /// <param name="rentalAgreement">The rental agreement to be saved</param>
        public InputPassportElementRentalAgreement(InputPersonalDocument rentalAgreement = default)
        {
            this.RentalAgreement = rentalAgreement;
        }
    }

    public partial class InputPassportElementPassportRegistration
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's passport registration
        /// </summary>
        public InputPassportElementPassportRegistration() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's passport registration
        /// </summary>
        /// <param name="passportRegistration">The passport registration page to be saved</param>
        public InputPassportElementPassportRegistration(InputPersonalDocument passportRegistration = default)
        {
            this.PassportRegistration = passportRegistration;
        }
    }

    public partial class InputPassportElementTemporaryRegistration
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's temporary registration
        /// </summary>
        public InputPassportElementTemporaryRegistration() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's temporary registration
        /// </summary>
        /// <param name="temporaryRegistration">The temporary registration document to be saved</param>
        public InputPassportElementTemporaryRegistration(InputPersonalDocument temporaryRegistration = default)
        {
            this.TemporaryRegistration = temporaryRegistration;
        }
    }

    public partial class InputPassportElementPhoneNumber
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's phone number
        /// </summary>
        public InputPassportElementPhoneNumber() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's phone number
        /// </summary>
        /// <param name="phoneNumber">The phone number to be saved</param>
        public InputPassportElementPhoneNumber(string phoneNumber = default)
        {
            this.PhoneNumber = phoneNumber;
        }
    }

    public partial class InputPassportElementEmailAddress
    {
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's email address
        /// </summary>
        public InputPassportElementEmailAddress() { }
        /// <summary>
        /// A Telegram Passport element to be saved containing the user's email address
        /// </summary>
        /// <param name="emailAddress">The email address to be saved</param>
        public InputPassportElementEmailAddress(string emailAddress = default)
        {
            this.EmailAddress = emailAddress;
        }
    }

    public partial class PassportElements
    {
        /// <summary>
        /// Contains information about saved Telegram Passport elements
        /// </summary>
        public PassportElements() { }
        /// <summary>
        /// Contains information about saved Telegram Passport elements
        /// </summary>
        /// <param name="elements">Telegram Passport elements</param>
        public PassportElements(PassportElement[] elements = default)
        {
            this.Elements = elements;
        }
    }

    public partial class PassportElementErrorSourceUnspecified
    {
        /// <summary>
        /// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
        /// </summary>
        public PassportElementErrorSourceUnspecified() { }
    }

    public partial class PassportElementErrorSourceDataField
    {
        /// <summary>
        /// One of the data fields contains an error. The error will be considered resolved when the value of the field changes
        /// </summary>
        public PassportElementErrorSourceDataField() { }
        /// <summary>
        /// One of the data fields contains an error. The error will be considered resolved when the value of the field changes
        /// </summary>
        /// <param name="fieldName">Field name</param>
        public PassportElementErrorSourceDataField(string fieldName = default)
        {
            this.FieldName = fieldName;
        }
    }

    public partial class PassportElementErrorSourceFrontSide
    {
        /// <summary>
        /// The front side of the document contains an error. The error will be considered resolved when the file with the front side changes
        /// </summary>
        public PassportElementErrorSourceFrontSide() { }
    }

    public partial class PassportElementErrorSourceReverseSide
    {
        /// <summary>
        /// The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes
        /// </summary>
        public PassportElementErrorSourceReverseSide() { }
    }

    public partial class PassportElementErrorSourceSelfie
    {
        /// <summary>
        /// The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes
        /// </summary>
        public PassportElementErrorSourceSelfie() { }
    }

    public partial class PassportElementErrorSourceTranslationFile
    {
        /// <summary>
        /// One of files with the translation of the document contains an error. The error will be considered resolved when the file changes
        /// </summary>
        public PassportElementErrorSourceTranslationFile() { }
        /// <summary>
        /// One of files with the translation of the document contains an error. The error will be considered resolved when the file changes
        /// </summary>
        /// <param name="fileIndex">Index of a file with the error</param>
        public PassportElementErrorSourceTranslationFile(int fileIndex = default)
        {
            this.FileIndex = fileIndex;
        }
    }

    public partial class PassportElementErrorSourceTranslationFiles
    {
        /// <summary>
        /// The translation of the document contains an error. The error will be considered resolved when the list of translation files changes
        /// </summary>
        public PassportElementErrorSourceTranslationFiles() { }
    }

    public partial class PassportElementErrorSourceFile
    {
        /// <summary>
        /// The file contains an error. The error will be considered resolved when the file changes
        /// </summary>
        public PassportElementErrorSourceFile() { }
        /// <summary>
        /// The file contains an error. The error will be considered resolved when the file changes
        /// </summary>
        /// <param name="fileIndex">Index of a file with the error</param>
        public PassportElementErrorSourceFile(int fileIndex = default)
        {
            this.FileIndex = fileIndex;
        }
    }

    public partial class PassportElementErrorSourceFiles
    {
        /// <summary>
        /// The list of attached files contains an error. The error will be considered resolved when the list of files changes
        /// </summary>
        public PassportElementErrorSourceFiles() { }
    }

    public partial class PassportElementError
    {
        /// <summary>
        /// Contains the description of an error in a Telegram Passport element
        /// </summary>
        public PassportElementError() { }
        /// <summary>
        /// Contains the description of an error in a Telegram Passport element
        /// </summary>
        /// <param name="type">Type of the Telegram Passport element which has the error</param>
        /// <param name="message">Error message</param>
        /// <param name="source">Error source</param>
        public PassportElementError(PassportElementType type = default, string message = default, PassportElementErrorSource source = default)
        {
            this.Type = type;
            this.Message = message;
            this.Source = source;
        }
    }

    public partial class PassportSuitableElement
    {
        /// <summary>
        /// Contains information about a Telegram Passport element that was requested by a service
        /// </summary>
        public PassportSuitableElement() { }
        /// <summary>
        /// Contains information about a Telegram Passport element that was requested by a service
        /// </summary>
        /// <param name="type">Type of the element</param>
        /// <param name="isSelfieRequired">True, if a selfie is required with the identity document</param>
        /// <param name="isTranslationRequired">True, if a certified English translation is required with the document</param>
        /// <param name="isNativeNameRequired">True, if personal details must include the user's name in the language of their country of residence</param>
        public PassportSuitableElement(PassportElementType type = default, bool isSelfieRequired = default, bool isTranslationRequired = default, bool isNativeNameRequired = default)
        {
            this.Type = type;
            this.IsSelfieRequired = isSelfieRequired;
            this.IsTranslationRequired = isTranslationRequired;
            this.IsNativeNameRequired = isNativeNameRequired;
        }
    }

    public partial class PassportRequiredElement
    {
        /// <summary>
        /// Contains a description of the required Telegram Passport element that was requested by a service
        /// </summary>
        public PassportRequiredElement() { }
        /// <summary>
        /// Contains a description of the required Telegram Passport element that was requested by a service
        /// </summary>
        /// <param name="suitableElements">List of Telegram Passport elements any of which is enough to provide</param>
        public PassportRequiredElement(PassportSuitableElement[] suitableElements = default)
        {
            this.SuitableElements = suitableElements;
        }
    }

    public partial class PassportAuthorizationForm
    {
        /// <summary>
        /// Contains information about a Telegram Passport authorization form that was requested
        /// </summary>
        public PassportAuthorizationForm() { }
        /// <summary>
        /// Contains information about a Telegram Passport authorization form that was requested
        /// </summary>
        /// <param name="id">Unique identifier of the authorization form</param>
        /// <param name="requiredElements">Information about the Telegram Passport elements that need to be provided to complete the form</param>
        /// <param name="privacyPolicyUrl">URL for the privacy policy of the service; may be empty</param>
        public PassportAuthorizationForm(int id = default, PassportRequiredElement[] requiredElements = default, string privacyPolicyUrl = default)
        {
            this.Id = id;
            this.RequiredElements = requiredElements;
            this.PrivacyPolicyUrl = privacyPolicyUrl;
        }
    }

    public partial class PassportElementsWithErrors
    {
        /// <summary>
        /// Contains information about a Telegram Passport elements and corresponding errors
        /// </summary>
        public PassportElementsWithErrors() { }
        /// <summary>
        /// Contains information about a Telegram Passport elements and corresponding errors
        /// </summary>
        /// <param name="elements">Telegram Passport elements</param>
        /// <param name="errors">Errors in the elements that are already available</param>
        public PassportElementsWithErrors(PassportElement[] elements = default, PassportElementError[] errors = default)
        {
            this.Elements = elements;
            this.Errors = errors;
        }
    }

    public partial class EncryptedCredentials
    {
        /// <summary>
        /// Contains encrypted Telegram Passport data credentials
        /// </summary>
        public EncryptedCredentials() { }
        /// <summary>
        /// Contains encrypted Telegram Passport data credentials
        /// </summary>
        /// <param name="data">The encrypted credentials</param>
        /// <param name="hash">The decrypted data hash</param>
        /// <param name="secret">Secret for data decryption, encrypted with the service's public key</param>
        public EncryptedCredentials(Memory<byte> data = default, Memory<byte> hash = default, Memory<byte> secret = default)
        {
            this.Data = data;
            this.Hash = hash;
            this.Secret = secret;
        }
    }

    public partial class EncryptedPassportElement
    {
        /// <summary>
        /// Contains information about an encrypted Telegram Passport element; for bots only
        /// </summary>
        public EncryptedPassportElement() { }
        /// <summary>
        /// Contains information about an encrypted Telegram Passport element; for bots only
        /// </summary>
        /// <param name="type">Type of Telegram Passport element</param>
        /// <param name="data">Encrypted JSON-encoded data about the user</param>
        /// <param name="frontSide">The front side of an identity document</param>
        /// <param name="reverseSide">The reverse side of an identity document; may be null</param>
        /// <param name="selfie">Selfie with the document; may be null</param>
        /// <param name="translation">List of files containing a certified English translation of the document</param>
        /// <param name="files">List of attached files</param>
        /// <param name="value">Unencrypted data, phone number or email address</param>
        /// <param name="hash">Hash of the entire element</param>
        public EncryptedPassportElement(PassportElementType type = default, Memory<byte> data = default, DatedFile frontSide = default, DatedFile reverseSide = default, DatedFile selfie = default, DatedFile[] translation = default, DatedFile[] files = default, string value = default, string hash = default)
        {
            this.Type = type;
            this.Data = data;
            this.FrontSide = frontSide;
            this.ReverseSide = reverseSide;
            this.Selfie = selfie;
            this.Translation = translation;
            this.Files = files;
            this.Value = value;
            this.Hash = hash;
        }
    }

    public partial class InputPassportElementErrorSourceUnspecified
    {
        /// <summary>
        /// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
        /// </summary>
        public InputPassportElementErrorSourceUnspecified() { }
        /// <summary>
        /// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
        /// </summary>
        /// <param name="elementHash">Current hash of the entire element</param>
        public InputPassportElementErrorSourceUnspecified(Memory<byte> elementHash = default)
        {
            this.ElementHash = elementHash;
        }
    }

    public partial class InputPassportElementErrorSourceDataField
    {
        /// <summary>
        /// A data field contains an error. The error is considered resolved when the field's value changes
        /// </summary>
        public InputPassportElementErrorSourceDataField() { }
        /// <summary>
        /// A data field contains an error. The error is considered resolved when the field's value changes
        /// </summary>
        /// <param name="fieldName">Field name</param>
        /// <param name="dataHash">Current data hash</param>
        public InputPassportElementErrorSourceDataField(string fieldName = default, Memory<byte> dataHash = default)
        {
            this.FieldName = fieldName;
            this.DataHash = dataHash;
        }
    }

    public partial class InputPassportElementErrorSourceFrontSide
    {
        /// <summary>
        /// The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes
        /// </summary>
        public InputPassportElementErrorSourceFrontSide() { }
        /// <summary>
        /// The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes
        /// </summary>
        /// <param name="fileHash">Current hash of the file containing the front side</param>
        public InputPassportElementErrorSourceFrontSide(Memory<byte> fileHash = default)
        {
            this.FileHash = fileHash;
        }
    }

    public partial class InputPassportElementErrorSourceReverseSide
    {
        /// <summary>
        /// The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes
        /// </summary>
        public InputPassportElementErrorSourceReverseSide() { }
        /// <summary>
        /// The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes
        /// </summary>
        /// <param name="fileHash">Current hash of the file containing the reverse side</param>
        public InputPassportElementErrorSourceReverseSide(Memory<byte> fileHash = default)
        {
            this.FileHash = fileHash;
        }
    }

    public partial class InputPassportElementErrorSourceSelfie
    {
        /// <summary>
        /// The selfie contains an error. The error is considered resolved when the file with the selfie changes
        /// </summary>
        public InputPassportElementErrorSourceSelfie() { }
        /// <summary>
        /// The selfie contains an error. The error is considered resolved when the file with the selfie changes
        /// </summary>
        /// <param name="fileHash">Current hash of the file containing the selfie</param>
        public InputPassportElementErrorSourceSelfie(Memory<byte> fileHash = default)
        {
            this.FileHash = fileHash;
        }
    }

    public partial class InputPassportElementErrorSourceTranslationFile
    {
        /// <summary>
        /// One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes
        /// </summary>
        public InputPassportElementErrorSourceTranslationFile() { }
        /// <summary>
        /// One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes
        /// </summary>
        /// <param name="fileHash">Current hash of the file containing the translation</param>
        public InputPassportElementErrorSourceTranslationFile(Memory<byte> fileHash = default)
        {
            this.FileHash = fileHash;
        }
    }

    public partial class InputPassportElementErrorSourceTranslationFiles
    {
        /// <summary>
        /// The translation of the document contains an error. The error is considered resolved when the list of files changes
        /// </summary>
        public InputPassportElementErrorSourceTranslationFiles() { }
        /// <summary>
        /// The translation of the document contains an error. The error is considered resolved when the list of files changes
        /// </summary>
        /// <param name="fileHashes">Current hashes of all files with the translation</param>
        public InputPassportElementErrorSourceTranslationFiles(Memory<byte>[] fileHashes = default)
        {
            this.FileHashes = fileHashes;
        }
    }

    public partial class InputPassportElementErrorSourceFile
    {
        /// <summary>
        /// The file contains an error. The error is considered resolved when the file changes
        /// </summary>
        public InputPassportElementErrorSourceFile() { }
        /// <summary>
        /// The file contains an error. The error is considered resolved when the file changes
        /// </summary>
        /// <param name="fileHash">Current hash of the file which has the error</param>
        public InputPassportElementErrorSourceFile(Memory<byte> fileHash = default)
        {
            this.FileHash = fileHash;
        }
    }

    public partial class InputPassportElementErrorSourceFiles
    {
        /// <summary>
        /// The list of attached files contains an error. The error is considered resolved when the file list changes
        /// </summary>
        public InputPassportElementErrorSourceFiles() { }
        /// <summary>
        /// The list of attached files contains an error. The error is considered resolved when the file list changes
        /// </summary>
        /// <param name="fileHashes">Current hashes of all attached files</param>
        public InputPassportElementErrorSourceFiles(Memory<byte>[] fileHashes = default)
        {
            this.FileHashes = fileHashes;
        }
    }

    public partial class InputPassportElementError
    {
        /// <summary>
        /// Contains the description of an error in a Telegram Passport element; for bots only
        /// </summary>
        public InputPassportElementError() { }
        /// <summary>
        /// Contains the description of an error in a Telegram Passport element; for bots only
        /// </summary>
        /// <param name="type">Type of Telegram Passport element that has the error</param>
        /// <param name="message">Error message</param>
        /// <param name="source">Error source</param>
        public InputPassportElementError(PassportElementType type = default, string message = default, InputPassportElementErrorSource source = default)
        {
            this.Type = type;
            this.Message = message;
            this.Source = source;
        }
    }

    public partial class MessageText
    {
        /// <summary>
        /// A text message
        /// </summary>
        public MessageText() { }
        /// <summary>
        /// A text message
        /// </summary>
        /// <param name="text">Text of the message</param>
        /// <param name="webPage">A preview of the web page that's mentioned in the text; may be null</param>
        public MessageText(FormattedText text = default, WebPage webPage = default)
        {
            this.Text = text;
            this.WebPage = webPage;
        }
    }

    public partial class MessageAnimation
    {
        /// <summary>
        /// An animation message (GIF-style).
        /// </summary>
        public MessageAnimation() { }
        /// <summary>
        /// An animation message (GIF-style).
        /// </summary>
        /// <param name="animation">The animation description</param>
        /// <param name="caption">Animation caption</param>
        /// <param name="isSecret">True, if the animation thumbnail must be blurred and the animation must be shown only while tapped</param>
        public MessageAnimation(Animation animation = default, FormattedText caption = default, bool isSecret = default)
        {
            this.Animation = animation;
            this.Caption = caption;
            this.IsSecret = isSecret;
        }
    }

    public partial class MessageAudio
    {
        /// <summary>
        /// An audio message
        /// </summary>
        public MessageAudio() { }
        /// <summary>
        /// An audio message
        /// </summary>
        /// <param name="audio">The audio description</param>
        /// <param name="caption">Audio caption</param>
        public MessageAudio(Audio audio = default, FormattedText caption = default)
        {
            this.Audio = audio;
            this.Caption = caption;
        }
    }

    public partial class MessageDocument
    {
        /// <summary>
        /// A document message (general file)
        /// </summary>
        public MessageDocument() { }
        /// <summary>
        /// A document message (general file)
        /// </summary>
        /// <param name="document">The document description</param>
        /// <param name="caption">Document caption</param>
        public MessageDocument(Document document = default, FormattedText caption = default)
        {
            this.Document = document;
            this.Caption = caption;
        }
    }

    public partial class MessagePhoto
    {
        /// <summary>
        /// A photo message
        /// </summary>
        public MessagePhoto() { }
        /// <summary>
        /// A photo message
        /// </summary>
        /// <param name="photo">The photo description</param>
        /// <param name="caption">Photo caption</param>
        /// <param name="isSecret">True, if the photo must be blurred and must be shown only while tapped</param>
        public MessagePhoto(Photo photo = default, FormattedText caption = default, bool isSecret = default)
        {
            this.Photo = photo;
            this.Caption = caption;
            this.IsSecret = isSecret;
        }
    }

    public partial class MessageExpiredPhoto
    {
        /// <summary>
        /// An expired photo message (self-destructed after TTL has elapsed)
        /// </summary>
        public MessageExpiredPhoto() { }
    }

    public partial class MessageSticker
    {
        /// <summary>
        /// A sticker message
        /// </summary>
        public MessageSticker() { }
        /// <summary>
        /// A sticker message
        /// </summary>
        /// <param name="sticker">The sticker description</param>
        public MessageSticker(Sticker sticker = default)
        {
            this.Sticker = sticker;
        }
    }

    public partial class MessageVideo
    {
        /// <summary>
        /// A video message
        /// </summary>
        public MessageVideo() { }
        /// <summary>
        /// A video message
        /// </summary>
        /// <param name="video">The video description</param>
        /// <param name="caption">Video caption</param>
        /// <param name="isSecret">True, if the video thumbnail must be blurred and the video must be shown only while tapped</param>
        public MessageVideo(Video video = default, FormattedText caption = default, bool isSecret = default)
        {
            this.Video = video;
            this.Caption = caption;
            this.IsSecret = isSecret;
        }
    }

    public partial class MessageExpiredVideo
    {
        /// <summary>
        /// An expired video message (self-destructed after TTL has elapsed)
        /// </summary>
        public MessageExpiredVideo() { }
    }

    public partial class MessageVideoNote
    {
        /// <summary>
        /// A video note message
        /// </summary>
        public MessageVideoNote() { }
        /// <summary>
        /// A video note message
        /// </summary>
        /// <param name="videoNote">The video note description</param>
        /// <param name="isViewed">True, if at least one of the recipients has viewed the video note</param>
        /// <param name="isSecret">True, if the video note thumbnail must be blurred and the video note must be shown only while tapped</param>
        public MessageVideoNote(VideoNote videoNote = default, bool isViewed = default, bool isSecret = default)
        {
            this.VideoNote = videoNote;
            this.IsViewed = isViewed;
            this.IsSecret = isSecret;
        }
    }

    public partial class MessageVoiceNote
    {
        /// <summary>
        /// A voice note message
        /// </summary>
        public MessageVoiceNote() { }
        /// <summary>
        /// A voice note message
        /// </summary>
        /// <param name="voiceNote">The voice note description</param>
        /// <param name="caption">Voice note caption</param>
        /// <param name="isListened">True, if at least one of the recipients has listened to the voice note</param>
        public MessageVoiceNote(VoiceNote voiceNote = default, FormattedText caption = default, bool isListened = default)
        {
            this.VoiceNote = voiceNote;
            this.Caption = caption;
            this.IsListened = isListened;
        }
    }

    public partial class MessageLocation
    {
        /// <summary>
        /// A message with a location
        /// </summary>
        public MessageLocation() { }
        /// <summary>
        /// A message with a location
        /// </summary>
        /// <param name="location">The location description</param>
        /// <param name="livePeriod">Time relative to the message sent date until which the location can be updated, in seconds</param>
        /// <param name="expiresIn">Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes</param>
        public MessageLocation(Location location = default, int livePeriod = default, int expiresIn = default)
        {
            this.Location = location;
            this.LivePeriod = livePeriod;
            this.ExpiresIn = expiresIn;
        }
    }

    public partial class MessageVenue
    {
        /// <summary>
        /// A message with information about a venue
        /// </summary>
        public MessageVenue() { }
        /// <summary>
        /// A message with information about a venue
        /// </summary>
        /// <param name="venue">The venue description</param>
        public MessageVenue(Venue venue = default)
        {
            this.Venue = venue;
        }
    }

    public partial class MessageContact
    {
        /// <summary>
        /// A message with a user contact
        /// </summary>
        public MessageContact() { }
        /// <summary>
        /// A message with a user contact
        /// </summary>
        /// <param name="contact">The contact description</param>
        public MessageContact(Contact contact = default)
        {
            this.Contact = contact;
        }
    }

    public partial class MessageDice
    {
        /// <summary>
        /// A dice message. The dice value is randomly generated by the server
        /// </summary>
        public MessageDice() { }
        /// <summary>
        /// A dice message. The dice value is randomly generated by the server
        /// </summary>
        /// <param name="initialStateSticker">The animated sticker with the initial dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known</param>
        /// <param name="finalStateSticker">The animated sticker with the final dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known</param>
        /// <param name="emoji">Emoji on which the dice throw animation is based</param>
        /// <param name="value">The dice value. If the value is 0, the dice don't have final state yet</param>
        /// <param name="successAnimationFrameNumber">Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded</param>
        public MessageDice(Sticker initialStateSticker = default, Sticker finalStateSticker = default, string emoji = default, int value = default, int successAnimationFrameNumber = default)
        {
            this.InitialStateSticker = initialStateSticker;
            this.FinalStateSticker = finalStateSticker;
            this.Emoji = emoji;
            this.Value = value;
            this.SuccessAnimationFrameNumber = successAnimationFrameNumber;
        }
    }

    public partial class MessageGame
    {
        /// <summary>
        /// A message with a game
        /// </summary>
        public MessageGame() { }
        /// <summary>
        /// A message with a game
        /// </summary>
        /// <param name="game">The game description</param>
        public MessageGame(Game game = default)
        {
            this.Game = game;
        }
    }

    public partial class MessagePoll
    {
        /// <summary>
        /// A message with a poll
        /// </summary>
        public MessagePoll() { }
        /// <summary>
        /// A message with a poll
        /// </summary>
        /// <param name="poll">The poll description</param>
        public MessagePoll(Poll poll = default)
        {
            this.Poll = poll;
        }
    }

    public partial class MessageInvoice
    {
        /// <summary>
        /// A message with an invoice from a bot
        /// </summary>
        public MessageInvoice() { }
        /// <summary>
        /// A message with an invoice from a bot
        /// </summary>
        /// <param name="title">Product title</param>
        /// <param name="description">A message with an invoice from a bot</param>
        /// <param name="photo">Product photo; may be null</param>
        /// <param name="currency">Currency for the product price</param>
        /// <param name="totalAmount">Product total price in the minimal quantity of the currency</param>
        /// <param name="startParameter">Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter}</param>
        /// <param name="isTest">True, if the invoice is a test invoice</param>
        /// <param name="needShippingAddress">True, if the shipping address should be specified</param>
        /// <param name="receiptMessageId">The identifier of the message with the receipt, after the product has been purchased</param>
        public MessageInvoice(string title = default, string description = default, Photo photo = default, string currency = default, long totalAmount = default, string startParameter = default, bool isTest = default, bool needShippingAddress = default, long receiptMessageId = default)
        {
            this.Title = title;
            this.Description = description;
            this.Photo = photo;
            this.Currency = currency;
            this.TotalAmount = totalAmount;
            this.StartParameter = startParameter;
            this.IsTest = isTest;
            this.NeedShippingAddress = needShippingAddress;
            this.ReceiptMessageId = receiptMessageId;
        }
    }

    public partial class MessageCall
    {
        /// <summary>
        /// A message with information about an ended call
        /// </summary>
        public MessageCall() { }
        /// <summary>
        /// A message with information about an ended call
        /// </summary>
        /// <param name="isVideo">True, if the call was a video call</param>
        /// <param name="discardReason">Reason why the call was discarded</param>
        /// <param name="duration">Call duration, in seconds</param>
        public MessageCall(bool isVideo = default, CallDiscardReason discardReason = default, int duration = default)
        {
            this.IsVideo = isVideo;
            this.DiscardReason = discardReason;
            this.Duration = duration;
        }
    }

    public partial class MessageBasicGroupChatCreate
    {
        /// <summary>
        /// A newly created basic group
        /// </summary>
        public MessageBasicGroupChatCreate() { }
        /// <summary>
        /// A newly created basic group
        /// </summary>
        /// <param name="title">Title of the basic group</param>
        /// <param name="memberUserIds">User identifiers of members in the basic group</param>
        public MessageBasicGroupChatCreate(string title = default, int[] memberUserIds = default)
        {
            this.Title = title;
            this.MemberUserIds = memberUserIds;
        }
    }

    public partial class MessageSupergroupChatCreate
    {
        /// <summary>
        /// A newly created supergroup or channel
        /// </summary>
        public MessageSupergroupChatCreate() { }
        /// <summary>
        /// A newly created supergroup or channel
        /// </summary>
        /// <param name="title">Title of the supergroup or channel</param>
        public MessageSupergroupChatCreate(string title = default)
        {
            this.Title = title;
        }
    }

    public partial class MessageChatChangeTitle
    {
        /// <summary>
        /// An updated chat title
        /// </summary>
        public MessageChatChangeTitle() { }
        /// <summary>
        /// An updated chat title
        /// </summary>
        /// <param name="title">New chat title</param>
        public MessageChatChangeTitle(string title = default)
        {
            this.Title = title;
        }
    }

    public partial class MessageChatChangePhoto
    {
        /// <summary>
        /// An updated chat photo
        /// </summary>
        public MessageChatChangePhoto() { }
        /// <summary>
        /// An updated chat photo
        /// </summary>
        /// <param name="photo">New chat photo</param>
        public MessageChatChangePhoto(ChatPhoto photo = default)
        {
            this.Photo = photo;
        }
    }

    public partial class MessageChatDeletePhoto
    {
        /// <summary>
        /// A deleted chat photo
        /// </summary>
        public MessageChatDeletePhoto() { }
    }

    public partial class MessageChatAddMembers
    {
        /// <summary>
        /// New chat members were added
        /// </summary>
        public MessageChatAddMembers() { }
        /// <summary>
        /// New chat members were added
        /// </summary>
        /// <param name="memberUserIds">User identifiers of the new members</param>
        public MessageChatAddMembers(int[] memberUserIds = default)
        {
            this.MemberUserIds = memberUserIds;
        }
    }

    public partial class MessageChatJoinByLink
    {
        /// <summary>
        /// A new member joined the chat by invite link
        /// </summary>
        public MessageChatJoinByLink() { }
    }

    public partial class MessageChatDeleteMember
    {
        /// <summary>
        /// A chat member was deleted
        /// </summary>
        public MessageChatDeleteMember() { }
        /// <summary>
        /// A chat member was deleted
        /// </summary>
        /// <param name="userId">User identifier of the deleted chat member</param>
        public MessageChatDeleteMember(int userId = default)
        {
            this.UserId = userId;
        }
    }

    public partial class MessageChatUpgradeTo
    {
        /// <summary>
        /// A basic group was upgraded to a supergroup and was deactivated as the result
        /// </summary>
        public MessageChatUpgradeTo() { }
        /// <summary>
        /// A basic group was upgraded to a supergroup and was deactivated as the result
        /// </summary>
        /// <param name="supergroupId">Identifier of the supergroup to which the basic group was upgraded</param>
        public MessageChatUpgradeTo(int supergroupId = default)
        {
            this.SupergroupId = supergroupId;
        }
    }

    public partial class MessageChatUpgradeFrom
    {
        /// <summary>
        /// A supergroup has been created from a basic group
        /// </summary>
        public MessageChatUpgradeFrom() { }
        /// <summary>
        /// A supergroup has been created from a basic group
        /// </summary>
        /// <param name="title">Title of the newly created supergroup</param>
        /// <param name="basicGroupId">The identifier of the original basic group</param>
        public MessageChatUpgradeFrom(string title = default, int basicGroupId = default)
        {
            this.Title = title;
            this.BasicGroupId = basicGroupId;
        }
    }

    public partial class MessagePinMessage
    {
        /// <summary>
        /// A message has been pinned
        /// </summary>
        public MessagePinMessage() { }
        /// <summary>
        /// A message has been pinned
        /// </summary>
        /// <param name="messageId">Identifier of the pinned message, can be an identifier of a deleted message or 0</param>
        public MessagePinMessage(long messageId = default)
        {
            this.MessageId = messageId;
        }
    }

    public partial class MessageScreenshotTaken
    {
        /// <summary>
        /// A screenshot of a message in the chat has been taken
        /// </summary>
        public MessageScreenshotTaken() { }
    }

    public partial class MessageChatSetTtl
    {
        /// <summary>
        /// The TTL (Time To Live) setting messages in a secret chat has been changed
        /// </summary>
        public MessageChatSetTtl() { }
        /// <summary>
        /// The TTL (Time To Live) setting messages in a secret chat has been changed
        /// </summary>
        /// <param name="ttl">New TTL</param>
        public MessageChatSetTtl(int ttl = default)
        {
            this.Ttl = ttl;
        }
    }

    public partial class MessageCustomServiceAction
    {
        /// <summary>
        /// A non-standard action has happened in the chat
        /// </summary>
        public MessageCustomServiceAction() { }
        /// <summary>
        /// A non-standard action has happened in the chat
        /// </summary>
        /// <param name="text">Message text to be shown in the chat</param>
        public MessageCustomServiceAction(string text = default)
        {
            this.Text = text;
        }
    }

    public partial class MessageGameScore
    {
        /// <summary>
        /// A new high score was achieved in a game
        /// </summary>
        public MessageGameScore() { }
        /// <summary>
        /// A new high score was achieved in a game
        /// </summary>
        /// <param name="gameMessageId">Identifier of the message with the game, can be an identifier of a deleted message</param>
        /// <param name="gameId">Identifier of the game; may be different from the games presented in the message with the game</param>
        /// <param name="score">New score</param>
        public MessageGameScore(long gameMessageId = default, long gameId = default, int score = default)
        {
            this.GameMessageId = gameMessageId;
            this.GameId = gameId;
            this.Score = score;
        }
    }

    public partial class MessagePaymentSuccessful
    {
        /// <summary>
        /// A payment has been completed
        /// </summary>
        public MessagePaymentSuccessful() { }
        /// <summary>
        /// A payment has been completed
        /// </summary>
        /// <param name="invoiceMessageId">Identifier of the message with the corresponding invoice; can be an identifier of a deleted message</param>
        /// <param name="currency">Currency for the price of the product</param>
        /// <param name="totalAmount">Total price for the product, in the minimal quantity of the currency</param>
        public MessagePaymentSuccessful(long invoiceMessageId = default, string currency = default, long totalAmount = default)
        {
            this.InvoiceMessageId = invoiceMessageId;
            this.Currency = currency;
            this.TotalAmount = totalAmount;
        }
    }

    public partial class MessagePaymentSuccessfulBot
    {
        /// <summary>
        /// A payment has been completed; for bots only
        /// </summary>
        public MessagePaymentSuccessfulBot() { }
        /// <summary>
        /// A payment has been completed; for bots only
        /// </summary>
        /// <param name="invoiceMessageId">Identifier of the message with the corresponding invoice; can be an identifier of a deleted message</param>
        /// <param name="currency">Currency for price of the product</param>
        /// <param name="totalAmount">Total price for the product, in the minimal quantity of the currency</param>
        /// <param name="invoicePayload">Invoice payload</param>
        /// <param name="shippingOptionId">Identifier of the shipping option chosen by the user; may be empty if not applicable</param>
        /// <param name="orderInfo">Information about the order; may be null</param>
        /// <param name="telegramPaymentChargeId">Telegram payment identifier</param>
        /// <param name="providerPaymentChargeId">Provider payment identifier</param>
        public MessagePaymentSuccessfulBot(long invoiceMessageId = default, string currency = default, long totalAmount = default, Memory<byte> invoicePayload = default, string shippingOptionId = default, OrderInfo orderInfo = default, string telegramPaymentChargeId = default, string providerPaymentChargeId = default)
        {
            this.InvoiceMessageId = invoiceMessageId;
            this.Currency = currency;
            this.TotalAmount = totalAmount;
            this.InvoicePayload = invoicePayload;
            this.ShippingOptionId = shippingOptionId;
            this.OrderInfo = orderInfo;
            this.TelegramPaymentChargeId = telegramPaymentChargeId;
            this.ProviderPaymentChargeId = providerPaymentChargeId;
        }
    }

    public partial class MessageContactRegistered
    {
        /// <summary>
        /// A contact has registered with Telegram
        /// </summary>
        public MessageContactRegistered() { }
    }

    public partial class MessageWebsiteConnected
    {
        /// <summary>
        /// The current user has connected a website by logging in using Telegram Login Widget on it
        /// </summary>
        public MessageWebsiteConnected() { }
        /// <summary>
        /// The current user has connected a website by logging in using Telegram Login Widget on it
        /// </summary>
        /// <param name="domainName">Domain name of the connected website</param>
        public MessageWebsiteConnected(string domainName = default)
        {
            this.DomainName = domainName;
        }
    }

    public partial class MessagePassportDataSent
    {
        /// <summary>
        /// Telegram Passport data has been sent
        /// </summary>
        public MessagePassportDataSent() { }
        /// <summary>
        /// Telegram Passport data has been sent
        /// </summary>
        /// <param name="types">List of Telegram Passport element types sent</param>
        public MessagePassportDataSent(PassportElementType[] types = default)
        {
            this.Types = types;
        }
    }

    public partial class MessagePassportDataReceived
    {
        /// <summary>
        /// Telegram Passport data has been received; for bots only
        /// </summary>
        public MessagePassportDataReceived() { }
        /// <summary>
        /// Telegram Passport data has been received; for bots only
        /// </summary>
        /// <param name="elements">List of received Telegram Passport elements</param>
        /// <param name="credentials">Encrypted data credentials</param>
        public MessagePassportDataReceived(EncryptedPassportElement[] elements = default, EncryptedCredentials credentials = default)
        {
            this.Elements = elements;
            this.Credentials = credentials;
        }
    }

    public partial class MessageUnsupported
    {
        /// <summary>
        /// Message content that is not supported in the current TDLib version
        /// </summary>
        public MessageUnsupported() { }
    }

    public partial class TextEntityTypeMention
    {
        /// <summary>
        /// A mention of a user by their username
        /// </summary>
        public TextEntityTypeMention() { }
    }

    public partial class TextEntityTypeHashtag
    {
        /// <summary>
        /// A hashtag text, beginning with "#"
        /// </summary>
        public TextEntityTypeHashtag() { }
    }

    public partial class TextEntityTypeCashtag
    {
        /// <summary>
        /// A cashtag text, beginning with "$" and consisting of capital english letters (i.e. "$USD")
        /// </summary>
        public TextEntityTypeCashtag() { }
    }

    public partial class TextEntityTypeBotCommand
    {
        /// <summary>
        /// A bot command, beginning with "/". This shouldn't be highlighted if there are no bots in the chat
        /// </summary>
        public TextEntityTypeBotCommand() { }
    }

    public partial class TextEntityTypeUrl
    {
        /// <summary>
        /// An HTTP URL
        /// </summary>
        public TextEntityTypeUrl() { }
    }

    public partial class TextEntityTypeEmailAddress
    {
        /// <summary>
        /// An email address
        /// </summary>
        public TextEntityTypeEmailAddress() { }
    }

    public partial class TextEntityTypePhoneNumber
    {
        /// <summary>
        /// A phone number
        /// </summary>
        public TextEntityTypePhoneNumber() { }
    }

    public partial class TextEntityTypeBankCardNumber
    {
        /// <summary>
        /// A bank card number. The getBankCardInfo method can be used to get information about the bank card
        /// </summary>
        public TextEntityTypeBankCardNumber() { }
    }

    public partial class TextEntityTypeBold
    {
        /// <summary>
        /// A bold text
        /// </summary>
        public TextEntityTypeBold() { }
    }

    public partial class TextEntityTypeItalic
    {
        /// <summary>
        /// An italic text
        /// </summary>
        public TextEntityTypeItalic() { }
    }

    public partial class TextEntityTypeUnderline
    {
        /// <summary>
        /// An underlined text
        /// </summary>
        public TextEntityTypeUnderline() { }
    }

    public partial class TextEntityTypeStrikethrough
    {
        /// <summary>
        /// A strikethrough text
        /// </summary>
        public TextEntityTypeStrikethrough() { }
    }

    public partial class TextEntityTypeCode
    {
        /// <summary>
        /// Text that must be formatted as if inside a code HTML tag
        /// </summary>
        public TextEntityTypeCode() { }
    }

    public partial class TextEntityTypePre
    {
        /// <summary>
        /// Text that must be formatted as if inside a pre HTML tag
        /// </summary>
        public TextEntityTypePre() { }
    }

    public partial class TextEntityTypePreCode
    {
        /// <summary>
        /// Text that must be formatted as if inside pre, and code HTML tags
        /// </summary>
        public TextEntityTypePreCode() { }
        /// <summary>
        /// Text that must be formatted as if inside pre, and code HTML tags
        /// </summary>
        /// <param name="language">Programming language of the code; as defined by the sender</param>
        public TextEntityTypePreCode(string language = default)
        {
            this.Language = language;
        }
    }

    public partial class TextEntityTypeTextUrl
    {
        /// <summary>
        /// A text description shown instead of a raw URL
        /// </summary>
        public TextEntityTypeTextUrl() { }
        /// <summary>
        /// A text description shown instead of a raw URL
        /// </summary>
        /// <param name="url">HTTP or tg:// URL to be opened when the link is clicked</param>
        public TextEntityTypeTextUrl(string url = default)
        {
            this.Url = url;
        }
    }

    public partial class TextEntityTypeMentionName
    {
        /// <summary>
        /// A text shows instead of a raw mention of the user (e.g., when the user has no username)
        /// </summary>
        public TextEntityTypeMentionName() { }
        /// <summary>
        /// A text shows instead of a raw mention of the user (e.g., when the user has no username)
        /// </summary>
        /// <param name="userId">Identifier of the mentioned user</param>
        public TextEntityTypeMentionName(int userId = default)
        {
            this.UserId = userId;
        }
    }

    public partial class InputThumbnail
    {
        /// <summary>
        /// A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size
        /// </summary>
        public InputThumbnail() { }
        /// <summary>
        /// A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size
        /// </summary>
        /// <param name="thumbnail">Thumbnail file to send. Sending thumbnails by file_id is currently not supported</param>
        /// <param name="width">Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown</param>
        /// <param name="height">Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown</param>
        public InputThumbnail(InputFile thumbnail = default, int width = default, int height = default)
        {
            this.Thumbnail = thumbnail;
            this.Width = width;
            this.Height = height;
        }
    }

    public partial class MessageSchedulingStateSendAtDate
    {
        /// <summary>
        /// The message will be sent at the specified date
        /// </summary>
        public MessageSchedulingStateSendAtDate() { }
        /// <summary>
        /// The message will be sent at the specified date
        /// </summary>
        /// <param name="sendDate">Date the message will be sent. The date must be within 367 days in the future</param>
        public MessageSchedulingStateSendAtDate(int sendDate = default)
        {
            this.SendDate = sendDate;
        }
    }

    public partial class MessageSchedulingStateSendWhenOnline
    {
        /// <summary>
        /// The message will be sent when the peer will be online. Applicable to private chats only and when the exact online status of the peer is known
        /// </summary>
        public MessageSchedulingStateSendWhenOnline() { }
    }

    public partial class MessageSendOptions
    {
        /// <summary>
        /// Options to be used when a message is sent
        /// </summary>
        public MessageSendOptions() { }
        /// <summary>
        /// Options to be used when a message is sent
        /// </summary>
        /// <param name="disableNotification">Pass true to disable notification for the message</param>
        /// <param name="fromBackground">Pass true if the message is sent from the background</param>
        /// <param name="schedulingState">Message scheduling state. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled</param>
        public MessageSendOptions(bool disableNotification = default, bool fromBackground = default, MessageSchedulingState schedulingState = default)
        {
            this.DisableNotification = disableNotification;
            this.FromBackground = fromBackground;
            this.SchedulingState = schedulingState;
        }
    }

    public partial class MessageCopyOptions
    {
        /// <summary>
        /// Options to be used when a message content is copied without a link to the original message
        /// </summary>
        public MessageCopyOptions() { }
        /// <summary>
        /// Options to be used when a message content is copied without a link to the original message
        /// </summary>
        /// <param name="sendCopy">True, if content of the message needs to be copied without a link to the original message. Always true if the message is forwarded to a secret chat</param>
        /// <param name="replaceCaption">True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false</param>
        /// <param name="newCaption">New message caption. Ignored if replace_caption is false</param>
        public MessageCopyOptions(bool sendCopy = default, bool replaceCaption = default, FormattedText newCaption = default)
        {
            this.SendCopy = sendCopy;
            this.ReplaceCaption = replaceCaption;
            this.NewCaption = newCaption;
        }
    }

    public partial class InputMessageText
    {
        /// <summary>
        /// A text message
        /// </summary>
        public InputMessageText() { }
        /// <summary>
        /// A text message
        /// </summary>
        /// <param name="text">Formatted text to be sent; 1-GetOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually</param>
        /// <param name="disableWebPagePreview">True, if rich web page previews for URLs in the message text should be disabled</param>
        /// <param name="clearDraft">True, if a chat message draft should be deleted</param>
        public InputMessageText(FormattedText text = default, bool disableWebPagePreview = default, bool clearDraft = default)
        {
            this.Text = text;
            this.DisableWebPagePreview = disableWebPagePreview;
            this.ClearDraft = clearDraft;
        }
    }

    public partial class InputMessageAnimation
    {
        /// <summary>
        /// An animation message (GIF-style).
        /// </summary>
        public InputMessageAnimation() { }
        /// <summary>
        /// An animation message (GIF-style).
        /// </summary>
        /// <param name="animation">Animation file to be sent</param>
        /// <param name="thumbnail">Animation thumbnail, if available</param>
        /// <param name="addedStickerFileIds">File identifiers of the stickers added to the animation, if applicable</param>
        /// <param name="duration">Duration of the animation, in seconds</param>
        /// <param name="width">Width of the animation; may be replaced by the server</param>
        /// <param name="height">Height of the animation; may be replaced by the server</param>
        /// <param name="caption">Animation caption; 0-GetOption("message_caption_length_max") characters</param>
        public InputMessageAnimation(InputFile animation = default, InputThumbnail thumbnail = default, int[] addedStickerFileIds = default, int duration = default, int width = default, int height = default, FormattedText caption = default)
        {
            this.Animation = animation;
            this.Thumbnail = thumbnail;
            this.AddedStickerFileIds = addedStickerFileIds;
            this.Duration = duration;
            this.Width = width;
            this.Height = height;
            this.Caption = caption;
        }
    }

    public partial class InputMessageAudio
    {
        /// <summary>
        /// An audio message
        /// </summary>
        public InputMessageAudio() { }
        /// <summary>
        /// An audio message
        /// </summary>
        /// <param name="audio">Audio file to be sent</param>
        /// <param name="albumCoverThumbnail">Thumbnail of the cover for the album, if available</param>
        /// <param name="duration">Duration of the audio, in seconds; may be replaced by the server</param>
        /// <param name="title">Title of the audio; 0-64 characters; may be replaced by the server</param>
        /// <param name="performer">Performer of the audio; 0-64 characters, may be replaced by the server</param>
        /// <param name="caption">Audio caption; 0-GetOption("message_caption_length_max") characters</param>
        public InputMessageAudio(InputFile audio = default, InputThumbnail albumCoverThumbnail = default, int duration = default, string title = default, string performer = default, FormattedText caption = default)
        {
            this.Audio = audio;
            this.AlbumCoverThumbnail = albumCoverThumbnail;
            this.Duration = duration;
            this.Title = title;
            this.Performer = performer;
            this.Caption = caption;
        }
    }

    public partial class InputMessageDocument
    {
        /// <summary>
        /// A document message (general file)
        /// </summary>
        public InputMessageDocument() { }
        /// <summary>
        /// A document message (general file)
        /// </summary>
        /// <param name="document">Document to be sent</param>
        /// <param name="thumbnail">Document thumbnail, if available</param>
        /// <param name="disableContentTypeDetection">If true, automatic file type detection will be disabled and the document will be always sent as file. Always true for files sent to secret chats</param>
        /// <param name="caption">Document caption; 0-GetOption("message_caption_length_max") characters</param>
        public InputMessageDocument(InputFile document = default, InputThumbnail thumbnail = default, bool disableContentTypeDetection = default, FormattedText caption = default)
        {
            this.Document = document;
            this.Thumbnail = thumbnail;
            this.DisableContentTypeDetection = disableContentTypeDetection;
            this.Caption = caption;
        }
    }

    public partial class InputMessagePhoto
    {
        /// <summary>
        /// A photo message
        /// </summary>
        public InputMessagePhoto() { }
        /// <summary>
        /// A photo message
        /// </summary>
        /// <param name="photo">Photo to send</param>
        /// <param name="thumbnail">Photo thumbnail to be sent, this is sent to the other party in secret chats only</param>
        /// <param name="addedStickerFileIds">File identifiers of the stickers added to the photo, if applicable</param>
        /// <param name="width">Photo width</param>
        /// <param name="height">Photo height</param>
        /// <param name="caption">Photo caption; 0-GetOption("message_caption_length_max") characters</param>
        /// <param name="ttl">Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats</param>
        public InputMessagePhoto(InputFile photo = default, InputThumbnail thumbnail = default, int[] addedStickerFileIds = default, int width = default, int height = default, FormattedText caption = default, int ttl = default)
        {
            this.Photo = photo;
            this.Thumbnail = thumbnail;
            this.AddedStickerFileIds = addedStickerFileIds;
            this.Width = width;
            this.Height = height;
            this.Caption = caption;
            this.Ttl = ttl;
        }
    }

    public partial class InputMessageSticker
    {
        /// <summary>
        /// A sticker message
        /// </summary>
        public InputMessageSticker() { }
        /// <summary>
        /// A sticker message
        /// </summary>
        /// <param name="sticker">Sticker to be sent</param>
        /// <param name="thumbnail">Sticker thumbnail, if available</param>
        /// <param name="width">Sticker width</param>
        /// <param name="height">Sticker height</param>
        public InputMessageSticker(InputFile sticker = default, InputThumbnail thumbnail = default, int width = default, int height = default)
        {
            this.Sticker = sticker;
            this.Thumbnail = thumbnail;
            this.Width = width;
            this.Height = height;
        }
    }

    public partial class InputMessageVideo
    {
        /// <summary>
        /// A video message
        /// </summary>
        public InputMessageVideo() { }
        /// <summary>
        /// A video message
        /// </summary>
        /// <param name="video">Video to be sent</param>
        /// <param name="thumbnail">Video thumbnail, if available</param>
        /// <param name="addedStickerFileIds">File identifiers of the stickers added to the video, if applicable</param>
        /// <param name="duration">Duration of the video, in seconds</param>
        /// <param name="width">Video width</param>
        /// <param name="height">Video height</param>
        /// <param name="supportsStreaming">True, if the video should be tried to be streamed</param>
        /// <param name="caption">Video caption; 0-GetOption("message_caption_length_max") characters</param>
        /// <param name="ttl">Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats</param>
        public InputMessageVideo(InputFile video = default, InputThumbnail thumbnail = default, int[] addedStickerFileIds = default, int duration = default, int width = default, int height = default, bool supportsStreaming = default, FormattedText caption = default, int ttl = default)
        {
            this.Video = video;
            this.Thumbnail = thumbnail;
            this.AddedStickerFileIds = addedStickerFileIds;
            this.Duration = duration;
            this.Width = width;
            this.Height = height;
            this.SupportsStreaming = supportsStreaming;
            this.Caption = caption;
            this.Ttl = ttl;
        }
    }

    public partial class InputMessageVideoNote
    {
        /// <summary>
        /// A video note message
        /// </summary>
        public InputMessageVideoNote() { }
        /// <summary>
        /// A video note message
        /// </summary>
        /// <param name="videoNote">Video note to be sent</param>
        /// <param name="thumbnail">Video thumbnail, if available</param>
        /// <param name="duration">Duration of the video, in seconds</param>
        /// <param name="length">Video width and height; must be positive and not greater than 640</param>
        public InputMessageVideoNote(InputFile videoNote = default, InputThumbnail thumbnail = default, int duration = default, int length = default)
        {
            this.VideoNote = videoNote;
            this.Thumbnail = thumbnail;
            this.Duration = duration;
            this.Length = length;
        }
    }

    public partial class InputMessageVoiceNote
    {
        /// <summary>
        /// A voice note message
        /// </summary>
        public InputMessageVoiceNote() { }
        /// <summary>
        /// A voice note message
        /// </summary>
        /// <param name="voiceNote">Voice note to be sent</param>
        /// <param name="duration">Duration of the voice note, in seconds</param>
        /// <param name="waveform">Waveform representation of the voice note, in 5-bit format</param>
        /// <param name="caption">Voice note caption; 0-GetOption("message_caption_length_max") characters</param>
        public InputMessageVoiceNote(InputFile voiceNote = default, int duration = default, Memory<byte> waveform = default, FormattedText caption = default)
        {
            this.VoiceNote = voiceNote;
            this.Duration = duration;
            this.Waveform = waveform;
            this.Caption = caption;
        }
    }

    public partial class InputMessageLocation
    {
        /// <summary>
        /// A message with a location
        /// </summary>
        public InputMessageLocation() { }
        /// <summary>
        /// A message with a location
        /// </summary>
        /// <param name="location">Location to be sent</param>
        /// <param name="livePeriod">Period for which the location can be updated, in seconds; should be between 60 and 86400 for a live location and 0 otherwise</param>
        public InputMessageLocation(Location location = default, int livePeriod = default)
        {
            this.Location = location;
            this.LivePeriod = livePeriod;
        }
    }

    public partial class InputMessageVenue
    {
        /// <summary>
        /// A message with information about a venue
        /// </summary>
        public InputMessageVenue() { }
        /// <summary>
        /// A message with information about a venue
        /// </summary>
        /// <param name="venue">Venue to send</param>
        public InputMessageVenue(Venue venue = default)
        {
            this.Venue = venue;
        }
    }

    public partial class InputMessageContact
    {
        /// <summary>
        /// A message containing a user contact
        /// </summary>
        public InputMessageContact() { }
        /// <summary>
        /// A message containing a user contact
        /// </summary>
        /// <param name="contact">Contact to send</param>
        public InputMessageContact(Contact contact = default)
        {
            this.Contact = contact;
        }
    }

    public partial class InputMessageDice
    {
        /// <summary>
        /// A dice message
        /// </summary>
        public InputMessageDice() { }
        /// <summary>
        /// A dice message
        /// </summary>
        /// <param name="emoji">Emoji on which the dice throw animation is based</param>
        /// <param name="clearDraft">True, if a chat message draft should be deleted</param>
        public InputMessageDice(string emoji = default, bool clearDraft = default)
        {
            this.Emoji = emoji;
            this.ClearDraft = clearDraft;
        }
    }

    public partial class InputMessageGame
    {
        /// <summary>
        /// A message with a game; not supported for channels or secret chats
        /// </summary>
        public InputMessageGame() { }
        /// <summary>
        /// A message with a game; not supported for channels or secret chats
        /// </summary>
        /// <param name="botUserId">User identifier of the bot that owns the game</param>
        /// <param name="gameShortName">Short name of the game</param>
        public InputMessageGame(int botUserId = default, string gameShortName = default)
        {
            this.BotUserId = botUserId;
            this.GameShortName = gameShortName;
        }
    }

    public partial class InputMessageInvoice
    {
        /// <summary>
        /// A message with an invoice; can be used only by bots and only in private chats
        /// </summary>
        public InputMessageInvoice() { }
        /// <summary>
        /// A message with an invoice; can be used only by bots and only in private chats
        /// </summary>
        /// <param name="invoice">Invoice</param>
        /// <param name="title">Product title; 1-32 characters</param>
        /// <param name="description">A message with an invoice; can be used only by bots and only in private chats</param>
        /// <param name="photoUrl">Product photo URL; optional</param>
        /// <param name="photoSize">Product photo size</param>
        /// <param name="photoWidth">Product photo width</param>
        /// <param name="photoHeight">Product photo height</param>
        /// <param name="payload">The invoice payload</param>
        /// <param name="providerToken">Payment provider token</param>
        /// <param name="providerData">JSON-encoded data about the invoice, which will be shared with the payment provider</param>
        /// <param name="startParameter">Unique invoice bot start_parameter for the generation of this invoice</param>
        public InputMessageInvoice(Invoice invoice = default, string title = default, string description = default, string photoUrl = default, int photoSize = default, int photoWidth = default, int photoHeight = default, Memory<byte> payload = default, string providerToken = default, string providerData = default, string startParameter = default)
        {
            this.Invoice = invoice;
            this.Title = title;
            this.Description = description;
            this.PhotoUrl = photoUrl;
            this.PhotoSize = photoSize;
            this.PhotoWidth = photoWidth;
            this.PhotoHeight = photoHeight;
            this.Payload = payload;
            this.ProviderToken = providerToken;
            this.ProviderData = providerData;
            this.StartParameter = startParameter;
        }
    }

    public partial class InputMessagePoll
    {
        /// <summary>
        /// A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot
        /// </summary>
        public InputMessagePoll() { }
        /// <summary>
        /// A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot
        /// </summary>
        /// <param name="question">Poll question, 1-255 characters (up to 300 characters for bots)</param>
        /// <param name="options">List of poll answer options, 2-10 strings 1-100 characters each</param>
        /// <param name="isAnonymous">True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels</param>
        /// <param name="type">Type of the poll</param>
        /// <param name="openPeriod">Amount of time the poll will be active after creation, in seconds; for bots only</param>
        /// <param name="closeDate">Point in time (Unix timestamp) when the poll will be automatically closed; for bots only</param>
        /// <param name="isClosed">True, if the poll needs to be sent already closed; for bots only</param>
        public InputMessagePoll(string question = default, string[] options = default, bool isAnonymous = default, PollType type = default, int openPeriod = default, int closeDate = default, bool isClosed = default)
        {
            this.Question = question;
            this.Options = options;
            this.IsAnonymous = isAnonymous;
            this.Type = type;
            this.OpenPeriod = openPeriod;
            this.CloseDate = closeDate;
            this.IsClosed = isClosed;
        }
    }

    public partial class InputMessageForwarded
    {
        /// <summary>
        /// A forwarded message
        /// </summary>
        public InputMessageForwarded() { }
        /// <summary>
        /// A forwarded message
        /// </summary>
        /// <param name="fromChatId">Identifier for the chat this forwarded message came from</param>
        /// <param name="messageId">Identifier of the message to forward</param>
        /// <param name="inGameShare">True, if a game message should be shared within a launched game; applies only to game messages</param>
        /// <param name="copyOptions">Options to be used to copy content of the message without a link to the original message</param>
        public InputMessageForwarded(long fromChatId = default, long messageId = default, bool inGameShare = default, MessageCopyOptions copyOptions = default)
        {
            this.FromChatId = fromChatId;
            this.MessageId = messageId;
            this.InGameShare = inGameShare;
            this.CopyOptions = copyOptions;
        }
    }

    public partial class SearchMessagesFilterEmpty
    {
        /// <summary>
        /// Returns all found messages, no filter is applied
        /// </summary>
        public SearchMessagesFilterEmpty() { }
    }

    public partial class SearchMessagesFilterAnimation
    {
        /// <summary>
        /// Returns only animation messages
        /// </summary>
        public SearchMessagesFilterAnimation() { }
    }

    public partial class SearchMessagesFilterAudio
    {
        /// <summary>
        /// Returns only audio messages
        /// </summary>
        public SearchMessagesFilterAudio() { }
    }

    public partial class SearchMessagesFilterDocument
    {
        /// <summary>
        /// Returns only document messages
        /// </summary>
        public SearchMessagesFilterDocument() { }
    }

    public partial class SearchMessagesFilterPhoto
    {
        /// <summary>
        /// Returns only photo messages
        /// </summary>
        public SearchMessagesFilterPhoto() { }
    }

    public partial class SearchMessagesFilterVideo
    {
        /// <summary>
        /// Returns only video messages
        /// </summary>
        public SearchMessagesFilterVideo() { }
    }

    public partial class SearchMessagesFilterVoiceNote
    {
        /// <summary>
        /// Returns only voice note messages
        /// </summary>
        public SearchMessagesFilterVoiceNote() { }
    }

    public partial class SearchMessagesFilterPhotoAndVideo
    {
        /// <summary>
        /// Returns only photo and video messages
        /// </summary>
        public SearchMessagesFilterPhotoAndVideo() { }
    }

    public partial class SearchMessagesFilterUrl
    {
        /// <summary>
        /// Returns only messages containing URLs
        /// </summary>
        public SearchMessagesFilterUrl() { }
    }

    public partial class SearchMessagesFilterChatPhoto
    {
        /// <summary>
        /// Returns only messages containing chat photos
        /// </summary>
        public SearchMessagesFilterChatPhoto() { }
    }

    public partial class SearchMessagesFilterCall
    {
        /// <summary>
        /// Returns only call messages
        /// </summary>
        public SearchMessagesFilterCall() { }
    }

    public partial class SearchMessagesFilterMissedCall
    {
        /// <summary>
        /// Returns only incoming call messages with missed/declined discard reasons
        /// </summary>
        public SearchMessagesFilterMissedCall() { }
    }

    public partial class SearchMessagesFilterVideoNote
    {
        /// <summary>
        /// Returns only video note messages
        /// </summary>
        public SearchMessagesFilterVideoNote() { }
    }

    public partial class SearchMessagesFilterVoiceAndVideoNote
    {
        /// <summary>
        /// Returns only voice and video note messages
        /// </summary>
        public SearchMessagesFilterVoiceAndVideoNote() { }
    }

    public partial class SearchMessagesFilterMention
    {
        /// <summary>
        /// Returns only messages with mentions of the current user, or messages that are replies to their messages
        /// </summary>
        public SearchMessagesFilterMention() { }
    }

    public partial class SearchMessagesFilterUnreadMention
    {
        /// <summary>
        /// Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
        /// </summary>
        public SearchMessagesFilterUnreadMention() { }
    }

    public partial class SearchMessagesFilterFailedToSend
    {
        /// <summary>
        /// Returns only failed to send messages. This filter can be used only if the message database is used
        /// </summary>
        public SearchMessagesFilterFailedToSend() { }
    }

    public partial class ChatActionTyping
    {
        /// <summary>
        /// The user is typing a message
        /// </summary>
        public ChatActionTyping() { }
    }

    public partial class ChatActionRecordingVideo
    {
        /// <summary>
        /// The user is recording a video
        /// </summary>
        public ChatActionRecordingVideo() { }
    }

    public partial class ChatActionUploadingVideo
    {
        /// <summary>
        /// The user is uploading a video
        /// </summary>
        public ChatActionUploadingVideo() { }
        /// <summary>
        /// The user is uploading a video
        /// </summary>
        /// <param name="progress">Upload progress, as a percentage</param>
        public ChatActionUploadingVideo(int progress = default)
        {
            this.Progress = progress;
        }
    }

    public partial class ChatActionRecordingVoiceNote
    {
        /// <summary>
        /// The user is recording a voice note
        /// </summary>
        public ChatActionRecordingVoiceNote() { }
    }

    public partial class ChatActionUploadingVoiceNote
    {
        /// <summary>
        /// The user is uploading a voice note
        /// </summary>
        public ChatActionUploadingVoiceNote() { }
        /// <summary>
        /// The user is uploading a voice note
        /// </summary>
        /// <param name="progress">Upload progress, as a percentage</param>
        public ChatActionUploadingVoiceNote(int progress = default)
        {
            this.Progress = progress;
        }
    }

    public partial class ChatActionUploadingPhoto
    {
        /// <summary>
        /// The user is uploading a photo
        /// </summary>
        public ChatActionUploadingPhoto() { }
        /// <summary>
        /// The user is uploading a photo
        /// </summary>
        /// <param name="progress">Upload progress, as a percentage</param>
        public ChatActionUploadingPhoto(int progress = default)
        {
            this.Progress = progress;
        }
    }

    public partial class ChatActionUploadingDocument
    {
        /// <summary>
        /// The user is uploading a document
        /// </summary>
        public ChatActionUploadingDocument() { }
        /// <summary>
        /// The user is uploading a document
        /// </summary>
        /// <param name="progress">Upload progress, as a percentage</param>
        public ChatActionUploadingDocument(int progress = default)
        {
            this.Progress = progress;
        }
    }

    public partial class ChatActionChoosingLocation
    {
        /// <summary>
        /// The user is picking a location or venue to send
        /// </summary>
        public ChatActionChoosingLocation() { }
    }

    public partial class ChatActionChoosingContact
    {
        /// <summary>
        /// The user is picking a contact to send
        /// </summary>
        public ChatActionChoosingContact() { }
    }

    public partial class ChatActionStartPlayingGame
    {
        /// <summary>
        /// The user has started to play a game
        /// </summary>
        public ChatActionStartPlayingGame() { }
    }

    public partial class ChatActionRecordingVideoNote
    {
        /// <summary>
        /// The user is recording a video note
        /// </summary>
        public ChatActionRecordingVideoNote() { }
    }

    public partial class ChatActionUploadingVideoNote
    {
        /// <summary>
        /// The user is uploading a video note
        /// </summary>
        public ChatActionUploadingVideoNote() { }
        /// <summary>
        /// The user is uploading a video note
        /// </summary>
        /// <param name="progress">Upload progress, as a percentage</param>
        public ChatActionUploadingVideoNote(int progress = default)
        {
            this.Progress = progress;
        }
    }

    public partial class ChatActionCancel
    {
        /// <summary>
        /// The user has cancelled the previous action
        /// </summary>
        public ChatActionCancel() { }
    }

    public partial class UserStatusEmpty
    {
        /// <summary>
        /// The user status was never changed
        /// </summary>
        public UserStatusEmpty() { }
    }

    public partial class UserStatusOnline
    {
        /// <summary>
        /// The user is online
        /// </summary>
        public UserStatusOnline() { }
        /// <summary>
        /// The user is online
        /// </summary>
        /// <param name="expires">Point in time (Unix timestamp) when the user's online status will expire</param>
        public UserStatusOnline(int expires = default)
        {
            this.Expires = expires;
        }
    }

    public partial class UserStatusOffline
    {
        /// <summary>
        /// The user is offline
        /// </summary>
        public UserStatusOffline() { }
        /// <summary>
        /// The user is offline
        /// </summary>
        /// <param name="wasOnline">Point in time (Unix timestamp) when the user was last online</param>
        public UserStatusOffline(int wasOnline = default)
        {
            this.WasOnline = wasOnline;
        }
    }

    public partial class UserStatusRecently
    {
        /// <summary>
        /// The user was online recently
        /// </summary>
        public UserStatusRecently() { }
    }

    public partial class UserStatusLastWeek
    {
        /// <summary>
        /// The user is offline, but was online last week
        /// </summary>
        public UserStatusLastWeek() { }
    }

    public partial class UserStatusLastMonth
    {
        /// <summary>
        /// The user is offline, but was online last month
        /// </summary>
        public UserStatusLastMonth() { }
    }

    public partial class Stickers
    {
        /// <summary>
        /// Represents a list of stickers
        /// </summary>
        public Stickers() { }
        /// <summary>
        /// Represents a list of stickers
        /// </summary>
        /// <param name="stickers">List of stickers</param>
        public Stickers(Sticker[] stickers_ = default)
        {
            this.Stickers_ = stickers_;
        }
    }

    public partial class Emojis
    {
        /// <summary>
        /// Represents a list of emoji
        /// </summary>
        public Emojis() { }
        /// <summary>
        /// Represents a list of emoji
        /// </summary>
        /// <param name="emojis">List of emojis</param>
        public Emojis(string[] emojis_ = default)
        {
            this.Emojis_ = emojis_;
        }
    }

    public partial class StickerSet
    {
        /// <summary>
        /// Represents a sticker set
        /// </summary>
        public StickerSet() { }
        /// <summary>
        /// Represents a sticker set
        /// </summary>
        /// <param name="id">Identifier of the sticker set</param>
        /// <param name="title">Title of the sticker set</param>
        /// <param name="name">Name of the sticker set</param>
        /// <param name="thumbnail">Sticker set thumbnail in WEBP or TGS format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed</param>
        /// <param name="isInstalled">True, if the sticker set has been installed by the current user</param>
        /// <param name="isArchived">True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously</param>
        /// <param name="isOfficial">True, if the sticker set is official</param>
        /// <param name="isAnimated">True, is the stickers in the set are animated</param>
        /// <param name="isMasks">True, if the stickers in the set are masks</param>
        /// <param name="isViewed">True for already viewed trending sticker sets</param>
        /// <param name="stickers">List of stickers in this set</param>
        /// <param name="emojis">A list of emoji corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object</param>
        public StickerSet(long id = default, string title = default, string name = default, Thumbnail thumbnail = default, bool isInstalled = default, bool isArchived = default, bool isOfficial = default, bool isAnimated = default, bool isMasks = default, bool isViewed = default, Sticker[] stickers = default, Emojis[] emojis = default)
        {
            this.Id = id;
            this.Title = title;
            this.Name = name;
            this.Thumbnail = thumbnail;
            this.IsInstalled = isInstalled;
            this.IsArchived = isArchived;
            this.IsOfficial = isOfficial;
            this.IsAnimated = isAnimated;
            this.IsMasks = isMasks;
            this.IsViewed = isViewed;
            this.Stickers = stickers;
            this.Emojis = emojis;
        }
    }

    public partial class StickerSetInfo
    {
        /// <summary>
        /// Represents short information about a sticker set
        /// </summary>
        public StickerSetInfo() { }
        /// <summary>
        /// Represents short information about a sticker set
        /// </summary>
        /// <param name="id">Identifier of the sticker set</param>
        /// <param name="title">Title of the sticker set</param>
        /// <param name="name">Name of the sticker set</param>
        /// <param name="thumbnail">Sticker set thumbnail in WEBP or TGS format with width and height 100; may be null</param>
        /// <param name="isInstalled">True, if the sticker set has been installed by current user</param>
        /// <param name="isArchived">True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously</param>
        /// <param name="isOfficial">True, if the sticker set is official</param>
        /// <param name="isAnimated">True, is the stickers in the set are animated</param>
        /// <param name="isMasks">True, if the stickers in the set are masks</param>
        /// <param name="isViewed">True for already viewed trending sticker sets</param>
        /// <param name="size">Total number of stickers in the set</param>
        /// <param name="covers">Contains up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full set should be requested</param>
        public StickerSetInfo(long id = default, string title = default, string name = default, Thumbnail thumbnail = default, bool isInstalled = default, bool isArchived = default, bool isOfficial = default, bool isAnimated = default, bool isMasks = default, bool isViewed = default, int size = default, Sticker[] covers = default)
        {
            this.Id = id;
            this.Title = title;
            this.Name = name;
            this.Thumbnail = thumbnail;
            this.IsInstalled = isInstalled;
            this.IsArchived = isArchived;
            this.IsOfficial = isOfficial;
            this.IsAnimated = isAnimated;
            this.IsMasks = isMasks;
            this.IsViewed = isViewed;
            this.Size = size;
            this.Covers = covers;
        }
    }

    public partial class StickerSets
    {
        /// <summary>
        /// Represents a list of sticker sets
        /// </summary>
        public StickerSets() { }
        /// <summary>
        /// Represents a list of sticker sets
        /// </summary>
        /// <param name="totalCount">Approximate total number of sticker sets found</param>
        /// <param name="sets">List of sticker sets</param>
        public StickerSets(int totalCount = default, StickerSetInfo[] sets = default)
        {
            this.TotalCount = totalCount;
            this.Sets = sets;
        }
    }

    public partial class CallDiscardReasonEmpty
    {
        /// <summary>
        /// The call wasn't discarded, or the reason is unknown
        /// </summary>
        public CallDiscardReasonEmpty() { }
    }

    public partial class CallDiscardReasonMissed
    {
        /// <summary>
        /// The call was ended before the conversation started. It was cancelled by the caller or missed by the other party
        /// </summary>
        public CallDiscardReasonMissed() { }
    }

    public partial class CallDiscardReasonDeclined
    {
        /// <summary>
        /// The call was ended before the conversation started. It was declined by the other party
        /// </summary>
        public CallDiscardReasonDeclined() { }
    }

    public partial class CallDiscardReasonDisconnected
    {
        /// <summary>
        /// The call was ended during the conversation because the users were disconnected
        /// </summary>
        public CallDiscardReasonDisconnected() { }
    }

    public partial class CallDiscardReasonHungUp
    {
        /// <summary>
        /// The call was ended because one of the parties hung up
        /// </summary>
        public CallDiscardReasonHungUp() { }
    }

    public partial class CallProtocol
    {
        /// <summary>
        /// Specifies the supported call protocols
        /// </summary>
        public CallProtocol() { }
        /// <summary>
        /// Specifies the supported call protocols
        /// </summary>
        /// <param name="udpP2p">True, if UDP peer-to-peer connections are supported</param>
        /// <param name="udpReflector">True, if connection through UDP reflectors is supported</param>
        /// <param name="minLayer">The minimum supported API layer; use 65</param>
        /// <param name="maxLayer">The maximum supported API layer; use 65</param>
        /// <param name="libraryVersions">List of supported libtgvoip versions</param>
        public CallProtocol(bool udpP2p = default, bool udpReflector = default, int minLayer = default, int maxLayer = default, string[] libraryVersions = default)
        {
            this.UdpP2p = udpP2p;
            this.UdpReflector = udpReflector;
            this.MinLayer = minLayer;
            this.MaxLayer = maxLayer;
            this.LibraryVersions = libraryVersions;
        }
    }

    public partial class CallServerTypeTelegramReflector
    {
        /// <summary>
        /// A Telegram call reflector
        /// </summary>
        public CallServerTypeTelegramReflector() { }
        /// <summary>
        /// A Telegram call reflector
        /// </summary>
        /// <param name="peerTag">A peer tag to be used with the reflector</param>
        public CallServerTypeTelegramReflector(Memory<byte> peerTag = default)
        {
            this.PeerTag = peerTag;
        }
    }

    public partial class CallServerTypeWebrtc
    {
        /// <summary>
        /// A WebRTC server
        /// </summary>
        public CallServerTypeWebrtc() { }
        /// <summary>
        /// A WebRTC server
        /// </summary>
        /// <param name="username">Username to be used for authentication</param>
        /// <param name="password">Authentication password</param>
        /// <param name="supportsTurn">True, if the server supports TURN</param>
        /// <param name="supportsStun">True, if the server supports STUN</param>
        public CallServerTypeWebrtc(string username = default, string password = default, bool supportsTurn = default, bool supportsStun = default)
        {
            this.Username = username;
            this.Password = password;
            this.SupportsTurn = supportsTurn;
            this.SupportsStun = supportsStun;
        }
    }

    public partial class CallServer
    {
        /// <summary>
        /// Describes a server for relaying call data
        /// </summary>
        public CallServer() { }
        /// <summary>
        /// Describes a server for relaying call data
        /// </summary>
        /// <param name="id">Server identifier</param>
        /// <param name="ipAddress">Server IPv4 address</param>
        /// <param name="ipv6Address">Server IPv6 address</param>
        /// <param name="port">Server port number</param>
        /// <param name="type">Server type</param>
        public CallServer(long id = default, string ipAddress = default, string ipv6Address = default, int port = default, CallServerType type = default)
        {
            this.Id = id;
            this.IpAddress = ipAddress;
            this.Ipv6Address = ipv6Address;
            this.Port = port;
            this.Type = type;
        }
    }

    public partial class CallId
    {
        /// <summary>
        /// Contains the call identifier
        /// </summary>
        public CallId() { }
        /// <summary>
        /// Contains the call identifier
        /// </summary>
        /// <param name="id">Call identifier</param>
        public CallId(int id = default)
        {
            this.Id = id;
        }
    }

    public partial class CallStatePending
    {
        /// <summary>
        /// The call is pending, waiting to be accepted by a user
        /// </summary>
        public CallStatePending() { }
        /// <summary>
        /// The call is pending, waiting to be accepted by a user
        /// </summary>
        /// <param name="isCreated">True, if the call has already been created by the server</param>
        /// <param name="isReceived">True, if the call has already been received by the other party</param>
        public CallStatePending(bool isCreated = default, bool isReceived = default)
        {
            this.IsCreated = isCreated;
            this.IsReceived = isReceived;
        }
    }

    public partial class CallStateExchangingKeys
    {
        /// <summary>
        /// The call has been answered and encryption keys are being exchanged
        /// </summary>
        public CallStateExchangingKeys() { }
    }

    public partial class CallStateReady
    {
        /// <summary>
        /// The call is ready to use
        /// </summary>
        public CallStateReady() { }
        /// <summary>
        /// The call is ready to use
        /// </summary>
        /// <param name="protocol">Call protocols supported by the peer</param>
        /// <param name="servers">List of available call servers</param>
        /// <param name="config">A JSON-encoded call config</param>
        /// <param name="encryptionKey">Call encryption key</param>
        /// <param name="emojis">Encryption key emojis fingerprint</param>
        /// <param name="allowP2p">True, if peer-to-peer connection is allowed by users privacy settings</param>
        public CallStateReady(CallProtocol protocol = default, CallServer[] servers = default, string config = default, Memory<byte> encryptionKey = default, string[] emojis = default, bool allowP2p = default)
        {
            this.Protocol = protocol;
            this.Servers = servers;
            this.Config = config;
            this.EncryptionKey = encryptionKey;
            this.Emojis = emojis;
            this.AllowP2p = allowP2p;
        }
    }

    public partial class CallStateHangingUp
    {
        /// <summary>
        /// The call is hanging up after discardCall has been called
        /// </summary>
        public CallStateHangingUp() { }
    }

    public partial class CallStateDiscarded
    {
        /// <summary>
        /// The call has ended successfully
        /// </summary>
        public CallStateDiscarded() { }
        /// <summary>
        /// The call has ended successfully
        /// </summary>
        /// <param name="reason">The reason, why the call has ended</param>
        /// <param name="needRating">True, if the call rating should be sent to the server</param>
        /// <param name="needDebugInformation">True, if the call debug information should be sent to the server</param>
        public CallStateDiscarded(CallDiscardReason reason = default, bool needRating = default, bool needDebugInformation = default)
        {
            this.Reason = reason;
            this.NeedRating = needRating;
            this.NeedDebugInformation = needDebugInformation;
        }
    }

    public partial class CallStateError
    {
        /// <summary>
        /// The call has ended with an error
        /// </summary>
        public CallStateError() { }
        /// <summary>
        /// The call has ended with an error
        /// </summary>
        /// <param name="error">Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout</param>
        public CallStateError(Error error = default)
        {
            this.Error = error;
        }
    }

    public partial class CallProblemEcho
    {
        /// <summary>
        /// The user heard their own voice
        /// </summary>
        public CallProblemEcho() { }
    }

    public partial class CallProblemNoise
    {
        /// <summary>
        /// The user heard background noise
        /// </summary>
        public CallProblemNoise() { }
    }

    public partial class CallProblemInterruptions
    {
        /// <summary>
        /// The other side kept disappearing
        /// </summary>
        public CallProblemInterruptions() { }
    }

    public partial class CallProblemDistortedSpeech
    {
        /// <summary>
        /// The speech was distorted
        /// </summary>
        public CallProblemDistortedSpeech() { }
    }

    public partial class CallProblemSilentLocal
    {
        /// <summary>
        /// The user couldn't hear the other side
        /// </summary>
        public CallProblemSilentLocal() { }
    }

    public partial class CallProblemSilentRemote
    {
        /// <summary>
        /// The other side couldn't hear the user
        /// </summary>
        public CallProblemSilentRemote() { }
    }

    public partial class CallProblemDropped
    {
        /// <summary>
        /// The call ended unexpectedly
        /// </summary>
        public CallProblemDropped() { }
    }

    public partial class CallProblemDistortedVideo
    {
        /// <summary>
        /// The video was distorted
        /// </summary>
        public CallProblemDistortedVideo() { }
    }

    public partial class CallProblemPixelatedVideo
    {
        /// <summary>
        /// The video was pixelated
        /// </summary>
        public CallProblemPixelatedVideo() { }
    }

    public partial class Call
    {
        /// <summary>
        /// Describes a call
        /// </summary>
        public Call() { }
        /// <summary>
        /// Describes a call
        /// </summary>
        /// <param name="id">Call identifier, not persistent</param>
        /// <param name="userId">Peer user identifier</param>
        /// <param name="isOutgoing">True, if the call is outgoing</param>
        /// <param name="isVideo">True, if the call is a video call</param>
        /// <param name="state">Call state</param>
        public Call(int id = default, int userId = default, bool isOutgoing = default, bool isVideo = default, CallState state = default)
        {
            this.Id = id;
            this.UserId = userId;
            this.IsOutgoing = isOutgoing;
            this.IsVideo = isVideo;
            this.State = state;
        }
    }

    public partial class PhoneNumberAuthenticationSettings
    {
        /// <summary>
        /// Contains settings for the authentication of the user's phone number
        /// </summary>
        public PhoneNumberAuthenticationSettings() { }
        /// <summary>
        /// Contains settings for the authentication of the user's phone number
        /// </summary>
        /// <param name="allowFlashCall">Pass true if the authentication code may be sent via flash call to the specified phone number</param>
        /// <param name="isCurrentPhoneNumber">Pass true if the authenticated phone number is used on the current device</param>
        /// <param name="allowSmsRetrieverApi">For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services &gt;= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details</param>
        public PhoneNumberAuthenticationSettings(bool allowFlashCall = default, bool isCurrentPhoneNumber = default, bool allowSmsRetrieverApi = default)
        {
            this.AllowFlashCall = allowFlashCall;
            this.IsCurrentPhoneNumber = isCurrentPhoneNumber;
            this.AllowSmsRetrieverApi = allowSmsRetrieverApi;
        }
    }

    public partial class Animations
    {
        /// <summary>
        /// Represents a list of animations
        /// </summary>
        public Animations() { }
        /// <summary>
        /// Represents a list of animations
        /// </summary>
        /// <param name="animations">List of animations</param>
        public Animations(Animation[] animations_ = default)
        {
            this.Animations_ = animations_;
        }
    }

    public partial class ImportedContacts
    {
        /// <summary>
        /// Represents the result of an ImportContacts request
        /// </summary>
        public ImportedContacts() { }
        /// <summary>
        /// Represents the result of an ImportContacts request
        /// </summary>
        /// <param name="userIds">User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user</param>
        /// <param name="importerCount">The number of users that imported the corresponding contact; 0 for already registered users or if unavailable</param>
        public ImportedContacts(int[] userIds = default, int[] importerCount = default)
        {
            this.UserIds = userIds;
            this.ImporterCount = importerCount;
        }
    }

    public partial class HttpUrl
    {
        /// <summary>
        /// Contains an HTTP URL
        /// </summary>
        public HttpUrl() { }
        /// <summary>
        /// Contains an HTTP URL
        /// </summary>
        /// <param name="url">The URL</param>
        public HttpUrl(string url = default)
        {
            this.Url = url;
        }
    }

    public partial class InputInlineQueryResultAnimation
    {
        /// <summary>
        /// Represents a link to an animated GIF or an animated (i.e. without sound) H.264/MPEG-4 AVC video
        /// </summary>
        public InputInlineQueryResultAnimation() { }
        /// <summary>
        /// Represents a link to an animated GIF or an animated (i.e. without sound) H.264/MPEG-4 AVC video
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="title">Title of the query result</param>
        /// <param name="thumbnailUrl">URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists</param>
        /// <param name="thumbnailMimeType">MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"</param>
        /// <param name="videoUrl">The URL of the video file (file size must not exceed 1MB)</param>
        /// <param name="videoMimeType">MIME type of the video file. Must be one of "image/gif" and "video/mp4"</param>
        /// <param name="videoDuration">Duration of the video, in seconds</param>
        /// <param name="videoWidth">Width of the video</param>
        /// <param name="videoHeight">Height of the video</param>
        /// <param name="replyMarkup">The message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        /// <param name="inputMessageContent">The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAnimation, InputMessageLocation, InputMessageVenue or InputMessageContact</param>
        public InputInlineQueryResultAnimation(string id = default, string title = default, string thumbnailUrl = default, string thumbnailMimeType = default, string videoUrl = default, string videoMimeType = default, int videoDuration = default, int videoWidth = default, int videoHeight = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.Id = id;
            this.Title = title;
            this.ThumbnailUrl = thumbnailUrl;
            this.ThumbnailMimeType = thumbnailMimeType;
            this.VideoUrl = videoUrl;
            this.VideoMimeType = videoMimeType;
            this.VideoDuration = videoDuration;
            this.VideoWidth = videoWidth;
            this.VideoHeight = videoHeight;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class InputInlineQueryResultArticle
    {
        /// <summary>
        /// Represents a link to an article or web page
        /// </summary>
        public InputInlineQueryResultArticle() { }
        /// <summary>
        /// Represents a link to an article or web page
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="url">URL of the result, if it exists</param>
        /// <param name="hideUrl">True, if the URL must be not shown</param>
        /// <param name="title">Title of the result</param>
        /// <param name="description">Represents a link to an article or web page</param>
        /// <param name="thumbnailUrl">URL of the result thumbnail, if it exists</param>
        /// <param name="thumbnailWidth">Thumbnail width, if known</param>
        /// <param name="thumbnailHeight">Thumbnail height, if known</param>
        /// <param name="replyMarkup">The message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        /// <param name="inputMessageContent">The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact</param>
        public InputInlineQueryResultArticle(string id = default, string url = default, bool hideUrl = default, string title = default, string description = default, string thumbnailUrl = default, int thumbnailWidth = default, int thumbnailHeight = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.Id = id;
            this.Url = url;
            this.HideUrl = hideUrl;
            this.Title = title;
            this.Description = description;
            this.ThumbnailUrl = thumbnailUrl;
            this.ThumbnailWidth = thumbnailWidth;
            this.ThumbnailHeight = thumbnailHeight;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class InputInlineQueryResultAudio
    {
        /// <summary>
        /// Represents a link to an MP3 audio file
        /// </summary>
        public InputInlineQueryResultAudio() { }
        /// <summary>
        /// Represents a link to an MP3 audio file
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="title">Title of the audio file</param>
        /// <param name="performer">Performer of the audio file</param>
        /// <param name="audioUrl">The URL of the audio file</param>
        /// <param name="audioDuration">Audio file duration, in seconds</param>
        /// <param name="replyMarkup">The message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        /// <param name="inputMessageContent">The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageAudio, InputMessageLocation, InputMessageVenue or InputMessageContact</param>
        public InputInlineQueryResultAudio(string id = default, string title = default, string performer = default, string audioUrl = default, int audioDuration = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.Id = id;
            this.Title = title;
            this.Performer = performer;
            this.AudioUrl = audioUrl;
            this.AudioDuration = audioDuration;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class InputInlineQueryResultContact
    {
        /// <summary>
        /// Represents a user contact
        /// </summary>
        public InputInlineQueryResultContact() { }
        /// <summary>
        /// Represents a user contact
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="contact">User contact</param>
        /// <param name="thumbnailUrl">URL of the result thumbnail, if it exists</param>
        /// <param name="thumbnailWidth">Thumbnail width, if known</param>
        /// <param name="thumbnailHeight">Thumbnail height, if known</param>
        /// <param name="replyMarkup">The message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        /// <param name="inputMessageContent">The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact</param>
        public InputInlineQueryResultContact(string id = default, Contact contact = default, string thumbnailUrl = default, int thumbnailWidth = default, int thumbnailHeight = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.Id = id;
            this.Contact = contact;
            this.ThumbnailUrl = thumbnailUrl;
            this.ThumbnailWidth = thumbnailWidth;
            this.ThumbnailHeight = thumbnailHeight;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class InputInlineQueryResultDocument
    {
        /// <summary>
        /// Represents a link to a file
        /// </summary>
        public InputInlineQueryResultDocument() { }
        /// <summary>
        /// Represents a link to a file
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="title">Title of the resulting file</param>
        /// <param name="description">Represents a link to a file</param>
        /// <param name="documentUrl">URL of the file</param>
        /// <param name="mimeType">MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed</param>
        /// <param name="thumbnailUrl">The URL of the file thumbnail, if it exists</param>
        /// <param name="thumbnailWidth">Width of the thumbnail</param>
        /// <param name="thumbnailHeight">Height of the thumbnail</param>
        /// <param name="replyMarkup">The message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        /// <param name="inputMessageContent">The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageDocument, InputMessageLocation, InputMessageVenue or InputMessageContact</param>
        public InputInlineQueryResultDocument(string id = default, string title = default, string description = default, string documentUrl = default, string mimeType = default, string thumbnailUrl = default, int thumbnailWidth = default, int thumbnailHeight = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.Id = id;
            this.Title = title;
            this.Description = description;
            this.DocumentUrl = documentUrl;
            this.MimeType = mimeType;
            this.ThumbnailUrl = thumbnailUrl;
            this.ThumbnailWidth = thumbnailWidth;
            this.ThumbnailHeight = thumbnailHeight;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class InputInlineQueryResultGame
    {
        /// <summary>
        /// Represents a game
        /// </summary>
        public InputInlineQueryResultGame() { }
        /// <summary>
        /// Represents a game
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="gameShortName">Short name of the game</param>
        /// <param name="replyMarkup">Message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        public InputInlineQueryResultGame(string id = default, string gameShortName = default, ReplyMarkup replyMarkup = default)
        {
            this.Id = id;
            this.GameShortName = gameShortName;
            this.ReplyMarkup = replyMarkup;
        }
    }

    public partial class InputInlineQueryResultLocation
    {
        /// <summary>
        /// Represents a point on the map
        /// </summary>
        public InputInlineQueryResultLocation() { }
        /// <summary>
        /// Represents a point on the map
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="location">Location result</param>
        /// <param name="livePeriod">Amount of time relative to the message sent time until the location can be updated, in seconds</param>
        /// <param name="title">Title of the result</param>
        /// <param name="thumbnailUrl">URL of the result thumbnail, if it exists</param>
        /// <param name="thumbnailWidth">Thumbnail width, if known</param>
        /// <param name="thumbnailHeight">Thumbnail height, if known</param>
        /// <param name="replyMarkup">The message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        /// <param name="inputMessageContent">The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact</param>
        public InputInlineQueryResultLocation(string id = default, Location location = default, int livePeriod = default, string title = default, string thumbnailUrl = default, int thumbnailWidth = default, int thumbnailHeight = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.Id = id;
            this.Location = location;
            this.LivePeriod = livePeriod;
            this.Title = title;
            this.ThumbnailUrl = thumbnailUrl;
            this.ThumbnailWidth = thumbnailWidth;
            this.ThumbnailHeight = thumbnailHeight;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class InputInlineQueryResultPhoto
    {
        /// <summary>
        /// Represents link to a JPEG image
        /// </summary>
        public InputInlineQueryResultPhoto() { }
        /// <summary>
        /// Represents link to a JPEG image
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="title">Title of the result, if known</param>
        /// <param name="description">Represents link to a JPEG image</param>
        /// <param name="thumbnailUrl">URL of the photo thumbnail, if it exists</param>
        /// <param name="photoUrl">The URL of the JPEG photo (photo size must not exceed 5MB)</param>
        /// <param name="photoWidth">Width of the photo</param>
        /// <param name="photoHeight">Height of the photo</param>
        /// <param name="replyMarkup">The message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        /// <param name="inputMessageContent">The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessagePhoto, InputMessageLocation, InputMessageVenue or InputMessageContact</param>
        public InputInlineQueryResultPhoto(string id = default, string title = default, string description = default, string thumbnailUrl = default, string photoUrl = default, int photoWidth = default, int photoHeight = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.Id = id;
            this.Title = title;
            this.Description = description;
            this.ThumbnailUrl = thumbnailUrl;
            this.PhotoUrl = photoUrl;
            this.PhotoWidth = photoWidth;
            this.PhotoHeight = photoHeight;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class InputInlineQueryResultSticker
    {
        /// <summary>
        /// Represents a link to a WEBP or TGS sticker
        /// </summary>
        public InputInlineQueryResultSticker() { }
        /// <summary>
        /// Represents a link to a WEBP or TGS sticker
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="thumbnailUrl">URL of the sticker thumbnail, if it exists</param>
        /// <param name="stickerUrl">The URL of the WEBP or TGS sticker (sticker file size must not exceed 5MB)</param>
        /// <param name="stickerWidth">Width of the sticker</param>
        /// <param name="stickerHeight">Height of the sticker</param>
        /// <param name="replyMarkup">The message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        /// <param name="inputMessageContent">The content of the message to be sent. Must be one of the following types: InputMessageText, inputMessageSticker, InputMessageLocation, InputMessageVenue or InputMessageContact</param>
        public InputInlineQueryResultSticker(string id = default, string thumbnailUrl = default, string stickerUrl = default, int stickerWidth = default, int stickerHeight = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.Id = id;
            this.ThumbnailUrl = thumbnailUrl;
            this.StickerUrl = stickerUrl;
            this.StickerWidth = stickerWidth;
            this.StickerHeight = stickerHeight;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class InputInlineQueryResultVenue
    {
        /// <summary>
        /// Represents information about a venue
        /// </summary>
        public InputInlineQueryResultVenue() { }
        /// <summary>
        /// Represents information about a venue
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="venue">Venue result</param>
        /// <param name="thumbnailUrl">URL of the result thumbnail, if it exists</param>
        /// <param name="thumbnailWidth">Thumbnail width, if known</param>
        /// <param name="thumbnailHeight">Thumbnail height, if known</param>
        /// <param name="replyMarkup">The message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        /// <param name="inputMessageContent">The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageLocation, InputMessageVenue or InputMessageContact</param>
        public InputInlineQueryResultVenue(string id = default, Venue venue = default, string thumbnailUrl = default, int thumbnailWidth = default, int thumbnailHeight = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.Id = id;
            this.Venue = venue;
            this.ThumbnailUrl = thumbnailUrl;
            this.ThumbnailWidth = thumbnailWidth;
            this.ThumbnailHeight = thumbnailHeight;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class InputInlineQueryResultVideo
    {
        /// <summary>
        /// Represents a link to a page containing an embedded video player or a video file
        /// </summary>
        public InputInlineQueryResultVideo() { }
        /// <summary>
        /// Represents a link to a page containing an embedded video player or a video file
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="title">Title of the result</param>
        /// <param name="description">Represents a link to a page containing an embedded video player or a video file</param>
        /// <param name="thumbnailUrl">The URL of the video thumbnail (JPEG), if it exists</param>
        /// <param name="videoUrl">URL of the embedded video player or video file</param>
        /// <param name="mimeType">MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported</param>
        /// <param name="videoWidth">Width of the video</param>
        /// <param name="videoHeight">Height of the video</param>
        /// <param name="videoDuration">Video duration, in seconds</param>
        /// <param name="replyMarkup">The message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        /// <param name="inputMessageContent">The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageVideo, InputMessageLocation, InputMessageVenue or InputMessageContact</param>
        public InputInlineQueryResultVideo(string id = default, string title = default, string description = default, string thumbnailUrl = default, string videoUrl = default, string mimeType = default, int videoWidth = default, int videoHeight = default, int videoDuration = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.Id = id;
            this.Title = title;
            this.Description = description;
            this.ThumbnailUrl = thumbnailUrl;
            this.VideoUrl = videoUrl;
            this.MimeType = mimeType;
            this.VideoWidth = videoWidth;
            this.VideoHeight = videoHeight;
            this.VideoDuration = videoDuration;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class InputInlineQueryResultVoiceNote
    {
        /// <summary>
        /// Represents a link to an opus-encoded audio file within an OGG container, single channel audio
        /// </summary>
        public InputInlineQueryResultVoiceNote() { }
        /// <summary>
        /// Represents a link to an opus-encoded audio file within an OGG container, single channel audio
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="title">Title of the voice note</param>
        /// <param name="voiceNoteUrl">The URL of the voice note file</param>
        /// <param name="voiceNoteDuration">Duration of the voice note, in seconds</param>
        /// <param name="replyMarkup">The message reply markup. Must be of type replyMarkupInlineKeyboard or null</param>
        /// <param name="inputMessageContent">The content of the message to be sent. Must be one of the following types: InputMessageText, InputMessageVoiceNote, InputMessageLocation, InputMessageVenue or InputMessageContact</param>
        public InputInlineQueryResultVoiceNote(string id = default, string title = default, string voiceNoteUrl = default, int voiceNoteDuration = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.Id = id;
            this.Title = title;
            this.VoiceNoteUrl = voiceNoteUrl;
            this.VoiceNoteDuration = voiceNoteDuration;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class InlineQueryResultArticle
    {
        /// <summary>
        /// Represents a link to an article or web page
        /// </summary>
        public InlineQueryResultArticle() { }
        /// <summary>
        /// Represents a link to an article or web page
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="url">URL of the result, if it exists</param>
        /// <param name="hideUrl">True, if the URL must be not shown</param>
        /// <param name="title">Title of the result</param>
        /// <param name="description">Represents a link to an article or web page</param>
        /// <param name="thumbnail">Result thumbnail in JPEG format; may be null</param>
        public InlineQueryResultArticle(string id = default, string url = default, bool hideUrl = default, string title = default, string description = default, Thumbnail thumbnail = default)
        {
            this.Id = id;
            this.Url = url;
            this.HideUrl = hideUrl;
            this.Title = title;
            this.Description = description;
            this.Thumbnail = thumbnail;
        }
    }

    public partial class InlineQueryResultContact
    {
        /// <summary>
        /// Represents a user contact
        /// </summary>
        public InlineQueryResultContact() { }
        /// <summary>
        /// Represents a user contact
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="contact">A user contact</param>
        /// <param name="thumbnail">Result thumbnail in JPEG format; may be null</param>
        public InlineQueryResultContact(string id = default, Contact contact = default, Thumbnail thumbnail = default)
        {
            this.Id = id;
            this.Contact = contact;
            this.Thumbnail = thumbnail;
        }
    }

    public partial class InlineQueryResultLocation
    {
        /// <summary>
        /// Represents a point on the map
        /// </summary>
        public InlineQueryResultLocation() { }
        /// <summary>
        /// Represents a point on the map
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="location">Location result</param>
        /// <param name="title">Title of the result</param>
        /// <param name="thumbnail">Result thumbnail in JPEG format; may be null</param>
        public InlineQueryResultLocation(string id = default, Location location = default, string title = default, Thumbnail thumbnail = default)
        {
            this.Id = id;
            this.Location = location;
            this.Title = title;
            this.Thumbnail = thumbnail;
        }
    }

    public partial class InlineQueryResultVenue
    {
        /// <summary>
        /// Represents information about a venue
        /// </summary>
        public InlineQueryResultVenue() { }
        /// <summary>
        /// Represents information about a venue
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="venue">Venue result</param>
        /// <param name="thumbnail">Result thumbnail in JPEG format; may be null</param>
        public InlineQueryResultVenue(string id = default, Venue venue = default, Thumbnail thumbnail = default)
        {
            this.Id = id;
            this.Venue = venue;
            this.Thumbnail = thumbnail;
        }
    }

    public partial class InlineQueryResultGame
    {
        /// <summary>
        /// Represents information about a game
        /// </summary>
        public InlineQueryResultGame() { }
        /// <summary>
        /// Represents information about a game
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="game">Game result</param>
        public InlineQueryResultGame(string id = default, Game game = default)
        {
            this.Id = id;
            this.Game = game;
        }
    }

    public partial class InlineQueryResultAnimation
    {
        /// <summary>
        /// Represents an animation file
        /// </summary>
        public InlineQueryResultAnimation() { }
        /// <summary>
        /// Represents an animation file
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="animation">Animation file</param>
        /// <param name="title">Animation title</param>
        public InlineQueryResultAnimation(string id = default, Animation animation = default, string title = default)
        {
            this.Id = id;
            this.Animation = animation;
            this.Title = title;
        }
    }

    public partial class InlineQueryResultAudio
    {
        /// <summary>
        /// Represents an audio file
        /// </summary>
        public InlineQueryResultAudio() { }
        /// <summary>
        /// Represents an audio file
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="audio">Audio file</param>
        public InlineQueryResultAudio(string id = default, Audio audio = default)
        {
            this.Id = id;
            this.Audio = audio;
        }
    }

    public partial class InlineQueryResultDocument
    {
        /// <summary>
        /// Represents a document
        /// </summary>
        public InlineQueryResultDocument() { }
        /// <summary>
        /// Represents a document
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="document">Document</param>
        /// <param name="title">Document title</param>
        /// <param name="description">Represents a document</param>
        public InlineQueryResultDocument(string id = default, Document document = default, string title = default, string description = default)
        {
            this.Id = id;
            this.Document = document;
            this.Title = title;
            this.Description = description;
        }
    }

    public partial class InlineQueryResultPhoto
    {
        /// <summary>
        /// Represents a photo
        /// </summary>
        public InlineQueryResultPhoto() { }
        /// <summary>
        /// Represents a photo
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="photo">Photo</param>
        /// <param name="title">Title of the result, if known</param>
        /// <param name="description">Represents a photo</param>
        public InlineQueryResultPhoto(string id = default, Photo photo = default, string title = default, string description = default)
        {
            this.Id = id;
            this.Photo = photo;
            this.Title = title;
            this.Description = description;
        }
    }

    public partial class InlineQueryResultSticker
    {
        /// <summary>
        /// Represents a sticker
        /// </summary>
        public InlineQueryResultSticker() { }
        /// <summary>
        /// Represents a sticker
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="sticker">Sticker</param>
        public InlineQueryResultSticker(string id = default, Sticker sticker = default)
        {
            this.Id = id;
            this.Sticker = sticker;
        }
    }

    public partial class InlineQueryResultVideo
    {
        /// <summary>
        /// Represents a video
        /// </summary>
        public InlineQueryResultVideo() { }
        /// <summary>
        /// Represents a video
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="video">Video</param>
        /// <param name="title">Title of the video</param>
        /// <param name="description">Represents a video</param>
        public InlineQueryResultVideo(string id = default, Video video = default, string title = default, string description = default)
        {
            this.Id = id;
            this.Video = video;
            this.Title = title;
            this.Description = description;
        }
    }

    public partial class InlineQueryResultVoiceNote
    {
        /// <summary>
        /// Represents a voice note
        /// </summary>
        public InlineQueryResultVoiceNote() { }
        /// <summary>
        /// Represents a voice note
        /// </summary>
        /// <param name="id">Unique identifier of the query result</param>
        /// <param name="voiceNote">Voice note</param>
        /// <param name="title">Title of the voice note</param>
        public InlineQueryResultVoiceNote(string id = default, VoiceNote voiceNote = default, string title = default)
        {
            this.Id = id;
            this.VoiceNote = voiceNote;
            this.Title = title;
        }
    }

    public partial class InlineQueryResults
    {
        /// <summary>
        /// Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query
        /// </summary>
        public InlineQueryResults() { }
        /// <summary>
        /// Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query
        /// </summary>
        /// <param name="inlineQueryId">Unique identifier of the inline query</param>
        /// <param name="nextOffset">The offset for the next request. If empty, there are no more results</param>
        /// <param name="results">Results of the query</param>
        /// <param name="switchPmText">If non-empty, this text should be shown on the button, which opens a private chat with the bot and sends the bot a start message with the switch_pm_parameter</param>
        /// <param name="switchPmParameter">Parameter for the bot start message</param>
        public InlineQueryResults(long inlineQueryId = default, string nextOffset = default, InlineQueryResult[] results = default, string switchPmText = default, string switchPmParameter = default)
        {
            this.InlineQueryId = inlineQueryId;
            this.NextOffset = nextOffset;
            this.Results = results;
            this.SwitchPmText = switchPmText;
            this.SwitchPmParameter = switchPmParameter;
        }
    }

    public partial class CallbackQueryPayloadData
    {
        /// <summary>
        /// The payload for a general callback button
        /// </summary>
        public CallbackQueryPayloadData() { }
        /// <summary>
        /// The payload for a general callback button
        /// </summary>
        /// <param name="data">Data that was attached to the callback button</param>
        public CallbackQueryPayloadData(Memory<byte> data = default)
        {
            this.Data = data;
        }
    }

    public partial class CallbackQueryPayloadDataWithPassword
    {
        /// <summary>
        /// The payload for a callback button requiring password
        /// </summary>
        public CallbackQueryPayloadDataWithPassword() { }
        /// <summary>
        /// The payload for a callback button requiring password
        /// </summary>
        /// <param name="password">The password for the current user</param>
        /// <param name="data">Data that was attached to the callback button</param>
        public CallbackQueryPayloadDataWithPassword(string password = default, Memory<byte> data = default)
        {
            this.Password = password;
            this.Data = data;
        }
    }

    public partial class CallbackQueryPayloadGame
    {
        /// <summary>
        /// The payload for a game callback button
        /// </summary>
        public CallbackQueryPayloadGame() { }
        /// <summary>
        /// The payload for a game callback button
        /// </summary>
        /// <param name="gameShortName">A short name of the game that was attached to the callback button</param>
        public CallbackQueryPayloadGame(string gameShortName = default)
        {
            this.GameShortName = gameShortName;
        }
    }

    public partial class CallbackQueryAnswer
    {
        /// <summary>
        /// Contains a bot's answer to a callback query
        /// </summary>
        public CallbackQueryAnswer() { }
        /// <summary>
        /// Contains a bot's answer to a callback query
        /// </summary>
        /// <param name="text">Text of the answer</param>
        /// <param name="showAlert">True, if an alert should be shown to the user instead of a toast notification</param>
        /// <param name="url">URL to be opened</param>
        public CallbackQueryAnswer(string text = default, bool showAlert = default, string url = default)
        {
            this.Text = text;
            this.ShowAlert = showAlert;
            this.Url = url;
        }
    }

    public partial class CustomRequestResult
    {
        /// <summary>
        /// Contains the result of a custom request
        /// </summary>
        public CustomRequestResult() { }
        /// <summary>
        /// Contains the result of a custom request
        /// </summary>
        /// <param name="result">A JSON-serialized result</param>
        public CustomRequestResult(string result = default)
        {
            this.Result = result;
        }
    }

    public partial class GameHighScore
    {
        /// <summary>
        /// Contains one row of the game high score table
        /// </summary>
        public GameHighScore() { }
        /// <summary>
        /// Contains one row of the game high score table
        /// </summary>
        /// <param name="position">Position in the high score table</param>
        /// <param name="userId">User identifier</param>
        /// <param name="score">User score</param>
        public GameHighScore(int position = default, int userId = default, int score = default)
        {
            this.Position = position;
            this.UserId = userId;
            this.Score = score;
        }
    }

    public partial class GameHighScores
    {
        /// <summary>
        /// Contains a list of game high scores
        /// </summary>
        public GameHighScores() { }
        /// <summary>
        /// Contains a list of game high scores
        /// </summary>
        /// <param name="scores">A list of game high scores</param>
        public GameHighScores(GameHighScore[] scores = default)
        {
            this.Scores = scores;
        }
    }

    public partial class ChatEventMessageEdited
    {
        /// <summary>
        /// A message was edited
        /// </summary>
        public ChatEventMessageEdited() { }
        /// <summary>
        /// A message was edited
        /// </summary>
        /// <param name="oldMessage">The original message before the edit</param>
        /// <param name="newMessage">The message after it was edited</param>
        public ChatEventMessageEdited(Message oldMessage = default, Message newMessage = default)
        {
            this.OldMessage = oldMessage;
            this.NewMessage = newMessage;
        }
    }

    public partial class ChatEventMessageDeleted
    {
        /// <summary>
        /// A message was deleted
        /// </summary>
        public ChatEventMessageDeleted() { }
        /// <summary>
        /// A message was deleted
        /// </summary>
        /// <param name="message">Deleted message</param>
        public ChatEventMessageDeleted(Message message = default)
        {
            this.Message = message;
        }
    }

    public partial class ChatEventPollStopped
    {
        /// <summary>
        /// A poll in a message was stopped
        /// </summary>
        public ChatEventPollStopped() { }
        /// <summary>
        /// A poll in a message was stopped
        /// </summary>
        /// <param name="message">The message with the poll</param>
        public ChatEventPollStopped(Message message = default)
        {
            this.Message = message;
        }
    }

    public partial class ChatEventMessagePinned
    {
        /// <summary>
        /// A message was pinned
        /// </summary>
        public ChatEventMessagePinned() { }
        /// <summary>
        /// A message was pinned
        /// </summary>
        /// <param name="message">Pinned message</param>
        public ChatEventMessagePinned(Message message = default)
        {
            this.Message = message;
        }
    }

    public partial class ChatEventMessageUnpinned
    {
        /// <summary>
        /// A message was unpinned
        /// </summary>
        public ChatEventMessageUnpinned() { }
    }

    public partial class ChatEventMemberJoined
    {
        /// <summary>
        /// A new member joined the chat
        /// </summary>
        public ChatEventMemberJoined() { }
    }

    public partial class ChatEventMemberLeft
    {
        /// <summary>
        /// A member left the chat
        /// </summary>
        public ChatEventMemberLeft() { }
    }

    public partial class ChatEventMemberInvited
    {
        /// <summary>
        /// A new chat member was invited
        /// </summary>
        public ChatEventMemberInvited() { }
        /// <summary>
        /// A new chat member was invited
        /// </summary>
        /// <param name="userId">New member user identifier</param>
        /// <param name="status">New member status</param>
        public ChatEventMemberInvited(int userId = default, ChatMemberStatus status = default)
        {
            this.UserId = userId;
            this.Status = status;
        }
    }

    public partial class ChatEventMemberPromoted
    {
        /// <summary>
        /// A chat member has gained/lost administrator status, or the list of their administrator privileges has changed
        /// </summary>
        public ChatEventMemberPromoted() { }
        /// <summary>
        /// A chat member has gained/lost administrator status, or the list of their administrator privileges has changed
        /// </summary>
        /// <param name="userId">Chat member user identifier</param>
        /// <param name="oldStatus">Previous status of the chat member</param>
        /// <param name="newStatus">New status of the chat member</param>
        public ChatEventMemberPromoted(int userId = default, ChatMemberStatus oldStatus = default, ChatMemberStatus newStatus = default)
        {
            this.UserId = userId;
            this.OldStatus = oldStatus;
            this.NewStatus = newStatus;
        }
    }

    public partial class ChatEventMemberRestricted
    {
        /// <summary>
        /// A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed
        /// </summary>
        public ChatEventMemberRestricted() { }
        /// <summary>
        /// A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed
        /// </summary>
        /// <param name="userId">Chat member user identifier</param>
        /// <param name="oldStatus">Previous status of the chat member</param>
        /// <param name="newStatus">New status of the chat member</param>
        public ChatEventMemberRestricted(int userId = default, ChatMemberStatus oldStatus = default, ChatMemberStatus newStatus = default)
        {
            this.UserId = userId;
            this.OldStatus = oldStatus;
            this.NewStatus = newStatus;
        }
    }

    public partial class ChatEventTitleChanged
    {
        /// <summary>
        /// The chat title was changed
        /// </summary>
        public ChatEventTitleChanged() { }
        /// <summary>
        /// The chat title was changed
        /// </summary>
        /// <param name="oldTitle">Previous chat title</param>
        /// <param name="newTitle">New chat title</param>
        public ChatEventTitleChanged(string oldTitle = default, string newTitle = default)
        {
            this.OldTitle = oldTitle;
            this.NewTitle = newTitle;
        }
    }

    public partial class ChatEventPermissionsChanged
    {
        /// <summary>
        /// The chat permissions was changed
        /// </summary>
        public ChatEventPermissionsChanged() { }
        /// <summary>
        /// The chat permissions was changed
        /// </summary>
        /// <param name="oldPermissions">Previous chat permissions</param>
        /// <param name="newPermissions">New chat permissions</param>
        public ChatEventPermissionsChanged(ChatPermissions oldPermissions = default, ChatPermissions newPermissions = default)
        {
            this.OldPermissions = oldPermissions;
            this.NewPermissions = newPermissions;
        }
    }

    public partial class ChatEventDescriptionChanged
    {
        /// <summary>
        /// The chat description was changed
        /// </summary>
        public ChatEventDescriptionChanged() { }
        /// <summary>
        /// The chat description was changed
        /// </summary>
        /// <param name="oldDescription">Previous chat description</param>
        /// <param name="newDescription">New chat description</param>
        public ChatEventDescriptionChanged(string oldDescription = default, string newDescription = default)
        {
            this.OldDescription = oldDescription;
            this.NewDescription = newDescription;
        }
    }

    public partial class ChatEventUsernameChanged
    {
        /// <summary>
        /// The chat username was changed
        /// </summary>
        public ChatEventUsernameChanged() { }
        /// <summary>
        /// The chat username was changed
        /// </summary>
        /// <param name="oldUsername">Previous chat username</param>
        /// <param name="newUsername">New chat username</param>
        public ChatEventUsernameChanged(string oldUsername = default, string newUsername = default)
        {
            this.OldUsername = oldUsername;
            this.NewUsername = newUsername;
        }
    }

    public partial class ChatEventPhotoChanged
    {
        /// <summary>
        /// The chat photo was changed
        /// </summary>
        public ChatEventPhotoChanged() { }
        /// <summary>
        /// The chat photo was changed
        /// </summary>
        /// <param name="oldPhoto">Previous chat photo value; may be null</param>
        /// <param name="newPhoto">New chat photo value; may be null</param>
        public ChatEventPhotoChanged(ChatPhoto oldPhoto = default, ChatPhoto newPhoto = default)
        {
            this.OldPhoto = oldPhoto;
            this.NewPhoto = newPhoto;
        }
    }

    public partial class ChatEventInvitesToggled
    {
        /// <summary>
        /// The can_invite_users permission of a supergroup chat was toggled
        /// </summary>
        public ChatEventInvitesToggled() { }
        /// <summary>
        /// The can_invite_users permission of a supergroup chat was toggled
        /// </summary>
        /// <param name="canInviteUsers">New value of can_invite_users permission</param>
        public ChatEventInvitesToggled(bool canInviteUsers = default)
        {
            this.CanInviteUsers = canInviteUsers;
        }
    }

    public partial class ChatEventLinkedChatChanged
    {
        /// <summary>
        /// The linked chat of a supergroup was changed
        /// </summary>
        public ChatEventLinkedChatChanged() { }
        /// <summary>
        /// The linked chat of a supergroup was changed
        /// </summary>
        /// <param name="oldLinkedChatId">Previous supergroup linked chat identifier</param>
        /// <param name="newLinkedChatId">New supergroup linked chat identifier</param>
        public ChatEventLinkedChatChanged(long oldLinkedChatId = default, long newLinkedChatId = default)
        {
            this.OldLinkedChatId = oldLinkedChatId;
            this.NewLinkedChatId = newLinkedChatId;
        }
    }

    public partial class ChatEventSlowModeDelayChanged
    {
        /// <summary>
        /// The slow_mode_delay setting of a supergroup was changed
        /// </summary>
        public ChatEventSlowModeDelayChanged() { }
        /// <summary>
        /// The slow_mode_delay setting of a supergroup was changed
        /// </summary>
        /// <param name="oldSlowModeDelay">Previous value of slow_mode_delay</param>
        /// <param name="newSlowModeDelay">New value of slow_mode_delay</param>
        public ChatEventSlowModeDelayChanged(int oldSlowModeDelay = default, int newSlowModeDelay = default)
        {
            this.OldSlowModeDelay = oldSlowModeDelay;
            this.NewSlowModeDelay = newSlowModeDelay;
        }
    }

    public partial class ChatEventSignMessagesToggled
    {
        /// <summary>
        /// The sign_messages setting of a channel was toggled
        /// </summary>
        public ChatEventSignMessagesToggled() { }
        /// <summary>
        /// The sign_messages setting of a channel was toggled
        /// </summary>
        /// <param name="signMessages">New value of sign_messages</param>
        public ChatEventSignMessagesToggled(bool signMessages = default)
        {
            this.SignMessages = signMessages;
        }
    }

    public partial class ChatEventStickerSetChanged
    {
        /// <summary>
        /// The supergroup sticker set was changed
        /// </summary>
        public ChatEventStickerSetChanged() { }
        /// <summary>
        /// The supergroup sticker set was changed
        /// </summary>
        /// <param name="oldStickerSetId">Previous identifier of the chat sticker set; 0 if none</param>
        /// <param name="newStickerSetId">New identifier of the chat sticker set; 0 if none</param>
        public ChatEventStickerSetChanged(long oldStickerSetId = default, long newStickerSetId = default)
        {
            this.OldStickerSetId = oldStickerSetId;
            this.NewStickerSetId = newStickerSetId;
        }
    }

    public partial class ChatEventLocationChanged
    {
        /// <summary>
        /// The supergroup location was changed
        /// </summary>
        public ChatEventLocationChanged() { }
        /// <summary>
        /// The supergroup location was changed
        /// </summary>
        /// <param name="oldLocation">Previous location; may be null</param>
        /// <param name="newLocation">New location; may be null</param>
        public ChatEventLocationChanged(ChatLocation oldLocation = default, ChatLocation newLocation = default)
        {
            this.OldLocation = oldLocation;
            this.NewLocation = newLocation;
        }
    }

    public partial class ChatEventIsAllHistoryAvailableToggled
    {
        /// <summary>
        /// The is_all_history_available setting of a supergroup was toggled
        /// </summary>
        public ChatEventIsAllHistoryAvailableToggled() { }
        /// <summary>
        /// The is_all_history_available setting of a supergroup was toggled
        /// </summary>
        /// <param name="isAllHistoryAvailable">New value of is_all_history_available</param>
        public ChatEventIsAllHistoryAvailableToggled(bool isAllHistoryAvailable = default)
        {
            this.IsAllHistoryAvailable = isAllHistoryAvailable;
        }
    }

    public partial class ChatEvent
    {
        /// <summary>
        /// Represents a chat event
        /// </summary>
        public ChatEvent() { }
        /// <summary>
        /// Represents a chat event
        /// </summary>
        /// <param name="id">Chat event identifier</param>
        /// <param name="date">Point in time (Unix timestamp) when the event happened</param>
        /// <param name="userId">Identifier of the user who performed the action that triggered the event</param>
        /// <param name="action">Action performed by the user</param>
        public ChatEvent(long id = default, int date = default, int userId = default, ChatEventAction action = default)
        {
            this.Id = id;
            this.Date = date;
            this.UserId = userId;
            this.Action = action;
        }
    }

    public partial class ChatEvents
    {
        /// <summary>
        /// Contains a list of chat events
        /// </summary>
        public ChatEvents() { }
        /// <summary>
        /// Contains a list of chat events
        /// </summary>
        /// <param name="events">List of events</param>
        public ChatEvents(ChatEvent[] events = default)
        {
            this.Events = events;
        }
    }

    public partial class ChatEventLogFilters
    {
        /// <summary>
        /// Represents a set of filters used to obtain a chat event log
        /// </summary>
        public ChatEventLogFilters() { }
        /// <summary>
        /// Represents a set of filters used to obtain a chat event log
        /// </summary>
        /// <param name="messageEdits">True, if message edits should be returned</param>
        /// <param name="messageDeletions">True, if message deletions should be returned</param>
        /// <param name="messagePins">True, if pin/unpin events should be returned</param>
        /// <param name="memberJoins">True, if members joining events should be returned</param>
        /// <param name="memberLeaves">True, if members leaving events should be returned</param>
        /// <param name="memberInvites">True, if invited member events should be returned</param>
        /// <param name="memberPromotions">True, if member promotion/demotion events should be returned</param>
        /// <param name="memberRestrictions">True, if member restricted/unrestricted/banned/unbanned events should be returned</param>
        /// <param name="infoChanges">True, if changes in chat information should be returned</param>
        /// <param name="settingChanges">True, if changes in chat settings should be returned</param>
        public ChatEventLogFilters(bool messageEdits = default, bool messageDeletions = default, bool messagePins = default, bool memberJoins = default, bool memberLeaves = default, bool memberInvites = default, bool memberPromotions = default, bool memberRestrictions = default, bool infoChanges = default, bool settingChanges = default)
        {
            this.MessageEdits = messageEdits;
            this.MessageDeletions = messageDeletions;
            this.MessagePins = messagePins;
            this.MemberJoins = memberJoins;
            this.MemberLeaves = memberLeaves;
            this.MemberInvites = memberInvites;
            this.MemberPromotions = memberPromotions;
            this.MemberRestrictions = memberRestrictions;
            this.InfoChanges = infoChanges;
            this.SettingChanges = settingChanges;
        }
    }

    public partial class LanguagePackStringValueOrdinary
    {
        /// <summary>
        /// An ordinary language pack string
        /// </summary>
        public LanguagePackStringValueOrdinary() { }
        /// <summary>
        /// An ordinary language pack string
        /// </summary>
        /// <param name="value">String value</param>
        public LanguagePackStringValueOrdinary(string value = default)
        {
            this.Value = value;
        }
    }

    public partial class LanguagePackStringValuePluralized
    {
        /// <summary>
        /// A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info
        /// </summary>
        public LanguagePackStringValuePluralized() { }
        /// <summary>
        /// A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info
        /// </summary>
        /// <param name="zeroValue">Value for zero objects</param>
        /// <param name="oneValue">Value for one object</param>
        /// <param name="twoValue">Value for two objects</param>
        /// <param name="fewValue">Value for few objects</param>
        /// <param name="manyValue">Value for many objects</param>
        /// <param name="otherValue">Default value</param>
        public LanguagePackStringValuePluralized(string zeroValue = default, string oneValue = default, string twoValue = default, string fewValue = default, string manyValue = default, string otherValue = default)
        {
            this.ZeroValue = zeroValue;
            this.OneValue = oneValue;
            this.TwoValue = twoValue;
            this.FewValue = fewValue;
            this.ManyValue = manyValue;
            this.OtherValue = otherValue;
        }
    }

    public partial class LanguagePackStringValueDeleted
    {
        /// <summary>
        /// A deleted language pack string, the value should be taken from the built-in english language pack
        /// </summary>
        public LanguagePackStringValueDeleted() { }
    }

    public partial class LanguagePackString
    {
        /// <summary>
        /// Represents one language pack string
        /// </summary>
        public LanguagePackString() { }
        /// <summary>
        /// Represents one language pack string
        /// </summary>
        /// <param name="key">String key</param>
        /// <param name="value">String value</param>
        public LanguagePackString(string key = default, LanguagePackStringValue value = default)
        {
            this.Key = key;
            this.Value = value;
        }
    }

    public partial class LanguagePackStrings
    {
        /// <summary>
        /// Contains a list of language pack strings
        /// </summary>
        public LanguagePackStrings() { }
        /// <summary>
        /// Contains a list of language pack strings
        /// </summary>
        /// <param name="strings">A list of language pack strings</param>
        public LanguagePackStrings(LanguagePackString[] strings = default)
        {
            this.Strings = strings;
        }
    }

    public partial class LanguagePackInfo
    {
        /// <summary>
        /// Contains information about a language pack
        /// </summary>
        public LanguagePackInfo() { }
        /// <summary>
        /// Contains information about a language pack
        /// </summary>
        /// <param name="id">Unique language pack identifier</param>
        /// <param name="baseLanguagePackId">Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it should be fetched from base language pack. Unsupported in custom language packs</param>
        /// <param name="name">Language name</param>
        /// <param name="nativeName">Name of the language in that language</param>
        /// <param name="pluralCode">A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info</param>
        /// <param name="isOfficial">True, if the language pack is official</param>
        /// <param name="isRtl">True, if the language pack strings are RTL</param>
        /// <param name="isBeta">True, if the language pack is a beta language pack</param>
        /// <param name="isInstalled">True, if the language pack is installed by the current user</param>
        /// <param name="totalStringCount">Total number of non-deleted strings from the language pack</param>
        /// <param name="translatedStringCount">Total number of translated strings from the language pack</param>
        /// <param name="localStringCount">Total number of non-deleted strings from the language pack available locally</param>
        /// <param name="translationUrl">Link to language translation interface; empty for custom local language packs</param>
        public LanguagePackInfo(string id = default, string baseLanguagePackId = default, string name = default, string nativeName = default, string pluralCode = default, bool isOfficial = default, bool isRtl = default, bool isBeta = default, bool isInstalled = default, int totalStringCount = default, int translatedStringCount = default, int localStringCount = default, string translationUrl = default)
        {
            this.Id = id;
            this.BaseLanguagePackId = baseLanguagePackId;
            this.Name = name;
            this.NativeName = nativeName;
            this.PluralCode = pluralCode;
            this.IsOfficial = isOfficial;
            this.IsRtl = isRtl;
            this.IsBeta = isBeta;
            this.IsInstalled = isInstalled;
            this.TotalStringCount = totalStringCount;
            this.TranslatedStringCount = translatedStringCount;
            this.LocalStringCount = localStringCount;
            this.TranslationUrl = translationUrl;
        }
    }

    public partial class LocalizationTargetInfo
    {
        /// <summary>
        /// Contains information about the current localization target
        /// </summary>
        public LocalizationTargetInfo() { }
        /// <summary>
        /// Contains information about the current localization target
        /// </summary>
        /// <param name="languagePacks">List of available language packs for this application</param>
        public LocalizationTargetInfo(LanguagePackInfo[] languagePacks = default)
        {
            this.LanguagePacks = languagePacks;
        }
    }

    public partial class DeviceTokenFirebaseCloudMessaging
    {
        /// <summary>
        /// A token for Firebase Cloud Messaging
        /// </summary>
        public DeviceTokenFirebaseCloudMessaging() { }
        /// <summary>
        /// A token for Firebase Cloud Messaging
        /// </summary>
        /// <param name="token">Device registration token; may be empty to de-register a device</param>
        /// <param name="encrypt">True, if push notifications should be additionally encrypted</param>
        public DeviceTokenFirebaseCloudMessaging(string token = default, bool encrypt = default)
        {
            this.Token = token;
            this.Encrypt = encrypt;
        }
    }

    public partial class DeviceTokenApplePush
    {
        /// <summary>
        /// A token for Apple Push Notification service
        /// </summary>
        public DeviceTokenApplePush() { }
        /// <summary>
        /// A token for Apple Push Notification service
        /// </summary>
        /// <param name="deviceToken">Device token; may be empty to de-register a device</param>
        /// <param name="isAppSandbox">True, if App Sandbox is enabled</param>
        public DeviceTokenApplePush(string deviceToken = default, bool isAppSandbox = default)
        {
            this.DeviceToken = deviceToken;
            this.IsAppSandbox = isAppSandbox;
        }
    }

    public partial class DeviceTokenApplePushVoIP
    {
        /// <summary>
        /// A token for Apple Push Notification service VoIP notifications
        /// </summary>
        public DeviceTokenApplePushVoIP() { }
        /// <summary>
        /// A token for Apple Push Notification service VoIP notifications
        /// </summary>
        /// <param name="deviceToken">Device token; may be empty to de-register a device</param>
        /// <param name="isAppSandbox">True, if App Sandbox is enabled</param>
        /// <param name="encrypt">True, if push notifications should be additionally encrypted</param>
        public DeviceTokenApplePushVoIP(string deviceToken = default, bool isAppSandbox = default, bool encrypt = default)
        {
            this.DeviceToken = deviceToken;
            this.IsAppSandbox = isAppSandbox;
            this.Encrypt = encrypt;
        }
    }

    public partial class DeviceTokenWindowsPush
    {
        /// <summary>
        /// A token for Windows Push Notification Services
        /// </summary>
        public DeviceTokenWindowsPush() { }
        /// <summary>
        /// A token for Windows Push Notification Services
        /// </summary>
        /// <param name="accessToken">The access token that will be used to send notifications; may be empty to de-register a device</param>
        public DeviceTokenWindowsPush(string accessToken = default)
        {
            this.AccessToken = accessToken;
        }
    }

    public partial class DeviceTokenMicrosoftPush
    {
        /// <summary>
        /// A token for Microsoft Push Notification Service
        /// </summary>
        public DeviceTokenMicrosoftPush() { }
        /// <summary>
        /// A token for Microsoft Push Notification Service
        /// </summary>
        /// <param name="channelUri">Push notification channel URI; may be empty to de-register a device</param>
        public DeviceTokenMicrosoftPush(string channelUri = default)
        {
            this.ChannelUri = channelUri;
        }
    }

    public partial class DeviceTokenMicrosoftPushVoIP
    {
        /// <summary>
        /// A token for Microsoft Push Notification Service VoIP channel
        /// </summary>
        public DeviceTokenMicrosoftPushVoIP() { }
        /// <summary>
        /// A token for Microsoft Push Notification Service VoIP channel
        /// </summary>
        /// <param name="channelUri">Push notification channel URI; may be empty to de-register a device</param>
        public DeviceTokenMicrosoftPushVoIP(string channelUri = default)
        {
            this.ChannelUri = channelUri;
        }
    }

    public partial class DeviceTokenWebPush
    {
        /// <summary>
        /// A token for web Push API
        /// </summary>
        public DeviceTokenWebPush() { }
        /// <summary>
        /// A token for web Push API
        /// </summary>
        /// <param name="endpoint">Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device</param>
        /// <param name="p256dhBase64url">Base64url-encoded P-256 elliptic curve Diffie-Hellman public key</param>
        /// <param name="authBase64url">Base64url-encoded authentication secret</param>
        public DeviceTokenWebPush(string endpoint = default, string p256dhBase64url = default, string authBase64url = default)
        {
            this.Endpoint = endpoint;
            this.P256dhBase64url = p256dhBase64url;
            this.AuthBase64url = authBase64url;
        }
    }

    public partial class DeviceTokenSimplePush
    {
        /// <summary>
        /// A token for Simple Push API for Firefox OS
        /// </summary>
        public DeviceTokenSimplePush() { }
        /// <summary>
        /// A token for Simple Push API for Firefox OS
        /// </summary>
        /// <param name="endpoint">Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device</param>
        public DeviceTokenSimplePush(string endpoint = default)
        {
            this.Endpoint = endpoint;
        }
    }

    public partial class DeviceTokenUbuntuPush
    {
        /// <summary>
        /// A token for Ubuntu Push Client service
        /// </summary>
        public DeviceTokenUbuntuPush() { }
        /// <summary>
        /// A token for Ubuntu Push Client service
        /// </summary>
        /// <param name="token">Token; may be empty to de-register a device</param>
        public DeviceTokenUbuntuPush(string token = default)
        {
            this.Token = token;
        }
    }

    public partial class DeviceTokenBlackBerryPush
    {
        /// <summary>
        /// A token for BlackBerry Push Service
        /// </summary>
        public DeviceTokenBlackBerryPush() { }
        /// <summary>
        /// A token for BlackBerry Push Service
        /// </summary>
        /// <param name="token">Token; may be empty to de-register a device</param>
        public DeviceTokenBlackBerryPush(string token = default)
        {
            this.Token = token;
        }
    }

    public partial class DeviceTokenTizenPush
    {
        /// <summary>
        /// A token for Tizen Push Service
        /// </summary>
        public DeviceTokenTizenPush() { }
        /// <summary>
        /// A token for Tizen Push Service
        /// </summary>
        /// <param name="regId">Push service registration identifier; may be empty to de-register a device</param>
        public DeviceTokenTizenPush(string regId = default)
        {
            this.RegId = regId;
        }
    }

    public partial class PushReceiverId
    {
        /// <summary>
        /// Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification
        /// </summary>
        public PushReceiverId() { }
        /// <summary>
        /// Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification
        /// </summary>
        /// <param name="id">The globally unique identifier of push notification subscription</param>
        public PushReceiverId(long id = default)
        {
            this.Id = id;
        }
    }

    public partial class BackgroundFillSolid
    {
        /// <summary>
        /// Describes a solid fill of a background
        /// </summary>
        public BackgroundFillSolid() { }
        /// <summary>
        /// Describes a solid fill of a background
        /// </summary>
        /// <param name="color">A color of the background in the RGB24 format</param>
        public BackgroundFillSolid(int color = default)
        {
            this.Color = color;
        }
    }

    public partial class BackgroundFillGradient
    {
        /// <summary>
        /// Describes a gradient fill of a background
        /// </summary>
        public BackgroundFillGradient() { }
        /// <summary>
        /// Describes a gradient fill of a background
        /// </summary>
        /// <param name="topColor">A top color of the background in the RGB24 format</param>
        /// <param name="bottomColor">A bottom color of the background in the RGB24 format</param>
        /// <param name="rotationAngle">Clockwise rotation angle of the gradient, in degrees; 0-359. Should be always divisible by 45</param>
        public BackgroundFillGradient(int topColor = default, int bottomColor = default, int rotationAngle = default)
        {
            this.TopColor = topColor;
            this.BottomColor = bottomColor;
            this.RotationAngle = rotationAngle;
        }
    }

    public partial class BackgroundTypeWallpaper
    {
        /// <summary>
        /// A wallpaper in JPEG format
        /// </summary>
        public BackgroundTypeWallpaper() { }
        /// <summary>
        /// A wallpaper in JPEG format
        /// </summary>
        /// <param name="isBlurred">True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12</param>
        /// <param name="isMoving">True, if the background needs to be slightly moved when device is tilted</param>
        public BackgroundTypeWallpaper(bool isBlurred = default, bool isMoving = default)
        {
            this.IsBlurred = isBlurred;
            this.IsMoving = isMoving;
        }
    }

    public partial class BackgroundTypePattern
    {
        /// <summary>
        /// A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user
        /// </summary>
        public BackgroundTypePattern() { }
        /// <summary>
        /// A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user
        /// </summary>
        /// <param name="fill">Description of the background fill</param>
        /// <param name="intensity">Intensity of the pattern when it is shown above the filled background, 0-100</param>
        /// <param name="isMoving">True, if the background needs to be slightly moved when device is tilted</param>
        public BackgroundTypePattern(BackgroundFill fill = default, int intensity = default, bool isMoving = default)
        {
            this.Fill = fill;
            this.Intensity = intensity;
            this.IsMoving = isMoving;
        }
    }

    public partial class BackgroundTypeFill
    {
        /// <summary>
        /// A filled background
        /// </summary>
        public BackgroundTypeFill() { }
        /// <summary>
        /// A filled background
        /// </summary>
        /// <param name="fill">Description of the background fill</param>
        public BackgroundTypeFill(BackgroundFill fill = default)
        {
            this.Fill = fill;
        }
    }

    public partial class Background
    {
        /// <summary>
        /// Describes a chat background
        /// </summary>
        public Background() { }
        /// <summary>
        /// Describes a chat background
        /// </summary>
        /// <param name="id">Unique background identifier</param>
        /// <param name="isDefault">True, if this is one of default backgrounds</param>
        /// <param name="isDark">True, if the background is dark and is recommended to be used with dark theme</param>
        /// <param name="name">Unique background name</param>
        /// <param name="document">Document with the background; may be null. Null only for filled backgrounds</param>
        /// <param name="type">Type of the background</param>
        public Background(long id = default, bool isDefault = default, bool isDark = default, string name = default, Document document = default, BackgroundType type = default)
        {
            this.Id = id;
            this.IsDefault = isDefault;
            this.IsDark = isDark;
            this.Name = name;
            this.Document = document;
            this.Type = type;
        }
    }

    public partial class Backgrounds
    {
        /// <summary>
        /// Contains a list of backgrounds
        /// </summary>
        public Backgrounds() { }
        /// <summary>
        /// Contains a list of backgrounds
        /// </summary>
        /// <param name="backgrounds">A list of backgrounds</param>
        public Backgrounds(Background[] backgrounds_ = default)
        {
            this.Backgrounds_ = backgrounds_;
        }
    }

    public partial class InputBackgroundLocal
    {
        /// <summary>
        /// A background from a local file
        /// </summary>
        public InputBackgroundLocal() { }
        /// <summary>
        /// A background from a local file
        /// </summary>
        /// <param name="background">Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns</param>
        public InputBackgroundLocal(InputFile background = default)
        {
            this.Background = background;
        }
    }

    public partial class InputBackgroundRemote
    {
        /// <summary>
        /// A background from the server
        /// </summary>
        public InputBackgroundRemote() { }
        /// <summary>
        /// A background from the server
        /// </summary>
        /// <param name="backgroundId">The background identifier</param>
        public InputBackgroundRemote(long backgroundId = default)
        {
            this.BackgroundId = backgroundId;
        }
    }

    public partial class Hashtags
    {
        /// <summary>
        /// Contains a list of hashtags
        /// </summary>
        public Hashtags() { }
        /// <summary>
        /// Contains a list of hashtags
        /// </summary>
        /// <param name="hashtags">A list of hashtags</param>
        public Hashtags(string[] hashtags_ = default)
        {
            this.Hashtags_ = hashtags_;
        }
    }

    public partial class CanTransferOwnershipResultOk
    {
        /// <summary>
        /// The session can be used
        /// </summary>
        public CanTransferOwnershipResultOk() { }
    }

    public partial class CanTransferOwnershipResultPasswordNeeded
    {
        /// <summary>
        /// The 2-step verification needs to be enabled first
        /// </summary>
        public CanTransferOwnershipResultPasswordNeeded() { }
    }

    public partial class CanTransferOwnershipResultPasswordTooFresh
    {
        /// <summary>
        /// The 2-step verification was enabled recently, user needs to wait
        /// </summary>
        public CanTransferOwnershipResultPasswordTooFresh() { }
        /// <summary>
        /// The 2-step verification was enabled recently, user needs to wait
        /// </summary>
        /// <param name="retryAfter">Time left before the session can be used to transfer ownership of a chat, in seconds</param>
        public CanTransferOwnershipResultPasswordTooFresh(int retryAfter = default)
        {
            this.RetryAfter = retryAfter;
        }
    }

    public partial class CanTransferOwnershipResultSessionTooFresh
    {
        /// <summary>
        /// The session was created recently, user needs to wait
        /// </summary>
        public CanTransferOwnershipResultSessionTooFresh() { }
        /// <summary>
        /// The session was created recently, user needs to wait
        /// </summary>
        /// <param name="retryAfter">Time left before the session can be used to transfer ownership of a chat, in seconds</param>
        public CanTransferOwnershipResultSessionTooFresh(int retryAfter = default)
        {
            this.RetryAfter = retryAfter;
        }
    }

    public partial class CheckChatUsernameResultOk
    {
        /// <summary>
        /// The username can be set
        /// </summary>
        public CheckChatUsernameResultOk() { }
    }

    public partial class CheckChatUsernameResultUsernameInvalid
    {
        /// <summary>
        /// The username is invalid
        /// </summary>
        public CheckChatUsernameResultUsernameInvalid() { }
    }

    public partial class CheckChatUsernameResultUsernameOccupied
    {
        /// <summary>
        /// The username is occupied
        /// </summary>
        public CheckChatUsernameResultUsernameOccupied() { }
    }

    public partial class CheckChatUsernameResultPublicChatsTooMuch
    {
        /// <summary>
        /// The user has too much chats with username, one of them should be made private first
        /// </summary>
        public CheckChatUsernameResultPublicChatsTooMuch() { }
    }

    public partial class CheckChatUsernameResultPublicGroupsUnavailable
    {
        /// <summary>
        /// The user can't be a member of a public supergroup
        /// </summary>
        public CheckChatUsernameResultPublicGroupsUnavailable() { }
    }

    public partial class PushMessageContentHidden
    {
        /// <summary>
        /// A general message with hidden content
        /// </summary>
        public PushMessageContentHidden() { }
        /// <summary>
        /// A general message with hidden content
        /// </summary>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentHidden(bool isPinned = default)
        {
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentAnimation
    {
        /// <summary>
        /// An animation message (GIF-style).
        /// </summary>
        public PushMessageContentAnimation() { }
        /// <summary>
        /// An animation message (GIF-style).
        /// </summary>
        /// <param name="animation">Message content; may be null</param>
        /// <param name="caption">Animation caption</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentAnimation(Animation animation = default, string caption = default, bool isPinned = default)
        {
            this.Animation = animation;
            this.Caption = caption;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentAudio
    {
        /// <summary>
        /// An audio message
        /// </summary>
        public PushMessageContentAudio() { }
        /// <summary>
        /// An audio message
        /// </summary>
        /// <param name="audio">Message content; may be null</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentAudio(Audio audio = default, bool isPinned = default)
        {
            this.Audio = audio;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentContact
    {
        /// <summary>
        /// A message with a user contact
        /// </summary>
        public PushMessageContentContact() { }
        /// <summary>
        /// A message with a user contact
        /// </summary>
        /// <param name="name">Contact's name</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentContact(string name = default, bool isPinned = default)
        {
            this.Name = name;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentContactRegistered
    {
        /// <summary>
        /// A contact has registered with Telegram
        /// </summary>
        public PushMessageContentContactRegistered() { }
    }

    public partial class PushMessageContentDocument
    {
        /// <summary>
        /// A document message (a general file)
        /// </summary>
        public PushMessageContentDocument() { }
        /// <summary>
        /// A document message (a general file)
        /// </summary>
        /// <param name="document">Message content; may be null</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentDocument(Document document = default, bool isPinned = default)
        {
            this.Document = document;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentGame
    {
        /// <summary>
        /// A message with a game
        /// </summary>
        public PushMessageContentGame() { }
        /// <summary>
        /// A message with a game
        /// </summary>
        /// <param name="title">Game title, empty for pinned game message</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentGame(string title = default, bool isPinned = default)
        {
            this.Title = title;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentGameScore
    {
        /// <summary>
        /// A new high score was achieved in a game
        /// </summary>
        public PushMessageContentGameScore() { }
        /// <summary>
        /// A new high score was achieved in a game
        /// </summary>
        /// <param name="title">Game title, empty for pinned message</param>
        /// <param name="score">New score, 0 for pinned message</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentGameScore(string title = default, int score = default, bool isPinned = default)
        {
            this.Title = title;
            this.Score = score;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentInvoice
    {
        /// <summary>
        /// A message with an invoice from a bot
        /// </summary>
        public PushMessageContentInvoice() { }
        /// <summary>
        /// A message with an invoice from a bot
        /// </summary>
        /// <param name="price">Product price</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentInvoice(string price = default, bool isPinned = default)
        {
            this.Price = price;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentLocation
    {
        /// <summary>
        /// A message with a location
        /// </summary>
        public PushMessageContentLocation() { }
        /// <summary>
        /// A message with a location
        /// </summary>
        /// <param name="isLive">True, if the location is live</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentLocation(bool isLive = default, bool isPinned = default)
        {
            this.IsLive = isLive;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentPhoto
    {
        /// <summary>
        /// A photo message
        /// </summary>
        public PushMessageContentPhoto() { }
        /// <summary>
        /// A photo message
        /// </summary>
        /// <param name="photo">Message content; may be null</param>
        /// <param name="caption">Photo caption</param>
        /// <param name="isSecret">True, if the photo is secret</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentPhoto(Photo photo = default, string caption = default, bool isSecret = default, bool isPinned = default)
        {
            this.Photo = photo;
            this.Caption = caption;
            this.IsSecret = isSecret;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentPoll
    {
        /// <summary>
        /// A message with a poll
        /// </summary>
        public PushMessageContentPoll() { }
        /// <summary>
        /// A message with a poll
        /// </summary>
        /// <param name="question">Poll question</param>
        /// <param name="isRegular">True, if the poll is regular and not in quiz mode</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentPoll(string question = default, bool isRegular = default, bool isPinned = default)
        {
            this.Question = question;
            this.IsRegular = isRegular;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentScreenshotTaken
    {
        /// <summary>
        /// A screenshot of a message in the chat has been taken
        /// </summary>
        public PushMessageContentScreenshotTaken() { }
    }

    public partial class PushMessageContentSticker
    {
        /// <summary>
        /// A message with a sticker
        /// </summary>
        public PushMessageContentSticker() { }
        /// <summary>
        /// A message with a sticker
        /// </summary>
        /// <param name="sticker">Message content; may be null</param>
        /// <param name="emoji">Emoji corresponding to the sticker; may be empty</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentSticker(Sticker sticker = default, string emoji = default, bool isPinned = default)
        {
            this.Sticker = sticker;
            this.Emoji = emoji;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentText
    {
        /// <summary>
        /// A text message
        /// </summary>
        public PushMessageContentText() { }
        /// <summary>
        /// A text message
        /// </summary>
        /// <param name="text">Message text</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentText(string text = default, bool isPinned = default)
        {
            this.Text = text;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentVideo
    {
        /// <summary>
        /// A video message
        /// </summary>
        public PushMessageContentVideo() { }
        /// <summary>
        /// A video message
        /// </summary>
        /// <param name="video">Message content; may be null</param>
        /// <param name="caption">Video caption</param>
        /// <param name="isSecret">True, if the video is secret</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentVideo(Video video = default, string caption = default, bool isSecret = default, bool isPinned = default)
        {
            this.Video = video;
            this.Caption = caption;
            this.IsSecret = isSecret;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentVideoNote
    {
        /// <summary>
        /// A video note message
        /// </summary>
        public PushMessageContentVideoNote() { }
        /// <summary>
        /// A video note message
        /// </summary>
        /// <param name="videoNote">Message content; may be null</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentVideoNote(VideoNote videoNote = default, bool isPinned = default)
        {
            this.VideoNote = videoNote;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentVoiceNote
    {
        /// <summary>
        /// A voice note message
        /// </summary>
        public PushMessageContentVoiceNote() { }
        /// <summary>
        /// A voice note message
        /// </summary>
        /// <param name="voiceNote">Message content; may be null</param>
        /// <param name="isPinned">True, if the message is a pinned message with the specified content</param>
        public PushMessageContentVoiceNote(VoiceNote voiceNote = default, bool isPinned = default)
        {
            this.VoiceNote = voiceNote;
            this.IsPinned = isPinned;
        }
    }

    public partial class PushMessageContentBasicGroupChatCreate
    {
        /// <summary>
        /// A newly created basic group
        /// </summary>
        public PushMessageContentBasicGroupChatCreate() { }
    }

    public partial class PushMessageContentChatAddMembers
    {
        /// <summary>
        /// New chat members were invited to a group
        /// </summary>
        public PushMessageContentChatAddMembers() { }
        /// <summary>
        /// New chat members were invited to a group
        /// </summary>
        /// <param name="memberName">Name of the added member</param>
        /// <param name="isCurrentUser">True, if the current user was added to the group</param>
        /// <param name="isReturned">True, if the user has returned to the group themself</param>
        public PushMessageContentChatAddMembers(string memberName = default, bool isCurrentUser = default, bool isReturned = default)
        {
            this.MemberName = memberName;
            this.IsCurrentUser = isCurrentUser;
            this.IsReturned = isReturned;
        }
    }

    public partial class PushMessageContentChatChangePhoto
    {
        /// <summary>
        /// A chat photo was edited
        /// </summary>
        public PushMessageContentChatChangePhoto() { }
    }

    public partial class PushMessageContentChatChangeTitle
    {
        /// <summary>
        /// A chat title was edited
        /// </summary>
        public PushMessageContentChatChangeTitle() { }
        /// <summary>
        /// A chat title was edited
        /// </summary>
        /// <param name="title">New chat title</param>
        public PushMessageContentChatChangeTitle(string title = default)
        {
            this.Title = title;
        }
    }

    public partial class PushMessageContentChatDeleteMember
    {
        /// <summary>
        /// A chat member was deleted
        /// </summary>
        public PushMessageContentChatDeleteMember() { }
        /// <summary>
        /// A chat member was deleted
        /// </summary>
        /// <param name="memberName">Name of the deleted member</param>
        /// <param name="isCurrentUser">True, if the current user was deleted from the group</param>
        /// <param name="isLeft">True, if the user has left the group themself</param>
        public PushMessageContentChatDeleteMember(string memberName = default, bool isCurrentUser = default, bool isLeft = default)
        {
            this.MemberName = memberName;
            this.IsCurrentUser = isCurrentUser;
            this.IsLeft = isLeft;
        }
    }

    public partial class PushMessageContentChatJoinByLink
    {
        /// <summary>
        /// A new member joined the chat by invite link
        /// </summary>
        public PushMessageContentChatJoinByLink() { }
    }

    public partial class PushMessageContentMessageForwards
    {
        /// <summary>
        /// A forwarded messages
        /// </summary>
        public PushMessageContentMessageForwards() { }
        /// <summary>
        /// A forwarded messages
        /// </summary>
        /// <param name="totalCount">Number of forwarded messages</param>
        public PushMessageContentMessageForwards(int totalCount = default)
        {
            this.TotalCount = totalCount;
        }
    }

    public partial class PushMessageContentMediaAlbum
    {
        /// <summary>
        /// A media album
        /// </summary>
        public PushMessageContentMediaAlbum() { }
        /// <summary>
        /// A media album
        /// </summary>
        /// <param name="totalCount">Number of messages in the album</param>
        /// <param name="hasPhotos">True, if the album has at least one photo</param>
        /// <param name="hasVideos">True, if the album has at least one video</param>
        public PushMessageContentMediaAlbum(int totalCount = default, bool hasPhotos = default, bool hasVideos = default)
        {
            this.TotalCount = totalCount;
            this.HasPhotos = hasPhotos;
            this.HasVideos = hasVideos;
        }
    }

    public partial class NotificationTypeNewMessage
    {
        /// <summary>
        /// New message was received
        /// </summary>
        public NotificationTypeNewMessage() { }
        /// <summary>
        /// New message was received
        /// </summary>
        /// <param name="message">The message</param>
        public NotificationTypeNewMessage(Message message = default)
        {
            this.Message = message;
        }
    }

    public partial class NotificationTypeNewSecretChat
    {
        /// <summary>
        /// New secret chat was created
        /// </summary>
        public NotificationTypeNewSecretChat() { }
    }

    public partial class NotificationTypeNewCall
    {
        /// <summary>
        /// New call was received
        /// </summary>
        public NotificationTypeNewCall() { }
        /// <summary>
        /// New call was received
        /// </summary>
        /// <param name="callId">Call identifier</param>
        public NotificationTypeNewCall(int callId = default)
        {
            this.CallId = callId;
        }
    }

    public partial class NotificationTypeNewPushMessage
    {
        /// <summary>
        /// New message was received through a push notification
        /// </summary>
        public NotificationTypeNewPushMessage() { }
        /// <summary>
        /// New message was received through a push notification
        /// </summary>
        /// <param name="messageId">The message identifier. The message will not be available in the chat history, but the ID can be used in viewMessages, or as reply_to_message_id</param>
        /// <param name="senderUserId">Sender of the message; 0 if unknown. Corresponding user may be inaccessible</param>
        /// <param name="senderChatId">Sender chat of the message; 0 if none</param>
        /// <param name="senderName">Name of the sender; can be different from the name of the sender user</param>
        /// <param name="isOutgoing">True, if the message is outgoing</param>
        /// <param name="content">Push message content</param>
        public NotificationTypeNewPushMessage(long messageId = default, int senderUserId = default, long senderChatId = default, string senderName = default, bool isOutgoing = default, PushMessageContent content = default)
        {
            this.MessageId = messageId;
            this.SenderUserId = senderUserId;
            this.SenderChatId = senderChatId;
            this.SenderName = senderName;
            this.IsOutgoing = isOutgoing;
            this.Content = content;
        }
    }

    public partial class NotificationGroupTypeMessages
    {
        /// <summary>
        /// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages
        /// </summary>
        public NotificationGroupTypeMessages() { }
    }

    public partial class NotificationGroupTypeMentions
    {
        /// <summary>
        /// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message
        /// </summary>
        public NotificationGroupTypeMentions() { }
    }

    public partial class NotificationGroupTypeSecretChat
    {
        /// <summary>
        /// A group containing a notification of type notificationTypeNewSecretChat
        /// </summary>
        public NotificationGroupTypeSecretChat() { }
    }

    public partial class NotificationGroupTypeCalls
    {
        /// <summary>
        /// A group containing notifications of type notificationTypeNewCall
        /// </summary>
        public NotificationGroupTypeCalls() { }
    }

    public partial class Notification
    {
        /// <summary>
        /// Contains information about a notification
        /// </summary>
        public Notification() { }
        /// <summary>
        /// Contains information about a notification
        /// </summary>
        /// <param name="id">Unique persistent identifier of this notification</param>
        /// <param name="date">Notification date</param>
        /// <param name="isSilent">True, if the notification was initially silent</param>
        /// <param name="type">Notification type</param>
        public Notification(int id = default, int date = default, bool isSilent = default, NotificationType type = default)
        {
            this.Id = id;
            this.Date = date;
            this.IsSilent = isSilent;
            this.Type = type;
        }
    }

    public partial class NotificationGroup
    {
        /// <summary>
        /// Describes a group of notifications
        /// </summary>
        public NotificationGroup() { }
        /// <summary>
        /// Describes a group of notifications
        /// </summary>
        /// <param name="id">Unique persistent auto-incremented from 1 identifier of the notification group</param>
        /// <param name="type">Type of the group</param>
        /// <param name="chatId">Identifier of a chat to which all notifications in the group belong</param>
        /// <param name="totalCount">Total number of active notifications in the group</param>
        /// <param name="notifications">The list of active notifications</param>
        public NotificationGroup(int id = default, NotificationGroupType type = default, long chatId = default, int totalCount = default, Notification[] notifications = default)
        {
            this.Id = id;
            this.Type = type;
            this.ChatId = chatId;
            this.TotalCount = totalCount;
            this.Notifications = notifications;
        }
    }

    public partial class OptionValueBoolean
    {
        /// <summary>
        /// Represents a boolean option
        /// </summary>
        public OptionValueBoolean() { }
        /// <summary>
        /// Represents a boolean option
        /// </summary>
        /// <param name="value">The value of the option</param>
        public OptionValueBoolean(bool value = default)
        {
            this.Value = value;
        }
    }

    public partial class OptionValueEmpty
    {
        /// <summary>
        /// Represents an unknown option or an option which has a default value
        /// </summary>
        public OptionValueEmpty() { }
    }

    public partial class OptionValueInteger
    {
        /// <summary>
        /// Represents an integer option
        /// </summary>
        public OptionValueInteger() { }
        /// <summary>
        /// Represents an integer option
        /// </summary>
        /// <param name="value">The value of the option</param>
        public OptionValueInteger(long value = default)
        {
            this.Value = value;
        }
    }

    public partial class OptionValueString
    {
        /// <summary>
        /// Represents a string option
        /// </summary>
        public OptionValueString() { }
        /// <summary>
        /// Represents a string option
        /// </summary>
        /// <param name="value">The value of the option</param>
        public OptionValueString(string value = default)
        {
            this.Value = value;
        }
    }

    public partial class JsonObjectMember
    {
        /// <summary>
        /// Represents one member of a JSON object
        /// </summary>
        public JsonObjectMember() { }
        /// <summary>
        /// Represents one member of a JSON object
        /// </summary>
        /// <param name="key">Member's key</param>
        /// <param name="value">Member's value</param>
        public JsonObjectMember(string key = default, JsonValue value = default)
        {
            this.Key = key;
            this.Value = value;
        }
    }

    public partial class JsonValueNull
    {
        /// <summary>
        /// Represents a null JSON value
        /// </summary>
        public JsonValueNull() { }
    }

    public partial class JsonValueBoolean
    {
        /// <summary>
        /// Represents a boolean JSON value
        /// </summary>
        public JsonValueBoolean() { }
        /// <summary>
        /// Represents a boolean JSON value
        /// </summary>
        /// <param name="value">The value</param>
        public JsonValueBoolean(bool value = default)
        {
            this.Value = value;
        }
    }

    public partial class JsonValueNumber
    {
        /// <summary>
        /// Represents a numeric JSON value
        /// </summary>
        public JsonValueNumber() { }
        /// <summary>
        /// Represents a numeric JSON value
        /// </summary>
        /// <param name="value">The value</param>
        public JsonValueNumber(double value = default)
        {
            this.Value = value;
        }
    }

    public partial class JsonValueString
    {
        /// <summary>
        /// Represents a string JSON value
        /// </summary>
        public JsonValueString() { }
        /// <summary>
        /// Represents a string JSON value
        /// </summary>
        /// <param name="value">The value</param>
        public JsonValueString(string value = default)
        {
            this.Value = value;
        }
    }

    public partial class JsonValueArray
    {
        /// <summary>
        /// Represents a JSON array
        /// </summary>
        public JsonValueArray() { }
        /// <summary>
        /// Represents a JSON array
        /// </summary>
        /// <param name="values">The list of array elements</param>
        public JsonValueArray(JsonValue[] values = default)
        {
            this.Values = values;
        }
    }

    public partial class JsonValueObject
    {
        /// <summary>
        /// Represents a JSON object
        /// </summary>
        public JsonValueObject() { }
        /// <summary>
        /// Represents a JSON object
        /// </summary>
        /// <param name="members">The list of object members</param>
        public JsonValueObject(JsonObjectMember[] members = default)
        {
            this.Members = members;
        }
    }

    public partial class UserPrivacySettingRuleAllowAll
    {
        /// <summary>
        /// A rule to allow all users to do something
        /// </summary>
        public UserPrivacySettingRuleAllowAll() { }
    }

    public partial class UserPrivacySettingRuleAllowContacts
    {
        /// <summary>
        /// A rule to allow all of a user's contacts to do something
        /// </summary>
        public UserPrivacySettingRuleAllowContacts() { }
    }

    public partial class UserPrivacySettingRuleAllowUsers
    {
        /// <summary>
        /// A rule to allow certain specified users to do something
        /// </summary>
        public UserPrivacySettingRuleAllowUsers() { }
        /// <summary>
        /// A rule to allow certain specified users to do something
        /// </summary>
        /// <param name="userIds">The user identifiers, total number of users in all rules must not exceed 1000</param>
        public UserPrivacySettingRuleAllowUsers(int[] userIds = default)
        {
            this.UserIds = userIds;
        }
    }

    public partial class UserPrivacySettingRuleAllowChatMembers
    {
        /// <summary>
        /// A rule to allow all members of certain specified basic groups and supergroups to doing something
        /// </summary>
        public UserPrivacySettingRuleAllowChatMembers() { }
        /// <summary>
        /// A rule to allow all members of certain specified basic groups and supergroups to doing something
        /// </summary>
        /// <param name="chatIds">The chat identifiers, total number of chats in all rules must not exceed 20</param>
        public UserPrivacySettingRuleAllowChatMembers(long[] chatIds = default)
        {
            this.ChatIds = chatIds;
        }
    }

    public partial class UserPrivacySettingRuleRestrictAll
    {
        /// <summary>
        /// A rule to restrict all users from doing something
        /// </summary>
        public UserPrivacySettingRuleRestrictAll() { }
    }

    public partial class UserPrivacySettingRuleRestrictContacts
    {
        /// <summary>
        /// A rule to restrict all contacts of a user from doing something
        /// </summary>
        public UserPrivacySettingRuleRestrictContacts() { }
    }

    public partial class UserPrivacySettingRuleRestrictUsers
    {
        /// <summary>
        /// A rule to restrict all specified users from doing something
        /// </summary>
        public UserPrivacySettingRuleRestrictUsers() { }
        /// <summary>
        /// A rule to restrict all specified users from doing something
        /// </summary>
        /// <param name="userIds">The user identifiers, total number of users in all rules must not exceed 1000</param>
        public UserPrivacySettingRuleRestrictUsers(int[] userIds = default)
        {
            this.UserIds = userIds;
        }
    }

    public partial class UserPrivacySettingRuleRestrictChatMembers
    {
        /// <summary>
        /// A rule to restrict all members of specified basic groups and supergroups from doing something
        /// </summary>
        public UserPrivacySettingRuleRestrictChatMembers() { }
        /// <summary>
        /// A rule to restrict all members of specified basic groups and supergroups from doing something
        /// </summary>
        /// <param name="chatIds">The chat identifiers, total number of chats in all rules must not exceed 20</param>
        public UserPrivacySettingRuleRestrictChatMembers(long[] chatIds = default)
        {
            this.ChatIds = chatIds;
        }
    }

    public partial class UserPrivacySettingRules
    {
        /// <summary>
        /// A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed
        /// </summary>
        public UserPrivacySettingRules() { }
        /// <summary>
        /// A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed
        /// </summary>
        /// <param name="rules">A list of rules</param>
        public UserPrivacySettingRules(UserPrivacySettingRule[] rules = default)
        {
            this.Rules = rules;
        }
    }

    public partial class UserPrivacySettingShowStatus
    {
        /// <summary>
        /// A privacy setting for managing whether the user's online status is visible
        /// </summary>
        public UserPrivacySettingShowStatus() { }
    }

    public partial class UserPrivacySettingShowProfilePhoto
    {
        /// <summary>
        /// A privacy setting for managing whether the user's profile photo is visible
        /// </summary>
        public UserPrivacySettingShowProfilePhoto() { }
    }

    public partial class UserPrivacySettingShowLinkInForwardedMessages
    {
        /// <summary>
        /// A privacy setting for managing whether a link to the user's account is included in forwarded messages
        /// </summary>
        public UserPrivacySettingShowLinkInForwardedMessages() { }
    }

    public partial class UserPrivacySettingShowPhoneNumber
    {
        /// <summary>
        /// A privacy setting for managing whether the user's phone number is visible
        /// </summary>
        public UserPrivacySettingShowPhoneNumber() { }
    }

    public partial class UserPrivacySettingAllowChatInvites
    {
        /// <summary>
        /// A privacy setting for managing whether the user can be invited to chats
        /// </summary>
        public UserPrivacySettingAllowChatInvites() { }
    }

    public partial class UserPrivacySettingAllowCalls
    {
        /// <summary>
        /// A privacy setting for managing whether the user can be called
        /// </summary>
        public UserPrivacySettingAllowCalls() { }
    }

    public partial class UserPrivacySettingAllowPeerToPeerCalls
    {
        /// <summary>
        /// A privacy setting for managing whether peer-to-peer connections can be used for calls
        /// </summary>
        public UserPrivacySettingAllowPeerToPeerCalls() { }
    }

    public partial class UserPrivacySettingAllowFindingByPhoneNumber
    {
        /// <summary>
        /// A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all"
        /// </summary>
        public UserPrivacySettingAllowFindingByPhoneNumber() { }
    }

    public partial class AccountTtl
    {
        /// <summary>
        /// Contains information about the period of inactivity after which the current user's account will automatically be deleted
        /// </summary>
        public AccountTtl() { }
        /// <summary>
        /// Contains information about the period of inactivity after which the current user's account will automatically be deleted
        /// </summary>
        /// <param name="days">Number of days of inactivity before the account will be flagged for deletion; should range from 30-366 days</param>
        public AccountTtl(int days = default)
        {
            this.Days = days;
        }
    }

    public partial class Session
    {
        /// <summary>
        /// Contains information about one session in a Telegram application used by the current user. Sessions should be shown to the user in the returned order
        /// </summary>
        public Session() { }
        /// <summary>
        /// Contains information about one session in a Telegram application used by the current user. Sessions should be shown to the user in the returned order
        /// </summary>
        /// <param name="id">Session identifier</param>
        /// <param name="isCurrent">True, if this session is the current session</param>
        /// <param name="isPasswordPending">True, if a password is needed to complete authorization of the session</param>
        /// <param name="apiId">Telegram API identifier, as provided by the application</param>
        /// <param name="applicationName">Name of the application, as provided by the application</param>
        /// <param name="applicationVersion">The version of the application, as provided by the application</param>
        /// <param name="isOfficialApplication">True, if the application is an official application or uses the api_id of an official application</param>
        /// <param name="deviceModel">Model of the device the application has been run or is running on, as provided by the application</param>
        /// <param name="platform">Operating system the application has been run or is running on, as provided by the application</param>
        /// <param name="systemVersion">Version of the operating system the application has been run or is running on, as provided by the application</param>
        /// <param name="logInDate">Point in time (Unix timestamp) when the user has logged in</param>
        /// <param name="lastActiveDate">Point in time (Unix timestamp) when the session was last used</param>
        /// <param name="ip">IP address from which the session was created, in human-readable format</param>
        /// <param name="country">A two-letter country code for the country from which the session was created, based on the IP address</param>
        /// <param name="region">Region code from which the session was created, based on the IP address</param>
        public Session(long id = default, bool isCurrent = default, bool isPasswordPending = default, int apiId = default, string applicationName = default, string applicationVersion = default, bool isOfficialApplication = default, string deviceModel = default, string platform = default, string systemVersion = default, int logInDate = default, int lastActiveDate = default, string ip = default, string country = default, string region = default)
        {
            this.Id = id;
            this.IsCurrent = isCurrent;
            this.IsPasswordPending = isPasswordPending;
            this.ApiId = apiId;
            this.ApplicationName = applicationName;
            this.ApplicationVersion = applicationVersion;
            this.IsOfficialApplication = isOfficialApplication;
            this.DeviceModel = deviceModel;
            this.Platform = platform;
            this.SystemVersion = systemVersion;
            this.LogInDate = logInDate;
            this.LastActiveDate = lastActiveDate;
            this.Ip = ip;
            this.Country = country;
            this.Region = region;
        }
    }

    public partial class Sessions
    {
        /// <summary>
        /// Contains a list of sessions
        /// </summary>
        public Sessions() { }
        /// <summary>
        /// Contains a list of sessions
        /// </summary>
        /// <param name="sessions">List of sessions</param>
        public Sessions(Session[] sessions_ = default)
        {
            this.Sessions_ = sessions_;
        }
    }

    public partial class ConnectedWebsite
    {
        /// <summary>
        /// Contains information about one website the current user is logged in with Telegram
        /// </summary>
        public ConnectedWebsite() { }
        /// <summary>
        /// Contains information about one website the current user is logged in with Telegram
        /// </summary>
        /// <param name="id">Website identifier</param>
        /// <param name="domainName">The domain name of the website</param>
        /// <param name="botUserId">User identifier of a bot linked with the website</param>
        /// <param name="browser">The version of a browser used to log in</param>
        /// <param name="platform">Operating system the browser is running on</param>
        /// <param name="logInDate">Point in time (Unix timestamp) when the user was logged in</param>
        /// <param name="lastActiveDate">Point in time (Unix timestamp) when obtained authorization was last used</param>
        /// <param name="ip">IP address from which the user was logged in, in human-readable format</param>
        /// <param name="location">Human-readable description of a country and a region, from which the user was logged in, based on the IP address</param>
        public ConnectedWebsite(long id = default, string domainName = default, int botUserId = default, string browser = default, string platform = default, int logInDate = default, int lastActiveDate = default, string ip = default, string location = default)
        {
            this.Id = id;
            this.DomainName = domainName;
            this.BotUserId = botUserId;
            this.Browser = browser;
            this.Platform = platform;
            this.LogInDate = logInDate;
            this.LastActiveDate = lastActiveDate;
            this.Ip = ip;
            this.Location = location;
        }
    }

    public partial class ConnectedWebsites
    {
        /// <summary>
        /// Contains a list of websites the current user is logged in with Telegram
        /// </summary>
        public ConnectedWebsites() { }
        /// <summary>
        /// Contains a list of websites the current user is logged in with Telegram
        /// </summary>
        /// <param name="websites">List of connected websites</param>
        public ConnectedWebsites(ConnectedWebsite[] websites = default)
        {
            this.Websites = websites;
        }
    }

    public partial class ChatReportReasonSpam
    {
        /// <summary>
        /// The chat contains spam messages
        /// </summary>
        public ChatReportReasonSpam() { }
    }

    public partial class ChatReportReasonViolence
    {
        /// <summary>
        /// The chat promotes violence
        /// </summary>
        public ChatReportReasonViolence() { }
    }

    public partial class ChatReportReasonPornography
    {
        /// <summary>
        /// The chat contains pornographic messages
        /// </summary>
        public ChatReportReasonPornography() { }
    }

    public partial class ChatReportReasonChildAbuse
    {
        /// <summary>
        /// The chat has child abuse related content
        /// </summary>
        public ChatReportReasonChildAbuse() { }
    }

    public partial class ChatReportReasonCopyright
    {
        /// <summary>
        /// The chat contains copyrighted content
        /// </summary>
        public ChatReportReasonCopyright() { }
    }

    public partial class ChatReportReasonUnrelatedLocation
    {
        /// <summary>
        /// The location-based chat is unrelated to its stated location
        /// </summary>
        public ChatReportReasonUnrelatedLocation() { }
    }

    public partial class ChatReportReasonCustom
    {
        /// <summary>
        /// A custom reason provided by the user
        /// </summary>
        public ChatReportReasonCustom() { }
        /// <summary>
        /// A custom reason provided by the user
        /// </summary>
        /// <param name="text">Report text</param>
        public ChatReportReasonCustom(string text = default)
        {
            this.Text = text;
        }
    }

    public partial class MessageLink
    {
        /// <summary>
        /// Contains an HTTPS link to a message in a supergroup or channel
        /// </summary>
        public MessageLink() { }
        /// <summary>
        /// Contains an HTTPS link to a message in a supergroup or channel
        /// </summary>
        /// <param name="link">Message link</param>
        /// <param name="isPublic">True, if the link will work for non-members of the chat</param>
        public MessageLink(string link = default, bool isPublic = default)
        {
            this.Link = link;
            this.IsPublic = isPublic;
        }
    }

    public partial class MessageLinkInfo
    {
        /// <summary>
        /// Contains information about a link to a message in a chat
        /// </summary>
        public MessageLinkInfo() { }
        /// <summary>
        /// Contains information about a link to a message in a chat
        /// </summary>
        /// <param name="isPublic">True, if the link is a public link for a message in a chat</param>
        /// <param name="chatId">If found, identifier of the chat to which the message belongs, 0 otherwise</param>
        /// <param name="message">If found, the linked message; may be null</param>
        /// <param name="forAlbum">True, if the whole media album to which the message belongs is linked</param>
        /// <param name="forComment">True, if the message is linked as a channel post comment or from a message thread</param>
        public MessageLinkInfo(bool isPublic = default, long chatId = default, Message message = default, bool forAlbum = default, bool forComment = default)
        {
            this.IsPublic = isPublic;
            this.ChatId = chatId;
            this.Message = message;
            this.ForAlbum = forAlbum;
            this.ForComment = forComment;
        }
    }

    public partial class FilePart
    {
        /// <summary>
        /// Contains a part of a file
        /// </summary>
        public FilePart() { }
        /// <summary>
        /// Contains a part of a file
        /// </summary>
        /// <param name="data">File bytes</param>
        public FilePart(Memory<byte> data = default)
        {
            this.Data = data;
        }
    }

    public partial class FileTypeNone
    {
        /// <summary>
        /// The data is not a file
        /// </summary>
        public FileTypeNone() { }
    }

    public partial class FileTypeAnimation
    {
        /// <summary>
        /// The file is an animation
        /// </summary>
        public FileTypeAnimation() { }
    }

    public partial class FileTypeAudio
    {
        /// <summary>
        /// The file is an audio file
        /// </summary>
        public FileTypeAudio() { }
    }

    public partial class FileTypeDocument
    {
        /// <summary>
        /// The file is a document
        /// </summary>
        public FileTypeDocument() { }
    }

    public partial class FileTypePhoto
    {
        /// <summary>
        /// The file is a photo
        /// </summary>
        public FileTypePhoto() { }
    }

    public partial class FileTypeProfilePhoto
    {
        /// <summary>
        /// The file is a profile photo
        /// </summary>
        public FileTypeProfilePhoto() { }
    }

    public partial class FileTypeSecret
    {
        /// <summary>
        /// The file was sent to a secret chat (the file type is not known to the server)
        /// </summary>
        public FileTypeSecret() { }
    }

    public partial class FileTypeSecretThumbnail
    {
        /// <summary>
        /// The file is a thumbnail of a file from a secret chat
        /// </summary>
        public FileTypeSecretThumbnail() { }
    }

    public partial class FileTypeSecure
    {
        /// <summary>
        /// The file is a file from Secure storage used for storing Telegram Passport files
        /// </summary>
        public FileTypeSecure() { }
    }

    public partial class FileTypeSticker
    {
        /// <summary>
        /// The file is a sticker
        /// </summary>
        public FileTypeSticker() { }
    }

    public partial class FileTypeThumbnail
    {
        /// <summary>
        /// The file is a thumbnail of another file
        /// </summary>
        public FileTypeThumbnail() { }
    }

    public partial class FileTypeUnknown
    {
        /// <summary>
        /// The file type is not yet known
        /// </summary>
        public FileTypeUnknown() { }
    }

    public partial class FileTypeVideo
    {
        /// <summary>
        /// The file is a video
        /// </summary>
        public FileTypeVideo() { }
    }

    public partial class FileTypeVideoNote
    {
        /// <summary>
        /// The file is a video note
        /// </summary>
        public FileTypeVideoNote() { }
    }

    public partial class FileTypeVoiceNote
    {
        /// <summary>
        /// The file is a voice note
        /// </summary>
        public FileTypeVoiceNote() { }
    }

    public partial class FileTypeWallpaper
    {
        /// <summary>
        /// The file is a wallpaper or a background pattern
        /// </summary>
        public FileTypeWallpaper() { }
    }

    public partial class StorageStatisticsByFileType
    {
        /// <summary>
        /// Contains the storage usage statistics for a specific file type
        /// </summary>
        public StorageStatisticsByFileType() { }
        /// <summary>
        /// Contains the storage usage statistics for a specific file type
        /// </summary>
        /// <param name="fileType">File type</param>
        /// <param name="size">Total size of the files</param>
        /// <param name="count">Total number of files</param>
        public StorageStatisticsByFileType(FileType fileType = default, long size = default, int count = default)
        {
            this.FileType = fileType;
            this.Size = size;
            this.Count = count;
        }
    }

    public partial class StorageStatisticsByChat
    {
        /// <summary>
        /// Contains the storage usage statistics for a specific chat
        /// </summary>
        public StorageStatisticsByChat() { }
        /// <summary>
        /// Contains the storage usage statistics for a specific chat
        /// </summary>
        /// <param name="chatId">Chat identifier; 0 if none</param>
        /// <param name="size">Total size of the files in the chat</param>
        /// <param name="count">Total number of files in the chat</param>
        /// <param name="byFileType">Statistics split by file types</param>
        public StorageStatisticsByChat(long chatId = default, long size = default, int count = default, StorageStatisticsByFileType[] byFileType = default)
        {
            this.ChatId = chatId;
            this.Size = size;
            this.Count = count;
            this.ByFileType = byFileType;
        }
    }

    public partial class StorageStatistics
    {
        /// <summary>
        /// Contains the exact storage usage statistics split by chats and file type
        /// </summary>
        public StorageStatistics() { }
        /// <summary>
        /// Contains the exact storage usage statistics split by chats and file type
        /// </summary>
        /// <param name="size">Total size of files</param>
        /// <param name="count">Total number of files</param>
        /// <param name="byChat">Statistics split by chats</param>
        public StorageStatistics(long size = default, int count = default, StorageStatisticsByChat[] byChat = default)
        {
            this.Size = size;
            this.Count = count;
            this.ByChat = byChat;
        }
    }

    public partial class StorageStatisticsFast
    {
        /// <summary>
        /// Contains approximate storage usage statistics, excluding files of unknown file type
        /// </summary>
        public StorageStatisticsFast() { }
        /// <summary>
        /// Contains approximate storage usage statistics, excluding files of unknown file type
        /// </summary>
        /// <param name="filesSize">Approximate total size of files</param>
        /// <param name="fileCount">Approximate number of files</param>
        /// <param name="databaseSize">Size of the database</param>
        /// <param name="languagePackDatabaseSize">Size of the language pack database</param>
        /// <param name="logSize">Size of the TDLib internal log</param>
        public StorageStatisticsFast(long filesSize = default, int fileCount = default, long databaseSize = default, long languagePackDatabaseSize = default, long logSize = default)
        {
            this.FilesSize = filesSize;
            this.FileCount = fileCount;
            this.DatabaseSize = databaseSize;
            this.LanguagePackDatabaseSize = languagePackDatabaseSize;
            this.LogSize = logSize;
        }
    }

    public partial class DatabaseStatistics
    {
        /// <summary>
        /// Contains database statistics
        /// </summary>
        public DatabaseStatistics() { }
        /// <summary>
        /// Contains database statistics
        /// </summary>
        /// <param name="statistics">Database statistics in an unspecified human-readable format</param>
        public DatabaseStatistics(string statistics = default)
        {
            this.Statistics = statistics;
        }
    }

    public partial class NetworkTypeNone
    {
        /// <summary>
        /// The network is not available
        /// </summary>
        public NetworkTypeNone() { }
    }

    public partial class NetworkTypeMobile
    {
        /// <summary>
        /// A mobile network
        /// </summary>
        public NetworkTypeMobile() { }
    }

    public partial class NetworkTypeMobileRoaming
    {
        /// <summary>
        /// A mobile roaming network
        /// </summary>
        public NetworkTypeMobileRoaming() { }
    }

    public partial class NetworkTypeWiFi
    {
        /// <summary>
        /// A Wi-Fi network
        /// </summary>
        public NetworkTypeWiFi() { }
    }

    public partial class NetworkTypeOther
    {
        /// <summary>
        /// A different network type (e.g., Ethernet network)
        /// </summary>
        public NetworkTypeOther() { }
    }

    public partial class NetworkStatisticsEntryFile
    {
        /// <summary>
        /// Contains information about the total amount of data that was used to send and receive files
        /// </summary>
        public NetworkStatisticsEntryFile() { }
        /// <summary>
        /// Contains information about the total amount of data that was used to send and receive files
        /// </summary>
        /// <param name="fileType">Type of the file the data is part of</param>
        /// <param name="networkType">Type of the network the data was sent through. Call setNetworkType to maintain the actual network type</param>
        /// <param name="sentBytes">Total number of bytes sent</param>
        /// <param name="receivedBytes">Total number of bytes received</param>
        public NetworkStatisticsEntryFile(FileType fileType = default, NetworkType networkType = default, long sentBytes = default, long receivedBytes = default)
        {
            this.FileType = fileType;
            this.NetworkType = networkType;
            this.SentBytes = sentBytes;
            this.ReceivedBytes = receivedBytes;
        }
    }

    public partial class NetworkStatisticsEntryCall
    {
        /// <summary>
        /// Contains information about the total amount of data that was used for calls
        /// </summary>
        public NetworkStatisticsEntryCall() { }
        /// <summary>
        /// Contains information about the total amount of data that was used for calls
        /// </summary>
        /// <param name="networkType">Type of the network the data was sent through. Call setNetworkType to maintain the actual network type</param>
        /// <param name="sentBytes">Total number of bytes sent</param>
        /// <param name="receivedBytes">Total number of bytes received</param>
        /// <param name="duration">Total call duration, in seconds</param>
        public NetworkStatisticsEntryCall(NetworkType networkType = default, long sentBytes = default, long receivedBytes = default, double duration = default)
        {
            this.NetworkType = networkType;
            this.SentBytes = sentBytes;
            this.ReceivedBytes = receivedBytes;
            this.Duration = duration;
        }
    }

    public partial class NetworkStatistics
    {
        /// <summary>
        /// A full list of available network statistic entries
        /// </summary>
        public NetworkStatistics() { }
        /// <summary>
        /// A full list of available network statistic entries
        /// </summary>
        /// <param name="sinceDate">Point in time (Unix timestamp) from which the statistics are collected</param>
        /// <param name="entries">Network statistics entries</param>
        public NetworkStatistics(int sinceDate = default, NetworkStatisticsEntry[] entries = default)
        {
            this.SinceDate = sinceDate;
            this.Entries = entries;
        }
    }

    public partial class AutoDownloadSettings
    {
        /// <summary>
        /// Contains auto-download settings
        /// </summary>
        public AutoDownloadSettings() { }
        /// <summary>
        /// Contains auto-download settings
        /// </summary>
        /// <param name="isAutoDownloadEnabled">True, if the auto-download is enabled</param>
        /// <param name="maxPhotoFileSize">The maximum size of a photo file to be auto-downloaded</param>
        /// <param name="maxVideoFileSize">The maximum size of a video file to be auto-downloaded</param>
        /// <param name="maxOtherFileSize">The maximum size of other file types to be auto-downloaded</param>
        /// <param name="videoUploadBitrate">The maximum suggested bitrate for uploaded videos</param>
        /// <param name="preloadLargeVideos">True, if the beginning of video files needs to be preloaded for instant playback</param>
        /// <param name="preloadNextAudio">True, if the next audio track needs to be preloaded while the user is listening to an audio file</param>
        /// <param name="useLessDataForCalls">True, if "use less data for calls" option needs to be enabled</param>
        public AutoDownloadSettings(bool isAutoDownloadEnabled = default, int maxPhotoFileSize = default, int maxVideoFileSize = default, int maxOtherFileSize = default, int videoUploadBitrate = default, bool preloadLargeVideos = default, bool preloadNextAudio = default, bool useLessDataForCalls = default)
        {
            this.IsAutoDownloadEnabled = isAutoDownloadEnabled;
            this.MaxPhotoFileSize = maxPhotoFileSize;
            this.MaxVideoFileSize = maxVideoFileSize;
            this.MaxOtherFileSize = maxOtherFileSize;
            this.VideoUploadBitrate = videoUploadBitrate;
            this.PreloadLargeVideos = preloadLargeVideos;
            this.PreloadNextAudio = preloadNextAudio;
            this.UseLessDataForCalls = useLessDataForCalls;
        }
    }

    public partial class AutoDownloadSettingsPresets
    {
        /// <summary>
        /// Contains auto-download settings presets for the user
        /// </summary>
        public AutoDownloadSettingsPresets() { }
        /// <summary>
        /// Contains auto-download settings presets for the user
        /// </summary>
        /// <param name="low">Preset with lowest settings; supposed to be used by default when roaming</param>
        /// <param name="medium">Preset with medium settings; supposed to be used by default when using mobile data</param>
        /// <param name="high">Preset with highest settings; supposed to be used by default when connected on Wi-Fi</param>
        public AutoDownloadSettingsPresets(AutoDownloadSettings low = default, AutoDownloadSettings medium = default, AutoDownloadSettings high = default)
        {
            this.Low = low;
            this.Medium = medium;
            this.High = high;
        }
    }

    public partial class ConnectionStateWaitingForNetwork
    {
        /// <summary>
        /// Currently waiting for the network to become available. Use setNetworkType to change the available network type
        /// </summary>
        public ConnectionStateWaitingForNetwork() { }
    }

    public partial class ConnectionStateConnectingToProxy
    {
        /// <summary>
        /// Currently establishing a connection with a proxy server
        /// </summary>
        public ConnectionStateConnectingToProxy() { }
    }

    public partial class ConnectionStateConnecting
    {
        /// <summary>
        /// Currently establishing a connection to the Telegram servers
        /// </summary>
        public ConnectionStateConnecting() { }
    }

    public partial class ConnectionStateUpdating
    {
        /// <summary>
        /// Downloading data received while the application was offline
        /// </summary>
        public ConnectionStateUpdating() { }
    }

    public partial class ConnectionStateReady
    {
        /// <summary>
        /// There is a working connection to the Telegram servers
        /// </summary>
        public ConnectionStateReady() { }
    }

    public partial class TopChatCategoryUsers
    {
        /// <summary>
        /// A category containing frequently used private chats with non-bot users
        /// </summary>
        public TopChatCategoryUsers() { }
    }

    public partial class TopChatCategoryBots
    {
        /// <summary>
        /// A category containing frequently used private chats with bot users
        /// </summary>
        public TopChatCategoryBots() { }
    }

    public partial class TopChatCategoryGroups
    {
        /// <summary>
        /// A category containing frequently used basic groups and supergroups
        /// </summary>
        public TopChatCategoryGroups() { }
    }

    public partial class TopChatCategoryChannels
    {
        /// <summary>
        /// A category containing frequently used channels
        /// </summary>
        public TopChatCategoryChannels() { }
    }

    public partial class TopChatCategoryInlineBots
    {
        /// <summary>
        /// A category containing frequently used chats with inline bots sorted by their usage in inline mode
        /// </summary>
        public TopChatCategoryInlineBots() { }
    }

    public partial class TopChatCategoryCalls
    {
        /// <summary>
        /// A category containing frequently used chats used for calls
        /// </summary>
        public TopChatCategoryCalls() { }
    }

    public partial class TopChatCategoryForwardChats
    {
        /// <summary>
        /// A category containing frequently used chats used to forward messages
        /// </summary>
        public TopChatCategoryForwardChats() { }
    }

    public partial class TMeUrlTypeUser
    {
        /// <summary>
        /// A URL linking to a user
        /// </summary>
        public TMeUrlTypeUser() { }
        /// <summary>
        /// A URL linking to a user
        /// </summary>
        /// <param name="userId">Identifier of the user</param>
        public TMeUrlTypeUser(int userId = default)
        {
            this.UserId = userId;
        }
    }

    public partial class TMeUrlTypeSupergroup
    {
        /// <summary>
        /// A URL linking to a public supergroup or channel
        /// </summary>
        public TMeUrlTypeSupergroup() { }
        /// <summary>
        /// A URL linking to a public supergroup or channel
        /// </summary>
        /// <param name="supergroupId">Identifier of the supergroup or channel</param>
        public TMeUrlTypeSupergroup(long supergroupId = default)
        {
            this.SupergroupId = supergroupId;
        }
    }

    public partial class TMeUrlTypeChatInvite
    {
        /// <summary>
        /// A chat invite link
        /// </summary>
        public TMeUrlTypeChatInvite() { }
        /// <summary>
        /// A chat invite link
        /// </summary>
        /// <param name="info">Chat invite link info</param>
        public TMeUrlTypeChatInvite(ChatInviteLinkInfo info = default)
        {
            this.Info = info;
        }
    }

    public partial class TMeUrlTypeStickerSet
    {
        /// <summary>
        /// A URL linking to a sticker set
        /// </summary>
        public TMeUrlTypeStickerSet() { }
        /// <summary>
        /// A URL linking to a sticker set
        /// </summary>
        /// <param name="stickerSetId">Identifier of the sticker set</param>
        public TMeUrlTypeStickerSet(long stickerSetId = default)
        {
            this.StickerSetId = stickerSetId;
        }
    }

    public partial class TMeUrl
    {
        /// <summary>
        /// Represents a URL linking to an internal Telegram entity
        /// </summary>
        public TMeUrl() { }
        /// <summary>
        /// Represents a URL linking to an internal Telegram entity
        /// </summary>
        /// <param name="url">URL</param>
        /// <param name="type">Type of the URL</param>
        public TMeUrl(string url = default, TMeUrlType type = default)
        {
            this.Url = url;
            this.Type = type;
        }
    }

    public partial class TMeUrls
    {
        /// <summary>
        /// Contains a list of t.me URLs
        /// </summary>
        public TMeUrls() { }
        /// <summary>
        /// Contains a list of t.me URLs
        /// </summary>
        /// <param name="urls">List of URLs</param>
        public TMeUrls(TMeUrl[] urls = default)
        {
            this.Urls = urls;
        }
    }

    public partial class SuggestedActionEnableArchiveAndMuteNewChats
    {
        /// <summary>
        /// Suggests the user to enable "archive_and_mute_new_chats_from_unknown_users" option
        /// </summary>
        public SuggestedActionEnableArchiveAndMuteNewChats() { }
    }

    public partial class SuggestedActionCheckPhoneNumber
    {
        /// <summary>
        /// Suggests the user to check authorization phone number and change the phone number if it is inaccessible
        /// </summary>
        public SuggestedActionCheckPhoneNumber() { }
    }

    public partial class Count
    {
        /// <summary>
        /// Contains a counter
        /// </summary>
        public Count() { }
        /// <summary>
        /// Contains a counter
        /// </summary>
        /// <param name="count">Count</param>
        public Count(int count_ = default)
        {
            this.Count_ = count_;
        }
    }

    public partial class Text
    {
        /// <summary>
        /// Contains some text
        /// </summary>
        public Text() { }
        /// <summary>
        /// Contains some text
        /// </summary>
        /// <param name="text">Text</param>
        public Text(string text_ = default)
        {
            this.Text_ = text_;
        }
    }

    public partial class Seconds
    {
        /// <summary>
        /// Contains a value representing a number of seconds
        /// </summary>
        public Seconds() { }
        /// <summary>
        /// Contains a value representing a number of seconds
        /// </summary>
        /// <param name="seconds">Number of seconds</param>
        public Seconds(double seconds_ = default)
        {
            this.Seconds_ = seconds_;
        }
    }

    public partial class DeepLinkInfo
    {
        /// <summary>
        /// Contains information about a tg:// deep link
        /// </summary>
        public DeepLinkInfo() { }
        /// <summary>
        /// Contains information about a tg:// deep link
        /// </summary>
        /// <param name="text">Text to be shown to the user</param>
        /// <param name="needUpdateApplication">True, if user should be asked to update the application</param>
        public DeepLinkInfo(FormattedText text = default, bool needUpdateApplication = default)
        {
            this.Text = text;
            this.NeedUpdateApplication = needUpdateApplication;
        }
    }

    public partial class TextParseModeMarkdown
    {
        /// <summary>
        /// The text uses Markdown-style formatting
        /// </summary>
        public TextParseModeMarkdown() { }
        /// <summary>
        /// The text uses Markdown-style formatting
        /// </summary>
        /// <param name="version">Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode</param>
        public TextParseModeMarkdown(int version = default)
        {
            this.Version = version;
        }
    }

    public partial class TextParseModeHTML
    {
        /// <summary>
        /// The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode
        /// </summary>
        public TextParseModeHTML() { }
    }

    public partial class ProxyTypeSocks5
    {
        /// <summary>
        /// A SOCKS5 proxy server
        /// </summary>
        public ProxyTypeSocks5() { }
        /// <summary>
        /// A SOCKS5 proxy server
        /// </summary>
        /// <param name="username">Username for logging in; may be empty</param>
        /// <param name="password">Password for logging in; may be empty</param>
        public ProxyTypeSocks5(string username = default, string password = default)
        {
            this.Username = username;
            this.Password = password;
        }
    }

    public partial class ProxyTypeHttp
    {
        /// <summary>
        /// A HTTP transparent proxy server
        /// </summary>
        public ProxyTypeHttp() { }
        /// <summary>
        /// A HTTP transparent proxy server
        /// </summary>
        /// <param name="username">Username for logging in; may be empty</param>
        /// <param name="password">Password for logging in; may be empty</param>
        /// <param name="httpOnly">Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method</param>
        public ProxyTypeHttp(string username = default, string password = default, bool httpOnly = default)
        {
            this.Username = username;
            this.Password = password;
            this.HttpOnly = httpOnly;
        }
    }

    public partial class ProxyTypeMtproto
    {
        /// <summary>
        /// An MTProto proxy server
        /// </summary>
        public ProxyTypeMtproto() { }
        /// <summary>
        /// An MTProto proxy server
        /// </summary>
        /// <param name="secret">The proxy's secret in hexadecimal encoding</param>
        public ProxyTypeMtproto(string secret = default)
        {
            this.Secret = secret;
        }
    }

    public partial class Proxy
    {
        /// <summary>
        /// Contains information about a proxy server
        /// </summary>
        public Proxy() { }
        /// <summary>
        /// Contains information about a proxy server
        /// </summary>
        /// <param name="id">Unique identifier of the proxy</param>
        /// <param name="server">Proxy server IP address</param>
        /// <param name="port">Proxy server port</param>
        /// <param name="lastUsedDate">Point in time (Unix timestamp) when the proxy was last used; 0 if never</param>
        /// <param name="isEnabled">True, if the proxy is enabled now</param>
        /// <param name="type">Type of the proxy</param>
        public Proxy(int id = default, string server = default, int port = default, int lastUsedDate = default, bool isEnabled = default, ProxyType type = default)
        {
            this.Id = id;
            this.Server = server;
            this.Port = port;
            this.LastUsedDate = lastUsedDate;
            this.IsEnabled = isEnabled;
            this.Type = type;
        }
    }

    public partial class Proxies
    {
        /// <summary>
        /// Represents a list of proxy servers
        /// </summary>
        public Proxies() { }
        /// <summary>
        /// Represents a list of proxy servers
        /// </summary>
        /// <param name="proxies">List of proxy servers</param>
        public Proxies(Proxy[] proxies_ = default)
        {
            this.Proxies_ = proxies_;
        }
    }

    public partial class InputStickerStatic
    {
        /// <summary>
        /// A static sticker in PNG format, which will be converted to WEBP server-side
        /// </summary>
        public InputStickerStatic() { }
        /// <summary>
        /// A static sticker in PNG format, which will be converted to WEBP server-side
        /// </summary>
        /// <param name="sticker">PNG image with the sticker; must be up to 512 KB in size and fit in a 512x512 square</param>
        /// <param name="emojis">Emojis corresponding to the sticker</param>
        /// <param name="maskPosition">For masks, position where the mask should be placed; may be null</param>
        public InputStickerStatic(InputFile sticker = default, string emojis = default, MaskPosition maskPosition = default)
        {
            this.Sticker = sticker;
            this.Emojis = emojis;
            this.MaskPosition = maskPosition;
        }
    }

    public partial class InputStickerAnimated
    {
        /// <summary>
        /// An animated sticker in TGS format
        /// </summary>
        public InputStickerAnimated() { }
        /// <summary>
        /// An animated sticker in TGS format
        /// </summary>
        /// <param name="sticker">File with the animated sticker. Only local or uploaded within a week files are supported. See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements</param>
        /// <param name="emojis">Emojis corresponding to the sticker</param>
        public InputStickerAnimated(InputFile sticker = default, string emojis = default)
        {
            this.Sticker = sticker;
            this.Emojis = emojis;
        }
    }

    public partial class DateRange
    {
        /// <summary>
        /// Represents a date range
        /// </summary>
        public DateRange() { }
        /// <summary>
        /// Represents a date range
        /// </summary>
        /// <param name="startDate">Point in time (Unix timestamp) at which the date range begins</param>
        /// <param name="endDate">Point in time (Unix timestamp) at which the date range ends</param>
        public DateRange(int startDate = default, int endDate = default)
        {
            this.StartDate = startDate;
            this.EndDate = endDate;
        }
    }

    public partial class StatisticsValue
    {
        /// <summary>
        /// A statistics value
        /// </summary>
        public StatisticsValue() { }
        /// <summary>
        /// A statistics value
        /// </summary>
        /// <param name="value">The value</param>
        /// <param name="previousValue">The value for the previous day</param>
        /// <param name="growthRatePercentage">The growth rate of the value, as a percentage</param>
        public StatisticsValue(double value = default, double previousValue = default, double growthRatePercentage = default)
        {
            this.Value = value;
            this.PreviousValue = previousValue;
            this.GrowthRatePercentage = growthRatePercentage;
        }
    }

    public partial class StatisticsGraphData
    {
        /// <summary>
        /// A graph data
        /// </summary>
        public StatisticsGraphData() { }
        /// <summary>
        /// A graph data
        /// </summary>
        /// <param name="jsonData">Graph data in JSON format</param>
        /// <param name="zoomToken">If non-empty, a token which can be used to receive a zoomed in graph</param>
        public StatisticsGraphData(string jsonData = default, string zoomToken = default)
        {
            this.JsonData = jsonData;
            this.ZoomToken = zoomToken;
        }
    }

    public partial class StatisticsGraphAsync
    {
        /// <summary>
        /// The graph data to be asynchronously loaded through getStatisticsGraph
        /// </summary>
        public StatisticsGraphAsync() { }
        /// <summary>
        /// The graph data to be asynchronously loaded through getStatisticsGraph
        /// </summary>
        /// <param name="token">The token to use for data loading</param>
        public StatisticsGraphAsync(string token = default)
        {
            this.Token = token;
        }
    }

    public partial class StatisticsGraphError
    {
        /// <summary>
        /// An error message to be shown to the user instead of the graph
        /// </summary>
        public StatisticsGraphError() { }
        /// <summary>
        /// An error message to be shown to the user instead of the graph
        /// </summary>
        /// <param name="errorMessage">The error message</param>
        public StatisticsGraphError(string errorMessage = default)
        {
            this.ErrorMessage = errorMessage;
        }
    }

    public partial class ChatStatisticsMessageInteractionInfo
    {
        /// <summary>
        /// Contains statistics about interactions with a message
        /// </summary>
        public ChatStatisticsMessageInteractionInfo() { }
        /// <summary>
        /// Contains statistics about interactions with a message
        /// </summary>
        /// <param name="messageId">Message identifier</param>
        /// <param name="viewCount">Number of times the message was viewed</param>
        /// <param name="forwardCount">Number of times the message was forwarded</param>
        public ChatStatisticsMessageInteractionInfo(long messageId = default, int viewCount = default, int forwardCount = default)
        {
            this.MessageId = messageId;
            this.ViewCount = viewCount;
            this.ForwardCount = forwardCount;
        }
    }

    public partial class ChatStatisticsMessageSenderInfo
    {
        /// <summary>
        /// Contains statistics about messages sent by a user
        /// </summary>
        public ChatStatisticsMessageSenderInfo() { }
        /// <summary>
        /// Contains statistics about messages sent by a user
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="sentMessageCount">Number of sent messages</param>
        /// <param name="averageCharacterCount">Average number of characters in sent messages</param>
        public ChatStatisticsMessageSenderInfo(int userId = default, int sentMessageCount = default, int averageCharacterCount = default)
        {
            this.UserId = userId;
            this.SentMessageCount = sentMessageCount;
            this.AverageCharacterCount = averageCharacterCount;
        }
    }

    public partial class ChatStatisticsAdministratorActionsInfo
    {
        /// <summary>
        /// Contains statistics about administrator actions done by a user
        /// </summary>
        public ChatStatisticsAdministratorActionsInfo() { }
        /// <summary>
        /// Contains statistics about administrator actions done by a user
        /// </summary>
        /// <param name="userId">Administrator user identifier</param>
        /// <param name="deletedMessageCount">Number of messages deleted by the administrator</param>
        /// <param name="bannedUserCount">Number of users banned by the administrator</param>
        /// <param name="restrictedUserCount">Number of users restricted by the administrator</param>
        public ChatStatisticsAdministratorActionsInfo(int userId = default, int deletedMessageCount = default, int bannedUserCount = default, int restrictedUserCount = default)
        {
            this.UserId = userId;
            this.DeletedMessageCount = deletedMessageCount;
            this.BannedUserCount = bannedUserCount;
            this.RestrictedUserCount = restrictedUserCount;
        }
    }

    public partial class ChatStatisticsInviterInfo
    {
        /// <summary>
        /// Contains statistics about number of new members invited by a user
        /// </summary>
        public ChatStatisticsInviterInfo() { }
        /// <summary>
        /// Contains statistics about number of new members invited by a user
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="addedMemberCount">Number of new members invited by the user</param>
        public ChatStatisticsInviterInfo(int userId = default, int addedMemberCount = default)
        {
            this.UserId = userId;
            this.AddedMemberCount = addedMemberCount;
        }
    }

    public partial class ChatStatisticsSupergroup
    {
        /// <summary>
        /// A detailed statistics about a supergroup chat
        /// </summary>
        public ChatStatisticsSupergroup() { }
        /// <summary>
        /// A detailed statistics about a supergroup chat
        /// </summary>
        /// <param name="period">A period to which the statistics applies</param>
        /// <param name="memberCount">Number of members in the chat</param>
        /// <param name="messageCount">Number of messages sent to the chat</param>
        /// <param name="viewerCount">Number of users who viewed messages in the chat</param>
        /// <param name="senderCount">Number of users who sent messages to the chat</param>
        /// <param name="memberCountGraph">A graph containing number of members in the chat</param>
        /// <param name="joinGraph">A graph containing number of members joined and left the chat</param>
        /// <param name="joinBySourceGraph">A graph containing number of new member joins per source</param>
        /// <param name="languageGraph">A graph containing distribution of active users per language</param>
        /// <param name="messageContentGraph">A graph containing distribution of sent messages by content type</param>
        /// <param name="actionGraph">A graph containing number of different actions in the chat</param>
        /// <param name="dayGraph">A graph containing distribution of message views per hour</param>
        /// <param name="weekGraph">A graph containing distribution of message views per day of week</param>
        /// <param name="topSenders">List of users sent most messages in the last week</param>
        /// <param name="topAdministrators">List of most active administrators in the last week</param>
        /// <param name="topInviters">List of most active inviters of new members in the last week</param>
        public ChatStatisticsSupergroup(DateRange period = default, StatisticsValue memberCount = default, StatisticsValue messageCount = default, StatisticsValue viewerCount = default, StatisticsValue senderCount = default, StatisticsGraph memberCountGraph = default, StatisticsGraph joinGraph = default, StatisticsGraph joinBySourceGraph = default, StatisticsGraph languageGraph = default, StatisticsGraph messageContentGraph = default, StatisticsGraph actionGraph = default, StatisticsGraph dayGraph = default, StatisticsGraph weekGraph = default, ChatStatisticsMessageSenderInfo[] topSenders = default, ChatStatisticsAdministratorActionsInfo[] topAdministrators = default, ChatStatisticsInviterInfo[] topInviters = default)
        {
            this.Period = period;
            this.MemberCount = memberCount;
            this.MessageCount = messageCount;
            this.ViewerCount = viewerCount;
            this.SenderCount = senderCount;
            this.MemberCountGraph = memberCountGraph;
            this.JoinGraph = joinGraph;
            this.JoinBySourceGraph = joinBySourceGraph;
            this.LanguageGraph = languageGraph;
            this.MessageContentGraph = messageContentGraph;
            this.ActionGraph = actionGraph;
            this.DayGraph = dayGraph;
            this.WeekGraph = weekGraph;
            this.TopSenders = topSenders;
            this.TopAdministrators = topAdministrators;
            this.TopInviters = topInviters;
        }
    }

    public partial class ChatStatisticsChannel
    {
        /// <summary>
        /// A detailed statistics about a channel chat
        /// </summary>
        public ChatStatisticsChannel() { }
        /// <summary>
        /// A detailed statistics about a channel chat
        /// </summary>
        /// <param name="period">A period to which the statistics applies</param>
        /// <param name="memberCount">Number of members in the chat</param>
        /// <param name="meanViewCount">Mean number of times the recently sent messages was viewed</param>
        /// <param name="meanShareCount">Mean number of times the recently sent messages was shared</param>
        /// <param name="enabledNotificationsPercentage">A percentage of users with enabled notifications for the chat</param>
        /// <param name="memberCountGraph">A graph containing number of members in the chat</param>
        /// <param name="joinGraph">A graph containing number of members joined and left the chat</param>
        /// <param name="muteGraph">A graph containing number of members muted and unmuted the chat</param>
        /// <param name="viewCountByHourGraph">A graph containing number of message views in a given hour in the last two weeks</param>
        /// <param name="viewCountBySourceGraph">A graph containing number of message views per source</param>
        /// <param name="joinBySourceGraph">A graph containing number of new member joins per source</param>
        /// <param name="languageGraph">A graph containing number of users viewed chat messages per language</param>
        /// <param name="messageInteractionGraph">A graph containing number of chat message views and shares</param>
        /// <param name="instantViewInteractionGraph">A graph containing number of views of associated with the chat instant views</param>
        /// <param name="recentMessageInteractions">Detailed statistics about number of views and shares of recently sent messages</param>
        public ChatStatisticsChannel(DateRange period = default, StatisticsValue memberCount = default, StatisticsValue meanViewCount = default, StatisticsValue meanShareCount = default, double enabledNotificationsPercentage = default, StatisticsGraph memberCountGraph = default, StatisticsGraph joinGraph = default, StatisticsGraph muteGraph = default, StatisticsGraph viewCountByHourGraph = default, StatisticsGraph viewCountBySourceGraph = default, StatisticsGraph joinBySourceGraph = default, StatisticsGraph languageGraph = default, StatisticsGraph messageInteractionGraph = default, StatisticsGraph instantViewInteractionGraph = default, ChatStatisticsMessageInteractionInfo[] recentMessageInteractions = default)
        {
            this.Period = period;
            this.MemberCount = memberCount;
            this.MeanViewCount = meanViewCount;
            this.MeanShareCount = meanShareCount;
            this.EnabledNotificationsPercentage = enabledNotificationsPercentage;
            this.MemberCountGraph = memberCountGraph;
            this.JoinGraph = joinGraph;
            this.MuteGraph = muteGraph;
            this.ViewCountByHourGraph = viewCountByHourGraph;
            this.ViewCountBySourceGraph = viewCountBySourceGraph;
            this.JoinBySourceGraph = joinBySourceGraph;
            this.LanguageGraph = languageGraph;
            this.MessageInteractionGraph = messageInteractionGraph;
            this.InstantViewInteractionGraph = instantViewInteractionGraph;
            this.RecentMessageInteractions = recentMessageInteractions;
        }
    }

    public partial class MessageStatistics
    {
        /// <summary>
        /// A detailed statistics about a message
        /// </summary>
        public MessageStatistics() { }
        /// <summary>
        /// A detailed statistics about a message
        /// </summary>
        /// <param name="messageInteractionGraph">A graph containing number of message views and shares</param>
        public MessageStatistics(StatisticsGraph messageInteractionGraph = default)
        {
            this.MessageInteractionGraph = messageInteractionGraph;
        }
    }

    public partial class UpdateAuthorizationState
    {
        /// <summary>
        /// The user authorization state has changed
        /// </summary>
        public UpdateAuthorizationState() { }
        /// <summary>
        /// The user authorization state has changed
        /// </summary>
        /// <param name="authorizationState">New authorization state</param>
        public UpdateAuthorizationState(AuthorizationState authorizationState = default)
        {
            this.AuthorizationState = authorizationState;
        }
    }

    public partial class UpdateNewMessage
    {
        /// <summary>
        /// A new message was received; can also be an outgoing message
        /// </summary>
        public UpdateNewMessage() { }
        /// <summary>
        /// A new message was received; can also be an outgoing message
        /// </summary>
        /// <param name="message">The new message</param>
        public UpdateNewMessage(Message message = default)
        {
            this.Message = message;
        }
    }

    public partial class UpdateMessageSendAcknowledged
    {
        /// <summary>
        /// A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully or even that the send message request will be processed. This update will be sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message
        /// </summary>
        public UpdateMessageSendAcknowledged() { }
        /// <summary>
        /// A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully or even that the send message request will be processed. This update will be sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message
        /// </summary>
        /// <param name="chatId">The chat identifier of the sent message</param>
        /// <param name="messageId">A temporary message identifier</param>
        public UpdateMessageSendAcknowledged(long chatId = default, long messageId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
        }
    }

    public partial class UpdateMessageSendSucceeded
    {
        /// <summary>
        /// A message has been successfully sent
        /// </summary>
        public UpdateMessageSendSucceeded() { }
        /// <summary>
        /// A message has been successfully sent
        /// </summary>
        /// <param name="message">Information about the sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change</param>
        /// <param name="oldMessageId">The previous temporary message identifier</param>
        public UpdateMessageSendSucceeded(Message message = default, long oldMessageId = default)
        {
            this.Message = message;
            this.OldMessageId = oldMessageId;
        }
    }

    public partial class UpdateMessageSendFailed
    {
        /// <summary>
        /// A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update
        /// </summary>
        public UpdateMessageSendFailed() { }
        /// <summary>
        /// A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update
        /// </summary>
        /// <param name="message">Contains information about the message which failed to send</param>
        /// <param name="oldMessageId">The previous temporary message identifier</param>
        /// <param name="errorCode">An error code</param>
        /// <param name="errorMessage">Error message</param>
        public UpdateMessageSendFailed(Message message = default, long oldMessageId = default, int errorCode = default, string errorMessage = default)
        {
            this.Message = message;
            this.OldMessageId = oldMessageId;
            this.ErrorCode = errorCode;
            this.ErrorMessage = errorMessage;
        }
    }

    public partial class UpdateMessageContent
    {
        /// <summary>
        /// The message content has changed
        /// </summary>
        public UpdateMessageContent() { }
        /// <summary>
        /// The message content has changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="newContent">New message content</param>
        public UpdateMessageContent(long chatId = default, long messageId = default, MessageContent newContent = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.NewContent = newContent;
        }
    }

    public partial class UpdateMessageEdited
    {
        /// <summary>
        /// A message was edited. Changes in the message content will come in a separate updateMessageContent
        /// </summary>
        public UpdateMessageEdited() { }
        /// <summary>
        /// A message was edited. Changes in the message content will come in a separate updateMessageContent
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="editDate">Point in time (Unix timestamp) when the message was edited</param>
        /// <param name="replyMarkup">New message reply markup; may be null</param>
        public UpdateMessageEdited(long chatId = default, long messageId = default, int editDate = default, ReplyMarkup replyMarkup = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.EditDate = editDate;
            this.ReplyMarkup = replyMarkup;
        }
    }

    public partial class UpdateMessageInteractionInfo
    {
        /// <summary>
        /// The information about interactions with a message has changed
        /// </summary>
        public UpdateMessageInteractionInfo() { }
        /// <summary>
        /// The information about interactions with a message has changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="interactionInfo">New information about interactions with the message; may be null</param>
        public UpdateMessageInteractionInfo(long chatId = default, long messageId = default, MessageInteractionInfo interactionInfo = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.InteractionInfo = interactionInfo;
        }
    }

    public partial class UpdateMessageContentOpened
    {
        /// <summary>
        /// The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the TTL timer for self-destructing messages
        /// </summary>
        public UpdateMessageContentOpened() { }
        /// <summary>
        /// The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the TTL timer for self-destructing messages
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Message identifier</param>
        public UpdateMessageContentOpened(long chatId = default, long messageId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
        }
    }

    public partial class UpdateMessageMentionRead
    {
        /// <summary>
        /// A message with an unread mention was read
        /// </summary>
        public UpdateMessageMentionRead() { }
        /// <summary>
        /// A message with an unread mention was read
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="unreadMentionCount">The new number of unread mention messages left in the chat</param>
        public UpdateMessageMentionRead(long chatId = default, long messageId = default, int unreadMentionCount = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.UnreadMentionCount = unreadMentionCount;
        }
    }

    public partial class UpdateMessageLiveLocationViewed
    {
        /// <summary>
        /// A message with a live location was viewed. When the update is received, the application is supposed to update the live location
        /// </summary>
        public UpdateMessageLiveLocationViewed() { }
        /// <summary>
        /// A message with a live location was viewed. When the update is received, the application is supposed to update the live location
        /// </summary>
        /// <param name="chatId">Identifier of the chat with the live location message</param>
        /// <param name="messageId">Identifier of the message with live location</param>
        public UpdateMessageLiveLocationViewed(long chatId = default, long messageId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
        }
    }

    public partial class UpdateNewChat
    {
        /// <summary>
        /// A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates
        /// </summary>
        public UpdateNewChat() { }
        /// <summary>
        /// A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates
        /// </summary>
        /// <param name="chat">The chat</param>
        public UpdateNewChat(Chat chat = default)
        {
            this.Chat = chat;
        }
    }

    public partial class UpdateChatTitle
    {
        /// <summary>
        /// The title of a chat was changed
        /// </summary>
        public UpdateChatTitle() { }
        /// <summary>
        /// The title of a chat was changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="title">The new chat title</param>
        public UpdateChatTitle(long chatId = default, string title = default)
        {
            this.ChatId = chatId;
            this.Title = title;
        }
    }

    public partial class UpdateChatPhoto
    {
        /// <summary>
        /// A chat photo was changed
        /// </summary>
        public UpdateChatPhoto() { }
        /// <summary>
        /// A chat photo was changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="photo">The new chat photo; may be null</param>
        public UpdateChatPhoto(long chatId = default, ChatPhotoInfo photo = default)
        {
            this.ChatId = chatId;
            this.Photo = photo;
        }
    }

    public partial class UpdateChatPermissions
    {
        /// <summary>
        /// Chat permissions was changed
        /// </summary>
        public UpdateChatPermissions() { }
        /// <summary>
        /// Chat permissions was changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="permissions">The new chat permissions</param>
        public UpdateChatPermissions(long chatId = default, ChatPermissions permissions = default)
        {
            this.ChatId = chatId;
            this.Permissions = permissions;
        }
    }

    public partial class UpdateChatLastMessage
    {
        /// <summary>
        /// The last message of a chat was changed. If last_message is null, then the last message in the chat became unknown. Some new unknown messages might be added to the chat in this case
        /// </summary>
        public UpdateChatLastMessage() { }
        /// <summary>
        /// The last message of a chat was changed. If last_message is null, then the last message in the chat became unknown. Some new unknown messages might be added to the chat in this case
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="lastMessage">The new last message in the chat; may be null</param>
        /// <param name="positions">The new chat positions in the chat lists</param>
        public UpdateChatLastMessage(long chatId = default, Message lastMessage = default, ChatPosition[] positions = default)
        {
            this.ChatId = chatId;
            this.LastMessage = lastMessage;
            this.Positions = positions;
        }
    }

    public partial class UpdateChatPosition
    {
        /// <summary>
        /// The position of a chat in a chat list has changed. Instead of this update updateChatLastMessage or updateChatDraftMessage might be sent
        /// </summary>
        public UpdateChatPosition() { }
        /// <summary>
        /// The position of a chat in a chat list has changed. Instead of this update updateChatLastMessage or updateChatDraftMessage might be sent
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="position">New chat position. If new order is 0, then the chat needs to be removed from the list</param>
        public UpdateChatPosition(long chatId = default, ChatPosition position = default)
        {
            this.ChatId = chatId;
            this.Position = position;
        }
    }

    public partial class UpdateChatIsMarkedAsUnread
    {
        /// <summary>
        /// A chat was marked as unread or was read
        /// </summary>
        public UpdateChatIsMarkedAsUnread() { }
        /// <summary>
        /// A chat was marked as unread or was read
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="isMarkedAsUnread">New value of is_marked_as_unread</param>
        public UpdateChatIsMarkedAsUnread(long chatId = default, bool isMarkedAsUnread = default)
        {
            this.ChatId = chatId;
            this.IsMarkedAsUnread = isMarkedAsUnread;
        }
    }

    public partial class UpdateChatIsBlocked
    {
        /// <summary>
        /// A chat was blocked or unblocked
        /// </summary>
        public UpdateChatIsBlocked() { }
        /// <summary>
        /// A chat was blocked or unblocked
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="isBlocked">New value of is_blocked</param>
        public UpdateChatIsBlocked(long chatId = default, bool isBlocked = default)
        {
            this.ChatId = chatId;
            this.IsBlocked = isBlocked;
        }
    }

    public partial class UpdateChatHasScheduledMessages
    {
        /// <summary>
        /// A chat's has_scheduled_messages field has changed
        /// </summary>
        public UpdateChatHasScheduledMessages() { }
        /// <summary>
        /// A chat's has_scheduled_messages field has changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="hasScheduledMessages">New value of has_scheduled_messages</param>
        public UpdateChatHasScheduledMessages(long chatId = default, bool hasScheduledMessages = default)
        {
            this.ChatId = chatId;
            this.HasScheduledMessages = hasScheduledMessages;
        }
    }

    public partial class UpdateChatDefaultDisableNotification
    {
        /// <summary>
        /// The value of the default disable_notification parameter, used when a message is sent to the chat, was changed
        /// </summary>
        public UpdateChatDefaultDisableNotification() { }
        /// <summary>
        /// The value of the default disable_notification parameter, used when a message is sent to the chat, was changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="defaultDisableNotification">The new default_disable_notification value</param>
        public UpdateChatDefaultDisableNotification(long chatId = default, bool defaultDisableNotification = default)
        {
            this.ChatId = chatId;
            this.DefaultDisableNotification = defaultDisableNotification;
        }
    }

    public partial class UpdateChatReadInbox
    {
        /// <summary>
        /// Incoming messages were read or number of unread messages has been changed
        /// </summary>
        public UpdateChatReadInbox() { }
        /// <summary>
        /// Incoming messages were read or number of unread messages has been changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="lastReadInboxMessageId">Identifier of the last read incoming message</param>
        /// <param name="unreadCount">The number of unread messages left in the chat</param>
        public UpdateChatReadInbox(long chatId = default, long lastReadInboxMessageId = default, int unreadCount = default)
        {
            this.ChatId = chatId;
            this.LastReadInboxMessageId = lastReadInboxMessageId;
            this.UnreadCount = unreadCount;
        }
    }

    public partial class UpdateChatReadOutbox
    {
        /// <summary>
        /// Outgoing messages were read
        /// </summary>
        public UpdateChatReadOutbox() { }
        /// <summary>
        /// Outgoing messages were read
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="lastReadOutboxMessageId">Identifier of last read outgoing message</param>
        public UpdateChatReadOutbox(long chatId = default, long lastReadOutboxMessageId = default)
        {
            this.ChatId = chatId;
            this.LastReadOutboxMessageId = lastReadOutboxMessageId;
        }
    }

    public partial class UpdateChatUnreadMentionCount
    {
        /// <summary>
        /// The chat unread_mention_count has changed
        /// </summary>
        public UpdateChatUnreadMentionCount() { }
        /// <summary>
        /// The chat unread_mention_count has changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="unreadMentionCount">The number of unread mention messages left in the chat</param>
        public UpdateChatUnreadMentionCount(long chatId = default, int unreadMentionCount = default)
        {
            this.ChatId = chatId;
            this.UnreadMentionCount = unreadMentionCount;
        }
    }

    public partial class UpdateChatNotificationSettings
    {
        /// <summary>
        /// Notification settings for a chat were changed
        /// </summary>
        public UpdateChatNotificationSettings() { }
        /// <summary>
        /// Notification settings for a chat were changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="notificationSettings">The new notification settings</param>
        public UpdateChatNotificationSettings(long chatId = default, ChatNotificationSettings notificationSettings = default)
        {
            this.ChatId = chatId;
            this.NotificationSettings = notificationSettings;
        }
    }

    public partial class UpdateScopeNotificationSettings
    {
        /// <summary>
        /// Notification settings for some type of chats were updated
        /// </summary>
        public UpdateScopeNotificationSettings() { }
        /// <summary>
        /// Notification settings for some type of chats were updated
        /// </summary>
        /// <param name="scope">Types of chats for which notification settings were updated</param>
        /// <param name="notificationSettings">The new notification settings</param>
        public UpdateScopeNotificationSettings(NotificationSettingsScope scope = default, ScopeNotificationSettings notificationSettings = default)
        {
            this.Scope = scope;
            this.NotificationSettings = notificationSettings;
        }
    }

    public partial class UpdateChatActionBar
    {
        /// <summary>
        /// The chat action bar was changed
        /// </summary>
        public UpdateChatActionBar() { }
        /// <summary>
        /// The chat action bar was changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="actionBar">The new value of the action bar; may be null</param>
        public UpdateChatActionBar(long chatId = default, ChatActionBar actionBar = default)
        {
            this.ChatId = chatId;
            this.ActionBar = actionBar;
        }
    }

    public partial class UpdateChatPinnedMessage
    {
        /// <summary>
        /// The chat pinned message was changed
        /// </summary>
        public UpdateChatPinnedMessage() { }
        /// <summary>
        /// The chat pinned message was changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="pinnedMessageId">The new identifier of the pinned message; 0 if there is no pinned message in the chat</param>
        public UpdateChatPinnedMessage(long chatId = default, long pinnedMessageId = default)
        {
            this.ChatId = chatId;
            this.PinnedMessageId = pinnedMessageId;
        }
    }

    public partial class UpdateChatReplyMarkup
    {
        /// <summary>
        /// The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user
        /// </summary>
        public UpdateChatReplyMarkup() { }
        /// <summary>
        /// The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="replyMarkupMessageId">Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat</param>
        public UpdateChatReplyMarkup(long chatId = default, long replyMarkupMessageId = default)
        {
            this.ChatId = chatId;
            this.ReplyMarkupMessageId = replyMarkupMessageId;
        }
    }

    public partial class UpdateChatDraftMessage
    {
        /// <summary>
        /// A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update shouldn't be applied
        /// </summary>
        public UpdateChatDraftMessage() { }
        /// <summary>
        /// A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update shouldn't be applied
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="draftMessage">The new draft message; may be null</param>
        /// <param name="positions">The new chat positions in the chat lists</param>
        public UpdateChatDraftMessage(long chatId = default, DraftMessage draftMessage = default, ChatPosition[] positions = default)
        {
            this.ChatId = chatId;
            this.DraftMessage = draftMessage;
            this.Positions = positions;
        }
    }

    public partial class UpdateChatFilters
    {
        /// <summary>
        /// The list of chat filters or a chat filter has changed
        /// </summary>
        public UpdateChatFilters() { }
        /// <summary>
        /// The list of chat filters or a chat filter has changed
        /// </summary>
        /// <param name="chatFilters">The new list of chat filters</param>
        public UpdateChatFilters(ChatFilterInfo[] chatFilters = default)
        {
            this.ChatFilters = chatFilters;
        }
    }

    public partial class UpdateChatOnlineMemberCount
    {
        /// <summary>
        /// The number of online group members has changed. This update with non-zero count is sent only for currently opened chats. There is no guarantee that it will be sent just after the count has changed
        /// </summary>
        public UpdateChatOnlineMemberCount() { }
        /// <summary>
        /// The number of online group members has changed. This update with non-zero count is sent only for currently opened chats. There is no guarantee that it will be sent just after the count has changed
        /// </summary>
        /// <param name="chatId">Identifier of the chat</param>
        /// <param name="onlineMemberCount">New number of online members in the chat, or 0 if unknown</param>
        public UpdateChatOnlineMemberCount(long chatId = default, int onlineMemberCount = default)
        {
            this.ChatId = chatId;
            this.OnlineMemberCount = onlineMemberCount;
        }
    }

    public partial class UpdateNotification
    {
        /// <summary>
        /// A notification was changed
        /// </summary>
        public UpdateNotification() { }
        /// <summary>
        /// A notification was changed
        /// </summary>
        /// <param name="notificationGroupId">Unique notification group identifier</param>
        /// <param name="notification">Changed notification</param>
        public UpdateNotification(int notificationGroupId = default, Notification notification = default)
        {
            this.NotificationGroupId = notificationGroupId;
            this.Notification = notification;
        }
    }

    public partial class UpdateNotificationGroup
    {
        /// <summary>
        /// A list of active notifications in a notification group has changed
        /// </summary>
        public UpdateNotificationGroup() { }
        /// <summary>
        /// A list of active notifications in a notification group has changed
        /// </summary>
        /// <param name="notificationGroupId">Unique notification group identifier</param>
        /// <param name="type">New type of the notification group</param>
        /// <param name="chatId">Identifier of a chat to which all notifications in the group belong</param>
        /// <param name="notificationSettingsChatId">Chat identifier, which notification settings must be applied to the added notifications</param>
        /// <param name="isSilent">True, if the notifications should be shown without sound</param>
        /// <param name="totalCount">Total number of unread notifications in the group, can be bigger than number of active notifications</param>
        /// <param name="addedNotifications">List of added group notifications, sorted by notification ID</param>
        /// <param name="removedNotificationIds">Identifiers of removed group notifications, sorted by notification ID</param>
        public UpdateNotificationGroup(int notificationGroupId = default, NotificationGroupType type = default, long chatId = default, long notificationSettingsChatId = default, bool isSilent = default, int totalCount = default, Notification[] addedNotifications = default, int[] removedNotificationIds = default)
        {
            this.NotificationGroupId = notificationGroupId;
            this.Type = type;
            this.ChatId = chatId;
            this.NotificationSettingsChatId = notificationSettingsChatId;
            this.IsSilent = isSilent;
            this.TotalCount = totalCount;
            this.AddedNotifications = addedNotifications;
            this.RemovedNotificationIds = removedNotificationIds;
        }
    }

    public partial class UpdateActiveNotifications
    {
        /// <summary>
        /// Contains active notifications that was shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update
        /// </summary>
        public UpdateActiveNotifications() { }
        /// <summary>
        /// Contains active notifications that was shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update
        /// </summary>
        /// <param name="groups">Lists of active notification groups</param>
        public UpdateActiveNotifications(NotificationGroup[] groups = default)
        {
            this.Groups = groups;
        }
    }

    public partial class UpdateHavePendingNotifications
    {
        /// <summary>
        /// Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications
        /// </summary>
        public UpdateHavePendingNotifications() { }
        /// <summary>
        /// Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications
        /// </summary>
        /// <param name="haveDelayedNotifications">True, if there are some delayed notification updates, which will be sent soon</param>
        /// <param name="haveUnreceivedNotifications">True, if there can be some yet unreceived notifications, which are being fetched from the server</param>
        public UpdateHavePendingNotifications(bool haveDelayedNotifications = default, bool haveUnreceivedNotifications = default)
        {
            this.HaveDelayedNotifications = haveDelayedNotifications;
            this.HaveUnreceivedNotifications = haveUnreceivedNotifications;
        }
    }

    public partial class UpdateDeleteMessages
    {
        /// <summary>
        /// Some messages were deleted
        /// </summary>
        public UpdateDeleteMessages() { }
        /// <summary>
        /// Some messages were deleted
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageIds">Identifiers of the deleted messages</param>
        /// <param name="isPermanent">True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)</param>
        /// <param name="fromCache">True, if the messages are deleted only from the cache and can possibly be retrieved again in the future</param>
        public UpdateDeleteMessages(long chatId = default, long[] messageIds = default, bool isPermanent = default, bool fromCache = default)
        {
            this.ChatId = chatId;
            this.MessageIds = messageIds;
            this.IsPermanent = isPermanent;
            this.FromCache = fromCache;
        }
    }

    public partial class UpdateUserChatAction
    {
        /// <summary>
        /// User activity in the chat has changed
        /// </summary>
        public UpdateUserChatAction() { }
        /// <summary>
        /// User activity in the chat has changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the action was performed</param>
        /// <param name="userId">Identifier of a user performing an action</param>
        /// <param name="action">The action description</param>
        public UpdateUserChatAction(long chatId = default, long messageThreadId = default, int userId = default, ChatAction action = default)
        {
            this.ChatId = chatId;
            this.MessageThreadId = messageThreadId;
            this.UserId = userId;
            this.Action = action;
        }
    }

    public partial class UpdateUserStatus
    {
        /// <summary>
        /// The user went online or offline
        /// </summary>
        public UpdateUserStatus() { }
        /// <summary>
        /// The user went online or offline
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="status">New status of the user</param>
        public UpdateUserStatus(int userId = default, UserStatus status = default)
        {
            this.UserId = userId;
            this.Status = status;
        }
    }

    public partial class UpdateUser
    {
        /// <summary>
        /// Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application
        /// </summary>
        public UpdateUser() { }
        /// <summary>
        /// Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application
        /// </summary>
        /// <param name="user">New data about the user</param>
        public UpdateUser(User user = default)
        {
            this.User = user;
        }
    }

    public partial class UpdateBasicGroup
    {
        /// <summary>
        /// Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application
        /// </summary>
        public UpdateBasicGroup() { }
        /// <summary>
        /// Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application
        /// </summary>
        /// <param name="basicGroup">New data about the group</param>
        public UpdateBasicGroup(BasicGroup basicGroup = default)
        {
            this.BasicGroup = basicGroup;
        }
    }

    public partial class UpdateSupergroup
    {
        /// <summary>
        /// Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application
        /// </summary>
        public UpdateSupergroup() { }
        /// <summary>
        /// Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application
        /// </summary>
        /// <param name="supergroup">New data about the supergroup</param>
        public UpdateSupergroup(Supergroup supergroup = default)
        {
            this.Supergroup = supergroup;
        }
    }

    public partial class UpdateSecretChat
    {
        /// <summary>
        /// Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application
        /// </summary>
        public UpdateSecretChat() { }
        /// <summary>
        /// Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application
        /// </summary>
        /// <param name="secretChat">New data about the secret chat</param>
        public UpdateSecretChat(SecretChat secretChat = default)
        {
            this.SecretChat = secretChat;
        }
    }

    public partial class UpdateUserFullInfo
    {
        /// <summary>
        /// Some data from userFullInfo has been changed
        /// </summary>
        public UpdateUserFullInfo() { }
        /// <summary>
        /// Some data from userFullInfo has been changed
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="userFullInfo">New full information about the user</param>
        public UpdateUserFullInfo(int userId = default, UserFullInfo userFullInfo = default)
        {
            this.UserId = userId;
            this.UserFullInfo = userFullInfo;
        }
    }

    public partial class UpdateBasicGroupFullInfo
    {
        /// <summary>
        /// Some data from basicGroupFullInfo has been changed
        /// </summary>
        public UpdateBasicGroupFullInfo() { }
        /// <summary>
        /// Some data from basicGroupFullInfo has been changed
        /// </summary>
        /// <param name="basicGroupId">Identifier of a basic group</param>
        /// <param name="basicGroupFullInfo">New full information about the group</param>
        public UpdateBasicGroupFullInfo(int basicGroupId = default, BasicGroupFullInfo basicGroupFullInfo = default)
        {
            this.BasicGroupId = basicGroupId;
            this.BasicGroupFullInfo = basicGroupFullInfo;
        }
    }

    public partial class UpdateSupergroupFullInfo
    {
        /// <summary>
        /// Some data from supergroupFullInfo has been changed
        /// </summary>
        public UpdateSupergroupFullInfo() { }
        /// <summary>
        /// Some data from supergroupFullInfo has been changed
        /// </summary>
        /// <param name="supergroupId">Identifier of the supergroup or channel</param>
        /// <param name="supergroupFullInfo">New full information about the supergroup</param>
        public UpdateSupergroupFullInfo(int supergroupId = default, SupergroupFullInfo supergroupFullInfo = default)
        {
            this.SupergroupId = supergroupId;
            this.SupergroupFullInfo = supergroupFullInfo;
        }
    }

    public partial class UpdateServiceNotification
    {
        /// <summary>
        /// Service notification from the server. Upon receiving this the application must show a popup with the content of the notification
        /// </summary>
        public UpdateServiceNotification() { }
        /// <summary>
        /// Service notification from the server. Upon receiving this the application must show a popup with the content of the notification
        /// </summary>
        /// <param name="type">Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" should be shown under notification; if user presses the second, all local data should be destroyed using Destroy method</param>
        /// <param name="content">Notification content</param>
        public UpdateServiceNotification(string type = default, MessageContent content = default)
        {
            this.Type = type;
            this.Content = content;
        }
    }

    public partial class UpdateFile
    {
        /// <summary>
        /// Information about a file was updated
        /// </summary>
        public UpdateFile() { }
        /// <summary>
        /// Information about a file was updated
        /// </summary>
        /// <param name="file">New data about the file</param>
        public UpdateFile(File file = default)
        {
            this.File = file;
        }
    }

    public partial class UpdateFileGenerationStart
    {
        /// <summary>
        /// The file generation process needs to be started by the application
        /// </summary>
        public UpdateFileGenerationStart() { }
        /// <summary>
        /// The file generation process needs to be started by the application
        /// </summary>
        /// <param name="generationId">Unique identifier for the generation process</param>
        /// <param name="originalPath">The path to a file from which a new file is generated; may be empty</param>
        /// <param name="destinationPath">The path to a file that should be created and where the new file should be generated</param>
        /// <param name="conversion">String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which should be downloaded by the application</param>
        public UpdateFileGenerationStart(long generationId = default, string originalPath = default, string destinationPath = default, string conversion = default)
        {
            this.GenerationId = generationId;
            this.OriginalPath = originalPath;
            this.DestinationPath = destinationPath;
            this.Conversion = conversion;
        }
    }

    public partial class UpdateFileGenerationStop
    {
        /// <summary>
        /// File generation is no longer needed
        /// </summary>
        public UpdateFileGenerationStop() { }
        /// <summary>
        /// File generation is no longer needed
        /// </summary>
        /// <param name="generationId">Unique identifier for the generation process</param>
        public UpdateFileGenerationStop(long generationId = default)
        {
            this.GenerationId = generationId;
        }
    }

    public partial class UpdateCall
    {
        /// <summary>
        /// New call was created or information about a call was updated
        /// </summary>
        public UpdateCall() { }
        /// <summary>
        /// New call was created or information about a call was updated
        /// </summary>
        /// <param name="call">New data about a call</param>
        public UpdateCall(Call call = default)
        {
            this.Call = call;
        }
    }

    public partial class UpdateNewCallSignalingData
    {
        /// <summary>
        /// New call signaling data arrived
        /// </summary>
        public UpdateNewCallSignalingData() { }
        /// <summary>
        /// New call signaling data arrived
        /// </summary>
        /// <param name="callId">The call identifier</param>
        /// <param name="data">The data</param>
        public UpdateNewCallSignalingData(int callId = default, Memory<byte> data = default)
        {
            this.CallId = callId;
            this.Data = data;
        }
    }

    public partial class UpdateUserPrivacySettingRules
    {
        /// <summary>
        /// Some privacy setting rules have been changed
        /// </summary>
        public UpdateUserPrivacySettingRules() { }
        /// <summary>
        /// Some privacy setting rules have been changed
        /// </summary>
        /// <param name="setting">The privacy setting</param>
        /// <param name="rules">New privacy rules</param>
        public UpdateUserPrivacySettingRules(UserPrivacySetting setting = default, UserPrivacySettingRules rules = default)
        {
            this.Setting = setting;
            this.Rules = rules;
        }
    }

    public partial class UpdateUnreadMessageCount
    {
        /// <summary>
        /// Number of unread messages in a chat list has changed. This update is sent only if the message database is used
        /// </summary>
        public UpdateUnreadMessageCount() { }
        /// <summary>
        /// Number of unread messages in a chat list has changed. This update is sent only if the message database is used
        /// </summary>
        /// <param name="chatList">The chat list with changed number of unread messages</param>
        /// <param name="unreadCount">Total number of unread messages</param>
        /// <param name="unreadUnmutedCount">Total number of unread messages in unmuted chats</param>
        public UpdateUnreadMessageCount(ChatList chatList = default, int unreadCount = default, int unreadUnmutedCount = default)
        {
            this.ChatList = chatList;
            this.UnreadCount = unreadCount;
            this.UnreadUnmutedCount = unreadUnmutedCount;
        }
    }

    public partial class UpdateUnreadChatCount
    {
        /// <summary>
        /// Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used
        /// </summary>
        public UpdateUnreadChatCount() { }
        /// <summary>
        /// Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used
        /// </summary>
        /// <param name="chatList">The chat list with changed number of unread messages</param>
        /// <param name="totalCount">Approximate total number of chats in the chat list</param>
        /// <param name="unreadCount">Total number of unread chats</param>
        /// <param name="unreadUnmutedCount">Total number of unread unmuted chats</param>
        /// <param name="markedAsUnreadCount">Total number of chats marked as unread</param>
        /// <param name="markedAsUnreadUnmutedCount">Total number of unmuted chats marked as unread</param>
        public UpdateUnreadChatCount(ChatList chatList = default, int totalCount = default, int unreadCount = default, int unreadUnmutedCount = default, int markedAsUnreadCount = default, int markedAsUnreadUnmutedCount = default)
        {
            this.ChatList = chatList;
            this.TotalCount = totalCount;
            this.UnreadCount = unreadCount;
            this.UnreadUnmutedCount = unreadUnmutedCount;
            this.MarkedAsUnreadCount = markedAsUnreadCount;
            this.MarkedAsUnreadUnmutedCount = markedAsUnreadUnmutedCount;
        }
    }

    public partial class UpdateOption
    {
        /// <summary>
        /// An option changed its value
        /// </summary>
        public UpdateOption() { }
        /// <summary>
        /// An option changed its value
        /// </summary>
        /// <param name="name">The option name</param>
        /// <param name="value">The new option value</param>
        public UpdateOption(string name = default, OptionValue value = default)
        {
            this.Name = name;
            this.Value = value;
        }
    }

    public partial class UpdateStickerSet
    {
        /// <summary>
        /// A sticker set has changed
        /// </summary>
        public UpdateStickerSet() { }
        /// <summary>
        /// A sticker set has changed
        /// </summary>
        /// <param name="stickerSet">The sticker set</param>
        public UpdateStickerSet(StickerSet stickerSet = default)
        {
            this.StickerSet = stickerSet;
        }
    }

    public partial class UpdateInstalledStickerSets
    {
        /// <summary>
        /// The list of installed sticker sets was updated
        /// </summary>
        public UpdateInstalledStickerSets() { }
        /// <summary>
        /// The list of installed sticker sets was updated
        /// </summary>
        /// <param name="isMasks">True, if the list of installed mask sticker sets was updated</param>
        /// <param name="stickerSetIds">The new list of installed ordinary sticker sets</param>
        public UpdateInstalledStickerSets(bool isMasks = default, long[] stickerSetIds = default)
        {
            this.IsMasks = isMasks;
            this.StickerSetIds = stickerSetIds;
        }
    }

    public partial class UpdateTrendingStickerSets
    {
        /// <summary>
        /// The list of trending sticker sets was updated or some of them were viewed
        /// </summary>
        public UpdateTrendingStickerSets() { }
        /// <summary>
        /// The list of trending sticker sets was updated or some of them were viewed
        /// </summary>
        /// <param name="stickerSets">The prefix of the list of trending sticker sets with the newest trending sticker sets</param>
        public UpdateTrendingStickerSets(StickerSets stickerSets = default)
        {
            this.StickerSets = stickerSets;
        }
    }

    public partial class UpdateRecentStickers
    {
        /// <summary>
        /// The list of recently used stickers was updated
        /// </summary>
        public UpdateRecentStickers() { }
        /// <summary>
        /// The list of recently used stickers was updated
        /// </summary>
        /// <param name="isAttached">True, if the list of stickers attached to photo or video files was updated, otherwise the list of sent stickers is updated</param>
        /// <param name="stickerIds">The new list of file identifiers of recently used stickers</param>
        public UpdateRecentStickers(bool isAttached = default, int[] stickerIds = default)
        {
            this.IsAttached = isAttached;
            this.StickerIds = stickerIds;
        }
    }

    public partial class UpdateFavoriteStickers
    {
        /// <summary>
        /// The list of favorite stickers was updated
        /// </summary>
        public UpdateFavoriteStickers() { }
        /// <summary>
        /// The list of favorite stickers was updated
        /// </summary>
        /// <param name="stickerIds">The new list of file identifiers of favorite stickers</param>
        public UpdateFavoriteStickers(int[] stickerIds = default)
        {
            this.StickerIds = stickerIds;
        }
    }

    public partial class UpdateSavedAnimations
    {
        /// <summary>
        /// The list of saved animations was updated
        /// </summary>
        public UpdateSavedAnimations() { }
        /// <summary>
        /// The list of saved animations was updated
        /// </summary>
        /// <param name="animationIds">The new list of file identifiers of saved animations</param>
        public UpdateSavedAnimations(int[] animationIds = default)
        {
            this.AnimationIds = animationIds;
        }
    }

    public partial class UpdateSelectedBackground
    {
        /// <summary>
        /// The selected background has changed
        /// </summary>
        public UpdateSelectedBackground() { }
        /// <summary>
        /// The selected background has changed
        /// </summary>
        /// <param name="forDarkTheme">True, if background for dark theme has changed</param>
        /// <param name="background">The new selected background; may be null</param>
        public UpdateSelectedBackground(bool forDarkTheme = default, Background background = default)
        {
            this.ForDarkTheme = forDarkTheme;
            this.Background = background;
        }
    }

    public partial class UpdateLanguagePackStrings
    {
        /// <summary>
        /// Some language pack strings have been updated
        /// </summary>
        public UpdateLanguagePackStrings() { }
        /// <summary>
        /// Some language pack strings have been updated
        /// </summary>
        /// <param name="localizationTarget">Localization target to which the language pack belongs</param>
        /// <param name="languagePackId">Identifier of the updated language pack</param>
        /// <param name="strings">List of changed language pack strings</param>
        public UpdateLanguagePackStrings(string localizationTarget = default, string languagePackId = default, LanguagePackString[] strings = default)
        {
            this.LocalizationTarget = localizationTarget;
            this.LanguagePackId = languagePackId;
            this.Strings = strings;
        }
    }

    public partial class UpdateConnectionState
    {
        /// <summary>
        /// The connection state has changed. This update must be used only to show the user a human-readable description of the connection state
        /// </summary>
        public UpdateConnectionState() { }
        /// <summary>
        /// The connection state has changed. This update must be used only to show the user a human-readable description of the connection state
        /// </summary>
        /// <param name="state">The new connection state</param>
        public UpdateConnectionState(ConnectionState state = default)
        {
            this.State = state;
        }
    }

    public partial class UpdateTermsOfService
    {
        /// <summary>
        /// New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method should be called with the reason "Decline ToS update"
        /// </summary>
        public UpdateTermsOfService() { }
        /// <summary>
        /// New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method should be called with the reason "Decline ToS update"
        /// </summary>
        /// <param name="termsOfServiceId">Identifier of the terms of service</param>
        /// <param name="termsOfService">The new terms of service</param>
        public UpdateTermsOfService(string termsOfServiceId = default, TermsOfService termsOfService = default)
        {
            this.TermsOfServiceId = termsOfServiceId;
            this.TermsOfService = termsOfService;
        }
    }

    public partial class UpdateUsersNearby
    {
        /// <summary>
        /// The list of users nearby has changed. The update is guaranteed to be sent only 60 seconds after a successful searchChatsNearby request
        /// </summary>
        public UpdateUsersNearby() { }
        /// <summary>
        /// The list of users nearby has changed. The update is guaranteed to be sent only 60 seconds after a successful searchChatsNearby request
        /// </summary>
        /// <param name="usersNearby">The new list of users nearby</param>
        public UpdateUsersNearby(ChatNearby[] usersNearby = default)
        {
            this.UsersNearby = usersNearby;
        }
    }

    public partial class UpdateDiceEmojis
    {
        /// <summary>
        /// The list of supported dice emojis has changed
        /// </summary>
        public UpdateDiceEmojis() { }
        /// <summary>
        /// The list of supported dice emojis has changed
        /// </summary>
        /// <param name="emojis">The new list of supported dice emojis</param>
        public UpdateDiceEmojis(string[] emojis = default)
        {
            this.Emojis = emojis;
        }
    }

    public partial class UpdateAnimationSearchParameters
    {
        /// <summary>
        /// The parameters of animation search through GetOption("animation_search_bot_username") bot has changed
        /// </summary>
        public UpdateAnimationSearchParameters() { }
        /// <summary>
        /// The parameters of animation search through GetOption("animation_search_bot_username") bot has changed
        /// </summary>
        /// <param name="provider">Name of the animation search provider</param>
        /// <param name="emojis">The new list of emojis suggested for searching</param>
        public UpdateAnimationSearchParameters(string provider = default, string[] emojis = default)
        {
            this.Provider = provider;
            this.Emojis = emojis;
        }
    }

    public partial class UpdateSuggestedActions
    {
        /// <summary>
        /// The list of suggested to the user actions has changed
        /// </summary>
        public UpdateSuggestedActions() { }
        /// <summary>
        /// The list of suggested to the user actions has changed
        /// </summary>
        /// <param name="addedActions">Added suggested actions</param>
        /// <param name="removedActions">Removed suggested actions</param>
        public UpdateSuggestedActions(SuggestedAction[] addedActions = default, SuggestedAction[] removedActions = default)
        {
            this.AddedActions = addedActions;
            this.RemovedActions = removedActions;
        }
    }

    public partial class UpdateNewInlineQuery
    {
        /// <summary>
        /// A new incoming inline query; for bots only
        /// </summary>
        public UpdateNewInlineQuery() { }
        /// <summary>
        /// A new incoming inline query; for bots only
        /// </summary>
        /// <param name="id">Unique query identifier</param>
        /// <param name="senderUserId">Identifier of the user who sent the query</param>
        /// <param name="userLocation">User location; may be null</param>
        /// <param name="query">Text of the query</param>
        /// <param name="offset">Offset of the first entry to return</param>
        public UpdateNewInlineQuery(long id = default, int senderUserId = default, Location userLocation = default, string query = default, string offset = default)
        {
            this.Id = id;
            this.SenderUserId = senderUserId;
            this.UserLocation = userLocation;
            this.Query = query;
            this.Offset = offset;
        }
    }

    public partial class UpdateNewChosenInlineResult
    {
        /// <summary>
        /// The user has chosen a result of an inline query; for bots only
        /// </summary>
        public UpdateNewChosenInlineResult() { }
        /// <summary>
        /// The user has chosen a result of an inline query; for bots only
        /// </summary>
        /// <param name="senderUserId">Identifier of the user who sent the query</param>
        /// <param name="userLocation">User location; may be null</param>
        /// <param name="query">Text of the query</param>
        /// <param name="resultId">Identifier of the chosen result</param>
        /// <param name="inlineMessageId">Identifier of the sent inline message, if known</param>
        public UpdateNewChosenInlineResult(int senderUserId = default, Location userLocation = default, string query = default, string resultId = default, string inlineMessageId = default)
        {
            this.SenderUserId = senderUserId;
            this.UserLocation = userLocation;
            this.Query = query;
            this.ResultId = resultId;
            this.InlineMessageId = inlineMessageId;
        }
    }

    public partial class UpdateNewCallbackQuery
    {
        /// <summary>
        /// A new incoming callback query; for bots only
        /// </summary>
        public UpdateNewCallbackQuery() { }
        /// <summary>
        /// A new incoming callback query; for bots only
        /// </summary>
        /// <param name="id">Unique query identifier</param>
        /// <param name="senderUserId">Identifier of the user who sent the query</param>
        /// <param name="chatId">Identifier of the chat where the query was sent</param>
        /// <param name="messageId">Identifier of the message, from which the query originated</param>
        /// <param name="chatInstance">Identifier that uniquely corresponds to the chat to which the message was sent</param>
        /// <param name="payload">Query payload</param>
        public UpdateNewCallbackQuery(long id = default, int senderUserId = default, long chatId = default, long messageId = default, long chatInstance = default, CallbackQueryPayload payload = default)
        {
            this.Id = id;
            this.SenderUserId = senderUserId;
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.ChatInstance = chatInstance;
            this.Payload = payload;
        }
    }

    public partial class UpdateNewInlineCallbackQuery
    {
        /// <summary>
        /// A new incoming callback query from a message sent via a bot; for bots only
        /// </summary>
        public UpdateNewInlineCallbackQuery() { }
        /// <summary>
        /// A new incoming callback query from a message sent via a bot; for bots only
        /// </summary>
        /// <param name="id">Unique query identifier</param>
        /// <param name="senderUserId">Identifier of the user who sent the query</param>
        /// <param name="inlineMessageId">Identifier of the inline message, from which the query originated</param>
        /// <param name="chatInstance">An identifier uniquely corresponding to the chat a message was sent to</param>
        /// <param name="payload">Query payload</param>
        public UpdateNewInlineCallbackQuery(long id = default, int senderUserId = default, string inlineMessageId = default, long chatInstance = default, CallbackQueryPayload payload = default)
        {
            this.Id = id;
            this.SenderUserId = senderUserId;
            this.InlineMessageId = inlineMessageId;
            this.ChatInstance = chatInstance;
            this.Payload = payload;
        }
    }

    public partial class UpdateNewShippingQuery
    {
        /// <summary>
        /// A new incoming shipping query; for bots only. Only for invoices with flexible price
        /// </summary>
        public UpdateNewShippingQuery() { }
        /// <summary>
        /// A new incoming shipping query; for bots only. Only for invoices with flexible price
        /// </summary>
        /// <param name="id">Unique query identifier</param>
        /// <param name="senderUserId">Identifier of the user who sent the query</param>
        /// <param name="invoicePayload">Invoice payload</param>
        /// <param name="shippingAddress">User shipping address</param>
        public UpdateNewShippingQuery(long id = default, int senderUserId = default, string invoicePayload = default, Address shippingAddress = default)
        {
            this.Id = id;
            this.SenderUserId = senderUserId;
            this.InvoicePayload = invoicePayload;
            this.ShippingAddress = shippingAddress;
        }
    }

    public partial class UpdateNewPreCheckoutQuery
    {
        /// <summary>
        /// A new incoming pre-checkout query; for bots only. Contains full information about a checkout
        /// </summary>
        public UpdateNewPreCheckoutQuery() { }
        /// <summary>
        /// A new incoming pre-checkout query; for bots only. Contains full information about a checkout
        /// </summary>
        /// <param name="id">Unique query identifier</param>
        /// <param name="senderUserId">Identifier of the user who sent the query</param>
        /// <param name="currency">Currency for the product price</param>
        /// <param name="totalAmount">Total price for the product, in the minimal quantity of the currency</param>
        /// <param name="invoicePayload">Invoice payload</param>
        /// <param name="shippingOptionId">Identifier of a shipping option chosen by the user; may be empty if not applicable</param>
        /// <param name="orderInfo">Information about the order; may be null</param>
        public UpdateNewPreCheckoutQuery(long id = default, int senderUserId = default, string currency = default, long totalAmount = default, Memory<byte> invoicePayload = default, string shippingOptionId = default, OrderInfo orderInfo = default)
        {
            this.Id = id;
            this.SenderUserId = senderUserId;
            this.Currency = currency;
            this.TotalAmount = totalAmount;
            this.InvoicePayload = invoicePayload;
            this.ShippingOptionId = shippingOptionId;
            this.OrderInfo = orderInfo;
        }
    }

    public partial class UpdateNewCustomEvent
    {
        /// <summary>
        /// A new incoming event; for bots only
        /// </summary>
        public UpdateNewCustomEvent() { }
        /// <summary>
        /// A new incoming event; for bots only
        /// </summary>
        /// <param name="@event">A JSON-serialized event</param>
        public UpdateNewCustomEvent(string @event = default)
        {
            this.Event = @event;
        }
    }

    public partial class UpdateNewCustomQuery
    {
        /// <summary>
        /// A new incoming query; for bots only
        /// </summary>
        public UpdateNewCustomQuery() { }
        /// <summary>
        /// A new incoming query; for bots only
        /// </summary>
        /// <param name="id">The query identifier</param>
        /// <param name="data">JSON-serialized query data</param>
        /// <param name="timeout">Query timeout</param>
        public UpdateNewCustomQuery(long id = default, string data = default, int timeout = default)
        {
            this.Id = id;
            this.Data = data;
            this.Timeout = timeout;
        }
    }

    public partial class UpdatePoll
    {
        /// <summary>
        /// A poll was updated; for bots only
        /// </summary>
        public UpdatePoll() { }
        /// <summary>
        /// A poll was updated; for bots only
        /// </summary>
        /// <param name="poll">New data about the poll</param>
        public UpdatePoll(Poll poll = default)
        {
            this.Poll = poll;
        }
    }

    public partial class UpdatePollAnswer
    {
        /// <summary>
        /// A user changed the answer to a poll; for bots only
        /// </summary>
        public UpdatePollAnswer() { }
        /// <summary>
        /// A user changed the answer to a poll; for bots only
        /// </summary>
        /// <param name="pollId">Unique poll identifier</param>
        /// <param name="userId">The user, who changed the answer to the poll</param>
        /// <param name="optionIds">0-based identifiers of answer options, chosen by the user</param>
        public UpdatePollAnswer(long pollId = default, int userId = default, int[] optionIds = default)
        {
            this.PollId = pollId;
            this.UserId = userId;
            this.OptionIds = optionIds;
        }
    }

    public partial class Updates
    {
        /// <summary>
        /// Contains a list of updates
        /// </summary>
        public Updates() { }
        /// <summary>
        /// Contains a list of updates
        /// </summary>
        /// <param name="updates">List of updates</param>
        public Updates(Update[] updates_ = default)
        {
            this.Updates_ = updates_;
        }
    }

    public partial class LogStreamDefault
    {
        /// <summary>
        /// The log is written to stderr or an OS specific log
        /// </summary>
        public LogStreamDefault() { }
    }

    public partial class LogStreamFile
    {
        /// <summary>
        /// The log is written to a file
        /// </summary>
        public LogStreamFile() { }
        /// <summary>
        /// The log is written to a file
        /// </summary>
        /// <param name="path">Path to the file to where the internal TDLib log will be written</param>
        /// <param name="maxFileSize">The maximum size of the file to where the internal TDLib log is written before the file will be auto-rotated</param>
        /// <param name="redirectStderr">Pass true to additionally redirect stderr to the log file. Ignored on Windows</param>
        public LogStreamFile(string path = default, long maxFileSize = default, bool redirectStderr = default)
        {
            this.Path = path;
            this.MaxFileSize = maxFileSize;
            this.RedirectStderr = redirectStderr;
        }
    }

    public partial class LogStreamEmpty
    {
        /// <summary>
        /// The log is written nowhere
        /// </summary>
        public LogStreamEmpty() { }
    }

    public partial class LogVerbosityLevel
    {
        /// <summary>
        /// Contains a TDLib internal log verbosity level
        /// </summary>
        public LogVerbosityLevel() { }
        /// <summary>
        /// Contains a TDLib internal log verbosity level
        /// </summary>
        /// <param name="verbosityLevel">Log verbosity level</param>
        public LogVerbosityLevel(int verbosityLevel = default)
        {
            this.VerbosityLevel = verbosityLevel;
        }
    }

    public partial class LogTags
    {
        /// <summary>
        /// Contains a list of available TDLib internal log tags
        /// </summary>
        public LogTags() { }
        /// <summary>
        /// Contains a list of available TDLib internal log tags
        /// </summary>
        /// <param name="tags">List of log tags</param>
        public LogTags(string[] tags = default)
        {
            this.Tags = tags;
        }
    }

    public partial class TestInt
    {
        /// <summary>
        /// A simple object containing a number; for testing only
        /// </summary>
        public TestInt() { }
        /// <summary>
        /// A simple object containing a number; for testing only
        /// </summary>
        /// <param name="value">Number</param>
        public TestInt(int value = default)
        {
            this.Value = value;
        }
    }

    public partial class TestString
    {
        /// <summary>
        /// A simple object containing a string; for testing only
        /// </summary>
        public TestString() { }
        /// <summary>
        /// A simple object containing a string; for testing only
        /// </summary>
        /// <param name="value">String</param>
        public TestString(string value = default)
        {
            this.Value = value;
        }
    }

    public partial class TestBytes
    {
        /// <summary>
        /// A simple object containing a sequence of bytes; for testing only
        /// </summary>
        public TestBytes() { }
        /// <summary>
        /// A simple object containing a sequence of bytes; for testing only
        /// </summary>
        /// <param name="value">Bytes</param>
        public TestBytes(Memory<byte> value = default)
        {
            this.Value = value;
        }
    }

    public partial class TestVectorInt
    {
        /// <summary>
        /// A simple object containing a vector of numbers; for testing only
        /// </summary>
        public TestVectorInt() { }
        /// <summary>
        /// A simple object containing a vector of numbers; for testing only
        /// </summary>
        /// <param name="value">Vector of numbers</param>
        public TestVectorInt(int[] value = default)
        {
            this.Value = value;
        }
    }

    public partial class TestVectorIntObject
    {
        /// <summary>
        /// A simple object containing a vector of objects that hold a number; for testing only
        /// </summary>
        public TestVectorIntObject() { }
        /// <summary>
        /// A simple object containing a vector of objects that hold a number; for testing only
        /// </summary>
        /// <param name="value">Vector of objects</param>
        public TestVectorIntObject(TestInt[] value = default)
        {
            this.Value = value;
        }
    }

    public partial class TestVectorString
    {
        /// <summary>
        /// A simple object containing a vector of strings; for testing only
        /// </summary>
        public TestVectorString() { }
        /// <summary>
        /// A simple object containing a vector of strings; for testing only
        /// </summary>
        /// <param name="value">Vector of strings</param>
        public TestVectorString(string[] value = default)
        {
            this.Value = value;
        }
    }

    public partial class TestVectorStringObject
    {
        /// <summary>
        /// A simple object containing a vector of objects that hold a string; for testing only
        /// </summary>
        public TestVectorStringObject() { }
        /// <summary>
        /// A simple object containing a vector of objects that hold a string; for testing only
        /// </summary>
        /// <param name="value">Vector of objects</param>
        public TestVectorStringObject(TestString[] value = default)
        {
            this.Value = value;
        }
    }

    public partial class GetAuthorizationState
    {
        /// <summary>
        /// Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state. Can be called before initialization
        /// </summary>
        public GetAuthorizationState() { }
    }

    public partial class SetTdlibParameters
    {
        /// <summary>
        /// Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
        /// </summary>
        public SetTdlibParameters() { }
        /// <summary>
        /// Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
        /// </summary>
        /// <param name="parameters">Parameters</param>
        public SetTdlibParameters(TdlibParameters parameters = default)
        {
            this.Parameters = parameters;
        }
    }

    public partial class CheckDatabaseEncryptionKey
    {
        /// <summary>
        /// Checks the database encryption key for correctness. Works only when the current authorization state is authorizationStateWaitEncryptionKey
        /// </summary>
        public CheckDatabaseEncryptionKey() { }
        /// <summary>
        /// Checks the database encryption key for correctness. Works only when the current authorization state is authorizationStateWaitEncryptionKey
        /// </summary>
        /// <param name="encryptionKey">Encryption key to check or set up</param>
        public CheckDatabaseEncryptionKey(Memory<byte> encryptionKey = default)
        {
            this.EncryptionKey = encryptionKey;
        }
    }

    public partial class SetAuthenticationPhoneNumber
    {
        /// <summary>
        /// Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber, -or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
        /// </summary>
        public SetAuthenticationPhoneNumber() { }
        /// <summary>
        /// Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber, -or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
        /// </summary>
        /// <param name="phoneNumber">The phone number of the user, in international format</param>
        /// <param name="settings">Settings for the authentication of the user's phone number</param>
        public SetAuthenticationPhoneNumber(string phoneNumber = default, PhoneNumberAuthenticationSettings settings = default)
        {
            this.PhoneNumber = phoneNumber;
            this.Settings = settings;
        }
    }

    public partial class ResendAuthenticationCode
    {
        /// <summary>
        /// Re-sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode and the next_code_type of the result is not null
        /// </summary>
        public ResendAuthenticationCode() { }
    }

    public partial class CheckAuthenticationCode
    {
        /// <summary>
        /// Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
        /// </summary>
        public CheckAuthenticationCode() { }
        /// <summary>
        /// Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
        /// </summary>
        /// <param name="code">The verification code received via SMS, Telegram message, phone call, or flash call</param>
        public CheckAuthenticationCode(string code = default)
        {
            this.Code = code;
        }
    }

    public partial class RequestQrCodeAuthentication
    {
        /// <summary>
        /// Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber, -or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
        /// </summary>
        public RequestQrCodeAuthentication() { }
        /// <summary>
        /// Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber, -or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
        /// </summary>
        /// <param name="otherUserIds">List of user identifiers of other users currently using the application</param>
        public RequestQrCodeAuthentication(int[] otherUserIds = default)
        {
            this.OtherUserIds = otherUserIds;
        }
    }

    public partial class RegisterUser
    {
        /// <summary>
        /// Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration
        /// </summary>
        public RegisterUser() { }
        /// <summary>
        /// Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration
        /// </summary>
        /// <param name="firstName">The first name of the user; 1-64 characters</param>
        /// <param name="lastName">The last name of the user; 0-64 characters</param>
        public RegisterUser(string firstName = default, string lastName = default)
        {
            this.FirstName = firstName;
            this.LastName = lastName;
        }
    }

    public partial class CheckAuthenticationPassword
    {
        /// <summary>
        /// Checks the authentication password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        public CheckAuthenticationPassword() { }
        /// <summary>
        /// Checks the authentication password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        /// <param name="password">The password to check</param>
        public CheckAuthenticationPassword(string password = default)
        {
            this.Password = password;
        }
    }

    public partial class RequestAuthenticationPasswordRecovery
    {
        /// <summary>
        /// Requests to send a password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        public RequestAuthenticationPasswordRecovery() { }
    }

    public partial class RecoverAuthenticationPassword
    {
        /// <summary>
        /// Recovers the password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        public RecoverAuthenticationPassword() { }
        /// <summary>
        /// Recovers the password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        /// <param name="recoveryCode">Recovery code to check</param>
        public RecoverAuthenticationPassword(string recoveryCode = default)
        {
            this.RecoveryCode = recoveryCode;
        }
    }

    public partial class CheckAuthenticationBotToken
    {
        /// <summary>
        /// Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
        /// </summary>
        public CheckAuthenticationBotToken() { }
        /// <summary>
        /// Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
        /// </summary>
        /// <param name="token">The bot token</param>
        public CheckAuthenticationBotToken(string token = default)
        {
            this.Token = token;
        }
    }

    public partial class LogOut
    {
        /// <summary>
        /// Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent
        /// </summary>
        public LogOut() { }
    }

    public partial class Close
    {
        /// <summary>
        /// Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization
        /// </summary>
        public Close() { }
    }

    public partial class Destroy
    {
        /// <summary>
        /// Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed. After the destruction completes updateAuthorizationState with authorizationStateClosed will be sent. Can be called before authorization
        /// </summary>
        public Destroy() { }
    }

    public partial class ConfirmQrCodeAuthentication
    {
        /// <summary>
        /// Confirms QR code authentication on another device. Returns created session on success
        /// </summary>
        public ConfirmQrCodeAuthentication() { }
        /// <summary>
        /// Confirms QR code authentication on another device. Returns created session on success
        /// </summary>
        /// <param name="link">A link from a QR code. The link must be scanned by the in-app camera</param>
        public ConfirmQrCodeAuthentication(string link = default)
        {
            this.Link = link;
        }
    }

    public partial class GetCurrentState
    {
        /// <summary>
        /// Returns all updates needed to restore current TDLib state, i.e. all actual UpdateAuthorizationState/UpdateUser/UpdateNewChat and others. This is especially useful if TDLib is run in a separate process. Can be called before initialization
        /// </summary>
        public GetCurrentState() { }
    }

    public partial class SetDatabaseEncryptionKey
    {
        /// <summary>
        /// Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
        /// </summary>
        public SetDatabaseEncryptionKey() { }
        /// <summary>
        /// Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
        /// </summary>
        /// <param name="newEncryptionKey">New encryption key</param>
        public SetDatabaseEncryptionKey(Memory<byte> newEncryptionKey = default)
        {
            this.NewEncryptionKey = newEncryptionKey;
        }
    }

    public partial class GetPasswordState
    {
        /// <summary>
        /// Returns the current state of 2-step verification
        /// </summary>
        public GetPasswordState() { }
    }

    public partial class SetPassword
    {
        /// <summary>
        /// Changes the password for the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed
        /// </summary>
        public SetPassword() { }
        /// <summary>
        /// Changes the password for the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed
        /// </summary>
        /// <param name="oldPassword">Previous password of the user</param>
        /// <param name="newPassword">New password of the user; may be empty to remove the password</param>
        /// <param name="newHint">New password hint; may be empty</param>
        /// <param name="setRecoveryEmailAddress">Pass true if the recovery email address should be changed</param>
        /// <param name="newRecoveryEmailAddress">New recovery email address; may be empty</param>
        public SetPassword(string oldPassword = default, string newPassword = default, string newHint = default, bool setRecoveryEmailAddress = default, string newRecoveryEmailAddress = default)
        {
            this.OldPassword = oldPassword;
            this.NewPassword = newPassword;
            this.NewHint = newHint;
            this.SetRecoveryEmailAddress = setRecoveryEmailAddress;
            this.NewRecoveryEmailAddress = newRecoveryEmailAddress;
        }
    }

    public partial class GetRecoveryEmailAddress
    {
        /// <summary>
        /// Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user
        /// </summary>
        public GetRecoveryEmailAddress() { }
        /// <summary>
        /// Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user
        /// </summary>
        /// <param name="password">The password for the current user</param>
        public GetRecoveryEmailAddress(string password = default)
        {
            this.Password = password;
        }
    }

    public partial class SetRecoveryEmailAddress
    {
        /// <summary>
        /// Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed. -If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation
        /// </summary>
        public SetRecoveryEmailAddress() { }
        /// <summary>
        /// Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed. -If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation
        /// </summary>
        /// <param name="password">Password of the current user</param>
        /// <param name="newRecoveryEmailAddress">New recovery email address</param>
        public SetRecoveryEmailAddress(string password = default, string newRecoveryEmailAddress = default)
        {
            this.Password = password;
            this.NewRecoveryEmailAddress = newRecoveryEmailAddress;
        }
    }

    public partial class CheckRecoveryEmailAddressCode
    {
        /// <summary>
        /// Checks the 2-step verification recovery email address verification code
        /// </summary>
        public CheckRecoveryEmailAddressCode() { }
        /// <summary>
        /// Checks the 2-step verification recovery email address verification code
        /// </summary>
        /// <param name="code">Verification code</param>
        public CheckRecoveryEmailAddressCode(string code = default)
        {
            this.Code = code;
        }
    }

    public partial class ResendRecoveryEmailAddressCode
    {
        /// <summary>
        /// Resends the 2-step verification recovery email address verification code
        /// </summary>
        public ResendRecoveryEmailAddressCode() { }
    }

    public partial class RequestPasswordRecovery
    {
        /// <summary>
        /// Requests to send a password recovery code to an email address that was previously set up
        /// </summary>
        public RequestPasswordRecovery() { }
    }

    public partial class RecoverPassword
    {
        /// <summary>
        /// Recovers the password using a recovery code sent to an email address that was previously set up
        /// </summary>
        public RecoverPassword() { }
        /// <summary>
        /// Recovers the password using a recovery code sent to an email address that was previously set up
        /// </summary>
        /// <param name="recoveryCode">Recovery code to check</param>
        public RecoverPassword(string recoveryCode = default)
        {
            this.RecoveryCode = recoveryCode;
        }
    }

    public partial class CreateTemporaryPassword
    {
        /// <summary>
        /// Creates a new temporary password for processing payments
        /// </summary>
        public CreateTemporaryPassword() { }
        /// <summary>
        /// Creates a new temporary password for processing payments
        /// </summary>
        /// <param name="password">Persistent user password</param>
        /// <param name="validFor">Time during which the temporary password will be valid, in seconds; should be between 60 and 86400</param>
        public CreateTemporaryPassword(string password = default, int validFor = default)
        {
            this.Password = password;
            this.ValidFor = validFor;
        }
    }

    public partial class GetTemporaryPasswordState
    {
        /// <summary>
        /// Returns information about the current temporary password
        /// </summary>
        public GetTemporaryPasswordState() { }
    }

    public partial class GetMe
    {
        /// <summary>
        /// Returns the current user
        /// </summary>
        public GetMe() { }
    }

    public partial class GetUser
    {
        /// <summary>
        /// Returns information about a user by their identifier. This is an offline request if the current user is not a bot
        /// </summary>
        public GetUser() { }
        /// <summary>
        /// Returns information about a user by their identifier. This is an offline request if the current user is not a bot
        /// </summary>
        /// <param name="userId">User identifier</param>
        public GetUser(int userId = default)
        {
            this.UserId = userId;
        }
    }

    public partial class GetUserFullInfo
    {
        /// <summary>
        /// Returns full information about a user by their identifier
        /// </summary>
        public GetUserFullInfo() { }
        /// <summary>
        /// Returns full information about a user by their identifier
        /// </summary>
        /// <param name="userId">User identifier</param>
        public GetUserFullInfo(int userId = default)
        {
            this.UserId = userId;
        }
    }

    public partial class GetBasicGroup
    {
        /// <summary>
        /// Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot
        /// </summary>
        public GetBasicGroup() { }
        /// <summary>
        /// Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot
        /// </summary>
        /// <param name="basicGroupId">Basic group identifier</param>
        public GetBasicGroup(int basicGroupId = default)
        {
            this.BasicGroupId = basicGroupId;
        }
    }

    public partial class GetBasicGroupFullInfo
    {
        /// <summary>
        /// Returns full information about a basic group by its identifier
        /// </summary>
        public GetBasicGroupFullInfo() { }
        /// <summary>
        /// Returns full information about a basic group by its identifier
        /// </summary>
        /// <param name="basicGroupId">Basic group identifier</param>
        public GetBasicGroupFullInfo(int basicGroupId = default)
        {
            this.BasicGroupId = basicGroupId;
        }
    }

    public partial class GetSupergroup
    {
        /// <summary>
        /// Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot
        /// </summary>
        public GetSupergroup() { }
        /// <summary>
        /// Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot
        /// </summary>
        /// <param name="supergroupId">Supergroup or channel identifier</param>
        public GetSupergroup(int supergroupId = default)
        {
            this.SupergroupId = supergroupId;
        }
    }

    public partial class GetSupergroupFullInfo
    {
        /// <summary>
        /// Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute
        /// </summary>
        public GetSupergroupFullInfo() { }
        /// <summary>
        /// Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute
        /// </summary>
        /// <param name="supergroupId">Supergroup or channel identifier</param>
        public GetSupergroupFullInfo(int supergroupId = default)
        {
            this.SupergroupId = supergroupId;
        }
    }

    public partial class GetSecretChat
    {
        /// <summary>
        /// Returns information about a secret chat by its identifier. This is an offline request
        /// </summary>
        public GetSecretChat() { }
        /// <summary>
        /// Returns information about a secret chat by its identifier. This is an offline request
        /// </summary>
        /// <param name="secretChatId">Secret chat identifier</param>
        public GetSecretChat(int secretChatId = default)
        {
            this.SecretChatId = secretChatId;
        }
    }

    public partial class GetChat
    {
        /// <summary>
        /// Returns information about a chat by its identifier, this is an offline request if the current user is not a bot
        /// </summary>
        public GetChat() { }
        /// <summary>
        /// Returns information about a chat by its identifier, this is an offline request if the current user is not a bot
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public GetChat(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class GetMessage
    {
        /// <summary>
        /// Returns information about a message
        /// </summary>
        public GetMessage() { }
        /// <summary>
        /// Returns information about a message
        /// </summary>
        /// <param name="chatId">Identifier of the chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message to get</param>
        public GetMessage(long chatId = default, long messageId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
        }
    }

    public partial class GetMessageLocally
    {
        /// <summary>
        /// Returns information about a message, if it is available locally without sending network request. This is an offline request
        /// </summary>
        public GetMessageLocally() { }
        /// <summary>
        /// Returns information about a message, if it is available locally without sending network request. This is an offline request
        /// </summary>
        /// <param name="chatId">Identifier of the chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message to get</param>
        public GetMessageLocally(long chatId = default, long messageId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
        }
    }

    public partial class GetRepliedMessage
    {
        /// <summary>
        /// Returns information about a message that is replied by a given message. Also returns the pinned message, the game message, and the invoice message for messages of the types messagePinMessage, messageGameScore, and messagePaymentSuccessful respectively
        /// </summary>
        public GetRepliedMessage() { }
        /// <summary>
        /// Returns information about a message that is replied by a given message. Also returns the pinned message, the game message, and the invoice message for messages of the types messagePinMessage, messageGameScore, and messagePaymentSuccessful respectively
        /// </summary>
        /// <param name="chatId">Identifier of the chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message reply to which to get</param>
        public GetRepliedMessage(long chatId = default, long messageId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
        }
    }

    public partial class GetChatPinnedMessage
    {
        /// <summary>
        /// Returns information about a pinned chat message
        /// </summary>
        public GetChatPinnedMessage() { }
        /// <summary>
        /// Returns information about a pinned chat message
        /// </summary>
        /// <param name="chatId">Identifier of the chat the message belongs to</param>
        public GetChatPinnedMessage(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class GetMessages
    {
        /// <summary>
        /// Returns information about messages. If a message is not found, returns null on the corresponding position of the result
        /// </summary>
        public GetMessages() { }
        /// <summary>
        /// Returns information about messages. If a message is not found, returns null on the corresponding position of the result
        /// </summary>
        /// <param name="chatId">Identifier of the chat the messages belong to</param>
        /// <param name="messageIds">Identifiers of the messages to get</param>
        public GetMessages(long chatId = default, long[] messageIds = default)
        {
            this.ChatId = chatId;
            this.MessageIds = messageIds;
        }
    }

    public partial class GetMessageThread
    {
        /// <summary>
        /// Returns information about a message thread. Can be used only if message.can_get_message_thread == true
        /// </summary>
        public GetMessageThread() { }
        /// <summary>
        /// Returns information about a message thread. Can be used only if message.can_get_message_thread == true
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Identifier of the message</param>
        public GetMessageThread(long chatId = default, long messageId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
        }
    }

    public partial class GetFile
    {
        /// <summary>
        /// Returns information about a file; this is an offline request
        /// </summary>
        public GetFile() { }
        /// <summary>
        /// Returns information about a file; this is an offline request
        /// </summary>
        /// <param name="fileId">Identifier of the file to get</param>
        public GetFile(int fileId = default)
        {
            this.FileId = fileId;
        }
    }

    public partial class GetRemoteFile
    {
        /// <summary>
        /// Returns information about a file by its remote ID; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user. -For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
        /// </summary>
        public GetRemoteFile() { }
        /// <summary>
        /// Returns information about a file by its remote ID; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user. -For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
        /// </summary>
        /// <param name="remoteFileId">Remote identifier of the file to get</param>
        /// <param name="fileType">File type, if known</param>
        public GetRemoteFile(string remoteFileId = default, FileType fileType = default)
        {
            this.RemoteFileId = remoteFileId;
            this.FileType = fileType;
        }
    }

    public partial class GetChats
    {
        /// <summary>
        /// Returns an ordered list of chats in a chat list. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. (For example, to get a list of chats from the beginning, the offset_order should be equal to a biggest signed 64-bit number 9223372036854775807 == 2^63 - 1). -For optimal performance the number of returned chats is chosen by the library
        /// </summary>
        public GetChats() { }
        /// <summary>
        /// Returns an ordered list of chats in a chat list. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. (For example, to get a list of chats from the beginning, the offset_order should be equal to a biggest signed 64-bit number 9223372036854775807 == 2^63 - 1). -For optimal performance the number of returned chats is chosen by the library
        /// </summary>
        /// <param name="chatList">The chat list in which to return chats</param>
        /// <param name="offsetOrder">Chat order to return chats from</param>
        /// <param name="offsetChatId">Chat identifier to return chats from</param>
        /// <param name="limit">The maximum number of chats to be returned. It is possible that fewer chats than the limit are returned even if the end of the list is not reached</param>
        public GetChats(ChatList chatList = default, long offsetOrder = default, long offsetChatId = default, int limit = default)
        {
            this.ChatList = chatList;
            this.OffsetOrder = offsetOrder;
            this.OffsetChatId = offsetChatId;
            this.Limit = limit;
        }
    }

    public partial class SearchPublicChat
    {
        /// <summary>
        /// Searches a public chat by its username. Currently only private chats, supergroups and channels can be public. Returns the chat if found; otherwise an error is returned
        /// </summary>
        public SearchPublicChat() { }
        /// <summary>
        /// Searches a public chat by its username. Currently only private chats, supergroups and channels can be public. Returns the chat if found; otherwise an error is returned
        /// </summary>
        /// <param name="username">Username to be resolved</param>
        public SearchPublicChat(string username = default)
        {
            this.Username = username;
        }
    }

    public partial class SearchPublicChats
    {
        /// <summary>
        /// Searches public chats by looking for specified query in their username and title. Currently only private chats, supergroups and channels can be public. Returns a meaningful number of results. Returns nothing if the length of the searched username prefix is less than 5. Excludes private chats with contacts and chats from the chat list from the results
        /// </summary>
        public SearchPublicChats() { }
        /// <summary>
        /// Searches public chats by looking for specified query in their username and title. Currently only private chats, supergroups and channels can be public. Returns a meaningful number of results. Returns nothing if the length of the searched username prefix is less than 5. Excludes private chats with contacts and chats from the chat list from the results
        /// </summary>
        /// <param name="query">Query to search for</param>
        public SearchPublicChats(string query = default)
        {
            this.Query = query;
        }
    }

    public partial class SearchChats
    {
        /// <summary>
        /// Searches for the specified query in the title and username of already known chats, this is an offline request. Returns chats in the order seen in the main chat list
        /// </summary>
        public SearchChats() { }
        /// <summary>
        /// Searches for the specified query in the title and username of already known chats, this is an offline request. Returns chats in the order seen in the main chat list
        /// </summary>
        /// <param name="query">Query to search for. If the query is empty, returns up to 20 recently found chats</param>
        /// <param name="limit">The maximum number of chats to be returned</param>
        public SearchChats(string query = default, int limit = default)
        {
            this.Query = query;
            this.Limit = limit;
        }
    }

    public partial class SearchChatsOnServer
    {
        /// <summary>
        /// Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list
        /// </summary>
        public SearchChatsOnServer() { }
        /// <summary>
        /// Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list
        /// </summary>
        /// <param name="query">Query to search for</param>
        /// <param name="limit">The maximum number of chats to be returned</param>
        public SearchChatsOnServer(string query = default, int limit = default)
        {
            this.Query = query;
            this.Limit = limit;
        }
    }

    public partial class SearchChatsNearby
    {
        /// <summary>
        /// Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby. The request should be sent again every 25 seconds with adjusted location to not miss new chats
        /// </summary>
        public SearchChatsNearby() { }
        /// <summary>
        /// Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby. The request should be sent again every 25 seconds with adjusted location to not miss new chats
        /// </summary>
        /// <param name="location">Current user location</param>
        public SearchChatsNearby(Location location = default)
        {
            this.Location = location;
        }
    }

    public partial class GetTopChats
    {
        /// <summary>
        /// Returns a list of frequently used chats. Supported only if the chat info database is enabled
        /// </summary>
        public GetTopChats() { }
        /// <summary>
        /// Returns a list of frequently used chats. Supported only if the chat info database is enabled
        /// </summary>
        /// <param name="category">Category of chats to be returned</param>
        /// <param name="limit">The maximum number of chats to be returned; up to 30</param>
        public GetTopChats(TopChatCategory category = default, int limit = default)
        {
            this.Category = category;
            this.Limit = limit;
        }
    }

    public partial class RemoveTopChat
    {
        /// <summary>
        /// Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
        /// </summary>
        public RemoveTopChat() { }
        /// <summary>
        /// Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
        /// </summary>
        /// <param name="category">Category of frequently used chats</param>
        /// <param name="chatId">Chat identifier</param>
        public RemoveTopChat(TopChatCategory category = default, long chatId = default)
        {
            this.Category = category;
            this.ChatId = chatId;
        }
    }

    public partial class AddRecentlyFoundChat
    {
        /// <summary>
        /// Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
        /// </summary>
        public AddRecentlyFoundChat() { }
        /// <summary>
        /// Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
        /// </summary>
        /// <param name="chatId">Identifier of the chat to add</param>
        public AddRecentlyFoundChat(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class RemoveRecentlyFoundChat
    {
        /// <summary>
        /// Removes a chat from the list of recently found chats
        /// </summary>
        public RemoveRecentlyFoundChat() { }
        /// <summary>
        /// Removes a chat from the list of recently found chats
        /// </summary>
        /// <param name="chatId">Identifier of the chat to be removed</param>
        public RemoveRecentlyFoundChat(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class ClearRecentlyFoundChats
    {
        /// <summary>
        /// Clears the list of recently found chats
        /// </summary>
        public ClearRecentlyFoundChats() { }
    }

    public partial class CheckChatUsername
    {
        /// <summary>
        /// Checks whether a username can be set for a chat
        /// </summary>
        public CheckChatUsername() { }
        /// <summary>
        /// Checks whether a username can be set for a chat
        /// </summary>
        /// <param name="chatId">Chat identifier; should be identifier of a supergroup chat, or a channel chat, or a private chat with self, or zero if chat is being created</param>
        /// <param name="username">Username to be checked</param>
        public CheckChatUsername(long chatId = default, string username = default)
        {
            this.ChatId = chatId;
            this.Username = username;
        }
    }

    public partial class GetCreatedPublicChats
    {
        /// <summary>
        /// Returns a list of public chats of the specified type, owned by the user
        /// </summary>
        public GetCreatedPublicChats() { }
        /// <summary>
        /// Returns a list of public chats of the specified type, owned by the user
        /// </summary>
        /// <param name="type">Type of the public chats to return</param>
        public GetCreatedPublicChats(PublicChatType type = default)
        {
            this.Type = type;
        }
    }

    public partial class CheckCreatedPublicChatsLimit
    {
        /// <summary>
        /// Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached
        /// </summary>
        public CheckCreatedPublicChatsLimit() { }
        /// <summary>
        /// Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached
        /// </summary>
        /// <param name="type">Type of the public chats, for which to check the limit</param>
        public CheckCreatedPublicChatsLimit(PublicChatType type = default)
        {
            this.Type = type;
        }
    }

    public partial class GetSuitableDiscussionChats
    {
        /// <summary>
        /// Returns a list of basic group and supergroup chats, which can be used as a discussion group for a channel. Basic group chats need to be first upgraded to supergroups before they can be set as a discussion group
        /// </summary>
        public GetSuitableDiscussionChats() { }
    }

    public partial class GetInactiveSupergroupChats
    {
        /// <summary>
        /// Returns a list of recently inactive supergroups and channels. Can be used when user reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH error
        /// </summary>
        public GetInactiveSupergroupChats() { }
    }

    public partial class GetGroupsInCommon
    {
        /// <summary>
        /// Returns a list of common group chats with a given user. Chats are sorted by their type and creation date
        /// </summary>
        public GetGroupsInCommon() { }
        /// <summary>
        /// Returns a list of common group chats with a given user. Chats are sorted by their type and creation date
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="offsetChatId">Chat identifier starting from which to return chats; use 0 for the first request</param>
        /// <param name="limit">The maximum number of chats to be returned; up to 100</param>
        public GetGroupsInCommon(int userId = default, long offsetChatId = default, int limit = default)
        {
            this.UserId = userId;
            this.OffsetChatId = offsetChatId;
            this.Limit = limit;
        }
    }

    public partial class GetChatHistory
    {
        /// <summary>
        /// Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). -For optimal performance the number of returned messages is chosen by the library. This is an offline request if only_local is true
        /// </summary>
        public GetChatHistory() { }
        /// <summary>
        /// Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). -For optimal performance the number of returned messages is chosen by the library. This is an offline request if only_local is true
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="fromMessageId">Identifier of the message starting from which history must be fetched; use 0 to get results from the last message</param>
        /// <param name="offset">Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages</param>
        /// <param name="limit">The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached</param>
        /// <param name="onlyLocal">If true, returns only messages that are available locally without sending network requests</param>
        public GetChatHistory(long chatId = default, long fromMessageId = default, int offset = default, int limit = default, bool onlyLocal = default)
        {
            this.ChatId = chatId;
            this.FromMessageId = fromMessageId;
            this.Offset = offset;
            this.Limit = limit;
            this.OnlyLocal = onlyLocal;
        }
    }

    public partial class GetMessageThreadHistory
    {
        /// <summary>
        /// Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup. -The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library
        /// </summary>
        public GetMessageThreadHistory() { }
        /// <summary>
        /// Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup. -The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Message identifier, which thread history needs to be returned</param>
        /// <param name="fromMessageId">Identifier of the message starting from which history must be fetched; use 0 to get results from the last message</param>
        /// <param name="offset">Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages</param>
        /// <param name="limit">The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset. Fewer messages may be returned than specified by the limit, even if the end of the message thread history has not been reached</param>
        public GetMessageThreadHistory(long chatId = default, long messageId = default, long fromMessageId = default, int offset = default, int limit = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.FromMessageId = fromMessageId;
            this.Offset = offset;
            this.Limit = limit;
        }
    }

    public partial class DeleteChatHistory
    {
        /// <summary>
        /// Deletes all messages in the chat. Use Chat.can_be_deleted_only_for_self and Chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat
        /// </summary>
        public DeleteChatHistory() { }
        /// <summary>
        /// Deletes all messages in the chat. Use Chat.can_be_deleted_only_for_self and Chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="removeFromChatList">Pass true if the chat should be removed from the chat list</param>
        /// <param name="revoke">Pass true to try to delete chat history for all users</param>
        public DeleteChatHistory(long chatId = default, bool removeFromChatList = default, bool revoke = default)
        {
            this.ChatId = chatId;
            this.RemoveFromChatList = removeFromChatList;
            this.Revoke = revoke;
        }
    }

    public partial class SearchChatMessages
    {
        /// <summary>
        /// Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query -(searchSecretMessages should be used instead), or without an enabled message database. For optimal performance the number of returned messages is chosen by the library
        /// </summary>
        public SearchChatMessages() { }
        /// <summary>
        /// Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query -(searchSecretMessages should be used instead), or without an enabled message database. For optimal performance the number of returned messages is chosen by the library
        /// </summary>
        /// <param name="chatId">Identifier of the chat in which to search messages</param>
        /// <param name="query">Query to search for</param>
        /// <param name="senderUserId">If not 0, only messages sent by the specified user will be returned. Not supported in secret chats</param>
        /// <param name="fromMessageId">Identifier of the message starting from which history must be fetched; use 0 to get results from the last message</param>
        /// <param name="offset">Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages</param>
        /// <param name="limit">The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached</param>
        /// <param name="filter">Filter for message content in the search results</param>
        /// <param name="messageThreadId">If not 0, only messages in the specified thread will be returned; supergroups only</param>
        public SearchChatMessages(long chatId = default, string query = default, int senderUserId = default, long fromMessageId = default, int offset = default, int limit = default, SearchMessagesFilter filter = default, long messageThreadId = default)
        {
            this.ChatId = chatId;
            this.Query = query;
            this.SenderUserId = senderUserId;
            this.FromMessageId = fromMessageId;
            this.Offset = offset;
            this.Limit = limit;
            this.Filter = filter;
            this.MessageThreadId = messageThreadId;
        }
    }

    public partial class SearchMessages
    {
        /// <summary>
        /// Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)). -For optimal performance the number of returned messages is chosen by the library
        /// </summary>
        public SearchMessages() { }
        /// <summary>
        /// Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)). -For optimal performance the number of returned messages is chosen by the library
        /// </summary>
        /// <param name="chatList">Chat list in which to search messages; pass null to search in all chats regardless of their chat list</param>
        /// <param name="query">Query to search for</param>
        /// <param name="offsetDate">The date of the message starting from which the results should be fetched. Use 0 or any date in the future to get results from the last message</param>
        /// <param name="offsetChatId">The chat identifier of the last found message, or 0 for the first request</param>
        /// <param name="offsetMessageId">The message identifier of the last found message, or 0 for the first request</param>
        /// <param name="limit">The maximum number of messages to be returned; up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached</param>
        /// <param name="filter">Filter for message content in the search results; searchMessagesFilterCall, searchMessagesFilterMissedCall, searchMessagesFilterMention, searchMessagesFilterUnreadMention and searchMessagesFilterFailedToSend are unsupported in this function</param>
        /// <param name="minDate">If not 0, the minimum date of the messages to return</param>
        /// <param name="maxDate">If not 0, the maximum date of the messages to return</param>
        public SearchMessages(ChatList chatList = default, string query = default, int offsetDate = default, long offsetChatId = default, long offsetMessageId = default, int limit = default, SearchMessagesFilter filter = default, int minDate = default, int maxDate = default)
        {
            this.ChatList = chatList;
            this.Query = query;
            this.OffsetDate = offsetDate;
            this.OffsetChatId = offsetChatId;
            this.OffsetMessageId = offsetMessageId;
            this.Limit = limit;
            this.Filter = filter;
            this.MinDate = minDate;
            this.MaxDate = maxDate;
        }
    }

    public partial class SearchSecretMessages
    {
        /// <summary>
        /// Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance the number of returned messages is chosen by the library
        /// </summary>
        public SearchSecretMessages() { }
        /// <summary>
        /// Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance the number of returned messages is chosen by the library
        /// </summary>
        /// <param name="chatId">Identifier of the chat in which to search. Specify 0 to search in all secret chats</param>
        /// <param name="query">Query to search for. If empty, searchChatMessages should be used instead</param>
        /// <param name="offset">Offset of the first entry to return as received from the previous request; use empty string to get first chunk of results</param>
        /// <param name="limit">The maximum number of messages to be returned; up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached</param>
        /// <param name="filter">A filter for message content in the search results</param>
        public SearchSecretMessages(long chatId = default, string query = default, string offset = default, int limit = default, SearchMessagesFilter filter = default)
        {
            this.ChatId = chatId;
            this.Query = query;
            this.Offset = offset;
            this.Limit = limit;
            this.Filter = filter;
        }
    }

    public partial class SearchCallMessages
    {
        /// <summary>
        /// Searches for call messages. Returns the results in reverse chronological order (i. e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library
        /// </summary>
        public SearchCallMessages() { }
        /// <summary>
        /// Searches for call messages. Returns the results in reverse chronological order (i. e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library
        /// </summary>
        /// <param name="fromMessageId">Identifier of the message from which to search; use 0 to get results from the last message</param>
        /// <param name="limit">The maximum number of messages to be returned; up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached</param>
        /// <param name="onlyMissed">If true, returns only messages with missed calls</param>
        public SearchCallMessages(long fromMessageId = default, int limit = default, bool onlyMissed = default)
        {
            this.FromMessageId = fromMessageId;
            this.Limit = limit;
            this.OnlyMissed = onlyMissed;
        }
    }

    public partial class SearchChatRecentLocationMessages
    {
        /// <summary>
        /// Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user
        /// </summary>
        public SearchChatRecentLocationMessages() { }
        /// <summary>
        /// Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="limit">The maximum number of messages to be returned</param>
        public SearchChatRecentLocationMessages(long chatId = default, int limit = default)
        {
            this.ChatId = chatId;
            this.Limit = limit;
        }
    }

    public partial class GetActiveLiveLocationMessages
    {
        /// <summary>
        /// Returns all active live locations that should be updated by the application. The list is persistent across application restarts only if the message database is used
        /// </summary>
        public GetActiveLiveLocationMessages() { }
    }

    public partial class GetChatMessageByDate
    {
        /// <summary>
        /// Returns the last message sent in a chat no later than the specified date
        /// </summary>
        public GetChatMessageByDate() { }
        /// <summary>
        /// Returns the last message sent in a chat no later than the specified date
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="date">Point in time (Unix timestamp) relative to which to search for messages</param>
        public GetChatMessageByDate(long chatId = default, int date = default)
        {
            this.ChatId = chatId;
            this.Date = date;
        }
    }

    public partial class GetChatMessageCount
    {
        /// <summary>
        /// Returns approximate number of messages of the specified type in the chat
        /// </summary>
        public GetChatMessageCount() { }
        /// <summary>
        /// Returns approximate number of messages of the specified type in the chat
        /// </summary>
        /// <param name="chatId">Identifier of the chat in which to count messages</param>
        /// <param name="filter">Filter for message content; searchMessagesFilterEmpty is unsupported in this function</param>
        /// <param name="returnLocal">If true, returns count that is available locally without sending network requests, returning -1 if the number of messages is unknown</param>
        public GetChatMessageCount(long chatId = default, SearchMessagesFilter filter = default, bool returnLocal = default)
        {
            this.ChatId = chatId;
            this.Filter = filter;
            this.ReturnLocal = returnLocal;
        }
    }

    public partial class GetChatScheduledMessages
    {
        /// <summary>
        /// Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
        /// </summary>
        public GetChatScheduledMessages() { }
        /// <summary>
        /// Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public GetChatScheduledMessages(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class GetMessagePublicForwards
    {
        /// <summary>
        /// Returns forwarded copies of a channel message to another public channels. For optimal performance the number of returned messages is chosen by the library. The method is under development and may or may not work
        /// </summary>
        public GetMessagePublicForwards() { }
        /// <summary>
        /// Returns forwarded copies of a channel message to another public channels. For optimal performance the number of returned messages is chosen by the library. The method is under development and may or may not work
        /// </summary>
        /// <param name="chatId">Chat identifier of the message</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="offset">Offset of the first entry to return as received from the previous request; use empty string to get first chunk of results</param>
        /// <param name="limit">The maximum number of messages to be returned; must be positive and can't be greater than 100. Fewer messages may be returned than specified by the limit, even if the end of the list has not been reached</param>
        public GetMessagePublicForwards(long chatId = default, long messageId = default, string offset = default, int limit = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.Offset = offset;
            this.Limit = limit;
        }
    }

    public partial class RemoveNotification
    {
        /// <summary>
        /// Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user
        /// </summary>
        public RemoveNotification() { }
        /// <summary>
        /// Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user
        /// </summary>
        /// <param name="notificationGroupId">Identifier of notification group to which the notification belongs</param>
        /// <param name="notificationId">Identifier of removed notification</param>
        public RemoveNotification(int notificationGroupId = default, int notificationId = default)
        {
            this.NotificationGroupId = notificationGroupId;
            this.NotificationId = notificationId;
        }
    }

    public partial class RemoveNotificationGroup
    {
        /// <summary>
        /// Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user
        /// </summary>
        public RemoveNotificationGroup() { }
        /// <summary>
        /// Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user
        /// </summary>
        /// <param name="notificationGroupId">Notification group identifier</param>
        /// <param name="maxNotificationId">The maximum identifier of removed notifications</param>
        public RemoveNotificationGroup(int notificationGroupId = default, int maxNotificationId = default)
        {
            this.NotificationGroupId = notificationGroupId;
            this.MaxNotificationId = maxNotificationId;
        }
    }

    public partial class GetMessageLink
    {
        /// <summary>
        /// Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels. This is an offline request
        /// </summary>
        public GetMessageLink() { }
        /// <summary>
        /// Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels. This is an offline request
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which the message belongs</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="forAlbum">Pass true to create a link for the whole media album</param>
        /// <param name="forComment">Pass true to create a link to the message as a channel post comment, or from a message thread</param>
        public GetMessageLink(long chatId = default, long messageId = default, bool forAlbum = default, bool forComment = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.ForAlbum = forAlbum;
            this.ForComment = forComment;
        }
    }

    public partial class GetMessageEmbeddingCode
    {
        /// <summary>
        /// Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username
        /// </summary>
        public GetMessageEmbeddingCode() { }
        /// <summary>
        /// Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which the message belongs</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="forAlbum">Pass true to return an HTML code for embedding of the whole media album</param>
        public GetMessageEmbeddingCode(long chatId = default, long messageId = default, bool forAlbum = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.ForAlbum = forAlbum;
        }
    }

    public partial class GetMessageLinkInfo
    {
        /// <summary>
        /// Returns information about a public or private message link
        /// </summary>
        public GetMessageLinkInfo() { }
        /// <summary>
        /// Returns information about a public or private message link
        /// </summary>
        /// <param name="url">The message link in the format "https://t.me/c/...", or "tg://privatepost?...", or "https://t.me/username/...", or "tg://resolve?..."</param>
        public GetMessageLinkInfo(string url = default)
        {
            this.Url = url;
        }
    }

    public partial class SendMessage
    {
        /// <summary>
        /// Sends a message. Returns the sent message
        /// </summary>
        public SendMessage() { }
        /// <summary>
        /// Sends a message. Returns the sent message
        /// </summary>
        /// <param name="chatId">Target chat</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the message will be sent</param>
        /// <param name="replyToMessageId">Identifier of the message to reply to or 0</param>
        /// <param name="options">Options to be used to send the message</param>
        /// <param name="replyMarkup">Markup for replying to the message; for bots only</param>
        /// <param name="inputMessageContent">The content of the message to be sent</param>
        public SendMessage(long chatId = default, long messageThreadId = default, long replyToMessageId = default, MessageSendOptions options = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.ChatId = chatId;
            this.MessageThreadId = messageThreadId;
            this.ReplyToMessageId = replyToMessageId;
            this.Options = options;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class SendMessageAlbum
    {
        /// <summary>
        /// Sends messages grouped together into an album. Currently only photo and video messages can be grouped into an album. Returns sent messages
        /// </summary>
        public SendMessageAlbum() { }
        /// <summary>
        /// Sends messages grouped together into an album. Currently only photo and video messages can be grouped into an album. Returns sent messages
        /// </summary>
        /// <param name="chatId">Target chat</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the messages will be sent</param>
        /// <param name="replyToMessageId">Identifier of a message to reply to or 0</param>
        /// <param name="options">Options to be used to send the messages</param>
        /// <param name="inputMessageContents">Contents of messages to be sent</param>
        public SendMessageAlbum(long chatId = default, long messageThreadId = default, long replyToMessageId = default, MessageSendOptions options = default, InputMessageContent[] inputMessageContents = default)
        {
            this.ChatId = chatId;
            this.MessageThreadId = messageThreadId;
            this.ReplyToMessageId = replyToMessageId;
            this.Options = options;
            this.InputMessageContents = inputMessageContents;
        }
    }

    public partial class SendBotStartMessage
    {
        /// <summary>
        /// Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
        /// </summary>
        public SendBotStartMessage() { }
        /// <summary>
        /// Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
        /// </summary>
        /// <param name="botUserId">Identifier of the bot</param>
        /// <param name="chatId">Identifier of the target chat</param>
        /// <param name="parameter">A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking)</param>
        public SendBotStartMessage(int botUserId = default, long chatId = default, string parameter = default)
        {
            this.BotUserId = botUserId;
            this.ChatId = chatId;
            this.Parameter = parameter;
        }
    }

    public partial class SendInlineQueryResultMessage
    {
        /// <summary>
        /// Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
        /// </summary>
        public SendInlineQueryResultMessage() { }
        /// <summary>
        /// Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
        /// </summary>
        /// <param name="chatId">Target chat</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the message will be sent</param>
        /// <param name="replyToMessageId">Identifier of a message to reply to or 0</param>
        /// <param name="options">Options to be used to send the message</param>
        /// <param name="queryId">Identifier of the inline query</param>
        /// <param name="resultId">Identifier of the inline result</param>
        /// <param name="hideViaBot">If true, there will be no mention of a bot, via which the message is sent. Can be used only for bots GetOption("animation_search_bot_username"), GetOption("photo_search_bot_username") and GetOption("venue_search_bot_username")</param>
        public SendInlineQueryResultMessage(long chatId = default, long messageThreadId = default, long replyToMessageId = default, MessageSendOptions options = default, long queryId = default, string resultId = default, bool hideViaBot = default)
        {
            this.ChatId = chatId;
            this.MessageThreadId = messageThreadId;
            this.ReplyToMessageId = replyToMessageId;
            this.Options = options;
            this.QueryId = queryId;
            this.ResultId = resultId;
            this.HideViaBot = hideViaBot;
        }
    }

    public partial class ForwardMessages
    {
        /// <summary>
        /// Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message
        /// </summary>
        public ForwardMessages() { }
        /// <summary>
        /// Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which to forward messages</param>
        /// <param name="fromChatId">Identifier of the chat from which to forward messages</param>
        /// <param name="messageIds">Identifiers of the messages to forward. Message identifiers must be in a strictly increasing order</param>
        /// <param name="options">Options to be used to send the messages</param>
        /// <param name="sendCopy">True, if content of the messages needs to be copied without links to the original messages. Always true if the messages are forwarded to a secret chat</param>
        /// <param name="removeCaption">True, if media caption of message copies needs to be removed. Ignored if send_copy is false</param>
        public ForwardMessages(long chatId = default, long fromChatId = default, long[] messageIds = default, MessageSendOptions options = default, bool sendCopy = default, bool removeCaption = default)
        {
            this.ChatId = chatId;
            this.FromChatId = fromChatId;
            this.MessageIds = messageIds;
            this.Options = options;
            this.SendCopy = sendCopy;
            this.RemoveCaption = removeCaption;
        }
    }

    public partial class ResendMessages
    {
        /// <summary>
        /// Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed. -If a message is re-sent, the corresponding failed to send message is deleted. Returns the sent messages in the same order as the message identifiers passed in message_ids. If a message can't be re-sent, null will be returned instead of the message
        /// </summary>
        public ResendMessages() { }
        /// <summary>
        /// Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed. -If a message is re-sent, the corresponding failed to send message is deleted. Returns the sent messages in the same order as the message identifiers passed in message_ids. If a message can't be re-sent, null will be returned instead of the message
        /// </summary>
        /// <param name="chatId">Identifier of the chat to send messages</param>
        /// <param name="messageIds">Identifiers of the messages to resend. Message identifiers must be in a strictly increasing order</param>
        public ResendMessages(long chatId = default, long[] messageIds = default)
        {
            this.ChatId = chatId;
            this.MessageIds = messageIds;
        }
    }

    public partial class SendChatSetTtlMessage
    {
        /// <summary>
        /// Changes the current TTL setting (sets a new self-destruct timer) in a secret chat and sends the corresponding message
        /// </summary>
        public SendChatSetTtlMessage() { }
        /// <summary>
        /// Changes the current TTL setting (sets a new self-destruct timer) in a secret chat and sends the corresponding message
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="ttl">New TTL value, in seconds</param>
        public SendChatSetTtlMessage(long chatId = default, int ttl = default)
        {
            this.ChatId = chatId;
            this.Ttl = ttl;
        }
    }

    public partial class SendChatScreenshotTakenNotification
    {
        /// <summary>
        /// Sends a notification about a screenshot taken in a chat. Supported only in private and secret chats
        /// </summary>
        public SendChatScreenshotTakenNotification() { }
        /// <summary>
        /// Sends a notification about a screenshot taken in a chat. Supported only in private and secret chats
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public SendChatScreenshotTakenNotification(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class AddLocalMessage
    {
        /// <summary>
        /// Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message
        /// </summary>
        public AddLocalMessage() { }
        /// <summary>
        /// Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message
        /// </summary>
        /// <param name="chatId">Target chat</param>
        /// <param name="senderUserId">Identifier of the user who will be shown as the sender of the message; may be 0 for channel posts</param>
        /// <param name="replyToMessageId">Identifier of the message to reply to or 0</param>
        /// <param name="disableNotification">Pass true to disable notification for the message</param>
        /// <param name="inputMessageContent">The content of the message to be added</param>
        public AddLocalMessage(long chatId = default, int senderUserId = default, long replyToMessageId = default, bool disableNotification = default, InputMessageContent inputMessageContent = default)
        {
            this.ChatId = chatId;
            this.SenderUserId = senderUserId;
            this.ReplyToMessageId = replyToMessageId;
            this.DisableNotification = disableNotification;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class DeleteMessages
    {
        /// <summary>
        /// Deletes messages
        /// </summary>
        public DeleteMessages() { }
        /// <summary>
        /// Deletes messages
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageIds">Identifiers of the messages to be deleted</param>
        /// <param name="revoke">Pass true to try to delete messages for all chat members. Always true for supergroups, channels and secret chats</param>
        public DeleteMessages(long chatId = default, long[] messageIds = default, bool revoke = default)
        {
            this.ChatId = chatId;
            this.MessageIds = messageIds;
            this.Revoke = revoke;
        }
    }

    public partial class DeleteChatMessagesFromUser
    {
        /// <summary>
        /// Deletes all messages sent by the specified user to a chat. Supported only for supergroups; requires can_delete_messages administrator privileges
        /// </summary>
        public DeleteChatMessagesFromUser() { }
        /// <summary>
        /// Deletes all messages sent by the specified user to a chat. Supported only for supergroups; requires can_delete_messages administrator privileges
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userId">User identifier</param>
        public DeleteChatMessagesFromUser(long chatId = default, int userId = default)
        {
            this.ChatId = chatId;
            this.UserId = userId;
        }
    }

    public partial class EditMessageText
    {
        /// <summary>
        /// Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side
        /// </summary>
        public EditMessageText() { }
        /// <summary>
        /// Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="replyMarkup">The new message reply markup; for bots only</param>
        /// <param name="inputMessageContent">New text content of the message. Should be of type InputMessageText</param>
        public EditMessageText(long chatId = default, long messageId = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class EditMessageLiveLocation
    {
        /// <summary>
        /// Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side
        /// </summary>
        public EditMessageLiveLocation() { }
        /// <summary>
        /// Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="replyMarkup">The new message reply markup; for bots only</param>
        /// <param name="location">New location content of the message; may be null. Pass null to stop sharing the live location</param>
        public EditMessageLiveLocation(long chatId = default, long messageId = default, ReplyMarkup replyMarkup = default, Location location = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.ReplyMarkup = replyMarkup;
            this.Location = location;
        }
    }

    public partial class EditMessageMedia
    {
        /// <summary>
        /// Edits the content of a message with an animation, an audio, a document, a photo or a video. The media in the message can't be replaced if the message was set to self-destruct. Media can't be replaced by self-destructing media. Media in an album can be edited only to contain a photo or a video. Returns the edited message after the edit is completed on the server side
        /// </summary>
        public EditMessageMedia() { }
        /// <summary>
        /// Edits the content of a message with an animation, an audio, a document, a photo or a video. The media in the message can't be replaced if the message was set to self-destruct. Media can't be replaced by self-destructing media. Media in an album can be edited only to contain a photo or a video. Returns the edited message after the edit is completed on the server side
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="replyMarkup">The new message reply markup; for bots only</param>
        /// <param name="inputMessageContent">New content of the message. Must be one of the following types: InputMessageAnimation, InputMessageAudio, InputMessageDocument, InputMessagePhoto or InputMessageVideo</param>
        public EditMessageMedia(long chatId = default, long messageId = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class EditMessageCaption
    {
        /// <summary>
        /// Edits the message content caption. Returns the edited message after the edit is completed on the server side
        /// </summary>
        public EditMessageCaption() { }
        /// <summary>
        /// Edits the message content caption. Returns the edited message after the edit is completed on the server side
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="replyMarkup">The new message reply markup; for bots only</param>
        /// <param name="caption">New message content caption; 0-GetOption("message_caption_length_max") characters</param>
        public EditMessageCaption(long chatId = default, long messageId = default, ReplyMarkup replyMarkup = default, FormattedText caption = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.ReplyMarkup = replyMarkup;
            this.Caption = caption;
        }
    }

    public partial class EditMessageReplyMarkup
    {
        /// <summary>
        /// Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side
        /// </summary>
        public EditMessageReplyMarkup() { }
        /// <summary>
        /// Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="replyMarkup">The new message reply markup</param>
        public EditMessageReplyMarkup(long chatId = default, long messageId = default, ReplyMarkup replyMarkup = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.ReplyMarkup = replyMarkup;
        }
    }

    public partial class EditInlineMessageText
    {
        /// <summary>
        /// Edits the text of an inline text or game message sent via a bot; for bots only
        /// </summary>
        public EditInlineMessageText() { }
        /// <summary>
        /// Edits the text of an inline text or game message sent via a bot; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="replyMarkup">The new message reply markup</param>
        /// <param name="inputMessageContent">New text content of the message. Should be of type InputMessageText</param>
        public EditInlineMessageText(string inlineMessageId = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.InlineMessageId = inlineMessageId;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class EditInlineMessageLiveLocation
    {
        /// <summary>
        /// Edits the content of a live location in an inline message sent via a bot; for bots only
        /// </summary>
        public EditInlineMessageLiveLocation() { }
        /// <summary>
        /// Edits the content of a live location in an inline message sent via a bot; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="replyMarkup">The new message reply markup</param>
        /// <param name="location">New location content of the message; may be null. Pass null to stop sharing the live location</param>
        public EditInlineMessageLiveLocation(string inlineMessageId = default, ReplyMarkup replyMarkup = default, Location location = default)
        {
            this.InlineMessageId = inlineMessageId;
            this.ReplyMarkup = replyMarkup;
            this.Location = location;
        }
    }

    public partial class EditInlineMessageMedia
    {
        /// <summary>
        /// Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only
        /// </summary>
        public EditInlineMessageMedia() { }
        /// <summary>
        /// Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="replyMarkup">The new message reply markup; for bots only</param>
        /// <param name="inputMessageContent">New content of the message. Must be one of the following types: InputMessageAnimation, InputMessageAudio, InputMessageDocument, InputMessagePhoto or InputMessageVideo</param>
        public EditInlineMessageMedia(string inlineMessageId = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            this.InlineMessageId = inlineMessageId;
            this.ReplyMarkup = replyMarkup;
            this.InputMessageContent = inputMessageContent;
        }
    }

    public partial class EditInlineMessageCaption
    {
        /// <summary>
        /// Edits the caption of an inline message sent via a bot; for bots only
        /// </summary>
        public EditInlineMessageCaption() { }
        /// <summary>
        /// Edits the caption of an inline message sent via a bot; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="replyMarkup">The new message reply markup</param>
        /// <param name="caption">New message content caption; 0-GetOption("message_caption_length_max") characters</param>
        public EditInlineMessageCaption(string inlineMessageId = default, ReplyMarkup replyMarkup = default, FormattedText caption = default)
        {
            this.InlineMessageId = inlineMessageId;
            this.ReplyMarkup = replyMarkup;
            this.Caption = caption;
        }
    }

    public partial class EditInlineMessageReplyMarkup
    {
        /// <summary>
        /// Edits the reply markup of an inline message sent via a bot; for bots only
        /// </summary>
        public EditInlineMessageReplyMarkup() { }
        /// <summary>
        /// Edits the reply markup of an inline message sent via a bot; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="replyMarkup">The new message reply markup</param>
        public EditInlineMessageReplyMarkup(string inlineMessageId = default, ReplyMarkup replyMarkup = default)
        {
            this.InlineMessageId = inlineMessageId;
            this.ReplyMarkup = replyMarkup;
        }
    }

    public partial class EditMessageSchedulingState
    {
        /// <summary>
        /// Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed
        /// </summary>
        public EditMessageSchedulingState() { }
        /// <summary>
        /// Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="schedulingState">The new message scheduling state. Pass null to send the message immediately</param>
        public EditMessageSchedulingState(long chatId = default, long messageId = default, MessageSchedulingState schedulingState = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.SchedulingState = schedulingState;
        }
    }

    public partial class GetTextEntities
    {
        /// <summary>
        /// Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) contained in the text. Can be called synchronously
        /// </summary>
        public GetTextEntities() { }
        /// <summary>
        /// Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) contained in the text. Can be called synchronously
        /// </summary>
        /// <param name="text">The text in which to look for entites</param>
        public GetTextEntities(string text = default)
        {
            this.Text = text;
        }
    }

    public partial class ParseTextEntities
    {
        /// <summary>
        /// Parses Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and MentionName entities contained in the text. Can be called synchronously
        /// </summary>
        public ParseTextEntities() { }
        /// <summary>
        /// Parses Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and MentionName entities contained in the text. Can be called synchronously
        /// </summary>
        /// <param name="text">The text to parse</param>
        /// <param name="parseMode">Text parse mode</param>
        public ParseTextEntities(string text = default, TextParseMode parseMode = default)
        {
            this.Text = text;
            this.ParseMode = parseMode;
        }
    }

    public partial class ParseMarkdown
    {
        /// <summary>
        /// Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
        /// </summary>
        public ParseMarkdown() { }
        /// <summary>
        /// Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
        /// </summary>
        /// <param name="text">The text to parse. For example, "__italic__ ~~strikethrough~~ **bold** `code` ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**"</param>
        public ParseMarkdown(FormattedText text = default)
        {
            this.Text = text;
        }
    }

    public partial class GetMarkdownText
    {
        /// <summary>
        /// Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
        /// </summary>
        public GetMarkdownText() { }
        /// <summary>
        /// Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
        /// </summary>
        /// <param name="text">The text</param>
        public GetMarkdownText(FormattedText text = default)
        {
            this.Text = text;
        }
    }

    public partial class GetFileMimeType
    {
        /// <summary>
        /// Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        public GetFileMimeType() { }
        /// <summary>
        /// Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        /// <param name="fileName">The name of the file or path to the file</param>
        public GetFileMimeType(string fileName = default)
        {
            this.FileName = fileName;
        }
    }

    public partial class GetFileExtension
    {
        /// <summary>
        /// Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        public GetFileExtension() { }
        /// <summary>
        /// Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        /// <param name="mimeType">The MIME type of the file</param>
        public GetFileExtension(string mimeType = default)
        {
            this.MimeType = mimeType;
        }
    }

    public partial class CleanFileName
    {
        /// <summary>
        /// Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        public CleanFileName() { }
        /// <summary>
        /// Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        /// <param name="fileName">File name or path to the file</param>
        public CleanFileName(string fileName = default)
        {
            this.FileName = fileName;
        }
    }

    public partial class GetLanguagePackString
    {
        /// <summary>
        /// Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
        /// </summary>
        public GetLanguagePackString() { }
        /// <summary>
        /// Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
        /// </summary>
        /// <param name="languagePackDatabasePath">Path to the language pack database in which strings are stored</param>
        /// <param name="localizationTarget">Localization target to which the language pack belongs</param>
        /// <param name="languagePackId">Language pack identifier</param>
        /// <param name="key">Language pack key of the string to be returned</param>
        public GetLanguagePackString(string languagePackDatabasePath = default, string localizationTarget = default, string languagePackId = default, string key = default)
        {
            this.LanguagePackDatabasePath = languagePackDatabasePath;
            this.LocalizationTarget = localizationTarget;
            this.LanguagePackId = languagePackId;
            this.Key = key;
        }
    }

    public partial class GetJsonValue
    {
        /// <summary>
        /// Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
        /// </summary>
        public GetJsonValue() { }
        /// <summary>
        /// Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
        /// </summary>
        /// <param name="json">The JSON-serialized string</param>
        public GetJsonValue(string json = default)
        {
            this.Json = json;
        }
    }

    public partial class GetJsonString
    {
        /// <summary>
        /// Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
        /// </summary>
        public GetJsonString() { }
        /// <summary>
        /// Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
        /// </summary>
        /// <param name="jsonValue">The JsonValue object</param>
        public GetJsonString(JsonValue jsonValue = default)
        {
            this.JsonValue = jsonValue;
        }
    }

    public partial class SetPollAnswer
    {
        /// <summary>
        /// Changes the user answer to a poll. A poll in quiz mode can be answered only once
        /// </summary>
        public SetPollAnswer() { }
        /// <summary>
        /// Changes the user answer to a poll. A poll in quiz mode can be answered only once
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which the poll belongs</param>
        /// <param name="messageId">Identifier of the message containing the poll</param>
        /// <param name="optionIds">0-based identifiers of answer options, chosen by the user. User can choose more than 1 answer option only is the poll allows multiple answers</param>
        public SetPollAnswer(long chatId = default, long messageId = default, int[] optionIds = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.OptionIds = optionIds;
        }
    }

    public partial class GetPollVoters
    {
        /// <summary>
        /// Returns users voted for the specified option in a non-anonymous polls. For the optimal performance the number of returned users is chosen by the library
        /// </summary>
        public GetPollVoters() { }
        /// <summary>
        /// Returns users voted for the specified option in a non-anonymous polls. For the optimal performance the number of returned users is chosen by the library
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which the poll belongs</param>
        /// <param name="messageId">Identifier of the message containing the poll</param>
        /// <param name="optionId">0-based identifier of the answer option</param>
        /// <param name="offset">Number of users to skip in the result; must be non-negative</param>
        /// <param name="limit">The maximum number of users to be returned; must be positive and can't be greater than 50. Fewer users may be returned than specified by the limit, even if the end of the voter list has not been reached</param>
        public GetPollVoters(long chatId = default, long messageId = default, int optionId = default, int offset = default, int limit = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.OptionId = optionId;
            this.Offset = offset;
            this.Limit = limit;
        }
    }

    public partial class StopPoll
    {
        /// <summary>
        /// Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag set
        /// </summary>
        public StopPoll() { }
        /// <summary>
        /// Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag set
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which the poll belongs</param>
        /// <param name="messageId">Identifier of the message containing the poll</param>
        /// <param name="replyMarkup">The new message reply markup; for bots only</param>
        public StopPoll(long chatId = default, long messageId = default, ReplyMarkup replyMarkup = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.ReplyMarkup = replyMarkup;
        }
    }

    public partial class HideSuggestedAction
    {
        /// <summary>
        /// Hides a suggested action
        /// </summary>
        public HideSuggestedAction() { }
        /// <summary>
        /// Hides a suggested action
        /// </summary>
        /// <param name="action">Suggested action to hide</param>
        public HideSuggestedAction(SuggestedAction action = default)
        {
            this.Action = action;
        }
    }

    public partial class GetLoginUrlInfo
    {
        /// <summary>
        /// Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button
        /// </summary>
        public GetLoginUrlInfo() { }
        /// <summary>
        /// Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button
        /// </summary>
        /// <param name="chatId">Chat identifier of the message with the button</param>
        /// <param name="messageId">Message identifier of the message with the button</param>
        /// <param name="buttonId">Button identifier</param>
        public GetLoginUrlInfo(long chatId = default, long messageId = default, int buttonId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.ButtonId = buttonId;
        }
    }

    public partial class GetLoginUrl
    {
        /// <summary>
        /// Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl. -Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button
        /// </summary>
        public GetLoginUrl() { }
        /// <summary>
        /// Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl. -Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button
        /// </summary>
        /// <param name="chatId">Chat identifier of the message with the button</param>
        /// <param name="messageId">Message identifier of the message with the button</param>
        /// <param name="buttonId">Button identifier</param>
        /// <param name="allowWriteAccess">True, if the user allowed the bot to send them messages</param>
        public GetLoginUrl(long chatId = default, long messageId = default, int buttonId = default, bool allowWriteAccess = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.ButtonId = buttonId;
            this.AllowWriteAccess = allowWriteAccess;
        }
    }

    public partial class GetInlineQueryResults
    {
        /// <summary>
        /// Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
        /// </summary>
        public GetInlineQueryResults() { }
        /// <summary>
        /// Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
        /// </summary>
        /// <param name="botUserId">The identifier of the target bot</param>
        /// <param name="chatId">Identifier of the chat where the query was sent</param>
        /// <param name="userLocation">Location of the user, only if needed</param>
        /// <param name="query">Text of the query</param>
        /// <param name="offset">Offset of the first entry to return</param>
        public GetInlineQueryResults(int botUserId = default, long chatId = default, Location userLocation = default, string query = default, string offset = default)
        {
            this.BotUserId = botUserId;
            this.ChatId = chatId;
            this.UserLocation = userLocation;
            this.Query = query;
            this.Offset = offset;
        }
    }

    public partial class AnswerInlineQuery
    {
        /// <summary>
        /// Sets the result of an inline query; for bots only
        /// </summary>
        public AnswerInlineQuery() { }
        /// <summary>
        /// Sets the result of an inline query; for bots only
        /// </summary>
        /// <param name="inlineQueryId">Identifier of the inline query</param>
        /// <param name="isPersonal">True, if the result of the query can be cached for the specified user</param>
        /// <param name="results">The results of the query</param>
        /// <param name="cacheTime">Allowed time to cache the results of the query, in seconds</param>
        /// <param name="nextOffset">Offset for the next inline query; pass an empty string if there are no more results</param>
        /// <param name="switchPmText">If non-empty, this text should be shown on the button that opens a private chat with the bot and sends a start message to the bot with the parameter switch_pm_parameter</param>
        /// <param name="switchPmParameter">The parameter for the bot start message</param>
        public AnswerInlineQuery(long inlineQueryId = default, bool isPersonal = default, InputInlineQueryResult[] results = default, int cacheTime = default, string nextOffset = default, string switchPmText = default, string switchPmParameter = default)
        {
            this.InlineQueryId = inlineQueryId;
            this.IsPersonal = isPersonal;
            this.Results = results;
            this.CacheTime = cacheTime;
            this.NextOffset = nextOffset;
            this.SwitchPmText = switchPmText;
            this.SwitchPmParameter = switchPmParameter;
        }
    }

    public partial class GetCallbackQueryAnswer
    {
        /// <summary>
        /// Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
        /// </summary>
        public GetCallbackQueryAnswer() { }
        /// <summary>
        /// Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
        /// </summary>
        /// <param name="chatId">Identifier of the chat with the message</param>
        /// <param name="messageId">Identifier of the message from which the query originated</param>
        /// <param name="payload">Query payload</param>
        public GetCallbackQueryAnswer(long chatId = default, long messageId = default, CallbackQueryPayload payload = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.Payload = payload;
        }
    }

    public partial class AnswerCallbackQuery
    {
        /// <summary>
        /// Sets the result of a callback query; for bots only
        /// </summary>
        public AnswerCallbackQuery() { }
        /// <summary>
        /// Sets the result of a callback query; for bots only
        /// </summary>
        /// <param name="callbackQueryId">Identifier of the callback query</param>
        /// <param name="text">Text of the answer</param>
        /// <param name="showAlert">If true, an alert should be shown to the user instead of a toast notification</param>
        /// <param name="url">URL to be opened</param>
        /// <param name="cacheTime">Time during which the result of the query can be cached, in seconds</param>
        public AnswerCallbackQuery(long callbackQueryId = default, string text = default, bool showAlert = default, string url = default, int cacheTime = default)
        {
            this.CallbackQueryId = callbackQueryId;
            this.Text = text;
            this.ShowAlert = showAlert;
            this.Url = url;
            this.CacheTime = cacheTime;
        }
    }

    public partial class AnswerShippingQuery
    {
        /// <summary>
        /// Sets the result of a shipping query; for bots only
        /// </summary>
        public AnswerShippingQuery() { }
        /// <summary>
        /// Sets the result of a shipping query; for bots only
        /// </summary>
        /// <param name="shippingQueryId">Identifier of the shipping query</param>
        /// <param name="shippingOptions">Available shipping options</param>
        /// <param name="errorMessage">An error message, empty on success</param>
        public AnswerShippingQuery(long shippingQueryId = default, ShippingOption[] shippingOptions = default, string errorMessage = default)
        {
            this.ShippingQueryId = shippingQueryId;
            this.ShippingOptions = shippingOptions;
            this.ErrorMessage = errorMessage;
        }
    }

    public partial class AnswerPreCheckoutQuery
    {
        /// <summary>
        /// Sets the result of a pre-checkout query; for bots only
        /// </summary>
        public AnswerPreCheckoutQuery() { }
        /// <summary>
        /// Sets the result of a pre-checkout query; for bots only
        /// </summary>
        /// <param name="preCheckoutQueryId">Identifier of the pre-checkout query</param>
        /// <param name="errorMessage">An error message, empty on success</param>
        public AnswerPreCheckoutQuery(long preCheckoutQueryId = default, string errorMessage = default)
        {
            this.PreCheckoutQueryId = preCheckoutQueryId;
            this.ErrorMessage = errorMessage;
        }
    }

    public partial class SetGameScore
    {
        /// <summary>
        /// Updates the game score of the specified user in the game; for bots only
        /// </summary>
        public SetGameScore() { }
        /// <summary>
        /// Updates the game score of the specified user in the game; for bots only
        /// </summary>
        /// <param name="chatId">The chat to which the message with the game belongs</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="editMessage">True, if the message should be edited</param>
        /// <param name="userId">User identifier</param>
        /// <param name="score">The new score</param>
        /// <param name="force">Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table</param>
        public SetGameScore(long chatId = default, long messageId = default, bool editMessage = default, int userId = default, int score = default, bool force = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.EditMessage = editMessage;
            this.UserId = userId;
            this.Score = score;
            this.Force = force;
        }
    }

    public partial class SetInlineGameScore
    {
        /// <summary>
        /// Updates the game score of the specified user in a game; for bots only
        /// </summary>
        public SetInlineGameScore() { }
        /// <summary>
        /// Updates the game score of the specified user in a game; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="editMessage">True, if the message should be edited</param>
        /// <param name="userId">User identifier</param>
        /// <param name="score">The new score</param>
        /// <param name="force">Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table</param>
        public SetInlineGameScore(string inlineMessageId = default, bool editMessage = default, int userId = default, int score = default, bool force = default)
        {
            this.InlineMessageId = inlineMessageId;
            this.EditMessage = editMessage;
            this.UserId = userId;
            this.Score = score;
            this.Force = force;
        }
    }

    public partial class GetGameHighScores
    {
        /// <summary>
        /// Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only
        /// </summary>
        public GetGameHighScores() { }
        /// <summary>
        /// Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only
        /// </summary>
        /// <param name="chatId">The chat that contains the message with the game</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="userId">User identifier</param>
        public GetGameHighScores(long chatId = default, long messageId = default, int userId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.UserId = userId;
        }
    }

    public partial class GetInlineGameHighScores
    {
        /// <summary>
        /// Returns game high scores and some part of the high score table in the range of the specified user; for bots only
        /// </summary>
        public GetInlineGameHighScores() { }
        /// <summary>
        /// Returns game high scores and some part of the high score table in the range of the specified user; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="userId">User identifier</param>
        public GetInlineGameHighScores(string inlineMessageId = default, int userId = default)
        {
            this.InlineMessageId = inlineMessageId;
            this.UserId = userId;
        }
    }

    public partial class DeleteChatReplyMarkup
    {
        /// <summary>
        /// Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if the reply markup will be changed
        /// </summary>
        public DeleteChatReplyMarkup() { }
        /// <summary>
        /// Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if the reply markup will be changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">The message identifier of the used keyboard</param>
        public DeleteChatReplyMarkup(long chatId = default, long messageId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
        }
    }

    public partial class SendChatAction
    {
        /// <summary>
        /// Sends a notification about user activity in a chat
        /// </summary>
        public SendChatAction() { }
        /// <summary>
        /// Sends a notification about user activity in a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the action was performed</param>
        /// <param name="action">The action description</param>
        public SendChatAction(long chatId = default, long messageThreadId = default, ChatAction action = default)
        {
            this.ChatId = chatId;
            this.MessageThreadId = messageThreadId;
            this.Action = action;
        }
    }

    public partial class OpenChat
    {
        /// <summary>
        /// Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
        /// </summary>
        public OpenChat() { }
        /// <summary>
        /// Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public OpenChat(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class CloseChat
    {
        /// <summary>
        /// Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed
        /// </summary>
        public CloseChat() { }
        /// <summary>
        /// Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public CloseChat(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class ViewMessages
    {
        /// <summary>
        /// Informs TDLib that messages are being viewed by the user. Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels)
        /// </summary>
        public ViewMessages() { }
        /// <summary>
        /// Informs TDLib that messages are being viewed by the user. Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels)
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the messages are being viewed</param>
        /// <param name="messageIds">The identifiers of the messages being viewed</param>
        /// <param name="forceRead">True, if messages in closed chats should be marked as read by the request</param>
        public ViewMessages(long chatId = default, long messageThreadId = default, long[] messageIds = default, bool forceRead = default)
        {
            this.ChatId = chatId;
            this.MessageThreadId = messageThreadId;
            this.MessageIds = messageIds;
            this.ForceRead = forceRead;
        }
    }

    public partial class OpenMessageContent
    {
        /// <summary>
        /// Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message). An updateMessageContentOpened update will be generated if something has changed
        /// </summary>
        public OpenMessageContent() { }
        /// <summary>
        /// Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message). An updateMessageContentOpened update will be generated if something has changed
        /// </summary>
        /// <param name="chatId">Chat identifier of the message</param>
        /// <param name="messageId">Identifier of the message with the opened content</param>
        public OpenMessageContent(long chatId = default, long messageId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
        }
    }

    public partial class ReadAllChatMentions
    {
        /// <summary>
        /// Marks all mentions in a chat as read
        /// </summary>
        public ReadAllChatMentions() { }
        /// <summary>
        /// Marks all mentions in a chat as read
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public ReadAllChatMentions(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class CreatePrivateChat
    {
        /// <summary>
        /// Returns an existing chat corresponding to a given user
        /// </summary>
        public CreatePrivateChat() { }
        /// <summary>
        /// Returns an existing chat corresponding to a given user
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="force">If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect</param>
        public CreatePrivateChat(int userId = default, bool force = default)
        {
            this.UserId = userId;
            this.Force = force;
        }
    }

    public partial class CreateBasicGroupChat
    {
        /// <summary>
        /// Returns an existing chat corresponding to a known basic group
        /// </summary>
        public CreateBasicGroupChat() { }
        /// <summary>
        /// Returns an existing chat corresponding to a known basic group
        /// </summary>
        /// <param name="basicGroupId">Basic group identifier</param>
        /// <param name="force">If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect</param>
        public CreateBasicGroupChat(int basicGroupId = default, bool force = default)
        {
            this.BasicGroupId = basicGroupId;
            this.Force = force;
        }
    }

    public partial class CreateSupergroupChat
    {
        /// <summary>
        /// Returns an existing chat corresponding to a known supergroup or channel
        /// </summary>
        public CreateSupergroupChat() { }
        /// <summary>
        /// Returns an existing chat corresponding to a known supergroup or channel
        /// </summary>
        /// <param name="supergroupId">Supergroup or channel identifier</param>
        /// <param name="force">If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect</param>
        public CreateSupergroupChat(int supergroupId = default, bool force = default)
        {
            this.SupergroupId = supergroupId;
            this.Force = force;
        }
    }

    public partial class CreateSecretChat
    {
        /// <summary>
        /// Returns an existing chat corresponding to a known secret chat
        /// </summary>
        public CreateSecretChat() { }
        /// <summary>
        /// Returns an existing chat corresponding to a known secret chat
        /// </summary>
        /// <param name="secretChatId">Secret chat identifier</param>
        public CreateSecretChat(int secretChatId = default)
        {
            this.SecretChatId = secretChatId;
        }
    }

    public partial class CreateNewBasicGroupChat
    {
        /// <summary>
        /// Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
        /// </summary>
        public CreateNewBasicGroupChat() { }
        /// <summary>
        /// Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
        /// </summary>
        /// <param name="userIds">Identifiers of users to be added to the basic group</param>
        /// <param name="title">Title of the new basic group; 1-128 characters</param>
        public CreateNewBasicGroupChat(int[] userIds = default, string title = default)
        {
            this.UserIds = userIds;
            this.Title = title;
        }
    }

    public partial class CreateNewSupergroupChat
    {
        /// <summary>
        /// Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
        /// </summary>
        public CreateNewSupergroupChat() { }
        /// <summary>
        /// Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
        /// </summary>
        /// <param name="title">Title of the new chat; 1-128 characters</param>
        /// <param name="isChannel">True, if a channel chat should be created</param>
        /// <param name="description">Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat</param>
        /// <param name="location">Chat location if a location-based supergroup is being created</param>
        public CreateNewSupergroupChat(string title = default, bool isChannel = default, string description = default, ChatLocation location = default)
        {
            this.Title = title;
            this.IsChannel = isChannel;
            this.Description = description;
            this.Location = location;
        }
    }

    public partial class CreateNewSecretChat
    {
        /// <summary>
        /// Creates a new secret chat. Returns the newly created chat
        /// </summary>
        public CreateNewSecretChat() { }
        /// <summary>
        /// Creates a new secret chat. Returns the newly created chat
        /// </summary>
        /// <param name="userId">Identifier of the target user</param>
        public CreateNewSecretChat(int userId = default)
        {
            this.UserId = userId;
        }
    }

    public partial class UpgradeBasicGroupChatToSupergroupChat
    {
        /// <summary>
        /// Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group
        /// </summary>
        public UpgradeBasicGroupChatToSupergroupChat() { }
        /// <summary>
        /// Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group
        /// </summary>
        /// <param name="chatId">Identifier of the chat to upgrade</param>
        public UpgradeBasicGroupChatToSupergroupChat(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class GetChatListsToAddChat
    {
        /// <summary>
        /// Returns chat lists to which the chat can be added. This is an offline request
        /// </summary>
        public GetChatListsToAddChat() { }
        /// <summary>
        /// Returns chat lists to which the chat can be added. This is an offline request
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public GetChatListsToAddChat(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class AddChatToList
    {
        /// <summary>
        /// Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed
        /// </summary>
        public AddChatToList() { }
        /// <summary>
        /// Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="chatList">The chat list. Use getChatListsToAddChat to get suitable chat lists</param>
        public AddChatToList(long chatId = default, ChatList chatList = default)
        {
            this.ChatId = chatId;
            this.ChatList = chatList;
        }
    }

    public partial class GetChatFilter
    {
        /// <summary>
        /// Returns information about a chat filter by its identifier
        /// </summary>
        public GetChatFilter() { }
        /// <summary>
        /// Returns information about a chat filter by its identifier
        /// </summary>
        /// <param name="chatFilterId">Chat filter identifier</param>
        public GetChatFilter(int chatFilterId = default)
        {
            this.ChatFilterId = chatFilterId;
        }
    }

    public partial class CreateChatFilter
    {
        /// <summary>
        /// Creates new chat filter. Returns information about the created chat filter
        /// </summary>
        public CreateChatFilter() { }
        /// <summary>
        /// Creates new chat filter. Returns information about the created chat filter
        /// </summary>
        /// <param name="filter">Chat filter</param>
        public CreateChatFilter(ChatFilter filter = default)
        {
            this.Filter = filter;
        }
    }

    public partial class EditChatFilter
    {
        /// <summary>
        /// Edits existing chat filter. Returns information about the edited chat filter
        /// </summary>
        public EditChatFilter() { }
        /// <summary>
        /// Edits existing chat filter. Returns information about the edited chat filter
        /// </summary>
        /// <param name="chatFilterId">Chat filter identifier</param>
        /// <param name="filter">The edited chat filter</param>
        public EditChatFilter(int chatFilterId = default, ChatFilter filter = default)
        {
            this.ChatFilterId = chatFilterId;
            this.Filter = filter;
        }
    }

    public partial class DeleteChatFilter
    {
        /// <summary>
        /// Deletes existing chat filter
        /// </summary>
        public DeleteChatFilter() { }
        /// <summary>
        /// Deletes existing chat filter
        /// </summary>
        /// <param name="chatFilterId">Chat filter identifier</param>
        public DeleteChatFilter(int chatFilterId = default)
        {
            this.ChatFilterId = chatFilterId;
        }
    }

    public partial class ReorderChatFilters
    {
        /// <summary>
        /// Changes the order of chat filters
        /// </summary>
        public ReorderChatFilters() { }
        /// <summary>
        /// Changes the order of chat filters
        /// </summary>
        /// <param name="chatFilterIds">Identifiers of chat filters in the new correct order</param>
        public ReorderChatFilters(int[] chatFilterIds = default)
        {
            this.ChatFilterIds = chatFilterIds;
        }
    }

    public partial class GetRecommendedChatFilters
    {
        /// <summary>
        /// Returns recommended chat filters for the current user
        /// </summary>
        public GetRecommendedChatFilters() { }
    }

    public partial class GetChatFilterDefaultIconName
    {
        /// <summary>
        /// Returns default icon name for a filter. Can be called synchronously
        /// </summary>
        public GetChatFilterDefaultIconName() { }
        /// <summary>
        /// Returns default icon name for a filter. Can be called synchronously
        /// </summary>
        /// <param name="filter">Chat filter</param>
        public GetChatFilterDefaultIconName(ChatFilter filter = default)
        {
            this.Filter = filter;
        }
    }

    public partial class SetChatTitle
    {
        /// <summary>
        /// Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info rights
        /// </summary>
        public SetChatTitle() { }
        /// <summary>
        /// Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info rights
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="title">New title of the chat; 1-128 characters</param>
        public SetChatTitle(long chatId = default, string title = default)
        {
            this.ChatId = chatId;
            this.Title = title;
        }
    }

    public partial class SetChatPhoto
    {
        /// <summary>
        /// Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info rights
        /// </summary>
        public SetChatPhoto() { }
        /// <summary>
        /// Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info rights
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="photo">New chat photo. Pass null to delete the chat photo</param>
        public SetChatPhoto(long chatId = default, InputChatPhoto photo = default)
        {
            this.ChatId = chatId;
            this.Photo = photo;
        }
    }

    public partial class SetChatPermissions
    {
        /// <summary>
        /// Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right
        /// </summary>
        public SetChatPermissions() { }
        /// <summary>
        /// Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="permissions">New non-administrator members permissions in the chat</param>
        public SetChatPermissions(long chatId = default, ChatPermissions permissions = default)
        {
            this.ChatId = chatId;
            this.Permissions = permissions;
        }
    }

    public partial class SetChatDraftMessage
    {
        /// <summary>
        /// Changes the draft message in a chat
        /// </summary>
        public SetChatDraftMessage() { }
        /// <summary>
        /// Changes the draft message in a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the draft was changed</param>
        /// <param name="draftMessage">New draft message; may be null</param>
        public SetChatDraftMessage(long chatId = default, long messageThreadId = default, DraftMessage draftMessage = default)
        {
            this.ChatId = chatId;
            this.MessageThreadId = messageThreadId;
            this.DraftMessage = draftMessage;
        }
    }

    public partial class SetChatNotificationSettings
    {
        /// <summary>
        /// Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed
        /// </summary>
        public SetChatNotificationSettings() { }
        /// <summary>
        /// Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="notificationSettings">New notification settings for the chat. If the chat is muted for more than 1 week, it is considered to be muted forever</param>
        public SetChatNotificationSettings(long chatId = default, ChatNotificationSettings notificationSettings = default)
        {
            this.ChatId = chatId;
            this.NotificationSettings = notificationSettings;
        }
    }

    public partial class ToggleChatIsMarkedAsUnread
    {
        /// <summary>
        /// Changes the marked as unread state of a chat
        /// </summary>
        public ToggleChatIsMarkedAsUnread() { }
        /// <summary>
        /// Changes the marked as unread state of a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="isMarkedAsUnread">New value of is_marked_as_unread</param>
        public ToggleChatIsMarkedAsUnread(long chatId = default, bool isMarkedAsUnread = default)
        {
            this.ChatId = chatId;
            this.IsMarkedAsUnread = isMarkedAsUnread;
        }
    }

    public partial class ToggleChatIsBlocked
    {
        /// <summary>
        /// Changes the block state of a chat. Currently, only private chats and supergroups can be blocked
        /// </summary>
        public ToggleChatIsBlocked() { }
        /// <summary>
        /// Changes the block state of a chat. Currently, only private chats and supergroups can be blocked
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="isBlocked">New value of is_blocked</param>
        public ToggleChatIsBlocked(long chatId = default, bool isBlocked = default)
        {
            this.ChatId = chatId;
            this.IsBlocked = isBlocked;
        }
    }

    public partial class ToggleChatDefaultDisableNotification
    {
        /// <summary>
        /// Changes the value of the default disable_notification parameter, used when a message is sent to a chat
        /// </summary>
        public ToggleChatDefaultDisableNotification() { }
        /// <summary>
        /// Changes the value of the default disable_notification parameter, used when a message is sent to a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="defaultDisableNotification">New value of default_disable_notification</param>
        public ToggleChatDefaultDisableNotification(long chatId = default, bool defaultDisableNotification = default)
        {
            this.ChatId = chatId;
            this.DefaultDisableNotification = defaultDisableNotification;
        }
    }

    public partial class SetChatClientData
    {
        /// <summary>
        /// Changes application-specific data associated with a chat
        /// </summary>
        public SetChatClientData() { }
        /// <summary>
        /// Changes application-specific data associated with a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="clientData">New value of client_data</param>
        public SetChatClientData(long chatId = default, string clientData = default)
        {
            this.ChatId = chatId;
            this.ClientData = clientData;
        }
    }

    public partial class SetChatDescription
    {
        /// <summary>
        /// Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info rights
        /// </summary>
        public SetChatDescription() { }
        /// <summary>
        /// Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info rights
        /// </summary>
        /// <param name="chatId">Identifier of the chat</param>
        /// <param name="description">Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info rights</param>
        public SetChatDescription(long chatId = default, string description = default)
        {
            this.ChatId = chatId;
            this.Description = description;
        }
    }

    public partial class SetChatDiscussionGroup
    {
        /// <summary>
        /// Changes the discussion group of a channel chat; requires can_change_info rights in the channel if it is specified
        /// </summary>
        public SetChatDiscussionGroup() { }
        /// <summary>
        /// Changes the discussion group of a channel chat; requires can_change_info rights in the channel if it is specified
        /// </summary>
        /// <param name="chatId">Identifier of the channel chat. Pass 0 to remove a link from the supergroup passed in the second argument to a linked channel chat (requires can_pin_messages rights in the supergroup)</param>
        /// <param name="discussionChatId">Identifier of a new channel's discussion group. Use 0 to remove the discussion group. -Use the method getSuitableDiscussionChats to find all suitable groups. Basic group chats need to be first upgraded to supergroup chats. If new chat members don't have access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable needs to be used first to change that</param>
        public SetChatDiscussionGroup(long chatId = default, long discussionChatId = default)
        {
            this.ChatId = chatId;
            this.DiscussionChatId = discussionChatId;
        }
    }

    public partial class SetChatLocation
    {
        /// <summary>
        /// Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use
        /// </summary>
        public SetChatLocation() { }
        /// <summary>
        /// Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="location">New location for the chat; must be valid and not null</param>
        public SetChatLocation(long chatId = default, ChatLocation location = default)
        {
            this.ChatId = chatId;
            this.Location = location;
        }
    }

    public partial class SetChatSlowModeDelay
    {
        /// <summary>
        /// Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights
        /// </summary>
        public SetChatSlowModeDelay() { }
        /// <summary>
        /// Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="slowModeDelay">New slow mode delay for the chat; must be one of 0, 10, 30, 60, 300, 900, 3600</param>
        public SetChatSlowModeDelay(long chatId = default, int slowModeDelay = default)
        {
            this.ChatId = chatId;
            this.SlowModeDelay = slowModeDelay;
        }
    }

    public partial class PinChatMessage
    {
        /// <summary>
        /// Pins a message in a chat; requires can_pin_messages rights
        /// </summary>
        public PinChatMessage() { }
        /// <summary>
        /// Pins a message in a chat; requires can_pin_messages rights
        /// </summary>
        /// <param name="chatId">Identifier of the chat</param>
        /// <param name="messageId">Identifier of the new pinned message</param>
        /// <param name="disableNotification">True, if there should be no notification about the pinned message</param>
        public PinChatMessage(long chatId = default, long messageId = default, bool disableNotification = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.DisableNotification = disableNotification;
        }
    }

    public partial class UnpinChatMessage
    {
        /// <summary>
        /// Removes the pinned message from a chat; requires can_pin_messages rights in the group or channel
        /// </summary>
        public UnpinChatMessage() { }
        /// <summary>
        /// Removes the pinned message from a chat; requires can_pin_messages rights in the group or channel
        /// </summary>
        /// <param name="chatId">Identifier of the chat</param>
        public UnpinChatMessage(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class JoinChat
    {
        /// <summary>
        /// Adds current user as a new member to a chat. Private and secret chats can't be joined using this method
        /// </summary>
        public JoinChat() { }
        /// <summary>
        /// Adds current user as a new member to a chat. Private and secret chats can't be joined using this method
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public JoinChat(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class LeaveChat
    {
        /// <summary>
        /// Removes current user from chat members. Private and secret chats can't be left using this method
        /// </summary>
        public LeaveChat() { }
        /// <summary>
        /// Removes current user from chat members. Private and secret chats can't be left using this method
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public LeaveChat(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class AddChatMember
    {
        /// <summary>
        /// Adds a new member to a chat. Members can't be added to private or secret chats. Members will not be added until the chat state has been synchronized with the server
        /// </summary>
        public AddChatMember() { }
        /// <summary>
        /// Adds a new member to a chat. Members can't be added to private or secret chats. Members will not be added until the chat state has been synchronized with the server
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userId">Identifier of the user</param>
        /// <param name="forwardLimit">The number of earlier messages from the chat to be forwarded to the new member; up to 100. Ignored for supergroups and channels</param>
        public AddChatMember(long chatId = default, int userId = default, int forwardLimit = default)
        {
            this.ChatId = chatId;
            this.UserId = userId;
            this.ForwardLimit = forwardLimit;
        }
    }

    public partial class AddChatMembers
    {
        /// <summary>
        /// Adds multiple new members to a chat. Currently this option is only available for supergroups and channels. This option can't be used to join a chat. Members can't be added to a channel if it has more than 200 members. Members will not be added until the chat state has been synchronized with the server
        /// </summary>
        public AddChatMembers() { }
        /// <summary>
        /// Adds multiple new members to a chat. Currently this option is only available for supergroups and channels. This option can't be used to join a chat. Members can't be added to a channel if it has more than 200 members. Members will not be added until the chat state has been synchronized with the server
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userIds">Identifiers of the users to be added to the chat</param>
        public AddChatMembers(long chatId = default, int[] userIds = default)
        {
            this.ChatId = chatId;
            this.UserIds = userIds;
        }
    }

    public partial class SetChatMemberStatus
    {
        /// <summary>
        /// Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for adding new members to the chat and transferring chat ownership; instead, use addChatMember or transferChatOwnership. The chat member status will not be changed until it has been synchronized with the server
        /// </summary>
        public SetChatMemberStatus() { }
        /// <summary>
        /// Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for adding new members to the chat and transferring chat ownership; instead, use addChatMember or transferChatOwnership. The chat member status will not be changed until it has been synchronized with the server
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userId">User identifier</param>
        /// <param name="status">The new status of the member in the chat</param>
        public SetChatMemberStatus(long chatId = default, int userId = default, ChatMemberStatus status = default)
        {
            this.ChatId = chatId;
            this.UserId = userId;
            this.Status = status;
        }
    }

    public partial class CanTransferOwnership
    {
        /// <summary>
        /// Checks whether the current session can be used to transfer a chat ownership to another user
        /// </summary>
        public CanTransferOwnership() { }
    }

    public partial class TransferChatOwnership
    {
        /// <summary>
        /// Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats
        /// </summary>
        public TransferChatOwnership() { }
        /// <summary>
        /// Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userId">Identifier of the user to which transfer the ownership. The ownership can't be transferred to a bot or to a deleted user</param>
        /// <param name="password">The password of the current user</param>
        public TransferChatOwnership(long chatId = default, int userId = default, string password = default)
        {
            this.ChatId = chatId;
            this.UserId = userId;
            this.Password = password;
        }
    }

    public partial class GetChatMember
    {
        /// <summary>
        /// Returns information about a single member of a chat
        /// </summary>
        public GetChatMember() { }
        /// <summary>
        /// Returns information about a single member of a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userId">User identifier</param>
        public GetChatMember(long chatId = default, int userId = default)
        {
            this.ChatId = chatId;
            this.UserId = userId;
        }
    }

    public partial class SearchChatMembers
    {
        /// <summary>
        /// Searches for a specified query in the first name, last name and username of the members of a specified chat. Requires administrator rights in channels
        /// </summary>
        public SearchChatMembers() { }
        /// <summary>
        /// Searches for a specified query in the first name, last name and username of the members of a specified chat. Requires administrator rights in channels
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="query">Query to search for</param>
        /// <param name="limit">The maximum number of users to be returned</param>
        /// <param name="filter">The type of users to return. By default, chatMembersFilterMembers</param>
        public SearchChatMembers(long chatId = default, string query = default, int limit = default, ChatMembersFilter filter = default)
        {
            this.ChatId = chatId;
            this.Query = query;
            this.Limit = limit;
            this.Filter = filter;
        }
    }

    public partial class GetChatAdministrators
    {
        /// <summary>
        /// Returns a list of administrators of the chat with their custom titles
        /// </summary>
        public GetChatAdministrators() { }
        /// <summary>
        /// Returns a list of administrators of the chat with their custom titles
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public GetChatAdministrators(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class ClearAllDraftMessages
    {
        /// <summary>
        /// Clears draft messages in all chats
        /// </summary>
        public ClearAllDraftMessages() { }
        /// <summary>
        /// Clears draft messages in all chats
        /// </summary>
        /// <param name="excludeSecretChats">If true, local draft messages in secret chats will not be cleared</param>
        public ClearAllDraftMessages(bool excludeSecretChats = default)
        {
            this.ExcludeSecretChats = excludeSecretChats;
        }
    }

    public partial class GetChatNotificationSettingsExceptions
    {
        /// <summary>
        /// Returns list of chats with non-default notification settings
        /// </summary>
        public GetChatNotificationSettingsExceptions() { }
        /// <summary>
        /// Returns list of chats with non-default notification settings
        /// </summary>
        /// <param name="scope">If specified, only chats from the specified scope will be returned</param>
        /// <param name="compareSound">If true, also chats with non-default sound will be returned</param>
        public GetChatNotificationSettingsExceptions(NotificationSettingsScope scope = default, bool compareSound = default)
        {
            this.Scope = scope;
            this.CompareSound = compareSound;
        }
    }

    public partial class GetScopeNotificationSettings
    {
        /// <summary>
        /// Returns the notification settings for chats of a given type
        /// </summary>
        public GetScopeNotificationSettings() { }
        /// <summary>
        /// Returns the notification settings for chats of a given type
        /// </summary>
        /// <param name="scope">Types of chats for which to return the notification settings information</param>
        public GetScopeNotificationSettings(NotificationSettingsScope scope = default)
        {
            this.Scope = scope;
        }
    }

    public partial class SetScopeNotificationSettings
    {
        /// <summary>
        /// Changes notification settings for chats of a given type
        /// </summary>
        public SetScopeNotificationSettings() { }
        /// <summary>
        /// Changes notification settings for chats of a given type
        /// </summary>
        /// <param name="scope">Types of chats for which to change the notification settings</param>
        /// <param name="notificationSettings">The new notification settings for the given scope</param>
        public SetScopeNotificationSettings(NotificationSettingsScope scope = default, ScopeNotificationSettings notificationSettings = default)
        {
            this.Scope = scope;
            this.NotificationSettings = notificationSettings;
        }
    }

    public partial class ResetAllNotificationSettings
    {
        /// <summary>
        /// Resets all notification settings to their default values. By default, all chats are unmuted, the sound is set to "default" and message previews are shown
        /// </summary>
        public ResetAllNotificationSettings() { }
    }

    public partial class ToggleChatIsPinned
    {
        /// <summary>
        /// Changes the pinned state of a chat. There can be up to GetOption("pinned_chat_count_max")/GetOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/arhive chat list
        /// </summary>
        public ToggleChatIsPinned() { }
        /// <summary>
        /// Changes the pinned state of a chat. There can be up to GetOption("pinned_chat_count_max")/GetOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/arhive chat list
        /// </summary>
        /// <param name="chatList">Chat list in which to change the pinned state of the chat</param>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="isPinned">True, if the chat is pinned</param>
        public ToggleChatIsPinned(ChatList chatList = default, long chatId = default, bool isPinned = default)
        {
            this.ChatList = chatList;
            this.ChatId = chatId;
            this.IsPinned = isPinned;
        }
    }

    public partial class SetPinnedChats
    {
        /// <summary>
        /// Changes the order of pinned chats
        /// </summary>
        public SetPinnedChats() { }
        /// <summary>
        /// Changes the order of pinned chats
        /// </summary>
        /// <param name="chatList">Chat list in which to change the order of pinned chats</param>
        /// <param name="chatIds">The new list of pinned chats</param>
        public SetPinnedChats(ChatList chatList = default, long[] chatIds = default)
        {
            this.ChatList = chatList;
            this.ChatIds = chatIds;
        }
    }

    public partial class DownloadFile
    {
        /// <summary>
        /// Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates
        /// </summary>
        public DownloadFile() { }
        /// <summary>
        /// Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates
        /// </summary>
        /// <param name="fileId">Identifier of the file to download</param>
        /// <param name="priority">Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile was called will be downloaded first</param>
        /// <param name="offset">The starting position from which the file should be downloaded</param>
        /// <param name="limit">Number of bytes which should be downloaded starting from the "offset" position before the download will be automatically cancelled; use 0 to download without a limit</param>
        /// <param name="synchronous">If false, this request returns file state just after the download has been started. If true, this request returns file state only after -the download has succeeded, has failed, has been cancelled or a new downloadFile request with different offset/limit parameters was sent</param>
        public DownloadFile(int fileId = default, int priority = default, int offset = default, int limit = default, bool synchronous = default)
        {
            this.FileId = fileId;
            this.Priority = priority;
            this.Offset = offset;
            this.Limit = limit;
            this.Synchronous = synchronous;
        }
    }

    public partial class GetFileDownloadedPrefixSize
    {
        /// <summary>
        /// Returns file downloaded prefix size from a given offset
        /// </summary>
        public GetFileDownloadedPrefixSize() { }
        /// <summary>
        /// Returns file downloaded prefix size from a given offset
        /// </summary>
        /// <param name="fileId">Identifier of the file</param>
        /// <param name="offset">Offset from which downloaded prefix size should be calculated</param>
        public GetFileDownloadedPrefixSize(int fileId = default, int offset = default)
        {
            this.FileId = fileId;
            this.Offset = offset;
        }
    }

    public partial class CancelDownloadFile
    {
        /// <summary>
        /// Stops the downloading of a file. If a file has already been downloaded, does nothing
        /// </summary>
        public CancelDownloadFile() { }
        /// <summary>
        /// Stops the downloading of a file. If a file has already been downloaded, does nothing
        /// </summary>
        /// <param name="fileId">Identifier of a file to stop downloading</param>
        /// <param name="onlyIfPending">Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server</param>
        public CancelDownloadFile(int fileId = default, bool onlyIfPending = default)
        {
            this.FileId = fileId;
            this.OnlyIfPending = onlyIfPending;
        }
    }

    public partial class UploadFile
    {
        /// <summary>
        /// Asynchronously uploads a file to the cloud without sending it in a message. updateFile will be used to notify about upload progress and successful completion of the upload. The file will not have a persistent remote identifier until it will be sent in a message
        /// </summary>
        public UploadFile() { }
        /// <summary>
        /// Asynchronously uploads a file to the cloud without sending it in a message. updateFile will be used to notify about upload progress and successful completion of the upload. The file will not have a persistent remote identifier until it will be sent in a message
        /// </summary>
        /// <param name="file">File to upload</param>
        /// <param name="fileType">File type</param>
        /// <param name="priority">Priority of the upload (1-32). The higher the priority, the earlier the file will be uploaded. If the priorities of two files are equal, then the first one for which uploadFile was called will be uploaded first</param>
        public UploadFile(InputFile file = default, FileType fileType = default, int priority = default)
        {
            this.File = file;
            this.FileType = fileType;
            this.Priority = priority;
        }
    }

    public partial class CancelUploadFile
    {
        /// <summary>
        /// Stops the uploading of a file. Supported only for files uploaded by using uploadFile. For other files the behavior is undefined
        /// </summary>
        public CancelUploadFile() { }
        /// <summary>
        /// Stops the uploading of a file. Supported only for files uploaded by using uploadFile. For other files the behavior is undefined
        /// </summary>
        /// <param name="fileId">Identifier of the file to stop uploading</param>
        public CancelUploadFile(int fileId = default)
        {
            this.FileId = fileId;
        }
    }

    public partial class WriteGeneratedFilePart
    {
        /// <summary>
        /// Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file
        /// </summary>
        public WriteGeneratedFilePart() { }
        /// <summary>
        /// Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file
        /// </summary>
        /// <param name="generationId">The identifier of the generation process</param>
        /// <param name="offset">The offset from which to write the data to the file</param>
        /// <param name="data">The data to write</param>
        public WriteGeneratedFilePart(long generationId = default, int offset = default, Memory<byte> data = default)
        {
            this.GenerationId = generationId;
            this.Offset = offset;
            this.Data = data;
        }
    }

    public partial class SetFileGenerationProgress
    {
        /// <summary>
        /// Informs TDLib on a file generation progress
        /// </summary>
        public SetFileGenerationProgress() { }
        /// <summary>
        /// Informs TDLib on a file generation progress
        /// </summary>
        /// <param name="generationId">The identifier of the generation process</param>
        /// <param name="expectedSize">Expected size of the generated file, in bytes; 0 if unknown</param>
        /// <param name="localPrefixSize">The number of bytes already generated</param>
        public SetFileGenerationProgress(long generationId = default, int expectedSize = default, int localPrefixSize = default)
        {
            this.GenerationId = generationId;
            this.ExpectedSize = expectedSize;
            this.LocalPrefixSize = localPrefixSize;
        }
    }

    public partial class FinishFileGeneration
    {
        /// <summary>
        /// Finishes the file generation
        /// </summary>
        public FinishFileGeneration() { }
        /// <summary>
        /// Finishes the file generation
        /// </summary>
        /// <param name="generationId">The identifier of the generation process</param>
        /// <param name="error">If set, means that file generation has failed and should be terminated</param>
        public FinishFileGeneration(long generationId = default, Error error = default)
        {
            this.GenerationId = generationId;
            this.Error = error;
        }
    }

    public partial class ReadFilePart
    {
        /// <summary>
        /// Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file
        /// </summary>
        public ReadFilePart() { }
        /// <summary>
        /// Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file
        /// </summary>
        /// <param name="fileId">Identifier of the file. The file must be located in the TDLib file cache</param>
        /// <param name="offset">The offset from which to read the file</param>
        /// <param name="count">Number of bytes to read. An error will be returned if there are not enough bytes available in the file from the specified position. Pass 0 to read all available data from the specified position</param>
        public ReadFilePart(int fileId = default, int offset = default, int count = default)
        {
            this.FileId = fileId;
            this.Offset = offset;
            this.Count = count;
        }
    }

    public partial class DeleteFile
    {
        /// <summary>
        /// Deletes a file from the TDLib file cache
        /// </summary>
        public DeleteFile() { }
        /// <summary>
        /// Deletes a file from the TDLib file cache
        /// </summary>
        /// <param name="fileId">Identifier of the file to delete</param>
        public DeleteFile(int fileId = default)
        {
            this.FileId = fileId;
        }
    }

    public partial class GenerateChatInviteLink
    {
        /// <summary>
        /// Generates a new invite link for a chat; the previously generated link is revoked. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right
        /// </summary>
        public GenerateChatInviteLink() { }
        /// <summary>
        /// Generates a new invite link for a chat; the previously generated link is revoked. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public GenerateChatInviteLink(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class CheckChatInviteLink
    {
        /// <summary>
        /// Checks the validity of an invite link for a chat and returns information about the corresponding chat
        /// </summary>
        public CheckChatInviteLink() { }
        /// <summary>
        /// Checks the validity of an invite link for a chat and returns information about the corresponding chat
        /// </summary>
        /// <param name="inviteLink">Invite link to be checked; should begin with "https://t.me/joinchat/", "https://telegram.me/joinchat/", or "https://telegram.dog/joinchat/"</param>
        public CheckChatInviteLink(string inviteLink = default)
        {
            this.InviteLink = inviteLink;
        }
    }

    public partial class JoinChatByInviteLink
    {
        /// <summary>
        /// Uses an invite link to add the current user to the chat if possible. The new member will not be added until the chat state has been synchronized with the server
        /// </summary>
        public JoinChatByInviteLink() { }
        /// <summary>
        /// Uses an invite link to add the current user to the chat if possible. The new member will not be added until the chat state has been synchronized with the server
        /// </summary>
        /// <param name="inviteLink">Invite link to import; should begin with "https://t.me/joinchat/", "https://telegram.me/joinchat/", or "https://telegram.dog/joinchat/"</param>
        public JoinChatByInviteLink(string inviteLink = default)
        {
            this.InviteLink = inviteLink;
        }
    }

    public partial class CreateCall
    {
        /// <summary>
        /// Creates a new call
        /// </summary>
        public CreateCall() { }
        /// <summary>
        /// Creates a new call
        /// </summary>
        /// <param name="userId">Identifier of the user to be called</param>
        /// <param name="protocol">Description of the call protocols supported by the application</param>
        /// <param name="isVideo">True, if a video call needs to be created</param>
        public CreateCall(int userId = default, CallProtocol protocol = default, bool isVideo = default)
        {
            this.UserId = userId;
            this.Protocol = protocol;
            this.IsVideo = isVideo;
        }
    }

    public partial class AcceptCall
    {
        /// <summary>
        /// Accepts an incoming call
        /// </summary>
        public AcceptCall() { }
        /// <summary>
        /// Accepts an incoming call
        /// </summary>
        /// <param name="callId">Call identifier</param>
        /// <param name="protocol">Description of the call protocols supported by the application</param>
        public AcceptCall(int callId = default, CallProtocol protocol = default)
        {
            this.CallId = callId;
            this.Protocol = protocol;
        }
    }

    public partial class SendCallSignalingData
    {
        /// <summary>
        /// Sends call signaling data
        /// </summary>
        public SendCallSignalingData() { }
        /// <summary>
        /// Sends call signaling data
        /// </summary>
        /// <param name="callId">Call identifier</param>
        /// <param name="data">The data</param>
        public SendCallSignalingData(int callId = default, Memory<byte> data = default)
        {
            this.CallId = callId;
            this.Data = data;
        }
    }

    public partial class DiscardCall
    {
        /// <summary>
        /// Discards a call
        /// </summary>
        public DiscardCall() { }
        /// <summary>
        /// Discards a call
        /// </summary>
        /// <param name="callId">Call identifier</param>
        /// <param name="isDisconnected">True, if the user was disconnected</param>
        /// <param name="duration">The call duration, in seconds</param>
        /// <param name="isVideo">True, if the call was a video call</param>
        /// <param name="connectionId">Identifier of the connection used during the call</param>
        public DiscardCall(int callId = default, bool isDisconnected = default, int duration = default, bool isVideo = default, long connectionId = default)
        {
            this.CallId = callId;
            this.IsDisconnected = isDisconnected;
            this.Duration = duration;
            this.IsVideo = isVideo;
            this.ConnectionId = connectionId;
        }
    }

    public partial class SendCallRating
    {
        /// <summary>
        /// Sends a call rating
        /// </summary>
        public SendCallRating() { }
        /// <summary>
        /// Sends a call rating
        /// </summary>
        /// <param name="callId">Call identifier</param>
        /// <param name="rating">Call rating; 1-5</param>
        /// <param name="comment">An optional user comment if the rating is less than 5</param>
        /// <param name="problems">List of the exact types of problems with the call, specified by the user</param>
        public SendCallRating(int callId = default, int rating = default, string comment = default, CallProblem[] problems = default)
        {
            this.CallId = callId;
            this.Rating = rating;
            this.Comment = comment;
            this.Problems = problems;
        }
    }

    public partial class SendCallDebugInformation
    {
        /// <summary>
        /// Sends debug information for a call
        /// </summary>
        public SendCallDebugInformation() { }
        /// <summary>
        /// Sends debug information for a call
        /// </summary>
        /// <param name="callId">Call identifier</param>
        /// <param name="debugInformation">Debug information in application-specific format</param>
        public SendCallDebugInformation(int callId = default, string debugInformation = default)
        {
            this.CallId = callId;
            this.DebugInformation = debugInformation;
        }
    }

    public partial class BlockChatFromReplies
    {
        /// <summary>
        /// Blocks an original sender of a message in the Replies chat
        /// </summary>
        public BlockChatFromReplies() { }
        /// <summary>
        /// Blocks an original sender of a message in the Replies chat
        /// </summary>
        /// <param name="messageId">The identifier of an incoming message in the Replies chat</param>
        /// <param name="deleteMessage">Pass true if the message must be deleted</param>
        /// <param name="deleteAllMessages">Pass true if all messages from the same sender must be deleted</param>
        /// <param name="reportSpam">Pass true if the sender must be reported to the Telegram moderators</param>
        public BlockChatFromReplies(long messageId = default, bool deleteMessage = default, bool deleteAllMessages = default, bool reportSpam = default)
        {
            this.MessageId = messageId;
            this.DeleteMessage = deleteMessage;
            this.DeleteAllMessages = deleteAllMessages;
            this.ReportSpam = reportSpam;
        }
    }

    public partial class GetBlockedChats
    {
        /// <summary>
        /// Returns chats that were blocked by the current user
        /// </summary>
        public GetBlockedChats() { }
        /// <summary>
        /// Returns chats that were blocked by the current user
        /// </summary>
        /// <param name="offset">Number of chats to skip in the result; must be non-negative</param>
        /// <param name="limit">The maximum number of chats to return; up to 100</param>
        public GetBlockedChats(int offset = default, int limit = default)
        {
            this.Offset = offset;
            this.Limit = limit;
        }
    }

    public partial class AddContact
    {
        /// <summary>
        /// Adds a user to the contact list or edits an existing contact by their user identifier
        /// </summary>
        public AddContact() { }
        /// <summary>
        /// Adds a user to the contact list or edits an existing contact by their user identifier
        /// </summary>
        /// <param name="contact">The contact to add or edit; phone number can be empty and needs to be specified only if known, vCard is ignored</param>
        /// <param name="sharePhoneNumber">True, if the new contact needs to be allowed to see current user's phone number. A corresponding rule to userPrivacySettingShowPhoneNumber will be added if needed. Use the field UserFullInfo.need_phone_number_privacy_exception to check whether the current user needs to be asked to share their phone number</param>
        public AddContact(Contact contact = default, bool sharePhoneNumber = default)
        {
            this.Contact = contact;
            this.SharePhoneNumber = sharePhoneNumber;
        }
    }

    public partial class ImportContacts
    {
        /// <summary>
        /// Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored
        /// </summary>
        public ImportContacts() { }
        /// <summary>
        /// Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored
        /// </summary>
        /// <param name="contacts">The list of contacts to import or edit; contacts' vCard are ignored and are not imported</param>
        public ImportContacts(Contact[] contacts = default)
        {
            this.Contacts = contacts;
        }
    }

    public partial class GetContacts
    {
        /// <summary>
        /// Returns all user contacts
        /// </summary>
        public GetContacts() { }
    }

    public partial class SearchContacts
    {
        /// <summary>
        /// Searches for the specified query in the first names, last names and usernames of the known user contacts
        /// </summary>
        public SearchContacts() { }
        /// <summary>
        /// Searches for the specified query in the first names, last names and usernames of the known user contacts
        /// </summary>
        /// <param name="query">Query to search for; may be empty to return all contacts</param>
        /// <param name="limit">The maximum number of users to be returned</param>
        public SearchContacts(string query = default, int limit = default)
        {
            this.Query = query;
            this.Limit = limit;
        }
    }

    public partial class RemoveContacts
    {
        /// <summary>
        /// Removes users from the contact list
        /// </summary>
        public RemoveContacts() { }
        /// <summary>
        /// Removes users from the contact list
        /// </summary>
        /// <param name="userIds">Identifiers of users to be deleted</param>
        public RemoveContacts(int[] userIds = default)
        {
            this.UserIds = userIds;
        }
    }

    public partial class GetImportedContactCount
    {
        /// <summary>
        /// Returns the total number of imported contacts
        /// </summary>
        public GetImportedContactCount() { }
    }

    public partial class ChangeImportedContacts
    {
        /// <summary>
        /// Changes imported contacts using the list of current user contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts. -Query result depends on the result of the previous query, so only one query is possible at the same time
        /// </summary>
        public ChangeImportedContacts() { }
        /// <summary>
        /// Changes imported contacts using the list of current user contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts. -Query result depends on the result of the previous query, so only one query is possible at the same time
        /// </summary>
        /// <param name="contacts">The new list of contacts, contact's vCard are ignored and are not imported</param>
        public ChangeImportedContacts(Contact[] contacts = default)
        {
            this.Contacts = contacts;
        }
    }

    public partial class ClearImportedContacts
    {
        /// <summary>
        /// Clears all imported contacts, contact list remains unchanged
        /// </summary>
        public ClearImportedContacts() { }
    }

    public partial class SharePhoneNumber
    {
        /// <summary>
        /// Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber
        /// </summary>
        public SharePhoneNumber() { }
        /// <summary>
        /// Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber
        /// </summary>
        /// <param name="userId">Identifier of the user with whom to share the phone number. The user must be a mutual contact</param>
        public SharePhoneNumber(int userId = default)
        {
            this.UserId = userId;
        }
    }

    public partial class GetUserProfilePhotos
    {
        /// <summary>
        /// Returns the profile photos of a user. The result of this query may be outdated: some photos might have been deleted already
        /// </summary>
        public GetUserProfilePhotos() { }
        /// <summary>
        /// Returns the profile photos of a user. The result of this query may be outdated: some photos might have been deleted already
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="offset">The number of photos to skip; must be non-negative</param>
        /// <param name="limit">The maximum number of photos to be returned; up to 100</param>
        public GetUserProfilePhotos(int userId = default, int offset = default, int limit = default)
        {
            this.UserId = userId;
            this.Offset = offset;
            this.Limit = limit;
        }
    }

    public partial class GetStickers
    {
        /// <summary>
        /// Returns stickers from the installed sticker sets that correspond to a given emoji. If the emoji is not empty, favorite and recently used stickers may also be returned
        /// </summary>
        public GetStickers() { }
        /// <summary>
        /// Returns stickers from the installed sticker sets that correspond to a given emoji. If the emoji is not empty, favorite and recently used stickers may also be returned
        /// </summary>
        /// <param name="emoji">String representation of emoji. If empty, returns all known installed stickers</param>
        /// <param name="limit">The maximum number of stickers to be returned</param>
        public GetStickers(string emoji = default, int limit = default)
        {
            this.Emoji = emoji;
            this.Limit = limit;
        }
    }

    public partial class SearchStickers
    {
        /// <summary>
        /// Searches for stickers from public sticker sets that correspond to a given emoji
        /// </summary>
        public SearchStickers() { }
        /// <summary>
        /// Searches for stickers from public sticker sets that correspond to a given emoji
        /// </summary>
        /// <param name="emoji">String representation of emoji; must be non-empty</param>
        /// <param name="limit">The maximum number of stickers to be returned</param>
        public SearchStickers(string emoji = default, int limit = default)
        {
            this.Emoji = emoji;
            this.Limit = limit;
        }
    }

    public partial class GetInstalledStickerSets
    {
        /// <summary>
        /// Returns a list of installed sticker sets
        /// </summary>
        public GetInstalledStickerSets() { }
        /// <summary>
        /// Returns a list of installed sticker sets
        /// </summary>
        /// <param name="isMasks">Pass true to return mask sticker sets; pass false to return ordinary sticker sets</param>
        public GetInstalledStickerSets(bool isMasks = default)
        {
            this.IsMasks = isMasks;
        }
    }

    public partial class GetArchivedStickerSets
    {
        /// <summary>
        /// Returns a list of archived sticker sets
        /// </summary>
        public GetArchivedStickerSets() { }
        /// <summary>
        /// Returns a list of archived sticker sets
        /// </summary>
        /// <param name="isMasks">Pass true to return mask stickers sets; pass false to return ordinary sticker sets</param>
        /// <param name="offsetStickerSetId">Identifier of the sticker set from which to return the result</param>
        /// <param name="limit">The maximum number of sticker sets to return</param>
        public GetArchivedStickerSets(bool isMasks = default, long offsetStickerSetId = default, int limit = default)
        {
            this.IsMasks = isMasks;
            this.OffsetStickerSetId = offsetStickerSetId;
            this.Limit = limit;
        }
    }

    public partial class GetTrendingStickerSets
    {
        /// <summary>
        /// Returns a list of trending sticker sets. For the optimal performance the number of returned sticker sets is chosen by the library
        /// </summary>
        public GetTrendingStickerSets() { }
        /// <summary>
        /// Returns a list of trending sticker sets. For the optimal performance the number of returned sticker sets is chosen by the library
        /// </summary>
        /// <param name="offset">The offset from which to return the sticker sets; must be non-negative</param>
        /// <param name="limit">The maximum number of sticker sets to be returned; must be non-negative. Fewer sticker sets may be returned than specified by the limit, even if the end of the list has not been reached</param>
        public GetTrendingStickerSets(int offset = default, int limit = default)
        {
            this.Offset = offset;
            this.Limit = limit;
        }
    }

    public partial class GetAttachedStickerSets
    {
        /// <summary>
        /// Returns a list of sticker sets attached to a file. Currently only photos and videos can have attached sticker sets
        /// </summary>
        public GetAttachedStickerSets() { }
        /// <summary>
        /// Returns a list of sticker sets attached to a file. Currently only photos and videos can have attached sticker sets
        /// </summary>
        /// <param name="fileId">File identifier</param>
        public GetAttachedStickerSets(int fileId = default)
        {
            this.FileId = fileId;
        }
    }

    public partial class GetStickerSet
    {
        /// <summary>
        /// Returns information about a sticker set by its identifier
        /// </summary>
        public GetStickerSet() { }
        /// <summary>
        /// Returns information about a sticker set by its identifier
        /// </summary>
        /// <param name="setId">Identifier of the sticker set</param>
        public GetStickerSet(long setId = default)
        {
            this.SetId = setId;
        }
    }

    public partial class SearchStickerSet
    {
        /// <summary>
        /// Searches for a sticker set by its name
        /// </summary>
        public SearchStickerSet() { }
        /// <summary>
        /// Searches for a sticker set by its name
        /// </summary>
        /// <param name="name">Name of the sticker set</param>
        public SearchStickerSet(string name = default)
        {
            this.Name = name;
        }
    }

    public partial class SearchInstalledStickerSets
    {
        /// <summary>
        /// Searches for installed sticker sets by looking for specified query in their title and name
        /// </summary>
        public SearchInstalledStickerSets() { }
        /// <summary>
        /// Searches for installed sticker sets by looking for specified query in their title and name
        /// </summary>
        /// <param name="isMasks">Pass true to return mask sticker sets; pass false to return ordinary sticker sets</param>
        /// <param name="query">Query to search for</param>
        /// <param name="limit">The maximum number of sticker sets to return</param>
        public SearchInstalledStickerSets(bool isMasks = default, string query = default, int limit = default)
        {
            this.IsMasks = isMasks;
            this.Query = query;
            this.Limit = limit;
        }
    }

    public partial class SearchStickerSets
    {
        /// <summary>
        /// Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results
        /// </summary>
        public SearchStickerSets() { }
        /// <summary>
        /// Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results
        /// </summary>
        /// <param name="query">Query to search for</param>
        public SearchStickerSets(string query = default)
        {
            this.Query = query;
        }
    }

    public partial class ChangeStickerSet
    {
        /// <summary>
        /// Installs/uninstalls or activates/archives a sticker set
        /// </summary>
        public ChangeStickerSet() { }
        /// <summary>
        /// Installs/uninstalls or activates/archives a sticker set
        /// </summary>
        /// <param name="setId">Identifier of the sticker set</param>
        /// <param name="isInstalled">The new value of is_installed</param>
        /// <param name="isArchived">The new value of is_archived. A sticker set can't be installed and archived simultaneously</param>
        public ChangeStickerSet(long setId = default, bool isInstalled = default, bool isArchived = default)
        {
            this.SetId = setId;
            this.IsInstalled = isInstalled;
            this.IsArchived = isArchived;
        }
    }

    public partial class ViewTrendingStickerSets
    {
        /// <summary>
        /// Informs the server that some trending sticker sets have been viewed by the user
        /// </summary>
        public ViewTrendingStickerSets() { }
        /// <summary>
        /// Informs the server that some trending sticker sets have been viewed by the user
        /// </summary>
        /// <param name="stickerSetIds">Identifiers of viewed trending sticker sets</param>
        public ViewTrendingStickerSets(long[] stickerSetIds = default)
        {
            this.StickerSetIds = stickerSetIds;
        }
    }

    public partial class ReorderInstalledStickerSets
    {
        /// <summary>
        /// Changes the order of installed sticker sets
        /// </summary>
        public ReorderInstalledStickerSets() { }
        /// <summary>
        /// Changes the order of installed sticker sets
        /// </summary>
        /// <param name="isMasks">Pass true to change the order of mask sticker sets; pass false to change the order of ordinary sticker sets</param>
        /// <param name="stickerSetIds">Identifiers of installed sticker sets in the new correct order</param>
        public ReorderInstalledStickerSets(bool isMasks = default, long[] stickerSetIds = default)
        {
            this.IsMasks = isMasks;
            this.StickerSetIds = stickerSetIds;
        }
    }

    public partial class GetRecentStickers
    {
        /// <summary>
        /// Returns a list of recently used stickers
        /// </summary>
        public GetRecentStickers() { }
        /// <summary>
        /// Returns a list of recently used stickers
        /// </summary>
        /// <param name="isAttached">Pass true to return stickers and masks that were recently attached to photos or video files; pass false to return recently sent stickers</param>
        public GetRecentStickers(bool isAttached = default)
        {
            this.IsAttached = isAttached;
        }
    }

    public partial class AddRecentSticker
    {
        /// <summary>
        /// Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list
        /// </summary>
        public AddRecentSticker() { }
        /// <summary>
        /// Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list
        /// </summary>
        /// <param name="isAttached">Pass true to add the sticker to the list of stickers recently attached to photo or video files; pass false to add the sticker to the list of recently sent stickers</param>
        /// <param name="sticker">Sticker file to add</param>
        public AddRecentSticker(bool isAttached = default, InputFile sticker = default)
        {
            this.IsAttached = isAttached;
            this.Sticker = sticker;
        }
    }

    public partial class RemoveRecentSticker
    {
        /// <summary>
        /// Removes a sticker from the list of recently used stickers
        /// </summary>
        public RemoveRecentSticker() { }
        /// <summary>
        /// Removes a sticker from the list of recently used stickers
        /// </summary>
        /// <param name="isAttached">Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers</param>
        /// <param name="sticker">Sticker file to delete</param>
        public RemoveRecentSticker(bool isAttached = default, InputFile sticker = default)
        {
            this.IsAttached = isAttached;
            this.Sticker = sticker;
        }
    }

    public partial class ClearRecentStickers
    {
        /// <summary>
        /// Clears the list of recently used stickers
        /// </summary>
        public ClearRecentStickers() { }
        /// <summary>
        /// Clears the list of recently used stickers
        /// </summary>
        /// <param name="isAttached">Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers</param>
        public ClearRecentStickers(bool isAttached = default)
        {
            this.IsAttached = isAttached;
        }
    }

    public partial class GetFavoriteStickers
    {
        /// <summary>
        /// Returns favorite stickers
        /// </summary>
        public GetFavoriteStickers() { }
    }

    public partial class AddFavoriteSticker
    {
        /// <summary>
        /// Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list
        /// </summary>
        public AddFavoriteSticker() { }
        /// <summary>
        /// Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list
        /// </summary>
        /// <param name="sticker">Sticker file to add</param>
        public AddFavoriteSticker(InputFile sticker = default)
        {
            this.Sticker = sticker;
        }
    }

    public partial class RemoveFavoriteSticker
    {
        /// <summary>
        /// Removes a sticker from the list of favorite stickers
        /// </summary>
        public RemoveFavoriteSticker() { }
        /// <summary>
        /// Removes a sticker from the list of favorite stickers
        /// </summary>
        /// <param name="sticker">Sticker file to delete from the list</param>
        public RemoveFavoriteSticker(InputFile sticker = default)
        {
            this.Sticker = sticker;
        }
    }

    public partial class GetStickerEmojis
    {
        /// <summary>
        /// Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
        /// </summary>
        public GetStickerEmojis() { }
        /// <summary>
        /// Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
        /// </summary>
        /// <param name="sticker">Sticker file identifier</param>
        public GetStickerEmojis(InputFile sticker = default)
        {
            this.Sticker = sticker;
        }
    }

    public partial class SearchEmojis
    {
        /// <summary>
        /// Searches for emojis by keywords. Supported only if the file database is enabled
        /// </summary>
        public SearchEmojis() { }
        /// <summary>
        /// Searches for emojis by keywords. Supported only if the file database is enabled
        /// </summary>
        /// <param name="text">Text to search for</param>
        /// <param name="exactMatch">True, if only emojis, which exactly match text needs to be returned</param>
        /// <param name="inputLanguageCodes">List of possible IETF language tags of the user's input language; may be empty if unknown</param>
        public SearchEmojis(string text = default, bool exactMatch = default, string[] inputLanguageCodes = default)
        {
            this.Text = text;
            this.ExactMatch = exactMatch;
            this.InputLanguageCodes = inputLanguageCodes;
        }
    }

    public partial class GetEmojiSuggestionsUrl
    {
        /// <summary>
        /// Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation
        /// </summary>
        public GetEmojiSuggestionsUrl() { }
        /// <summary>
        /// Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation
        /// </summary>
        /// <param name="languageCode">Language code for which the emoji replacements will be suggested</param>
        public GetEmojiSuggestionsUrl(string languageCode = default)
        {
            this.LanguageCode = languageCode;
        }
    }

    public partial class GetSavedAnimations
    {
        /// <summary>
        /// Returns saved animations
        /// </summary>
        public GetSavedAnimations() { }
    }

    public partial class AddSavedAnimation
    {
        /// <summary>
        /// Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
        /// </summary>
        public AddSavedAnimation() { }
        /// <summary>
        /// Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
        /// </summary>
        /// <param name="animation">The animation file to be added. Only animations known to the server (i.e. successfully sent via a message) can be added to the list</param>
        public AddSavedAnimation(InputFile animation = default)
        {
            this.Animation = animation;
        }
    }

    public partial class RemoveSavedAnimation
    {
        /// <summary>
        /// Removes an animation from the list of saved animations
        /// </summary>
        public RemoveSavedAnimation() { }
        /// <summary>
        /// Removes an animation from the list of saved animations
        /// </summary>
        /// <param name="animation">Animation file to be removed</param>
        public RemoveSavedAnimation(InputFile animation = default)
        {
            this.Animation = animation;
        }
    }

    public partial class GetRecentInlineBots
    {
        /// <summary>
        /// Returns up to 20 recently used inline bots in the order of their last usage
        /// </summary>
        public GetRecentInlineBots() { }
    }

    public partial class SearchHashtags
    {
        /// <summary>
        /// Searches for recently used hashtags by their prefix
        /// </summary>
        public SearchHashtags() { }
        /// <summary>
        /// Searches for recently used hashtags by their prefix
        /// </summary>
        /// <param name="prefix">Hashtag prefix to search for</param>
        /// <param name="limit">The maximum number of hashtags to be returned</param>
        public SearchHashtags(string prefix = default, int limit = default)
        {
            this.Prefix = prefix;
            this.Limit = limit;
        }
    }

    public partial class RemoveRecentHashtag
    {
        /// <summary>
        /// Removes a hashtag from the list of recently used hashtags
        /// </summary>
        public RemoveRecentHashtag() { }
        /// <summary>
        /// Removes a hashtag from the list of recently used hashtags
        /// </summary>
        /// <param name="hashtag">Hashtag to delete</param>
        public RemoveRecentHashtag(string hashtag = default)
        {
            this.Hashtag = hashtag;
        }
    }

    public partial class GetWebPagePreview
    {
        /// <summary>
        /// Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview
        /// </summary>
        public GetWebPagePreview() { }
        /// <summary>
        /// Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview
        /// </summary>
        /// <param name="text">Message text with formatting</param>
        public GetWebPagePreview(FormattedText text = default)
        {
            this.Text = text;
        }
    }

    public partial class GetWebPageInstantView
    {
        /// <summary>
        /// Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page
        /// </summary>
        public GetWebPageInstantView() { }
        /// <summary>
        /// Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page
        /// </summary>
        /// <param name="url">The web page URL</param>
        /// <param name="forceFull">If true, the full instant view for the web page will be returned</param>
        public GetWebPageInstantView(string url = default, bool forceFull = default)
        {
            this.Url = url;
            this.ForceFull = forceFull;
        }
    }

    public partial class SetProfilePhoto
    {
        /// <summary>
        /// Changes a profile photo for the current user
        /// </summary>
        public SetProfilePhoto() { }
        /// <summary>
        /// Changes a profile photo for the current user
        /// </summary>
        /// <param name="photo">Profile photo to set</param>
        public SetProfilePhoto(InputChatPhoto photo = default)
        {
            this.Photo = photo;
        }
    }

    public partial class DeleteProfilePhoto
    {
        /// <summary>
        /// Deletes a profile photo
        /// </summary>
        public DeleteProfilePhoto() { }
        /// <summary>
        /// Deletes a profile photo
        /// </summary>
        /// <param name="profilePhotoId">Identifier of the profile photo to delete</param>
        public DeleteProfilePhoto(long profilePhotoId = default)
        {
            this.ProfilePhotoId = profilePhotoId;
        }
    }

    public partial class SetName
    {
        /// <summary>
        /// Changes the first and last name of the current user
        /// </summary>
        public SetName() { }
        /// <summary>
        /// Changes the first and last name of the current user
        /// </summary>
        /// <param name="firstName">The new value of the first name for the user; 1-64 characters</param>
        /// <param name="lastName">The new value of the optional last name for the user; 0-64 characters</param>
        public SetName(string firstName = default, string lastName = default)
        {
            this.FirstName = firstName;
            this.LastName = lastName;
        }
    }

    public partial class SetBio
    {
        /// <summary>
        /// Changes the bio of the current user
        /// </summary>
        public SetBio() { }
        /// <summary>
        /// Changes the bio of the current user
        /// </summary>
        /// <param name="bio">The new value of the user bio; 0-70 characters without line feeds</param>
        public SetBio(string bio = default)
        {
            this.Bio = bio;
        }
    }

    public partial class SetUsername
    {
        /// <summary>
        /// Changes the username of the current user
        /// </summary>
        public SetUsername() { }
        /// <summary>
        /// Changes the username of the current user
        /// </summary>
        /// <param name="username">The new value of the username. Use an empty string to remove the username</param>
        public SetUsername(string username = default)
        {
            this.Username = username;
        }
    }

    public partial class SetLocation
    {
        /// <summary>
        /// Changes the location of the current user. Needs to be called if GetOption("is_location_visible") is true and location changes for more than 1 kilometer
        /// </summary>
        public SetLocation() { }
        /// <summary>
        /// Changes the location of the current user. Needs to be called if GetOption("is_location_visible") is true and location changes for more than 1 kilometer
        /// </summary>
        /// <param name="location">The new location of the user</param>
        public SetLocation(Location location = default)
        {
            this.Location = location;
        }
    }

    public partial class ChangePhoneNumber
    {
        /// <summary>
        /// Changes the phone number of the user and sends an authentication code to the user's new phone number. On success, returns information about the sent code
        /// </summary>
        public ChangePhoneNumber() { }
        /// <summary>
        /// Changes the phone number of the user and sends an authentication code to the user's new phone number. On success, returns information about the sent code
        /// </summary>
        /// <param name="phoneNumber">The new phone number of the user in international format</param>
        /// <param name="settings">Settings for the authentication of the user's phone number</param>
        public ChangePhoneNumber(string phoneNumber = default, PhoneNumberAuthenticationSettings settings = default)
        {
            this.PhoneNumber = phoneNumber;
            this.Settings = settings;
        }
    }

    public partial class ResendChangePhoneNumberCode
    {
        /// <summary>
        /// Re-sends the authentication code sent to confirm a new phone number for the user. Works only if the previously received authenticationCodeInfo next_code_type was not null
        /// </summary>
        public ResendChangePhoneNumberCode() { }
    }

    public partial class CheckChangePhoneNumberCode
    {
        /// <summary>
        /// Checks the authentication code sent to confirm a new phone number of the user
        /// </summary>
        public CheckChangePhoneNumberCode() { }
        /// <summary>
        /// Checks the authentication code sent to confirm a new phone number of the user
        /// </summary>
        /// <param name="code">Verification code received by SMS, phone call or flash call</param>
        public CheckChangePhoneNumberCode(string code = default)
        {
            this.Code = code;
        }
    }

    public partial class SetCommands
    {
        /// <summary>
        /// Sets the list of commands supported by the bot; for bots only
        /// </summary>
        public SetCommands() { }
        /// <summary>
        /// Sets the list of commands supported by the bot; for bots only
        /// </summary>
        /// <param name="commands">List of the bot's commands</param>
        public SetCommands(BotCommand[] commands = default)
        {
            this.Commands = commands;
        }
    }

    public partial class GetActiveSessions
    {
        /// <summary>
        /// Returns all active sessions of the current user
        /// </summary>
        public GetActiveSessions() { }
    }

    public partial class TerminateSession
    {
        /// <summary>
        /// Terminates a session of the current user
        /// </summary>
        public TerminateSession() { }
        /// <summary>
        /// Terminates a session of the current user
        /// </summary>
        /// <param name="sessionId">Session identifier</param>
        public TerminateSession(long sessionId = default)
        {
            this.SessionId = sessionId;
        }
    }

    public partial class TerminateAllOtherSessions
    {
        /// <summary>
        /// Terminates all other sessions of the current user
        /// </summary>
        public TerminateAllOtherSessions() { }
    }

    public partial class GetConnectedWebsites
    {
        /// <summary>
        /// Returns all website where the current user used Telegram to log in
        /// </summary>
        public GetConnectedWebsites() { }
    }

    public partial class DisconnectWebsite
    {
        /// <summary>
        /// Disconnects website from the current user's Telegram account
        /// </summary>
        public DisconnectWebsite() { }
        /// <summary>
        /// Disconnects website from the current user's Telegram account
        /// </summary>
        /// <param name="websiteId">Website identifier</param>
        public DisconnectWebsite(long websiteId = default)
        {
            this.WebsiteId = websiteId;
        }
    }

    public partial class DisconnectAllWebsites
    {
        /// <summary>
        /// Disconnects all websites from the current user's Telegram account
        /// </summary>
        public DisconnectAllWebsites() { }
    }

    public partial class SetSupergroupUsername
    {
        /// <summary>
        /// Changes the username of a supergroup or channel, requires owner privileges in the supergroup or channel
        /// </summary>
        public SetSupergroupUsername() { }
        /// <summary>
        /// Changes the username of a supergroup or channel, requires owner privileges in the supergroup or channel
        /// </summary>
        /// <param name="supergroupId">Identifier of the supergroup or channel</param>
        /// <param name="username">New value of the username. Use an empty string to remove the username</param>
        public SetSupergroupUsername(int supergroupId = default, string username = default)
        {
            this.SupergroupId = supergroupId;
            this.Username = username;
        }
    }

    public partial class SetSupergroupStickerSet
    {
        /// <summary>
        /// Changes the sticker set of a supergroup; requires can_change_info rights
        /// </summary>
        public SetSupergroupStickerSet() { }
        /// <summary>
        /// Changes the sticker set of a supergroup; requires can_change_info rights
        /// </summary>
        /// <param name="supergroupId">Identifier of the supergroup</param>
        /// <param name="stickerSetId">New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set</param>
        public SetSupergroupStickerSet(int supergroupId = default, long stickerSetId = default)
        {
            this.SupergroupId = supergroupId;
            this.StickerSetId = stickerSetId;
        }
    }

    public partial class ToggleSupergroupSignMessages
    {
        /// <summary>
        /// Toggles sender signatures messages sent in a channel; requires can_change_info rights
        /// </summary>
        public ToggleSupergroupSignMessages() { }
        /// <summary>
        /// Toggles sender signatures messages sent in a channel; requires can_change_info rights
        /// </summary>
        /// <param name="supergroupId">Identifier of the channel</param>
        /// <param name="signMessages">New value of sign_messages</param>
        public ToggleSupergroupSignMessages(int supergroupId = default, bool signMessages = default)
        {
            this.SupergroupId = supergroupId;
            this.SignMessages = signMessages;
        }
    }

    public partial class ToggleSupergroupIsAllHistoryAvailable
    {
        /// <summary>
        /// Toggles whether the message history of a supergroup is available to new members; requires can_change_info rights
        /// </summary>
        public ToggleSupergroupIsAllHistoryAvailable() { }
        /// <summary>
        /// Toggles whether the message history of a supergroup is available to new members; requires can_change_info rights
        /// </summary>
        /// <param name="supergroupId">The identifier of the supergroup</param>
        /// <param name="isAllHistoryAvailable">The new value of is_all_history_available</param>
        public ToggleSupergroupIsAllHistoryAvailable(int supergroupId = default, bool isAllHistoryAvailable = default)
        {
            this.SupergroupId = supergroupId;
            this.IsAllHistoryAvailable = isAllHistoryAvailable;
        }
    }

    public partial class ReportSupergroupSpam
    {
        /// <summary>
        /// Reports some messages from a user in a supergroup as spam; requires administrator rights in the supergroup
        /// </summary>
        public ReportSupergroupSpam() { }
        /// <summary>
        /// Reports some messages from a user in a supergroup as spam; requires administrator rights in the supergroup
        /// </summary>
        /// <param name="supergroupId">Supergroup identifier</param>
        /// <param name="userId">User identifier</param>
        /// <param name="messageIds">Identifiers of messages sent in the supergroup by the user. This list must be non-empty</param>
        public ReportSupergroupSpam(int supergroupId = default, int userId = default, long[] messageIds = default)
        {
            this.SupergroupId = supergroupId;
            this.UserId = userId;
            this.MessageIds = messageIds;
        }
    }

    public partial class GetSupergroupMembers
    {
        /// <summary>
        /// Returns information about members or banned users in a supergroup or channel. Can be used only if SupergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters
        /// </summary>
        public GetSupergroupMembers() { }
        /// <summary>
        /// Returns information about members or banned users in a supergroup or channel. Can be used only if SupergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters
        /// </summary>
        /// <param name="supergroupId">Identifier of the supergroup or channel</param>
        /// <param name="filter">The type of users to return. By default, supergroupMembersRecent</param>
        /// <param name="offset">Number of users to skip</param>
        /// <param name="limit">The maximum number of users be returned; up to 200</param>
        public GetSupergroupMembers(int supergroupId = default, SupergroupMembersFilter filter = default, int offset = default, int limit = default)
        {
            this.SupergroupId = supergroupId;
            this.Filter = filter;
            this.Offset = offset;
            this.Limit = limit;
        }
    }

    public partial class DeleteSupergroup
    {
        /// <summary>
        /// Deletes a supergroup or channel along with all messages in the corresponding chat. This will release the supergroup or channel username and remove all members; requires owner privileges in the supergroup or channel. Chats with more than 1000 members can't be deleted using this method
        /// </summary>
        public DeleteSupergroup() { }
        /// <summary>
        /// Deletes a supergroup or channel along with all messages in the corresponding chat. This will release the supergroup or channel username and remove all members; requires owner privileges in the supergroup or channel. Chats with more than 1000 members can't be deleted using this method
        /// </summary>
        /// <param name="supergroupId">Identifier of the supergroup or channel</param>
        public DeleteSupergroup(int supergroupId = default)
        {
            this.SupergroupId = supergroupId;
        }
    }

    public partial class CloseSecretChat
    {
        /// <summary>
        /// Closes a secret chat, effectively transferring its state to secretChatStateClosed
        /// </summary>
        public CloseSecretChat() { }
        /// <summary>
        /// Closes a secret chat, effectively transferring its state to secretChatStateClosed
        /// </summary>
        /// <param name="secretChatId">Secret chat identifier</param>
        public CloseSecretChat(int secretChatId = default)
        {
            this.SecretChatId = secretChatId;
        }
    }

    public partial class GetChatEventLog
    {
        /// <summary>
        /// Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i. e., in order of decreasing event_id)
        /// </summary>
        public GetChatEventLog() { }
        /// <summary>
        /// Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i. e., in order of decreasing event_id)
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="query">Search query by which to filter events</param>
        /// <param name="fromEventId">Identifier of an event from which to return results. Use 0 to get results from the latest events</param>
        /// <param name="limit">The maximum number of events to return; up to 100</param>
        /// <param name="filters">The types of events to return. By default, all types will be returned</param>
        /// <param name="userIds">User identifiers by which to filter events. By default, events relating to all users will be returned</param>
        public GetChatEventLog(long chatId = default, string query = default, long fromEventId = default, int limit = default, ChatEventLogFilters filters = default, int[] userIds = default)
        {
            this.ChatId = chatId;
            this.Query = query;
            this.FromEventId = fromEventId;
            this.Limit = limit;
            this.Filters = filters;
            this.UserIds = userIds;
        }
    }

    public partial class GetPaymentForm
    {
        /// <summary>
        /// Returns an invoice payment form. This method should be called when the user presses inlineKeyboardButtonBuy
        /// </summary>
        public GetPaymentForm() { }
        /// <summary>
        /// Returns an invoice payment form. This method should be called when the user presses inlineKeyboardButtonBuy
        /// </summary>
        /// <param name="chatId">Chat identifier of the Invoice message</param>
        /// <param name="messageId">Message identifier</param>
        public GetPaymentForm(long chatId = default, long messageId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
        }
    }

    public partial class ValidateOrderInfo
    {
        /// <summary>
        /// Validates the order information provided by a user and returns the available shipping options for a flexible invoice
        /// </summary>
        public ValidateOrderInfo() { }
        /// <summary>
        /// Validates the order information provided by a user and returns the available shipping options for a flexible invoice
        /// </summary>
        /// <param name="chatId">Chat identifier of the Invoice message</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="orderInfo">The order information, provided by the user</param>
        /// <param name="allowSave">True, if the order information can be saved</param>
        public ValidateOrderInfo(long chatId = default, long messageId = default, OrderInfo orderInfo = default, bool allowSave = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.OrderInfo = orderInfo;
            this.AllowSave = allowSave;
        }
    }

    public partial class SendPaymentForm
    {
        /// <summary>
        /// Sends a filled-out payment form to the bot for final verification
        /// </summary>
        public SendPaymentForm() { }
        /// <summary>
        /// Sends a filled-out payment form to the bot for final verification
        /// </summary>
        /// <param name="chatId">Chat identifier of the Invoice message</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="orderInfoId">Identifier returned by ValidateOrderInfo, or an empty string</param>
        /// <param name="shippingOptionId">Identifier of a chosen shipping option, if applicable</param>
        /// <param name="credentials">The credentials chosen by user for payment</param>
        public SendPaymentForm(long chatId = default, long messageId = default, string orderInfoId = default, string shippingOptionId = default, InputCredentials credentials = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.OrderInfoId = orderInfoId;
            this.ShippingOptionId = shippingOptionId;
            this.Credentials = credentials;
        }
    }

    public partial class GetPaymentReceipt
    {
        /// <summary>
        /// Returns information about a successful payment
        /// </summary>
        public GetPaymentReceipt() { }
        /// <summary>
        /// Returns information about a successful payment
        /// </summary>
        /// <param name="chatId">Chat identifier of the PaymentSuccessful message</param>
        /// <param name="messageId">Message identifier</param>
        public GetPaymentReceipt(long chatId = default, long messageId = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
        }
    }

    public partial class GetSavedOrderInfo
    {
        /// <summary>
        /// Returns saved order info, if any
        /// </summary>
        public GetSavedOrderInfo() { }
    }

    public partial class DeleteSavedOrderInfo
    {
        /// <summary>
        /// Deletes saved order info
        /// </summary>
        public DeleteSavedOrderInfo() { }
    }

    public partial class DeleteSavedCredentials
    {
        /// <summary>
        /// Deletes saved credentials for all payment provider bots
        /// </summary>
        public DeleteSavedCredentials() { }
    }

    public partial class GetSupportUser
    {
        /// <summary>
        /// Returns a user that can be contacted to get support
        /// </summary>
        public GetSupportUser() { }
    }

    public partial class GetBackgrounds
    {
        /// <summary>
        /// Returns backgrounds installed by the user
        /// </summary>
        public GetBackgrounds() { }
        /// <summary>
        /// Returns backgrounds installed by the user
        /// </summary>
        /// <param name="forDarkTheme">True, if the backgrounds need to be ordered for dark theme</param>
        public GetBackgrounds(bool forDarkTheme = default)
        {
            this.ForDarkTheme = forDarkTheme;
        }
    }

    public partial class GetBackgroundUrl
    {
        /// <summary>
        /// Constructs a persistent HTTP URL for a background
        /// </summary>
        public GetBackgroundUrl() { }
        /// <summary>
        /// Constructs a persistent HTTP URL for a background
        /// </summary>
        /// <param name="name">Background name</param>
        /// <param name="type">Background type</param>
        public GetBackgroundUrl(string name = default, BackgroundType type = default)
        {
            this.Name = name;
            this.Type = type;
        }
    }

    public partial class SearchBackground
    {
        /// <summary>
        /// Searches for a background by its name
        /// </summary>
        public SearchBackground() { }
        /// <summary>
        /// Searches for a background by its name
        /// </summary>
        /// <param name="name">The name of the background</param>
        public SearchBackground(string name = default)
        {
            this.Name = name;
        }
    }

    public partial class SetBackground
    {
        /// <summary>
        /// Changes the background selected by the user; adds background to the list of installed backgrounds
        /// </summary>
        public SetBackground() { }
        /// <summary>
        /// Changes the background selected by the user; adds background to the list of installed backgrounds
        /// </summary>
        /// <param name="background">The input background to use, null for filled backgrounds</param>
        /// <param name="type">Background type; null for default background. The method will return error 404 if type is null</param>
        /// <param name="forDarkTheme">True, if the background is chosen for dark theme</param>
        public SetBackground(InputBackground background = default, BackgroundType type = default, bool forDarkTheme = default)
        {
            this.Background = background;
            this.Type = type;
            this.ForDarkTheme = forDarkTheme;
        }
    }

    public partial class RemoveBackground
    {
        /// <summary>
        /// Removes background from the list of installed backgrounds
        /// </summary>
        public RemoveBackground() { }
        /// <summary>
        /// Removes background from the list of installed backgrounds
        /// </summary>
        /// <param name="backgroundId">The background identifier</param>
        public RemoveBackground(long backgroundId = default)
        {
            this.BackgroundId = backgroundId;
        }
    }

    public partial class ResetBackgrounds
    {
        /// <summary>
        /// Resets list of installed backgrounds to its default value
        /// </summary>
        public ResetBackgrounds() { }
    }

    public partial class GetLocalizationTargetInfo
    {
        /// <summary>
        /// Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization
        /// </summary>
        public GetLocalizationTargetInfo() { }
        /// <summary>
        /// Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization
        /// </summary>
        /// <param name="onlyLocal">If true, returns only locally available information without sending network requests</param>
        public GetLocalizationTargetInfo(bool onlyLocal = default)
        {
            this.OnlyLocal = onlyLocal;
        }
    }

    public partial class GetLanguagePackInfo
    {
        /// <summary>
        /// Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization
        /// </summary>
        public GetLanguagePackInfo() { }
        /// <summary>
        /// Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Language pack identifier</param>
        public GetLanguagePackInfo(string languagePackId = default)
        {
            this.LanguagePackId = languagePackId;
        }
    }

    public partial class GetLanguagePackStrings
    {
        /// <summary>
        /// Returns strings from a language pack in the current localization target by their keys. Can be called before authorization
        /// </summary>
        public GetLanguagePackStrings() { }
        /// <summary>
        /// Returns strings from a language pack in the current localization target by their keys. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Language pack identifier of the strings to be returned</param>
        /// <param name="keys">Language pack keys of the strings to be returned; leave empty to request all available strings</param>
        public GetLanguagePackStrings(string languagePackId = default, string[] keys = default)
        {
            this.LanguagePackId = languagePackId;
            this.Keys = keys;
        }
    }

    public partial class SynchronizeLanguagePack
    {
        /// <summary>
        /// Fetches the latest versions of all strings from a language pack in the current localization target from the server. This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization
        /// </summary>
        public SynchronizeLanguagePack() { }
        /// <summary>
        /// Fetches the latest versions of all strings from a language pack in the current localization target from the server. This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Language pack identifier</param>
        public SynchronizeLanguagePack(string languagePackId = default)
        {
            this.LanguagePackId = languagePackId;
        }
    }

    public partial class AddCustomServerLanguagePack
    {
        /// <summary>
        /// Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization
        /// </summary>
        public AddCustomServerLanguagePack() { }
        /// <summary>
        /// Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Identifier of a language pack to be added; may be different from a name that is used in an "https://t.me/setlanguage/" link</param>
        public AddCustomServerLanguagePack(string languagePackId = default)
        {
            this.LanguagePackId = languagePackId;
        }
    }

    public partial class SetCustomLanguagePack
    {
        /// <summary>
        /// Adds or changes a custom local language pack to the current localization target
        /// </summary>
        public SetCustomLanguagePack() { }
        /// <summary>
        /// Adds or changes a custom local language pack to the current localization target
        /// </summary>
        /// <param name="info">Information about the language pack. Language pack ID must start with 'X', consist only of English letters, digits and hyphens, and must not exceed 64 characters. Can be called before authorization</param>
        /// <param name="strings">Strings of the new language pack</param>
        public SetCustomLanguagePack(LanguagePackInfo info = default, LanguagePackString[] strings = default)
        {
            this.Info = info;
            this.Strings = strings;
        }
    }

    public partial class EditCustomLanguagePackInfo
    {
        /// <summary>
        /// Edits information about a custom local language pack in the current localization target. Can be called before authorization
        /// </summary>
        public EditCustomLanguagePackInfo() { }
        /// <summary>
        /// Edits information about a custom local language pack in the current localization target. Can be called before authorization
        /// </summary>
        /// <param name="info">New information about the custom local language pack</param>
        public EditCustomLanguagePackInfo(LanguagePackInfo info = default)
        {
            this.Info = info;
        }
    }

    public partial class SetCustomLanguagePackString
    {
        /// <summary>
        /// Adds, edits or deletes a string in a custom local language pack. Can be called before authorization
        /// </summary>
        public SetCustomLanguagePackString() { }
        /// <summary>
        /// Adds, edits or deletes a string in a custom local language pack. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Identifier of a previously added custom local language pack in the current localization target</param>
        /// <param name="newString">New language pack string</param>
        public SetCustomLanguagePackString(string languagePackId = default, LanguagePackString newString = default)
        {
            this.LanguagePackId = languagePackId;
            this.NewString = newString;
        }
    }

    public partial class DeleteLanguagePack
    {
        /// <summary>
        /// Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted. Can be called before authorization
        /// </summary>
        public DeleteLanguagePack() { }
        /// <summary>
        /// Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Identifier of the language pack to delete</param>
        public DeleteLanguagePack(string languagePackId = default)
        {
            this.LanguagePackId = languagePackId;
        }
    }

    public partial class RegisterDevice
    {
        /// <summary>
        /// Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription
        /// </summary>
        public RegisterDevice() { }
        /// <summary>
        /// Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription
        /// </summary>
        /// <param name="deviceToken">Device token</param>
        /// <param name="otherUserIds">List of user identifiers of other users currently using the application</param>
        public RegisterDevice(DeviceToken deviceToken = default, int[] otherUserIds = default)
        {
            this.DeviceToken = deviceToken;
            this.OtherUserIds = otherUserIds;
        }
    }

    public partial class ProcessPushNotification
    {
        /// <summary>
        /// Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization
        /// </summary>
        public ProcessPushNotification() { }
        /// <summary>
        /// Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization
        /// </summary>
        /// <param name="payload">JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time" and "google.notification.sound" fields added</param>
        public ProcessPushNotification(string payload = default)
        {
            this.Payload = payload;
        }
    }

    public partial class GetPushReceiverId
    {
        /// <summary>
        /// Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
        /// </summary>
        public GetPushReceiverId() { }
        /// <summary>
        /// Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
        /// </summary>
        /// <param name="payload">JSON-encoded push notification payload</param>
        public GetPushReceiverId(string payload = default)
        {
            this.Payload = payload;
        }
    }

    public partial class GetRecentlyVisitedTMeUrls
    {
        /// <summary>
        /// Returns t.me URLs recently visited by a newly registered user
        /// </summary>
        public GetRecentlyVisitedTMeUrls() { }
        /// <summary>
        /// Returns t.me URLs recently visited by a newly registered user
        /// </summary>
        /// <param name="referrer">Google Play referrer to identify the user</param>
        public GetRecentlyVisitedTMeUrls(string referrer = default)
        {
            this.Referrer = referrer;
        }
    }

    public partial class SetUserPrivacySettingRules
    {
        /// <summary>
        /// Changes user privacy settings
        /// </summary>
        public SetUserPrivacySettingRules() { }
        /// <summary>
        /// Changes user privacy settings
        /// </summary>
        /// <param name="setting">The privacy setting</param>
        /// <param name="rules">The new privacy rules</param>
        public SetUserPrivacySettingRules(UserPrivacySetting setting = default, UserPrivacySettingRules rules = default)
        {
            this.Setting = setting;
            this.Rules = rules;
        }
    }

    public partial class GetUserPrivacySettingRules
    {
        /// <summary>
        /// Returns the current privacy settings
        /// </summary>
        public GetUserPrivacySettingRules() { }
        /// <summary>
        /// Returns the current privacy settings
        /// </summary>
        /// <param name="setting">The privacy setting</param>
        public GetUserPrivacySettingRules(UserPrivacySetting setting = default)
        {
            this.Setting = setting;
        }
    }

    public partial class GetOption
    {
        /// <summary>
        /// Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization
        /// </summary>
        public GetOption() { }
        /// <summary>
        /// Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization
        /// </summary>
        /// <param name="name">The name of the option</param>
        public GetOption(string name = default)
        {
            this.Name = name;
        }
    }

    public partial class SetOption
    {
        /// <summary>
        /// Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
        /// </summary>
        public SetOption() { }
        /// <summary>
        /// Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
        /// </summary>
        /// <param name="name">The name of the option</param>
        /// <param name="value">The new value of the option</param>
        public SetOption(string name = default, OptionValue value = default)
        {
            this.Name = name;
            this.Value = value;
        }
    }

    public partial class SetAccountTtl
    {
        /// <summary>
        /// Changes the period of inactivity after which the account of the current user will automatically be deleted
        /// </summary>
        public SetAccountTtl() { }
        /// <summary>
        /// Changes the period of inactivity after which the account of the current user will automatically be deleted
        /// </summary>
        /// <param name="ttl">New account TTL</param>
        public SetAccountTtl(AccountTtl ttl = default)
        {
            this.Ttl = ttl;
        }
    }

    public partial class GetAccountTtl
    {
        /// <summary>
        /// Returns the period of inactivity after which the account of the current user will automatically be deleted
        /// </summary>
        public GetAccountTtl() { }
    }

    public partial class DeleteAccount
    {
        /// <summary>
        /// Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account. Can be called before authorization when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        public DeleteAccount() { }
        /// <summary>
        /// Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account. Can be called before authorization when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        /// <param name="reason">The reason why the account was deleted; optional</param>
        public DeleteAccount(string reason = default)
        {
            this.Reason = reason;
        }
    }

    public partial class RemoveChatActionBar
    {
        /// <summary>
        /// Removes a chat action bar without any other action
        /// </summary>
        public RemoveChatActionBar() { }
        /// <summary>
        /// Removes a chat action bar without any other action
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public RemoveChatActionBar(long chatId = default)
        {
            this.ChatId = chatId;
        }
    }

    public partial class ReportChat
    {
        /// <summary>
        /// Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if this is a private chats with a bot, a private chat with a user sharing their location, a supergroup, or a channel, since other chats can't be checked by moderators
        /// </summary>
        public ReportChat() { }
        /// <summary>
        /// Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if this is a private chats with a bot, a private chat with a user sharing their location, a supergroup, or a channel, since other chats can't be checked by moderators
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="reason">The reason for reporting the chat</param>
        /// <param name="messageIds">Identifiers of reported messages, if any</param>
        public ReportChat(long chatId = default, ChatReportReason reason = default, long[] messageIds = default)
        {
            this.ChatId = chatId;
            this.Reason = reason;
            this.MessageIds = messageIds;
        }
    }

    public partial class GetChatStatisticsUrl
    {
        /// <summary>
        /// Returns an HTTP URL with the chat statistics. Currently this method of getting the statistics are disabled and can be deleted in the future
        /// </summary>
        public GetChatStatisticsUrl() { }
        /// <summary>
        /// Returns an HTTP URL with the chat statistics. Currently this method of getting the statistics are disabled and can be deleted in the future
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="parameters">Parameters from "tg://statsrefresh?params=******" link</param>
        /// <param name="isDark">Pass true if a URL with the dark theme must be returned</param>
        public GetChatStatisticsUrl(long chatId = default, string parameters = default, bool isDark = default)
        {
            this.ChatId = chatId;
            this.Parameters = parameters;
            this.IsDark = isDark;
        }
    }

    public partial class GetChatStatistics
    {
        /// <summary>
        /// Returns detailed statistics about a chat. Currently this method can be used only for supergroups and channels. Can be used only if SupergroupFullInfo.can_get_statistics == true
        /// </summary>
        public GetChatStatistics() { }
        /// <summary>
        /// Returns detailed statistics about a chat. Currently this method can be used only for supergroups and channels. Can be used only if SupergroupFullInfo.can_get_statistics == true
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="isDark">Pass true if a dark theme is used by the application</param>
        public GetChatStatistics(long chatId = default, bool isDark = default)
        {
            this.ChatId = chatId;
            this.IsDark = isDark;
        }
    }

    public partial class GetMessageStatistics
    {
        /// <summary>
        /// Returns detailed statistics about a message. Can be used only if Message.can_get_statistics == true. The method is under development and may or may not work
        /// </summary>
        public GetMessageStatistics() { }
        /// <summary>
        /// Returns detailed statistics about a message. Can be used only if Message.can_get_statistics == true. The method is under development and may or may not work
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="isDark">Pass true if a dark theme is used by the application</param>
        public GetMessageStatistics(long chatId = default, long messageId = default, bool isDark = default)
        {
            this.ChatId = chatId;
            this.MessageId = messageId;
            this.IsDark = isDark;
        }
    }

    public partial class GetStatisticsGraph
    {
        /// <summary>
        /// Loads asynchronous or zoomed in chat or message statistics graph
        /// </summary>
        public GetStatisticsGraph() { }
        /// <summary>
        /// Loads asynchronous or zoomed in chat or message statistics graph
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="token">The token for graph loading</param>
        /// <param name="x">X-value for zoomed in graph or 0 otherwise</param>
        public GetStatisticsGraph(long chatId = default, string token = default, long x = default)
        {
            this.ChatId = chatId;
            this.Token = token;
            this.X = x;
        }
    }

    public partial class GetStorageStatistics
    {
        /// <summary>
        /// Returns storage usage statistics. Can be called before authorization
        /// </summary>
        public GetStorageStatistics() { }
        /// <summary>
        /// Returns storage usage statistics. Can be called before authorization
        /// </summary>
        /// <param name="chatLimit">The maximum number of chats with the largest storage usage for which separate statistics should be returned. All other chats will be grouped in entries with chat_id == 0. If the chat info database is not used, the chat_limit is ignored and is always set to 0</param>
        public GetStorageStatistics(int chatLimit = default)
        {
            this.ChatLimit = chatLimit;
        }
    }

    public partial class GetStorageStatisticsFast
    {
        /// <summary>
        /// Quickly returns approximate storage usage statistics. Can be called before authorization
        /// </summary>
        public GetStorageStatisticsFast() { }
    }

    public partial class GetDatabaseStatistics
    {
        /// <summary>
        /// Returns database statistics
        /// </summary>
        public GetDatabaseStatistics() { }
    }

    public partial class OptimizeStorage
    {
        /// <summary>
        /// Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted
        /// </summary>
        public OptimizeStorage() { }
        /// <summary>
        /// Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted
        /// </summary>
        /// <param name="size">Limit on the total size of files after deletion. Pass -1 to use the default limit</param>
        /// <param name="ttl">Limit on the time that has passed since the last time a file was accessed (or creation time for some filesystems). Pass -1 to use the default limit</param>
        /// <param name="count">Limit on the total count of files after deletion. Pass -1 to use the default limit</param>
        /// <param name="immunityDelay">The amount of time after the creation of a file during which it can't be deleted, in seconds. Pass -1 to use the default value</param>
        /// <param name="fileTypes">If not empty, only files with the given type(s) are considered. By default, all types except thumbnails, profile photos, stickers and wallpapers are deleted</param>
        /// <param name="chatIds">If not empty, only files from the given chats are considered. Use 0 as chat identifier to delete files not belonging to any chat (e.g., profile photos)</param>
        /// <param name="excludeChatIds">If not empty, files from the given chats are excluded. Use 0 as chat identifier to exclude all files not belonging to any chat (e.g., profile photos)</param>
        /// <param name="returnDeletedFileStatistics">Pass true if deleted file statistics need to be returned instead of the whole storage usage statistics. Affects only returned statistics</param>
        /// <param name="chatLimit">Same as in getStorageStatistics. Affects only returned statistics</param>
        public OptimizeStorage(long size = default, int ttl = default, int count = default, int immunityDelay = default, FileType[] fileTypes = default, long[] chatIds = default, long[] excludeChatIds = default, bool returnDeletedFileStatistics = default, int chatLimit = default)
        {
            this.Size = size;
            this.Ttl = ttl;
            this.Count = count;
            this.ImmunityDelay = immunityDelay;
            this.FileTypes = fileTypes;
            this.ChatIds = chatIds;
            this.ExcludeChatIds = excludeChatIds;
            this.ReturnDeletedFileStatistics = returnDeletedFileStatistics;
            this.ChatLimit = chatLimit;
        }
    }

    public partial class SetNetworkType
    {
        /// <summary>
        /// Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks, so it should be called whenever the network is changed, even if the network type remains the same. -Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics
        /// </summary>
        public SetNetworkType() { }
        /// <summary>
        /// Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks, so it should be called whenever the network is changed, even if the network type remains the same. -Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics
        /// </summary>
        /// <param name="type">The new network type. By default, networkTypeOther</param>
        public SetNetworkType(NetworkType type = default)
        {
            this.Type = type;
        }
    }

    public partial class GetNetworkStatistics
    {
        /// <summary>
        /// Returns network data usage statistics. Can be called before authorization
        /// </summary>
        public GetNetworkStatistics() { }
        /// <summary>
        /// Returns network data usage statistics. Can be called before authorization
        /// </summary>
        /// <param name="onlyCurrent">If true, returns only data for the current library launch</param>
        public GetNetworkStatistics(bool onlyCurrent = default)
        {
            this.OnlyCurrent = onlyCurrent;
        }
    }

    public partial class AddNetworkStatistics
    {
        /// <summary>
        /// Adds the specified data to data usage statistics. Can be called before authorization
        /// </summary>
        public AddNetworkStatistics() { }
        /// <summary>
        /// Adds the specified data to data usage statistics. Can be called before authorization
        /// </summary>
        /// <param name="entry">The network statistics entry with the data to be added to statistics</param>
        public AddNetworkStatistics(NetworkStatisticsEntry entry = default)
        {
            this.Entry = entry;
        }
    }

    public partial class ResetNetworkStatistics
    {
        /// <summary>
        /// Resets all network data usage statistics to zero. Can be called before authorization
        /// </summary>
        public ResetNetworkStatistics() { }
    }

    public partial class GetAutoDownloadSettingsPresets
    {
        /// <summary>
        /// Returns auto-download settings presets for the current user
        /// </summary>
        public GetAutoDownloadSettingsPresets() { }
    }

    public partial class SetAutoDownloadSettings
    {
        /// <summary>
        /// Sets auto-download settings
        /// </summary>
        public SetAutoDownloadSettings() { }
        /// <summary>
        /// Sets auto-download settings
        /// </summary>
        /// <param name="settings">New user auto-download settings</param>
        /// <param name="type">Type of the network for which the new settings are applied</param>
        public SetAutoDownloadSettings(AutoDownloadSettings settings = default, NetworkType type = default)
        {
            this.Settings = settings;
            this.Type = type;
        }
    }

    public partial class GetBankCardInfo
    {
        /// <summary>
        /// Returns information about a bank card
        /// </summary>
        public GetBankCardInfo() { }
        /// <summary>
        /// Returns information about a bank card
        /// </summary>
        /// <param name="bankCardNumber">The bank card number</param>
        public GetBankCardInfo(string bankCardNumber = default)
        {
            this.BankCardNumber = bankCardNumber;
        }
    }

    public partial class GetPassportElement
    {
        /// <summary>
        /// Returns one of the available Telegram Passport elements
        /// </summary>
        public GetPassportElement() { }
        /// <summary>
        /// Returns one of the available Telegram Passport elements
        /// </summary>
        /// <param name="type">Telegram Passport element type</param>
        /// <param name="password">Password of the current user</param>
        public GetPassportElement(PassportElementType type = default, string password = default)
        {
            this.Type = type;
            this.Password = password;
        }
    }

    public partial class GetAllPassportElements
    {
        /// <summary>
        /// Returns all available Telegram Passport elements
        /// </summary>
        public GetAllPassportElements() { }
        /// <summary>
        /// Returns all available Telegram Passport elements
        /// </summary>
        /// <param name="password">Password of the current user</param>
        public GetAllPassportElements(string password = default)
        {
            this.Password = password;
        }
    }

    public partial class SetPassportElement
    {
        /// <summary>
        /// Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first
        /// </summary>
        public SetPassportElement() { }
        /// <summary>
        /// Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first
        /// </summary>
        /// <param name="element">Input Telegram Passport element</param>
        /// <param name="password">Password of the current user</param>
        public SetPassportElement(InputPassportElement element = default, string password = default)
        {
            this.Element = element;
            this.Password = password;
        }
    }

    public partial class DeletePassportElement
    {
        /// <summary>
        /// Deletes a Telegram Passport element
        /// </summary>
        public DeletePassportElement() { }
        /// <summary>
        /// Deletes a Telegram Passport element
        /// </summary>
        /// <param name="type">Element type</param>
        public DeletePassportElement(PassportElementType type = default)
        {
            this.Type = type;
        }
    }

    public partial class SetPassportElementErrors
    {
        /// <summary>
        /// Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed
        /// </summary>
        public SetPassportElementErrors() { }
        /// <summary>
        /// Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="errors">The errors</param>
        public SetPassportElementErrors(int userId = default, InputPassportElementError[] errors = default)
        {
            this.UserId = userId;
            this.Errors = errors;
        }
    }

    public partial class GetPreferredCountryLanguage
    {
        /// <summary>
        /// Returns an IETF language tag of the language preferred in the country, which should be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown
        /// </summary>
        public GetPreferredCountryLanguage() { }
        /// <summary>
        /// Returns an IETF language tag of the language preferred in the country, which should be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown
        /// </summary>
        /// <param name="countryCode">A two-letter ISO 3166-1 alpha-2 country code</param>
        public GetPreferredCountryLanguage(string countryCode = default)
        {
            this.CountryCode = countryCode;
        }
    }

    public partial class SendPhoneNumberVerificationCode
    {
        /// <summary>
        /// Sends a code to verify a phone number to be added to a user's Telegram Passport
        /// </summary>
        public SendPhoneNumberVerificationCode() { }
        /// <summary>
        /// Sends a code to verify a phone number to be added to a user's Telegram Passport
        /// </summary>
        /// <param name="phoneNumber">The phone number of the user, in international format</param>
        /// <param name="settings">Settings for the authentication of the user's phone number</param>
        public SendPhoneNumberVerificationCode(string phoneNumber = default, PhoneNumberAuthenticationSettings settings = default)
        {
            this.PhoneNumber = phoneNumber;
            this.Settings = settings;
        }
    }

    public partial class ResendPhoneNumberVerificationCode
    {
        /// <summary>
        /// Re-sends the code to verify a phone number to be added to a user's Telegram Passport
        /// </summary>
        public ResendPhoneNumberVerificationCode() { }
    }

    public partial class CheckPhoneNumberVerificationCode
    {
        /// <summary>
        /// Checks the phone number verification code for Telegram Passport
        /// </summary>
        public CheckPhoneNumberVerificationCode() { }
        /// <summary>
        /// Checks the phone number verification code for Telegram Passport
        /// </summary>
        /// <param name="code">Verification code</param>
        public CheckPhoneNumberVerificationCode(string code = default)
        {
            this.Code = code;
        }
    }

    public partial class SendEmailAddressVerificationCode
    {
        /// <summary>
        /// Sends a code to verify an email address to be added to a user's Telegram Passport
        /// </summary>
        public SendEmailAddressVerificationCode() { }
        /// <summary>
        /// Sends a code to verify an email address to be added to a user's Telegram Passport
        /// </summary>
        /// <param name="emailAddress">Email address</param>
        public SendEmailAddressVerificationCode(string emailAddress = default)
        {
            this.EmailAddress = emailAddress;
        }
    }

    public partial class ResendEmailAddressVerificationCode
    {
        /// <summary>
        /// Re-sends the code to verify an email address to be added to a user's Telegram Passport
        /// </summary>
        public ResendEmailAddressVerificationCode() { }
    }

    public partial class CheckEmailAddressVerificationCode
    {
        /// <summary>
        /// Checks the email address verification code for Telegram Passport
        /// </summary>
        public CheckEmailAddressVerificationCode() { }
        /// <summary>
        /// Checks the email address verification code for Telegram Passport
        /// </summary>
        /// <param name="code">Verification code</param>
        public CheckEmailAddressVerificationCode(string code = default)
        {
            this.Code = code;
        }
    }

    public partial class GetPassportAuthorizationForm
    {
        /// <summary>
        /// Returns a Telegram Passport authorization form for sharing data with a service
        /// </summary>
        public GetPassportAuthorizationForm() { }
        /// <summary>
        /// Returns a Telegram Passport authorization form for sharing data with a service
        /// </summary>
        /// <param name="botUserId">User identifier of the service's bot</param>
        /// <param name="scope">Telegram Passport element types requested by the service</param>
        /// <param name="publicKey">Service's public_key</param>
        /// <param name="nonce">Authorization form nonce provided by the service</param>
        public GetPassportAuthorizationForm(int botUserId = default, string scope = default, string publicKey = default, string nonce = default)
        {
            this.BotUserId = botUserId;
            this.Scope = scope;
            this.PublicKey = publicKey;
            this.Nonce = nonce;
        }
    }

    public partial class GetPassportAuthorizationFormAvailableElements
    {
        /// <summary>
        /// Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form
        /// </summary>
        public GetPassportAuthorizationFormAvailableElements() { }
        /// <summary>
        /// Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form
        /// </summary>
        /// <param name="autorizationFormId">Authorization form identifier</param>
        /// <param name="password">Password of the current user</param>
        public GetPassportAuthorizationFormAvailableElements(int autorizationFormId = default, string password = default)
        {
            this.AutorizationFormId = autorizationFormId;
            this.Password = password;
        }
    }

    public partial class SendPassportAuthorizationForm
    {
        /// <summary>
        /// Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements need to be used
        /// </summary>
        public SendPassportAuthorizationForm() { }
        /// <summary>
        /// Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements need to be used
        /// </summary>
        /// <param name="autorizationFormId">Authorization form identifier</param>
        /// <param name="types">Types of Telegram Passport elements chosen by user to complete the authorization form</param>
        public SendPassportAuthorizationForm(int autorizationFormId = default, PassportElementType[] types = default)
        {
            this.AutorizationFormId = autorizationFormId;
            this.Types = types;
        }
    }

    public partial class SendPhoneNumberConfirmationCode
    {
        /// <summary>
        /// Sends phone number confirmation code. Should be called when user presses "https://t.me/confirmphone?phone=*******&amp;hash=**********" or "tg://confirmphone?phone=*******&amp;hash=**********" link
        /// </summary>
        public SendPhoneNumberConfirmationCode() { }
        /// <summary>
        /// Sends phone number confirmation code. Should be called when user presses "https://t.me/confirmphone?phone=*******&amp;hash=**********" or "tg://confirmphone?phone=*******&amp;hash=**********" link
        /// </summary>
        /// <param name="hash">Value of the "hash" parameter from the link</param>
        /// <param name="phoneNumber">Value of the "phone" parameter from the link</param>
        /// <param name="settings">Settings for the authentication of the user's phone number</param>
        public SendPhoneNumberConfirmationCode(string hash = default, string phoneNumber = default, PhoneNumberAuthenticationSettings settings = default)
        {
            this.Hash = hash;
            this.PhoneNumber = phoneNumber;
            this.Settings = settings;
        }
    }

    public partial class ResendPhoneNumberConfirmationCode
    {
        /// <summary>
        /// Resends phone number confirmation code
        /// </summary>
        public ResendPhoneNumberConfirmationCode() { }
    }

    public partial class CheckPhoneNumberConfirmationCode
    {
        /// <summary>
        /// Checks phone number confirmation code
        /// </summary>
        public CheckPhoneNumberConfirmationCode() { }
        /// <summary>
        /// Checks phone number confirmation code
        /// </summary>
        /// <param name="code">The phone number confirmation code</param>
        public CheckPhoneNumberConfirmationCode(string code = default)
        {
            this.Code = code;
        }
    }

    public partial class SetBotUpdatesStatus
    {
        /// <summary>
        /// Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
        /// </summary>
        public SetBotUpdatesStatus() { }
        /// <summary>
        /// Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
        /// </summary>
        /// <param name="pendingUpdateCount">The number of pending updates</param>
        /// <param name="errorMessage">The last error message</param>
        public SetBotUpdatesStatus(int pendingUpdateCount = default, string errorMessage = default)
        {
            this.PendingUpdateCount = pendingUpdateCount;
            this.ErrorMessage = errorMessage;
        }
    }

    public partial class UploadStickerFile
    {
        /// <summary>
        /// Uploads a PNG image with a sticker; for bots only; returns the uploaded file
        /// </summary>
        public UploadStickerFile() { }
        /// <summary>
        /// Uploads a PNG image with a sticker; for bots only; returns the uploaded file
        /// </summary>
        /// <param name="userId">Sticker file owner</param>
        /// <param name="pngSticker">PNG image with the sticker; must be up to 512 KB in size and fit in 512x512 square</param>
        public UploadStickerFile(int userId = default, InputFile pngSticker = default)
        {
            this.UserId = userId;
            this.PngSticker = pngSticker;
        }
    }

    public partial class CreateNewStickerSet
    {
        /// <summary>
        /// Creates a new sticker set; for bots only. Returns the newly created sticker set
        /// </summary>
        public CreateNewStickerSet() { }
        /// <summary>
        /// Creates a new sticker set; for bots only. Returns the newly created sticker set
        /// </summary>
        /// <param name="userId">Sticker set owner</param>
        /// <param name="title">Sticker set title; 1-64 characters</param>
        /// <param name="name">Sticker set name. Can contain only English letters, digits and underscores. Must end with *"_by_&lt;bot username&gt;"* (*&lt;bot_username&gt;* is case insensitive); 1-64 characters</param>
        /// <param name="isMasks">True, if stickers are masks. Animated stickers can't be masks</param>
        /// <param name="stickers">List of stickers to be added to the set; must be non-empty. All stickers must be of the same type</param>
        public CreateNewStickerSet(int userId = default, string title = default, string name = default, bool isMasks = default, InputSticker[] stickers = default)
        {
            this.UserId = userId;
            this.Title = title;
            this.Name = name;
            this.IsMasks = isMasks;
            this.Stickers = stickers;
        }
    }

    public partial class AddStickerToSet
    {
        /// <summary>
        /// Adds a new sticker to a set; for bots only. Returns the sticker set
        /// </summary>
        public AddStickerToSet() { }
        /// <summary>
        /// Adds a new sticker to a set; for bots only. Returns the sticker set
        /// </summary>
        /// <param name="userId">Sticker set owner</param>
        /// <param name="name">Sticker set name</param>
        /// <param name="sticker">Sticker to add to the set</param>
        public AddStickerToSet(int userId = default, string name = default, InputSticker sticker = default)
        {
            this.UserId = userId;
            this.Name = name;
            this.Sticker = sticker;
        }
    }

    public partial class SetStickerSetThumbnail
    {
        /// <summary>
        /// Sets a sticker set thumbnail; for bots only. Returns the sticker set
        /// </summary>
        public SetStickerSetThumbnail() { }
        /// <summary>
        /// Sets a sticker set thumbnail; for bots only. Returns the sticker set
        /// </summary>
        /// <param name="userId">Sticker set owner</param>
        /// <param name="name">Sticker set name</param>
        /// <param name="thumbnail">Thumbnail to set in PNG or TGS format. Animated thumbnail must be set for animated sticker sets and only for them. Pass a zero InputFileId to delete the thumbnail</param>
        public SetStickerSetThumbnail(int userId = default, string name = default, InputFile thumbnail = default)
        {
            this.UserId = userId;
            this.Name = name;
            this.Thumbnail = thumbnail;
        }
    }

    public partial class SetStickerPositionInSet
    {
        /// <summary>
        /// Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
        /// </summary>
        public SetStickerPositionInSet() { }
        /// <summary>
        /// Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
        /// </summary>
        /// <param name="sticker">Sticker</param>
        /// <param name="position">New position of the sticker in the set, zero-based</param>
        public SetStickerPositionInSet(InputFile sticker = default, int position = default)
        {
            this.Sticker = sticker;
            this.Position = position;
        }
    }

    public partial class RemoveStickerFromSet
    {
        /// <summary>
        /// Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
        /// </summary>
        public RemoveStickerFromSet() { }
        /// <summary>
        /// Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
        /// </summary>
        /// <param name="sticker">Sticker</param>
        public RemoveStickerFromSet(InputFile sticker = default)
        {
            this.Sticker = sticker;
        }
    }

    public partial class GetMapThumbnailFile
    {
        /// <summary>
        /// Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded
        /// </summary>
        public GetMapThumbnailFile() { }
        /// <summary>
        /// Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded
        /// </summary>
        /// <param name="location">Location of the map center</param>
        /// <param name="zoom">Map zoom level; 13-20</param>
        /// <param name="width">Map width in pixels before applying scale; 16-1024</param>
        /// <param name="height">Map height in pixels before applying scale; 16-1024</param>
        /// <param name="scale">Map scale; 1-3</param>
        /// <param name="chatId">Identifier of a chat, in which the thumbnail will be shown. Use 0 if unknown</param>
        public GetMapThumbnailFile(Location location = default, int zoom = default, int width = default, int height = default, int scale = default, long chatId = default)
        {
            this.Location = location;
            this.Zoom = zoom;
            this.Width = width;
            this.Height = height;
            this.Scale = scale;
            this.ChatId = chatId;
        }
    }

    public partial class AcceptTermsOfService
    {
        /// <summary>
        /// Accepts Telegram terms of services
        /// </summary>
        public AcceptTermsOfService() { }
        /// <summary>
        /// Accepts Telegram terms of services
        /// </summary>
        /// <param name="termsOfServiceId">Terms of service identifier</param>
        public AcceptTermsOfService(string termsOfServiceId = default)
        {
            this.TermsOfServiceId = termsOfServiceId;
        }
    }

    public partial class SendCustomRequest
    {
        /// <summary>
        /// Sends a custom request; for bots only
        /// </summary>
        public SendCustomRequest() { }
        /// <summary>
        /// Sends a custom request; for bots only
        /// </summary>
        /// <param name="method">The method name</param>
        /// <param name="parameters">JSON-serialized method parameters</param>
        public SendCustomRequest(string method = default, string parameters = default)
        {
            this.Method = method;
            this.Parameters = parameters;
        }
    }

    public partial class AnswerCustomQuery
    {
        /// <summary>
        /// Answers a custom query; for bots only
        /// </summary>
        public AnswerCustomQuery() { }
        /// <summary>
        /// Answers a custom query; for bots only
        /// </summary>
        /// <param name="customQueryId">Identifier of a custom query</param>
        /// <param name="data">JSON-serialized answer to the query</param>
        public AnswerCustomQuery(long customQueryId = default, string data = default)
        {
            this.CustomQueryId = customQueryId;
            this.Data = data;
        }
    }

    public partial class SetAlarm
    {
        /// <summary>
        /// Succeeds after a specified amount of time has passed. Can be called before initialization
        /// </summary>
        public SetAlarm() { }
        /// <summary>
        /// Succeeds after a specified amount of time has passed. Can be called before initialization
        /// </summary>
        /// <param name="seconds">Number of seconds before the function returns</param>
        public SetAlarm(double seconds = default)
        {
            this.Seconds = seconds;
        }
    }

    public partial class GetCountries
    {
        /// <summary>
        /// Returns information about existing countries. Can be called before authorization
        /// </summary>
        public GetCountries() { }
    }

    public partial class GetCountryCode
    {
        /// <summary>
        /// Uses current user IP address to find their country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization
        /// </summary>
        public GetCountryCode() { }
    }

    public partial class GetPhoneNumberInfo
    {
        /// <summary>
        /// Returns information about a phone number by its prefix. Can be called before authorization
        /// </summary>
        public GetPhoneNumberInfo() { }
        /// <summary>
        /// Returns information about a phone number by its prefix. Can be called before authorization
        /// </summary>
        /// <param name="phoneNumberPrefix">The phone number prefix</param>
        public GetPhoneNumberInfo(string phoneNumberPrefix = default)
        {
            this.PhoneNumberPrefix = phoneNumberPrefix;
        }
    }

    public partial class GetInviteText
    {
        /// <summary>
        /// Returns the default text for invitation messages to be used as a placeholder when the current user invites friends to Telegram
        /// </summary>
        public GetInviteText() { }
    }

    public partial class GetDeepLinkInfo
    {
        /// <summary>
        /// Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization
        /// </summary>
        public GetDeepLinkInfo() { }
        /// <summary>
        /// Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization
        /// </summary>
        /// <param name="link">The link</param>
        public GetDeepLinkInfo(string link = default)
        {
            this.Link = link;
        }
    }

    public partial class GetApplicationConfig
    {
        /// <summary>
        /// Returns application config, provided by the server. Can be called before authorization
        /// </summary>
        public GetApplicationConfig() { }
    }

    public partial class SaveApplicationLogEvent
    {
        /// <summary>
        /// Saves application log event on the server. Can be called before authorization
        /// </summary>
        public SaveApplicationLogEvent() { }
        /// <summary>
        /// Saves application log event on the server. Can be called before authorization
        /// </summary>
        /// <param name="type">Event type</param>
        /// <param name="chatId">Optional chat identifier, associated with the event</param>
        /// <param name="data">The log event data</param>
        public SaveApplicationLogEvent(string type = default, long chatId = default, JsonValue data = default)
        {
            this.Type = type;
            this.ChatId = chatId;
            this.Data = data;
        }
    }

    public partial class AddProxy
    {
        /// <summary>
        /// Adds a proxy server for network requests. Can be called before authorization
        /// </summary>
        public AddProxy() { }
        /// <summary>
        /// Adds a proxy server for network requests. Can be called before authorization
        /// </summary>
        /// <param name="server">Proxy server IP address</param>
        /// <param name="port">Proxy server port</param>
        /// <param name="enable">True, if the proxy should be enabled</param>
        /// <param name="type">Proxy type</param>
        public AddProxy(string server = default, int port = default, bool enable = default, ProxyType type = default)
        {
            this.Server = server;
            this.Port = port;
            this.Enable = enable;
            this.Type = type;
        }
    }

    public partial class EditProxy
    {
        /// <summary>
        /// Edits an existing proxy server for network requests. Can be called before authorization
        /// </summary>
        public EditProxy() { }
        /// <summary>
        /// Edits an existing proxy server for network requests. Can be called before authorization
        /// </summary>
        /// <param name="proxyId">Proxy identifier</param>
        /// <param name="server">Proxy server IP address</param>
        /// <param name="port">Proxy server port</param>
        /// <param name="enable">True, if the proxy should be enabled</param>
        /// <param name="type">Proxy type</param>
        public EditProxy(int proxyId = default, string server = default, int port = default, bool enable = default, ProxyType type = default)
        {
            this.ProxyId = proxyId;
            this.Server = server;
            this.Port = port;
            this.Enable = enable;
            this.Type = type;
        }
    }

    public partial class EnableProxy
    {
        /// <summary>
        /// Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization
        /// </summary>
        public EnableProxy() { }
        /// <summary>
        /// Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization
        /// </summary>
        /// <param name="proxyId">Proxy identifier</param>
        public EnableProxy(int proxyId = default)
        {
            this.ProxyId = proxyId;
        }
    }

    public partial class DisableProxy
    {
        /// <summary>
        /// Disables the currently enabled proxy. Can be called before authorization
        /// </summary>
        public DisableProxy() { }
    }

    public partial class RemoveProxy
    {
        /// <summary>
        /// Removes a proxy server. Can be called before authorization
        /// </summary>
        public RemoveProxy() { }
        /// <summary>
        /// Removes a proxy server. Can be called before authorization
        /// </summary>
        /// <param name="proxyId">Proxy identifier</param>
        public RemoveProxy(int proxyId = default)
        {
            this.ProxyId = proxyId;
        }
    }

    public partial class GetProxies
    {
        /// <summary>
        /// Returns list of proxies that are currently set up. Can be called before authorization
        /// </summary>
        public GetProxies() { }
    }

    public partial class GetProxyLink
    {
        /// <summary>
        /// Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization
        /// </summary>
        public GetProxyLink() { }
        /// <summary>
        /// Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization
        /// </summary>
        /// <param name="proxyId">Proxy identifier</param>
        public GetProxyLink(int proxyId = default)
        {
            this.ProxyId = proxyId;
        }
    }

    public partial class PingProxy
    {
        /// <summary>
        /// Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization
        /// </summary>
        public PingProxy() { }
        /// <summary>
        /// Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization
        /// </summary>
        /// <param name="proxyId">Proxy identifier. Use 0 to ping a Telegram server without a proxy</param>
        public PingProxy(int proxyId = default)
        {
            this.ProxyId = proxyId;
        }
    }

    public partial class SetLogStream
    {
        /// <summary>
        /// Sets new log stream for internal logging of TDLib. Can be called synchronously
        /// </summary>
        public SetLogStream() { }
        /// <summary>
        /// Sets new log stream for internal logging of TDLib. Can be called synchronously
        /// </summary>
        /// <param name="logStream">New log stream</param>
        public SetLogStream(LogStream logStream = default)
        {
            this.LogStream = logStream;
        }
    }

    public partial class GetLogStream
    {
        /// <summary>
        /// Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously
        /// </summary>
        public GetLogStream() { }
    }

    public partial class SetLogVerbosityLevel
    {
        /// <summary>
        /// Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
        /// </summary>
        public SetLogVerbosityLevel() { }
        /// <summary>
        /// Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
        /// </summary>
        /// <param name="newVerbosityLevel">New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings, value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds to verbose debug, value greater than 5 and up to 1023 can be used to enable even more logging</param>
        public SetLogVerbosityLevel(int newVerbosityLevel = default)
        {
            this.NewVerbosityLevel = newVerbosityLevel;
        }
    }

    public partial class GetLogVerbosityLevel
    {
        /// <summary>
        /// Returns current verbosity level of the internal logging of TDLib. Can be called synchronously
        /// </summary>
        public GetLogVerbosityLevel() { }
    }

    public partial class GetLogTags
    {
        /// <summary>
        /// Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
        /// </summary>
        public GetLogTags() { }
    }

    public partial class SetLogTagVerbosityLevel
    {
        /// <summary>
        /// Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
        /// </summary>
        public SetLogTagVerbosityLevel() { }
        /// <summary>
        /// Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
        /// </summary>
        /// <param name="tag">Logging tag to change verbosity level</param>
        /// <param name="newVerbosityLevel">New verbosity level; 1-1024</param>
        public SetLogTagVerbosityLevel(string tag = default, int newVerbosityLevel = default)
        {
            this.Tag = tag;
            this.NewVerbosityLevel = newVerbosityLevel;
        }
    }

    public partial class GetLogTagVerbosityLevel
    {
        /// <summary>
        /// Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
        /// </summary>
        public GetLogTagVerbosityLevel() { }
        /// <summary>
        /// Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
        /// </summary>
        /// <param name="tag">Logging tag to change verbosity level</param>
        public GetLogTagVerbosityLevel(string tag = default)
        {
            this.Tag = tag;
        }
    }

    public partial class AddLogMessage
    {
        /// <summary>
        /// Adds a message to TDLib internal log. Can be called synchronously
        /// </summary>
        public AddLogMessage() { }
        /// <summary>
        /// Adds a message to TDLib internal log. Can be called synchronously
        /// </summary>
        /// <param name="verbosityLevel">The minimum verbosity level needed for the message to be logged, 0-1023</param>
        /// <param name="text">Text of a message to log</param>
        public AddLogMessage(int verbosityLevel = default, string text = default)
        {
            this.VerbosityLevel = verbosityLevel;
            this.Text = text;
        }
    }

    public partial class TestCallEmpty
    {
        /// <summary>
        /// Does nothing; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        public TestCallEmpty() { }
    }

    public partial class TestCallString
    {
        /// <summary>
        /// Returns the received string; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        public TestCallString() { }
        /// <summary>
        /// Returns the received string; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">String to return</param>
        public TestCallString(string x = default)
        {
            this.X = x;
        }
    }

    public partial class TestCallBytes
    {
        /// <summary>
        /// Returns the received bytes; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        public TestCallBytes() { }
        /// <summary>
        /// Returns the received bytes; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Bytes to return</param>
        public TestCallBytes(Memory<byte> x = default)
        {
            this.X = x;
        }
    }

    public partial class TestCallVectorInt
    {
        /// <summary>
        /// Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        public TestCallVectorInt() { }
        /// <summary>
        /// Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Vector of numbers to return</param>
        public TestCallVectorInt(int[] x = default)
        {
            this.X = x;
        }
    }

    public partial class TestCallVectorIntObject
    {
        /// <summary>
        /// Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        public TestCallVectorIntObject() { }
        /// <summary>
        /// Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Vector of objects to return</param>
        public TestCallVectorIntObject(TestInt[] x = default)
        {
            this.X = x;
        }
    }

    public partial class TestCallVectorString
    {
        /// <summary>
        /// Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        public TestCallVectorString() { }
        /// <summary>
        /// Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Vector of strings to return</param>
        public TestCallVectorString(string[] x = default)
        {
            this.X = x;
        }
    }

    public partial class TestCallVectorStringObject
    {
        /// <summary>
        /// Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        public TestCallVectorStringObject() { }
        /// <summary>
        /// Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Vector of objects to return</param>
        public TestCallVectorStringObject(TestString[] x = default)
        {
            this.X = x;
        }
    }

    public partial class TestSquareInt
    {
        /// <summary>
        /// Returns the squared received number; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        public TestSquareInt() { }
        /// <summary>
        /// Returns the squared received number; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Number to square</param>
        public TestSquareInt(int x = default)
        {
            this.X = x;
        }
    }

    public partial class TestNetwork
    {
        /// <summary>
        /// Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization
        /// </summary>
        public TestNetwork() { }
    }

    public partial class TestProxy
    {
        /// <summary>
        /// Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization
        /// </summary>
        public TestProxy() { }
        /// <summary>
        /// Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization
        /// </summary>
        /// <param name="server">Proxy server IP address</param>
        /// <param name="port">Proxy server port</param>
        /// <param name="type">Proxy type</param>
        /// <param name="dcId">Identifier of a datacenter, with which to test connection</param>
        /// <param name="timeout">The maximum overall timeout for the request</param>
        public TestProxy(string server = default, int port = default, ProxyType type = default, int dcId = default, double timeout = default)
        {
            this.Server = server;
            this.Port = port;
            this.Type = type;
            this.DcId = dcId;
            this.Timeout = timeout;
        }
    }

    public partial class TestGetDifference
    {
        /// <summary>
        /// Forces an updates.getDifference call to the Telegram servers; for testing only
        /// </summary>
        public TestGetDifference() { }
    }

    public partial class TestUseUpdate
    {
        /// <summary>
        /// Does nothing and ensures that the Update object is used; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        public TestUseUpdate() { }
    }

    public partial class TestReturnError
    {
        /// <summary>
        /// Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
        /// </summary>
        public TestReturnError() { }
        /// <summary>
        /// Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
        /// </summary>
        /// <param name="error">The error to be returned</param>
        public TestReturnError(Error error = default)
        {
            this.Error = error;
        }
    }

}
