// Generated by codegen/genext.rb
using System;
using System.Threading.Tasks;
using TDLibCore;
using TDLibCore.Api;

namespace TDLibCore.ClientExtensions
{
    public static partial class ClientExtensions
    {
        /// <summary>
        /// Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state. Can be called before initialization
        /// </summary>
        public static async Task<AuthorizationState> GetAuthorizationState(this Client client)
        {
            var obj = new GetAuthorizationState();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
        /// </summary>
        /// <param name="parameters">Parameters for TDLib initialization</param>
        public static async Task SetTdlibParameters(this Client client, TdlibParameters parameters = default)
        {
            var obj = new SetTdlibParameters
            {
                Parameters = parameters,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Checks the database encryption key for correctness. Works only when the current authorization state is authorizationStateWaitEncryptionKey
        /// </summary>
        /// <param name="encryptionKey">Encryption key to check or set up</param>
        public static async Task CheckDatabaseEncryptionKey(this Client client, Memory<byte> encryptionKey = default)
        {
            var obj = new CheckDatabaseEncryptionKey
            {
                EncryptionKey = encryptionKey,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber, -or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
        /// </summary>
        /// <param name="phoneNumber">The phone number of the user, in international format</param>
        /// <param name="settings">Settings for the authentication of the user's phone number; pass null to use default settings</param>
        public static async Task SetAuthenticationPhoneNumber(this Client client, string phoneNumber = default, PhoneNumberAuthenticationSettings settings = default)
        {
            var obj = new SetAuthenticationPhoneNumber
            {
                PhoneNumber = phoneNumber,
                Settings = settings,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Re-sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode, the next_code_type of the result is not null and the server-specified timeout has passed
        /// </summary>
        public static async Task ResendAuthenticationCode(this Client client)
        {
            var obj = new ResendAuthenticationCode();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
        /// </summary>
        /// <param name="code">The verification code received via SMS, Telegram message, phone call, or flash call</param>
        public static async Task CheckAuthenticationCode(this Client client, string code = default)
        {
            var obj = new CheckAuthenticationCode
            {
                Code = code,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber, -or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
        /// </summary>
        /// <param name="otherUserIds">List of user identifiers of other users currently using the application</param>
        public static async Task RequestQrCodeAuthentication(this Client client, long[] otherUserIds = default)
        {
            var obj = new RequestQrCodeAuthentication
            {
                OtherUserIds = otherUserIds,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration
        /// </summary>
        /// <param name="firstName">The first name of the user; 1-64 characters</param>
        /// <param name="lastName">The last name of the user; 0-64 characters</param>
        public static async Task RegisterUser(this Client client, string firstName = default, string lastName = default)
        {
            var obj = new RegisterUser
            {
                FirstName = firstName,
                LastName = lastName,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Checks the authentication password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        /// <param name="password">The password to check</param>
        public static async Task CheckAuthenticationPassword(this Client client, string password = default)
        {
            var obj = new CheckAuthenticationPassword
            {
                Password = password,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Requests to send a password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        public static async Task RequestAuthenticationPasswordRecovery(this Client client)
        {
            var obj = new RequestAuthenticationPasswordRecovery();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Checks whether a password recovery code sent to an email address is valid. Works only when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        /// <param name="recoveryCode">Recovery code to check</param>
        public static async Task CheckAuthenticationPasswordRecoveryCode(this Client client, string recoveryCode = default)
        {
            var obj = new CheckAuthenticationPasswordRecoveryCode
            {
                RecoveryCode = recoveryCode,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Recovers the password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        /// <param name="recoveryCode">Recovery code to check</param>
        /// <param name="newPassword">New password of the user; may be empty to remove the password</param>
        /// <param name="newHint">New password hint; may be empty</param>
        public static async Task RecoverAuthenticationPassword(this Client client, string recoveryCode = default, string newPassword = default, string newHint = default)
        {
            var obj = new RecoverAuthenticationPassword
            {
                RecoveryCode = recoveryCode,
                NewPassword = newPassword,
                NewHint = newHint,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
        /// </summary>
        /// <param name="token">The bot token</param>
        public static async Task CheckAuthenticationBotToken(this Client client, string token = default)
        {
            var obj = new CheckAuthenticationBotToken
            {
                Token = token,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent
        /// </summary>
        public static async Task LogOut(this Client client)
        {
            var obj = new LogOut();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization
        /// </summary>
        public static async Task Close(this Client client)
        {
            var obj = new Close();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed. After the destruction completes updateAuthorizationState with authorizationStateClosed will be sent. Can be called before authorization
        /// </summary>
        public static async Task Destroy(this Client client)
        {
            var obj = new Destroy();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Confirms QR code authentication on another device. Returns created session on success
        /// </summary>
        /// <param name="link">A link from a QR code. The link must be scanned by the in-app camera</param>
        public static async Task<Session> ConfirmQrCodeAuthentication(this Client client, string link = default)
        {
            var obj = new ConfirmQrCodeAuthentication
            {
                Link = link,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns all updates needed to restore current TDLib state, i.e. all actual UpdateAuthorizationState/UpdateUser/UpdateNewChat and others. This is especially useful if TDLib is run in a separate process. Can be called before initialization
        /// </summary>
        public static async Task<Updates> GetCurrentState(this Client client)
        {
            var obj = new GetCurrentState();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
        /// </summary>
        /// <param name="newEncryptionKey">New encryption key</param>
        public static async Task SetDatabaseEncryptionKey(this Client client, Memory<byte> newEncryptionKey = default)
        {
            var obj = new SetDatabaseEncryptionKey
            {
                NewEncryptionKey = newEncryptionKey,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns the current state of 2-step verification
        /// </summary>
        public static async Task<PasswordState> GetPasswordState(this Client client)
        {
            var obj = new GetPasswordState();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes the password for the current user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed
        /// </summary>
        /// <param name="oldPassword">Previous password of the user</param>
        /// <param name="newPassword">New password of the user; may be empty to remove the password</param>
        /// <param name="newHint">New password hint; may be empty</param>
        /// <param name="setRecoveryEmailAddress">Pass true if the recovery email address must be changed</param>
        /// <param name="newRecoveryEmailAddress">New recovery email address; may be empty</param>
        public static async Task<PasswordState> SetPassword(this Client client, string oldPassword = default, string newPassword = default, string newHint = default, bool setRecoveryEmailAddress = false, string newRecoveryEmailAddress = default)
        {
            var obj = new SetPassword
            {
                OldPassword = oldPassword,
                NewPassword = newPassword,
                NewHint = newHint,
                SetRecoveryEmailAddress = setRecoveryEmailAddress,
                NewRecoveryEmailAddress = newRecoveryEmailAddress,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user
        /// </summary>
        /// <param name="password">The password for the current user</param>
        public static async Task<RecoveryEmailAddress> GetRecoveryEmailAddress(this Client client, string password = default)
        {
            var obj = new GetRecoveryEmailAddress
            {
                Password = password,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed. -If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation
        /// </summary>
        /// <param name="password">Password of the current user</param>
        /// <param name="newRecoveryEmailAddress">New recovery email address</param>
        public static async Task<PasswordState> SetRecoveryEmailAddress(this Client client, string password = default, string newRecoveryEmailAddress = default)
        {
            var obj = new SetRecoveryEmailAddress
            {
                Password = password,
                NewRecoveryEmailAddress = newRecoveryEmailAddress,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Checks the 2-step verification recovery email address verification code
        /// </summary>
        /// <param name="code">Verification code</param>
        public static async Task<PasswordState> CheckRecoveryEmailAddressCode(this Client client, string code = default)
        {
            var obj = new CheckRecoveryEmailAddressCode
            {
                Code = code,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Resends the 2-step verification recovery email address verification code
        /// </summary>
        public static async Task<PasswordState> ResendRecoveryEmailAddressCode(this Client client)
        {
            var obj = new ResendRecoveryEmailAddressCode();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Requests to send a 2-step verification password recovery code to an email address that was previously set up
        /// </summary>
        public static async Task<EmailAddressAuthenticationCodeInfo> RequestPasswordRecovery(this Client client)
        {
            var obj = new RequestPasswordRecovery();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Checks whether a 2-step verification password recovery code sent to an email address is valid
        /// </summary>
        /// <param name="recoveryCode">Recovery code to check</param>
        public static async Task CheckPasswordRecoveryCode(this Client client, string recoveryCode = default)
        {
            var obj = new CheckPasswordRecoveryCode
            {
                RecoveryCode = recoveryCode,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Recovers the 2-step verification password using a recovery code sent to an email address that was previously set up
        /// </summary>
        /// <param name="recoveryCode">Recovery code to check</param>
        /// <param name="newPassword">New password of the user; may be empty to remove the password</param>
        /// <param name="newHint">New password hint; may be empty</param>
        public static async Task<PasswordState> RecoverPassword(this Client client, string recoveryCode = default, string newPassword = default, string newHint = default)
        {
            var obj = new RecoverPassword
            {
                RecoveryCode = recoveryCode,
                NewPassword = newPassword,
                NewHint = newHint,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Removes 2-step verification password without previous password and access to recovery email address. The password can't be reset immediately and the request needs to be repeated after the specified time
        /// </summary>
        public static async Task<ResetPasswordResult> ResetPassword(this Client client)
        {
            var obj = new ResetPassword();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date &gt; 0
        /// </summary>
        public static async Task CancelPasswordReset(this Client client)
        {
            var obj = new CancelPasswordReset();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Creates a new temporary password for processing payments
        /// </summary>
        /// <param name="password">Persistent user password</param>
        /// <param name="validFor">Time during which the temporary password will be valid, in seconds; must be between 60 and 86400</param>
        public static async Task<TemporaryPasswordState> CreateTemporaryPassword(this Client client, string password = default, int validFor = 0)
        {
            var obj = new CreateTemporaryPassword
            {
                Password = password,
                ValidFor = validFor,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about the current temporary password
        /// </summary>
        public static async Task<TemporaryPasswordState> GetTemporaryPasswordState(this Client client)
        {
            var obj = new GetTemporaryPasswordState();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the current user
        /// </summary>
        public static async Task<User> GetMe(this Client client)
        {
            var obj = new GetMe();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a user by their identifier. This is an offline request if the current user is not a bot
        /// </summary>
        /// <param name="userId">User identifier</param>
        public static async Task<User> GetUser(this Client client, long userId = 0)
        {
            var obj = new GetUser
            {
                UserId = userId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns full information about a user by their identifier
        /// </summary>
        /// <param name="userId">User identifier</param>
        public static async Task<UserFullInfo> GetUserFullInfo(this Client client, long userId = 0)
        {
            var obj = new GetUserFullInfo
            {
                UserId = userId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot
        /// </summary>
        /// <param name="basicGroupId">Basic group identifier</param>
        public static async Task<BasicGroup> GetBasicGroup(this Client client, long basicGroupId = 0)
        {
            var obj = new GetBasicGroup
            {
                BasicGroupId = basicGroupId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns full information about a basic group by its identifier
        /// </summary>
        /// <param name="basicGroupId">Basic group identifier</param>
        public static async Task<BasicGroupFullInfo> GetBasicGroupFullInfo(this Client client, long basicGroupId = 0)
        {
            var obj = new GetBasicGroupFullInfo
            {
                BasicGroupId = basicGroupId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot
        /// </summary>
        /// <param name="supergroupId">Supergroup or channel identifier</param>
        public static async Task<Supergroup> GetSupergroup(this Client client, long supergroupId = 0)
        {
            var obj = new GetSupergroup
            {
                SupergroupId = supergroupId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute
        /// </summary>
        /// <param name="supergroupId">Supergroup or channel identifier</param>
        public static async Task<SupergroupFullInfo> GetSupergroupFullInfo(this Client client, long supergroupId = 0)
        {
            var obj = new GetSupergroupFullInfo
            {
                SupergroupId = supergroupId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a secret chat by its identifier. This is an offline request
        /// </summary>
        /// <param name="secretChatId">Secret chat identifier</param>
        public static async Task<SecretChat> GetSecretChat(this Client client, int secretChatId = 0)
        {
            var obj = new GetSecretChat
            {
                SecretChatId = secretChatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a chat by its identifier, this is an offline request if the current user is not a bot
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task<Chat> GetChat(this Client client, long chatId = 0)
        {
            var obj = new GetChat
            {
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a message
        /// </summary>
        /// <param name="chatId">Identifier of the chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message to get</param>
        public static async Task<Message> GetMessage(this Client client, long chatId = 0, long messageId = 0)
        {
            var obj = new GetMessage
            {
                ChatId = chatId,
                MessageId = messageId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a message, if it is available locally without sending network request. This is an offline request
        /// </summary>
        /// <param name="chatId">Identifier of the chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message to get</param>
        public static async Task<Message> GetMessageLocally(this Client client, long chatId = 0, long messageId = 0)
        {
            var obj = new GetMessageLocally
            {
                ChatId = chatId,
                MessageId = messageId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a message that is replied by a given message. Also returns the pinned message, the game message, and the invoice message for messages of the types messagePinMessage, messageGameScore, and messagePaymentSuccessful respectively
        /// </summary>
        /// <param name="chatId">Identifier of the chat the message belongs to</param>
        /// <param name="messageId">Identifier of the reply message</param>
        public static async Task<Message> GetRepliedMessage(this Client client, long chatId = 0, long messageId = 0)
        {
            var obj = new GetRepliedMessage
            {
                ChatId = chatId,
                MessageId = messageId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a newest pinned message in the chat
        /// </summary>
        /// <param name="chatId">Identifier of the chat the message belongs to</param>
        public static async Task<Message> GetChatPinnedMessage(this Client client, long chatId = 0)
        {
            var obj = new GetChatPinnedMessage
            {
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a message with the callback button that originated a callback query; for bots only
        /// </summary>
        /// <param name="chatId">Identifier of the chat the message belongs to</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="callbackQueryId">Identifier of the callback query</param>
        public static async Task<Message> GetCallbackQueryMessage(this Client client, long chatId = 0, long messageId = 0, long callbackQueryId = 0)
        {
            var obj = new GetCallbackQueryMessage
            {
                ChatId = chatId,
                MessageId = messageId,
                CallbackQueryId = callbackQueryId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about messages. If a message is not found, returns null on the corresponding position of the result
        /// </summary>
        /// <param name="chatId">Identifier of the chat the messages belong to</param>
        /// <param name="messageIds">Identifiers of the messages to get</param>
        public static async Task<Messages> GetMessages(this Client client, long chatId = 0, long[] messageIds = default)
        {
            var obj = new GetMessages
            {
                ChatId = chatId,
                MessageIds = messageIds,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a message thread. Can be used only if message.can_get_message_thread == true
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Identifier of the message</param>
        public static async Task<MessageThreadInfo> GetMessageThread(this Client client, long chatId = 0, long messageId = 0)
        {
            var obj = new GetMessageThread
            {
                ChatId = chatId,
                MessageId = messageId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns viewers of a recent outgoing message in a basic group or a supergroup chat. For video notes and voice notes only users, opened content of the message, are returned. The method can be called if message.can_get_viewers == true
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Identifier of the message</param>
        public static async Task<Users> GetMessageViewers(this Client client, long chatId = 0, long messageId = 0)
        {
            var obj = new GetMessageViewers
            {
                ChatId = chatId,
                MessageId = messageId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a file; this is an offline request
        /// </summary>
        /// <param name="fileId">Identifier of the file to get</param>
        public static async Task<File> GetFile(this Client client, int fileId = 0)
        {
            var obj = new GetFile
            {
                FileId = fileId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a file by its remote ID; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user. -For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
        /// </summary>
        /// <param name="remoteFileId">Remote identifier of the file to get</param>
        /// <param name="fileType">File type; pass null if unknown</param>
        public static async Task<File> GetRemoteFile(this Client client, string remoteFileId = default, FileType fileType = default)
        {
            var obj = new GetRemoteFile
            {
                RemoteFileId = remoteFileId,
                FileType = fileType,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Loads more chats from a chat list. The loaded chats and their positions in the chat list will be sent through updates. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. Returns a 404 error if all chats have been loaded
        /// </summary>
        /// <param name="chatList">The chat list in which to load chats; pass null to load chats from the main chat list</param>
        /// <param name="limit">The maximum number of chats to be loaded. For optimal performance, the number of loaded chats is chosen by TDLib and can be smaller than the specified limit, even if the end of the list is not reached</param>
        public static async Task LoadChats(this Client client, ChatList chatList = default, int limit = 0)
        {
            var obj = new LoadChats
            {
                ChatList = chatList,
                Limit = limit,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns an ordered list of chats from the beginning of a chat list. For informational purposes only. Use loadChats and updates processing instead to maintain chat lists in a consistent state
        /// </summary>
        /// <param name="chatList">The chat list in which to return chats; pass null to get chats from the main chat list</param>
        /// <param name="limit">The maximum number of chats to be returned</param>
        public static async Task<Chats> GetChats(this Client client, ChatList chatList = default, int limit = 0)
        {
            var obj = new GetChats
            {
                ChatList = chatList,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches a public chat by its username. Currently only private chats, supergroups and channels can be public. Returns the chat if found; otherwise an error is returned
        /// </summary>
        /// <param name="username">Username to be resolved</param>
        public static async Task<Chat> SearchPublicChat(this Client client, string username = default)
        {
            var obj = new SearchPublicChat
            {
                Username = username,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches public chats by looking for specified query in their username and title. Currently only private chats, supergroups and channels can be public. Returns a meaningful number of results. -Excludes private chats with contacts and chats from the chat list from the results
        /// </summary>
        /// <param name="query">Query to search for</param>
        public static async Task<Chats> SearchPublicChats(this Client client, string query = default)
        {
            var obj = new SearchPublicChats
            {
                Query = query,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for the specified query in the title and username of already known chats, this is an offline request. Returns chats in the order seen in the main chat list
        /// </summary>
        /// <param name="query">Query to search for. If the query is empty, returns up to 50 recently found chats</param>
        /// <param name="limit">The maximum number of chats to be returned</param>
        public static async Task<Chats> SearchChats(this Client client, string query = default, int limit = 0)
        {
            var obj = new SearchChats
            {
                Query = query,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list
        /// </summary>
        /// <param name="query">Query to search for</param>
        /// <param name="limit">The maximum number of chats to be returned</param>
        public static async Task<Chats> SearchChatsOnServer(this Client client, string query = default, int limit = 0)
        {
            var obj = new SearchChatsOnServer
            {
                Query = query,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby. The request must be sent again every 25 seconds with adjusted location to not miss new chats
        /// </summary>
        /// <param name="location">Current user location</param>
        public static async Task<ChatsNearby> SearchChatsNearby(this Client client, Location location = default)
        {
            var obj = new SearchChatsNearby
            {
                Location = location,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a list of frequently used chats. Supported only if the chat info database is enabled
        /// </summary>
        /// <param name="category">Category of chats to be returned</param>
        /// <param name="limit">The maximum number of chats to be returned; up to 30</param>
        public static async Task<Chats> GetTopChats(this Client client, TopChatCategory category = default, int limit = 0)
        {
            var obj = new GetTopChats
            {
                Category = category,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
        /// </summary>
        /// <param name="category">Category of frequently used chats</param>
        /// <param name="chatId">Chat identifier</param>
        public static async Task RemoveTopChat(this Client client, TopChatCategory category = default, long chatId = 0)
        {
            var obj = new RemoveTopChat
            {
                Category = category,
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
        /// </summary>
        /// <param name="chatId">Identifier of the chat to add</param>
        public static async Task AddRecentlyFoundChat(this Client client, long chatId = 0)
        {
            var obj = new AddRecentlyFoundChat
            {
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Removes a chat from the list of recently found chats
        /// </summary>
        /// <param name="chatId">Identifier of the chat to be removed</param>
        public static async Task RemoveRecentlyFoundChat(this Client client, long chatId = 0)
        {
            var obj = new RemoveRecentlyFoundChat
            {
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Clears the list of recently found chats
        /// </summary>
        public static async Task ClearRecentlyFoundChats(this Client client)
        {
            var obj = new ClearRecentlyFoundChats();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns recently opened chats, this is an offline request. Returns chats in the order of last opening
        /// </summary>
        /// <param name="limit">The maximum number of chats to be returned</param>
        public static async Task<Chats> GetRecentlyOpenedChats(this Client client, int limit = 0)
        {
            var obj = new GetRecentlyOpenedChats
            {
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Checks whether a username can be set for a chat
        /// </summary>
        /// <param name="chatId">Chat identifier; must be identifier of a supergroup chat, or a channel chat, or a private chat with self, or zero if the chat is being created</param>
        /// <param name="username">Username to be checked</param>
        public static async Task<CheckChatUsernameResult> CheckChatUsername(this Client client, long chatId = 0, string username = default)
        {
            var obj = new CheckChatUsername
            {
                ChatId = chatId,
                Username = username,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a list of public chats of the specified type, owned by the user
        /// </summary>
        /// <param name="type">Type of the public chats to return</param>
        public static async Task<Chats> GetCreatedPublicChats(this Client client, PublicChatType type = default)
        {
            var obj = new GetCreatedPublicChats
            {
                Type = type,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached
        /// </summary>
        /// <param name="type">Type of the public chats, for which to check the limit</param>
        public static async Task CheckCreatedPublicChatsLimit(this Client client, PublicChatType type = default)
        {
            var obj = new CheckCreatedPublicChatsLimit
            {
                Type = type,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns a list of basic group and supergroup chats, which can be used as a discussion group for a channel. Returned basic group chats must be first upgraded to supergroups before they can be set as a discussion group. To set a returned supergroup as a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable first
        /// </summary>
        public static async Task<Chats> GetSuitableDiscussionChats(this Client client)
        {
            var obj = new GetSuitableDiscussionChats();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a list of recently inactive supergroups and channels. Can be used when user reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH error
        /// </summary>
        public static async Task<Chats> GetInactiveSupergroupChats(this Client client)
        {
            var obj = new GetInactiveSupergroupChats();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a list of common group chats with a given user. Chats are sorted by their type and creation date
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="offsetChatId">Chat identifier starting from which to return chats; use 0 for the first request</param>
        /// <param name="limit">The maximum number of chats to be returned; up to 100</param>
        public static async Task<Chats> GetGroupsInCommon(this Client client, long userId = 0, long offsetChatId = 0, int limit = 0)
        {
            var obj = new GetGroupsInCommon
            {
                UserId = userId,
                OffsetChatId = offsetChatId,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). -For optimal performance, the number of returned messages is chosen by TDLib. This is an offline request if only_local is true
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="fromMessageId">Identifier of the message starting from which history must be fetched; use 0 to get results from the last message</param>
        /// <param name="offset">Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages</param>
        /// <param name="limit">The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit</param>
        /// <param name="onlyLocal">If true, returns only messages that are available locally without sending network requests</param>
        public static async Task<Messages> GetChatHistory(this Client client, long chatId = 0, long fromMessageId = 0, int offset = 0, int limit = 0, bool onlyLocal = false)
        {
            var obj = new GetChatHistory
            {
                ChatId = chatId,
                FromMessageId = fromMessageId,
                Offset = offset,
                Limit = limit,
                OnlyLocal = onlyLocal,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup. -The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Message identifier, which thread history needs to be returned</param>
        /// <param name="fromMessageId">Identifier of the message starting from which history must be fetched; use 0 to get results from the last message</param>
        /// <param name="offset">Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages</param>
        /// <param name="limit">The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit</param>
        public static async Task<Messages> GetMessageThreadHistory(this Client client, long chatId = 0, long messageId = 0, long fromMessageId = 0, int offset = 0, int limit = 0)
        {
            var obj = new GetMessageThreadHistory
            {
                ChatId = chatId,
                MessageId = messageId,
                FromMessageId = fromMessageId,
                Offset = offset,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="removeFromChatList">Pass true if the chat needs to be removed from the chat list</param>
        /// <param name="revoke">Pass true to try to delete chat history for all users</param>
        public static async Task DeleteChatHistory(this Client client, long chatId = 0, bool removeFromChatList = false, bool revoke = false)
        {
            var obj = new DeleteChatHistory
            {
                ChatId = chatId,
                RemoveFromChatList = removeFromChatList,
                Revoke = revoke,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Deletes a chat along with all messages in the corresponding chat for all chat members; requires owner privileges. For group chats this will release the username and remove all members. Chats with more than 1000 members can't be deleted using this method
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task DeleteChat(this Client client, long chatId = 0)
        {
            var obj = new DeleteChat
            {
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query -(searchSecretMessages must be used instead), or without an enabled message database. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
        /// </summary>
        /// <param name="chatId">Identifier of the chat in which to search messages</param>
        /// <param name="query">Query to search for</param>
        /// <param name="sender">Sender of messages to search for; pass null to search for messages from any sender. Not supported in secret chats</param>
        /// <param name="fromMessageId">Identifier of the message starting from which history must be fetched; use 0 to get results from the last message</param>
        /// <param name="offset">Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages</param>
        /// <param name="limit">The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit</param>
        /// <param name="filter">Additional filter for messages to search; pass null to search for all messages</param>
        /// <param name="messageThreadId">If not 0, only messages in the specified thread will be returned; supergroups only</param>
        public static async Task<Messages> SearchChatMessages(this Client client, long chatId = 0, string query = default, MessageSender sender = default, long fromMessageId = 0, int offset = 0, int limit = 0, SearchMessagesFilter filter = default, long messageThreadId = 0)
        {
            var obj = new SearchChatMessages
            {
                ChatId = chatId,
                Query = query,
                Sender = sender,
                FromMessageId = fromMessageId,
                Offset = offset,
                Limit = limit,
                Filter = filter,
                MessageThreadId = messageThreadId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)). -For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
        /// </summary>
        /// <param name="chatList">Chat list in which to search messages; pass null to search in all chats regardless of their chat list. Only Main and Archive chat lists are supported</param>
        /// <param name="query">Query to search for</param>
        /// <param name="offsetDate">The date of the message starting from which the results need to be fetched. Use 0 or any date in the future to get results from the last message</param>
        /// <param name="offsetChatId">The chat identifier of the last found message, or 0 for the first request</param>
        /// <param name="offsetMessageId">The message identifier of the last found message, or 0 for the first request</param>
        /// <param name="limit">The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit</param>
        /// <param name="filter">Additional filter for messages to search; pass null to search for all messages. Filters searchMessagesFilterCall, searchMessagesFilterMissedCall, searchMessagesFilterMention, searchMessagesFilterUnreadMention, searchMessagesFilterFailedToSend and searchMessagesFilterPinned are unsupported in this function</param>
        /// <param name="minDate">If not 0, the minimum date of the messages to return</param>
        /// <param name="maxDate">If not 0, the maximum date of the messages to return</param>
        public static async Task<Messages> SearchMessages(this Client client, ChatList chatList = default, string query = default, int offsetDate = 0, long offsetChatId = 0, long offsetMessageId = 0, int limit = 0, SearchMessagesFilter filter = default, int minDate = 0, int maxDate = 0)
        {
            var obj = new SearchMessages
            {
                ChatList = chatList,
                Query = query,
                OffsetDate = offsetDate,
                OffsetChatId = offsetChatId,
                OffsetMessageId = offsetMessageId,
                Limit = limit,
                Filter = filter,
                MinDate = minDate,
                MaxDate = maxDate,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance, the number of returned messages is chosen by TDLib
        /// </summary>
        /// <param name="chatId">Identifier of the chat in which to search. Specify 0 to search in all secret chats</param>
        /// <param name="query">Query to search for. If empty, searchChatMessages must be used instead</param>
        /// <param name="offset">Offset of the first entry to return as received from the previous request; use empty string to get first chunk of results</param>
        /// <param name="limit">The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit</param>
        /// <param name="filter">Additional filter for messages to search; pass null to search for all messages</param>
        public static async Task<FoundMessages> SearchSecretMessages(this Client client, long chatId = 0, string query = default, string offset = default, int limit = 0, SearchMessagesFilter filter = default)
        {
            var obj = new SearchSecretMessages
            {
                ChatId = chatId,
                Query = query,
                Offset = offset,
                Limit = limit,
                Filter = filter,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for call messages. Returns the results in reverse chronological order (i. e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
        /// </summary>
        /// <param name="fromMessageId">Identifier of the message from which to search; use 0 to get results from the last message</param>
        /// <param name="limit">The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit</param>
        /// <param name="onlyMissed">If true, returns only messages with missed calls</param>
        public static async Task<Messages> SearchCallMessages(this Client client, long fromMessageId = 0, int limit = 0, bool onlyMissed = false)
        {
            var obj = new SearchCallMessages
            {
                FromMessageId = fromMessageId,
                Limit = limit,
                OnlyMissed = onlyMissed,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Deletes all call messages
        /// </summary>
        /// <param name="revoke">Pass true to delete the messages for all users</param>
        public static async Task DeleteAllCallMessages(this Client client, bool revoke = false)
        {
            var obj = new DeleteAllCallMessages
            {
                Revoke = revoke,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="limit">The maximum number of messages to be returned</param>
        public static async Task<Messages> SearchChatRecentLocationMessages(this Client client, long chatId = 0, int limit = 0)
        {
            var obj = new SearchChatRecentLocationMessages
            {
                ChatId = chatId,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns all active live locations that need to be updated by the application. The list is persistent across application restarts only if the message database is used
        /// </summary>
        public static async Task<Messages> GetActiveLiveLocationMessages(this Client client)
        {
            var obj = new GetActiveLiveLocationMessages();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the last message sent in a chat no later than the specified date
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="date">Point in time (Unix timestamp) relative to which to search for messages</param>
        public static async Task<Message> GetChatMessageByDate(this Client client, long chatId = 0, int date = 0)
        {
            var obj = new GetChatMessageByDate
            {
                ChatId = chatId,
                Date = date,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns sparse positions of messages of the specified type in the chat to be used for shared media scroll implementation. Returns the results in reverse chronological order (i.e., in order of decreasing message_id). -Cannot be used in secret chats or with searchMessagesFilterFailedToSend filter without an enabled message database
        /// </summary>
        /// <param name="chatId">Identifier of the chat in which to return information about message positions</param>
        /// <param name="filter">Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterCall, searchMessagesFilterMissedCall, searchMessagesFilterMention and searchMessagesFilterUnreadMention are unsupported in this function</param>
        /// <param name="fromMessageId">The message identifier from which to return information about message positions</param>
        /// <param name="limit">The expected number of message positions to be returned; 50-2000. A smaller number of positions can be returned, if there are not enough appropriate messages</param>
        public static async Task<MessagePositions> GetChatSparseMessagePositions(this Client client, long chatId = 0, SearchMessagesFilter filter = default, long fromMessageId = 0, int limit = 0)
        {
            var obj = new GetChatSparseMessagePositions
            {
                ChatId = chatId,
                Filter = filter,
                FromMessageId = fromMessageId,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about the next messages of the specified type in the chat splitted by days. Returns the results in reverse chronological order. Can return partial result for the last returned day. Behavior of this method depends on the value of the option "utc_time_offset"
        /// </summary>
        /// <param name="chatId">Identifier of the chat in which to return information about messages</param>
        /// <param name="filter">Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterCall, searchMessagesFilterMissedCall, searchMessagesFilterMention and searchMessagesFilterUnreadMention are unsupported in this function</param>
        /// <param name="fromMessageId">The message identifier from which to return information about messages; use 0 to get results from the last message</param>
        public static async Task<MessageCalendar> GetChatMessageCalendar(this Client client, long chatId = 0, SearchMessagesFilter filter = default, long fromMessageId = 0)
        {
            var obj = new GetChatMessageCalendar
            {
                ChatId = chatId,
                Filter = filter,
                FromMessageId = fromMessageId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns approximate number of messages of the specified type in the chat
        /// </summary>
        /// <param name="chatId">Identifier of the chat in which to count messages</param>
        /// <param name="filter">Filter for message content; searchMessagesFilterEmpty is unsupported in this function</param>
        /// <param name="returnLocal">If true, returns count that is available locally without sending network requests, returning -1 if the number of messages is unknown</param>
        public static async Task<Count> GetChatMessageCount(this Client client, long chatId = 0, SearchMessagesFilter filter = default, bool returnLocal = false)
        {
            var obj = new GetChatMessageCount
            {
                ChatId = chatId,
                Filter = filter,
                ReturnLocal = returnLocal,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task<Messages> GetChatScheduledMessages(this Client client, long chatId = 0)
        {
            var obj = new GetChatScheduledMessages
            {
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns forwarded copies of a channel message to different public channels. For optimal performance, the number of returned messages is chosen by TDLib
        /// </summary>
        /// <param name="chatId">Chat identifier of the message</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="offset">Offset of the first entry to return as received from the previous request; use empty string to get first chunk of results</param>
        /// <param name="limit">The maximum number of messages to be returned; must be positive and can't be greater than 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit</param>
        public static async Task<FoundMessages> GetMessagePublicForwards(this Client client, long chatId = 0, long messageId = 0, string offset = default, int limit = 0)
        {
            var obj = new GetMessagePublicForwards
            {
                ChatId = chatId,
                MessageId = messageId,
                Offset = offset,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns sponsored messages to be shown in a chat; for channel chats only
        /// </summary>
        /// <param name="chatId">Identifier of the chat</param>
        public static async Task<SponsoredMessages> GetChatSponsoredMessages(this Client client, long chatId = 0)
        {
            var obj = new GetChatSponsoredMessages
            {
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Informs TDLib that a sponsored message was viewed by the user
        /// </summary>
        /// <param name="chatId">Identifier of the chat with the sponsored message</param>
        /// <param name="sponsoredMessageId">The identifier of the sponsored message being viewed</param>
        public static async Task ViewSponsoredMessage(this Client client, long chatId = 0, int sponsoredMessageId = 0)
        {
            var obj = new ViewSponsoredMessage
            {
                ChatId = chatId,
                SponsoredMessageId = sponsoredMessageId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user
        /// </summary>
        /// <param name="notificationGroupId">Identifier of notification group to which the notification belongs</param>
        /// <param name="notificationId">Identifier of removed notification</param>
        public static async Task RemoveNotification(this Client client, int notificationGroupId = 0, int notificationId = 0)
        {
            var obj = new RemoveNotification
            {
                NotificationGroupId = notificationGroupId,
                NotificationId = notificationId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user
        /// </summary>
        /// <param name="notificationGroupId">Notification group identifier</param>
        /// <param name="maxNotificationId">The maximum identifier of removed notifications</param>
        public static async Task RemoveNotificationGroup(this Client client, int notificationGroupId = 0, int maxNotificationId = 0)
        {
            var obj = new RemoveNotificationGroup
            {
                NotificationGroupId = notificationGroupId,
                MaxNotificationId = maxNotificationId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels, or if message.can_get_media_timestamp_links and a media timestamp link is generated. This is an offline request
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which the message belongs</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="mediaTimestamp">If not 0, timestamp from which the video/audio/video note/voice note playing must start, in seconds. The media can be in the message content or in its web page preview</param>
        /// <param name="forAlbum">Pass true to create a link for the whole media album</param>
        /// <param name="forComment">Pass true to create a link to the message as a channel post comment, or from a message thread</param>
        public static async Task<MessageLink> GetMessageLink(this Client client, long chatId = 0, long messageId = 0, int mediaTimestamp = 0, bool forAlbum = false, bool forComment = false)
        {
            var obj = new GetMessageLink
            {
                ChatId = chatId,
                MessageId = messageId,
                MediaTimestamp = mediaTimestamp,
                ForAlbum = forAlbum,
                ForComment = forComment,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which the message belongs</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="forAlbum">Pass true to return an HTML code for embedding of the whole media album</param>
        public static async Task<Text> GetMessageEmbeddingCode(this Client client, long chatId = 0, long messageId = 0, bool forAlbum = false)
        {
            var obj = new GetMessageEmbeddingCode
            {
                ChatId = chatId,
                MessageId = messageId,
                ForAlbum = forAlbum,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a public or private message link. Can be called for any internal link of the type internalLinkTypeMessage
        /// </summary>
        /// <param name="url">The message link</param>
        public static async Task<MessageLinkInfo> GetMessageLinkInfo(this Client client, string url = default)
        {
            var obj = new GetMessageLinkInfo
            {
                Url = url,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sends a message. Returns the sent message
        /// </summary>
        /// <param name="chatId">Target chat</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the message will be sent</param>
        /// <param name="replyToMessageId">Identifier of the message to reply to or 0</param>
        /// <param name="options">Options to be used to send the message; pass null to use default options</param>
        /// <param name="replyMarkup">Markup for replying to the message; pass null if none; for bots only</param>
        /// <param name="inputMessageContent">The content of the message to be sent</param>
        public static async Task<Message> SendMessage(this Client client, long chatId = 0, long messageThreadId = 0, long replyToMessageId = 0, MessageSendOptions options = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            var obj = new SendMessage
            {
                ChatId = chatId,
                MessageThreadId = messageThreadId,
                ReplyToMessageId = replyToMessageId,
                Options = options,
                ReplyMarkup = replyMarkup,
                InputMessageContent = inputMessageContent,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sends 2-10 messages grouped together into an album. Currently only audio, document, photo and video messages can be grouped into an album. Documents and audio files can be only grouped in an album with messages of the same type. Returns sent messages
        /// </summary>
        /// <param name="chatId">Target chat</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the messages will be sent</param>
        /// <param name="replyToMessageId">Identifier of a message to reply to or 0</param>
        /// <param name="options">Options to be used to send the messages; pass null to use default options</param>
        /// <param name="inputMessageContents">Contents of messages to be sent. At most 10 messages can be added to an album</param>
        public static async Task<Messages> SendMessageAlbum(this Client client, long chatId = 0, long messageThreadId = 0, long replyToMessageId = 0, MessageSendOptions options = default, InputMessageContent[] inputMessageContents = default)
        {
            var obj = new SendMessageAlbum
            {
                ChatId = chatId,
                MessageThreadId = messageThreadId,
                ReplyToMessageId = replyToMessageId,
                Options = options,
                InputMessageContents = inputMessageContents,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
        /// </summary>
        /// <param name="botUserId">Identifier of the bot</param>
        /// <param name="chatId">Identifier of the target chat</param>
        /// <param name="parameter">A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking)</param>
        public static async Task<Message> SendBotStartMessage(this Client client, long botUserId = 0, long chatId = 0, string parameter = default)
        {
            var obj = new SendBotStartMessage
            {
                BotUserId = botUserId,
                ChatId = chatId,
                Parameter = parameter,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
        /// </summary>
        /// <param name="chatId">Target chat</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the message will be sent</param>
        /// <param name="replyToMessageId">Identifier of a message to reply to or 0</param>
        /// <param name="options">Options to be used to send the message; pass null to use default options</param>
        /// <param name="queryId">Identifier of the inline query</param>
        /// <param name="resultId">Identifier of the inline result</param>
        /// <param name="hideViaBot">If true, there will be no mention of a bot, via which the message is sent. Can be used only for bots GetOption("animation_search_bot_username"), GetOption("photo_search_bot_username") and GetOption("venue_search_bot_username")</param>
        public static async Task<Message> SendInlineQueryResultMessage(this Client client, long chatId = 0, long messageThreadId = 0, long replyToMessageId = 0, MessageSendOptions options = default, long queryId = 0, string resultId = default, bool hideViaBot = false)
        {
            var obj = new SendInlineQueryResultMessage
            {
                ChatId = chatId,
                MessageThreadId = messageThreadId,
                ReplyToMessageId = replyToMessageId,
                Options = options,
                QueryId = queryId,
                ResultId = resultId,
                HideViaBot = hideViaBot,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which to forward messages</param>
        /// <param name="fromChatId">Identifier of the chat from which to forward messages</param>
        /// <param name="messageIds">Identifiers of the messages to forward. Message identifiers must be in a strictly increasing order. At most 100 messages can be forwarded simultaneously</param>
        /// <param name="options">Options to be used to send the messages; pass null to use default options</param>
        /// <param name="sendCopy">If true, content of the messages will be copied without reference to the original sender. Always true if the messages are forwarded to a secret chat or are local</param>
        /// <param name="removeCaption">If true, media caption of message copies will be removed. Ignored if send_copy is false</param>
        /// <param name="onlyPreview">If true, messages will not be forwarded and instead fake messages will be returned</param>
        public static async Task<Messages> ForwardMessages(this Client client, long chatId = 0, long fromChatId = 0, long[] messageIds = default, MessageSendOptions options = default, bool sendCopy = false, bool removeCaption = false, bool onlyPreview = false)
        {
            var obj = new ForwardMessages
            {
                ChatId = chatId,
                FromChatId = fromChatId,
                MessageIds = messageIds,
                Options = options,
                SendCopy = sendCopy,
                RemoveCaption = removeCaption,
                OnlyPreview = onlyPreview,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed. -If a message is re-sent, the corresponding failed to send message is deleted. Returns the sent messages in the same order as the message identifiers passed in message_ids. If a message can't be re-sent, null will be returned instead of the message
        /// </summary>
        /// <param name="chatId">Identifier of the chat to send messages</param>
        /// <param name="messageIds">Identifiers of the messages to resend. Message identifiers must be in a strictly increasing order</param>
        public static async Task<Messages> ResendMessages(this Client client, long chatId = 0, long[] messageIds = default)
        {
            var obj = new ResendMessages
            {
                ChatId = chatId,
                MessageIds = messageIds,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sends a notification about a screenshot taken in a chat. Supported only in private and secret chats
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task SendChatScreenshotTakenNotification(this Client client, long chatId = 0)
        {
            var obj = new SendChatScreenshotTakenNotification
            {
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message
        /// </summary>
        /// <param name="chatId">Target chat</param>
        /// <param name="sender">The sender of the message</param>
        /// <param name="replyToMessageId">Identifier of the message to reply to or 0</param>
        /// <param name="disableNotification">Pass true to disable notification for the message</param>
        /// <param name="inputMessageContent">The content of the message to be added</param>
        public static async Task<Message> AddLocalMessage(this Client client, long chatId = 0, MessageSender sender = default, long replyToMessageId = 0, bool disableNotification = false, InputMessageContent inputMessageContent = default)
        {
            var obj = new AddLocalMessage
            {
                ChatId = chatId,
                Sender = sender,
                ReplyToMessageId = replyToMessageId,
                DisableNotification = disableNotification,
                InputMessageContent = inputMessageContent,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Deletes messages
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageIds">Identifiers of the messages to be deleted</param>
        /// <param name="revoke">Pass true to try to delete messages for all chat members. Always true for supergroups, channels and secret chats</param>
        public static async Task DeleteMessages(this Client client, long chatId = 0, long[] messageIds = default, bool revoke = false)
        {
            var obj = new DeleteMessages
            {
                ChatId = chatId,
                MessageIds = messageIds,
                Revoke = revoke,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Deletes all messages sent by the specified user to a chat. Supported only for supergroups; requires can_delete_messages administrator privileges
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userId">User identifier</param>
        public static async Task DeleteChatMessagesFromUser(this Client client, long chatId = 0, long userId = 0)
        {
            var obj = new DeleteChatMessagesFromUser
            {
                ChatId = chatId,
                UserId = userId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Deletes all messages between the specified dates in a chat. Supported only for private chats and basic groups. Messages sent in the last 30 seconds will not be deleted
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="minDate">The minimum date of the messages to delete</param>
        /// <param name="maxDate">The maximum date of the messages to delete</param>
        /// <param name="revoke">Pass true to try to delete chat messages for all users; private chats only</param>
        public static async Task DeleteChatMessagesByDate(this Client client, long chatId = 0, int minDate = 0, int maxDate = 0, bool revoke = false)
        {
            var obj = new DeleteChatMessagesByDate
            {
                ChatId = chatId,
                MinDate = minDate,
                MaxDate = maxDate,
                Revoke = revoke,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="replyMarkup">The new message reply markup; pass null if none; for bots only</param>
        /// <param name="inputMessageContent">New text content of the message. Must be of type inputMessageText</param>
        public static async Task<Message> EditMessageText(this Client client, long chatId = 0, long messageId = 0, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            var obj = new EditMessageText
            {
                ChatId = chatId,
                MessageId = messageId,
                ReplyMarkup = replyMarkup,
                InputMessageContent = inputMessageContent,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="replyMarkup">The new message reply markup; pass null if none; for bots only</param>
        /// <param name="location">New location content of the message; pass null to stop sharing the live location</param>
        /// <param name="heading">The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown</param>
        /// <param name="proximityAlertRadius">The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled</param>
        public static async Task<Message> EditMessageLiveLocation(this Client client, long chatId = 0, long messageId = 0, ReplyMarkup replyMarkup = default, Location location = default, int heading = 0, int proximityAlertRadius = 0)
        {
            var obj = new EditMessageLiveLocation
            {
                ChatId = chatId,
                MessageId = messageId,
                ReplyMarkup = replyMarkup,
                Location = location,
                Heading = heading,
                ProximityAlertRadius = proximityAlertRadius,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Edits the content of a message with an animation, an audio, a document, a photo or a video, including message caption. If only the caption needs to be edited, use editMessageCaption instead. -The media can't be edited if the message was set to self-destruct or to a self-destructing media. The type of message content in an album can't be changed with exception of replacing a photo with a video or vice versa. Returns the edited message after the edit is completed on the server side
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="replyMarkup">The new message reply markup; pass null if none; for bots only</param>
        /// <param name="inputMessageContent">New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo</param>
        public static async Task<Message> EditMessageMedia(this Client client, long chatId = 0, long messageId = 0, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            var obj = new EditMessageMedia
            {
                ChatId = chatId,
                MessageId = messageId,
                ReplyMarkup = replyMarkup,
                InputMessageContent = inputMessageContent,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Edits the message content caption. Returns the edited message after the edit is completed on the server side
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="replyMarkup">The new message reply markup; pass null if none; for bots only</param>
        /// <param name="caption">New message content caption; 0-GetOption("message_caption_length_max") characters; pass null to remove caption</param>
        public static async Task<Message> EditMessageCaption(this Client client, long chatId = 0, long messageId = 0, ReplyMarkup replyMarkup = default, FormattedText caption = default)
        {
            var obj = new EditMessageCaption
            {
                ChatId = chatId,
                MessageId = messageId,
                ReplyMarkup = replyMarkup,
                Caption = caption,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="replyMarkup">The new message reply markup; pass null if none</param>
        public static async Task<Message> EditMessageReplyMarkup(this Client client, long chatId = 0, long messageId = 0, ReplyMarkup replyMarkup = default)
        {
            var obj = new EditMessageReplyMarkup
            {
                ChatId = chatId,
                MessageId = messageId,
                ReplyMarkup = replyMarkup,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Edits the text of an inline text or game message sent via a bot; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="replyMarkup">The new message reply markup; pass null if none</param>
        /// <param name="inputMessageContent">New text content of the message. Must be of type inputMessageText</param>
        public static async Task EditInlineMessageText(this Client client, string inlineMessageId = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            var obj = new EditInlineMessageText
            {
                InlineMessageId = inlineMessageId,
                ReplyMarkup = replyMarkup,
                InputMessageContent = inputMessageContent,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Edits the content of a live location in an inline message sent via a bot; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="replyMarkup">The new message reply markup; pass null if none</param>
        /// <param name="location">New location content of the message; pass null to stop sharing the live location</param>
        /// <param name="heading">The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown</param>
        /// <param name="proximityAlertRadius">The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled</param>
        public static async Task EditInlineMessageLiveLocation(this Client client, string inlineMessageId = default, ReplyMarkup replyMarkup = default, Location location = default, int heading = 0, int proximityAlertRadius = 0)
        {
            var obj = new EditInlineMessageLiveLocation
            {
                InlineMessageId = inlineMessageId,
                ReplyMarkup = replyMarkup,
                Location = location,
                Heading = heading,
                ProximityAlertRadius = proximityAlertRadius,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="replyMarkup">The new message reply markup; pass null if none; for bots only</param>
        /// <param name="inputMessageContent">New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo</param>
        public static async Task EditInlineMessageMedia(this Client client, string inlineMessageId = default, ReplyMarkup replyMarkup = default, InputMessageContent inputMessageContent = default)
        {
            var obj = new EditInlineMessageMedia
            {
                InlineMessageId = inlineMessageId,
                ReplyMarkup = replyMarkup,
                InputMessageContent = inputMessageContent,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Edits the caption of an inline message sent via a bot; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="replyMarkup">The new message reply markup; pass null if none</param>
        /// <param name="caption">New message content caption; pass null to remove caption; 0-GetOption("message_caption_length_max") characters</param>
        public static async Task EditInlineMessageCaption(this Client client, string inlineMessageId = default, ReplyMarkup replyMarkup = default, FormattedText caption = default)
        {
            var obj = new EditInlineMessageCaption
            {
                InlineMessageId = inlineMessageId,
                ReplyMarkup = replyMarkup,
                Caption = caption,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Edits the reply markup of an inline message sent via a bot; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="replyMarkup">The new message reply markup; pass null if none</param>
        public static async Task EditInlineMessageReplyMarkup(this Client client, string inlineMessageId = default, ReplyMarkup replyMarkup = default)
        {
            var obj = new EditInlineMessageReplyMarkup
            {
                InlineMessageId = inlineMessageId,
                ReplyMarkup = replyMarkup,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed
        /// </summary>
        /// <param name="chatId">The chat the message belongs to</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="schedulingState">The new message scheduling state; pass null to send the message immediately</param>
        public static async Task EditMessageSchedulingState(this Client client, long chatId = 0, long messageId = 0, MessageSchedulingState schedulingState = default)
        {
            var obj = new EditMessageSchedulingState
            {
                ChatId = chatId,
                MessageId = messageId,
                SchedulingState = schedulingState,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) contained in the text. Can be called synchronously
        /// </summary>
        /// <param name="text">The text in which to look for entites</param>
        public static async Task<TextEntities> GetTextEntities(this Client client, string text = default)
        {
            var obj = new GetTextEntities
            {
                Text = text,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) contained in the text. Can be called synchronously
        /// </summary>
        /// <param name="text">The text in which to look for entites</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static TextEntities GetTextEntitiesSync(this Client client, string text = default)
        {
            var obj = new GetTextEntities
            {
                Text = text,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Parses Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and MentionName entities contained in the text. Can be called synchronously
        /// </summary>
        /// <param name="text">The text to parse</param>
        /// <param name="parseMode">Text parse mode</param>
        public static async Task<FormattedText> ParseTextEntities(this Client client, string text = default, TextParseMode parseMode = default)
        {
            var obj = new ParseTextEntities
            {
                Text = text,
                ParseMode = parseMode,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Parses Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and MentionName entities contained in the text. Can be called synchronously
        /// </summary>
        /// <param name="text">The text to parse</param>
        /// <param name="parseMode">Text parse mode</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static FormattedText ParseTextEntitiesSync(this Client client, string text = default, TextParseMode parseMode = default)
        {
            var obj = new ParseTextEntities
            {
                Text = text,
                ParseMode = parseMode,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
        /// </summary>
        /// <param name="text">The text to parse. For example, "__italic__ ~~strikethrough~~ **bold** `code` ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**"</param>
        public static async Task<FormattedText> ParseMarkdown(this Client client, FormattedText text = default)
        {
            var obj = new ParseMarkdown
            {
                Text = text,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
        /// </summary>
        /// <param name="text">The text to parse. For example, "__italic__ ~~strikethrough~~ **bold** `code` ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**"</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static FormattedText ParseMarkdownSync(this Client client, FormattedText text = default)
        {
            var obj = new ParseMarkdown
            {
                Text = text,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
        /// </summary>
        /// <param name="text">The text</param>
        public static async Task<FormattedText> GetMarkdownText(this Client client, FormattedText text = default)
        {
            var obj = new GetMarkdownText
            {
                Text = text,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
        /// </summary>
        /// <param name="text">The text</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static FormattedText GetMarkdownTextSync(this Client client, FormattedText text = default)
        {
            var obj = new GetMarkdownText
            {
                Text = text,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        /// <param name="fileName">The name of the file or path to the file</param>
        public static async Task<Text> GetFileMimeType(this Client client, string fileName = default)
        {
            var obj = new GetFileMimeType
            {
                FileName = fileName,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        /// <param name="fileName">The name of the file or path to the file</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static Text GetFileMimeTypeSync(this Client client, string fileName = default)
        {
            var obj = new GetFileMimeType
            {
                FileName = fileName,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        /// <param name="mimeType">The MIME type of the file</param>
        public static async Task<Text> GetFileExtension(this Client client, string mimeType = default)
        {
            var obj = new GetFileExtension
            {
                MimeType = mimeType,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        /// <param name="mimeType">The MIME type of the file</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static Text GetFileExtensionSync(this Client client, string mimeType = default)
        {
            var obj = new GetFileExtension
            {
                MimeType = mimeType,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        /// <param name="fileName">File name or path to the file</param>
        public static async Task<Text> CleanFileName(this Client client, string fileName = default)
        {
            var obj = new CleanFileName
            {
                FileName = fileName,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
        /// </summary>
        /// <param name="fileName">File name or path to the file</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static Text CleanFileNameSync(this Client client, string fileName = default)
        {
            var obj = new CleanFileName
            {
                FileName = fileName,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
        /// </summary>
        /// <param name="languagePackDatabasePath">Path to the language pack database in which strings are stored</param>
        /// <param name="localizationTarget">Localization target to which the language pack belongs</param>
        /// <param name="languagePackId">Language pack identifier</param>
        /// <param name="key">Language pack key of the string to be returned</param>
        public static async Task<LanguagePackStringValue> GetLanguagePackString(this Client client, string languagePackDatabasePath = default, string localizationTarget = default, string languagePackId = default, string key = default)
        {
            var obj = new GetLanguagePackString
            {
                LanguagePackDatabasePath = languagePackDatabasePath,
                LocalizationTarget = localizationTarget,
                LanguagePackId = languagePackId,
                Key = key,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
        /// </summary>
        /// <param name="languagePackDatabasePath">Path to the language pack database in which strings are stored</param>
        /// <param name="localizationTarget">Localization target to which the language pack belongs</param>
        /// <param name="languagePackId">Language pack identifier</param>
        /// <param name="key">Language pack key of the string to be returned</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static LanguagePackStringValue GetLanguagePackStringSync(this Client client, string languagePackDatabasePath = default, string localizationTarget = default, string languagePackId = default, string key = default)
        {
            var obj = new GetLanguagePackString
            {
                LanguagePackDatabasePath = languagePackDatabasePath,
                LocalizationTarget = localizationTarget,
                LanguagePackId = languagePackId,
                Key = key,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
        /// </summary>
        /// <param name="json">The JSON-serialized string</param>
        public static async Task<JsonValue> GetJsonValue(this Client client, string json = default)
        {
            var obj = new GetJsonValue
            {
                Json = json,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
        /// </summary>
        /// <param name="json">The JSON-serialized string</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static JsonValue GetJsonValueSync(this Client client, string json = default)
        {
            var obj = new GetJsonValue
            {
                Json = json,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
        /// </summary>
        /// <param name="jsonValue">The JsonValue object</param>
        public static async Task<Text> GetJsonString(this Client client, JsonValue jsonValue = default)
        {
            var obj = new GetJsonString
            {
                JsonValue = jsonValue,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
        /// </summary>
        /// <param name="jsonValue">The JsonValue object</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static Text GetJsonStringSync(this Client client, JsonValue jsonValue = default)
        {
            var obj = new GetJsonString
            {
                JsonValue = jsonValue,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Changes the user answer to a poll. A poll in quiz mode can be answered only once
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which the poll belongs</param>
        /// <param name="messageId">Identifier of the message containing the poll</param>
        /// <param name="optionIds">0-based identifiers of answer options, chosen by the user. User can choose more than 1 answer option only is the poll allows multiple answers</param>
        public static async Task SetPollAnswer(this Client client, long chatId = 0, long messageId = 0, int[] optionIds = default)
        {
            var obj = new SetPollAnswer
            {
                ChatId = chatId,
                MessageId = messageId,
                OptionIds = optionIds,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns users voted for the specified option in a non-anonymous polls. For optimal performance, the number of returned users is chosen by TDLib
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which the poll belongs</param>
        /// <param name="messageId">Identifier of the message containing the poll</param>
        /// <param name="optionId">0-based identifier of the answer option</param>
        /// <param name="offset">Number of users to skip in the result; must be non-negative</param>
        /// <param name="limit">The maximum number of users to be returned; must be positive and can't be greater than 50. For optimal performance, the number of returned users is chosen by TDLib and can be smaller than the specified limit, even if the end of the voter list has not been reached</param>
        public static async Task<Users> GetPollVoters(this Client client, long chatId = 0, long messageId = 0, int optionId = 0, int offset = 0, int limit = 0)
        {
            var obj = new GetPollVoters
            {
                ChatId = chatId,
                MessageId = messageId,
                OptionId = optionId,
                Offset = offset,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag set
        /// </summary>
        /// <param name="chatId">Identifier of the chat to which the poll belongs</param>
        /// <param name="messageId">Identifier of the message containing the poll</param>
        /// <param name="replyMarkup">The new message reply markup; pass null if none; for bots only</param>
        public static async Task StopPoll(this Client client, long chatId = 0, long messageId = 0, ReplyMarkup replyMarkup = default)
        {
            var obj = new StopPoll
            {
                ChatId = chatId,
                MessageId = messageId,
                ReplyMarkup = replyMarkup,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Hides a suggested action
        /// </summary>
        /// <param name="action">Suggested action to hide</param>
        public static async Task HideSuggestedAction(this Client client, SuggestedAction action = default)
        {
            var obj = new HideSuggestedAction
            {
                Action = action,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button
        /// </summary>
        /// <param name="chatId">Chat identifier of the message with the button</param>
        /// <param name="messageId">Message identifier of the message with the button</param>
        /// <param name="buttonId">Button identifier</param>
        public static async Task<LoginUrlInfo> GetLoginUrlInfo(this Client client, long chatId = 0, long messageId = 0, long buttonId = 0)
        {
            var obj = new GetLoginUrlInfo
            {
                ChatId = chatId,
                MessageId = messageId,
                ButtonId = buttonId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl. -Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button
        /// </summary>
        /// <param name="chatId">Chat identifier of the message with the button</param>
        /// <param name="messageId">Message identifier of the message with the button</param>
        /// <param name="buttonId">Button identifier</param>
        /// <param name="allowWriteAccess">True, if the user allowed the bot to send them messages</param>
        public static async Task<HttpUrl> GetLoginUrl(this Client client, long chatId = 0, long messageId = 0, long buttonId = 0, bool allowWriteAccess = false)
        {
            var obj = new GetLoginUrl
            {
                ChatId = chatId,
                MessageId = messageId,
                ButtonId = buttonId,
                AllowWriteAccess = allowWriteAccess,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
        /// </summary>
        /// <param name="botUserId">The identifier of the target bot</param>
        /// <param name="chatId">Identifier of the chat where the query was sent</param>
        /// <param name="userLocation">Location of the user; pass null if unknown or the bot doesn't need user's location</param>
        /// <param name="query">Text of the query</param>
        /// <param name="offset">Offset of the first entry to return</param>
        public static async Task<InlineQueryResults> GetInlineQueryResults(this Client client, long botUserId = 0, long chatId = 0, Location userLocation = default, string query = default, string offset = default)
        {
            var obj = new GetInlineQueryResults
            {
                BotUserId = botUserId,
                ChatId = chatId,
                UserLocation = userLocation,
                Query = query,
                Offset = offset,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sets the result of an inline query; for bots only
        /// </summary>
        /// <param name="inlineQueryId">Identifier of the inline query</param>
        /// <param name="isPersonal">True, if the result of the query can be cached for the specified user</param>
        /// <param name="results">The results of the query</param>
        /// <param name="cacheTime">Allowed time to cache the results of the query, in seconds</param>
        /// <param name="nextOffset">Offset for the next inline query; pass an empty string if there are no more results</param>
        /// <param name="switchPmText">If non-empty, this text must be shown on the button that opens a private chat with the bot and sends a start message to the bot with the parameter switch_pm_parameter</param>
        /// <param name="switchPmParameter">The parameter for the bot start message</param>
        public static async Task AnswerInlineQuery(this Client client, long inlineQueryId = 0, bool isPersonal = false, InputInlineQueryResult[] results = default, int cacheTime = 0, string nextOffset = default, string switchPmText = default, string switchPmParameter = default)
        {
            var obj = new AnswerInlineQuery
            {
                InlineQueryId = inlineQueryId,
                IsPersonal = isPersonal,
                Results = results,
                CacheTime = cacheTime,
                NextOffset = nextOffset,
                SwitchPmText = switchPmText,
                SwitchPmParameter = switchPmParameter,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
        /// </summary>
        /// <param name="chatId">Identifier of the chat with the message</param>
        /// <param name="messageId">Identifier of the message from which the query originated</param>
        /// <param name="payload">Query payload</param>
        public static async Task<CallbackQueryAnswer> GetCallbackQueryAnswer(this Client client, long chatId = 0, long messageId = 0, CallbackQueryPayload payload = default)
        {
            var obj = new GetCallbackQueryAnswer
            {
                ChatId = chatId,
                MessageId = messageId,
                Payload = payload,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sets the result of a callback query; for bots only
        /// </summary>
        /// <param name="callbackQueryId">Identifier of the callback query</param>
        /// <param name="text">Text of the answer</param>
        /// <param name="showAlert">If true, an alert must be shown to the user instead of a toast notification</param>
        /// <param name="url">URL to be opened</param>
        /// <param name="cacheTime">Time during which the result of the query can be cached, in seconds</param>
        public static async Task AnswerCallbackQuery(this Client client, long callbackQueryId = 0, string text = default, bool showAlert = false, string url = default, int cacheTime = 0)
        {
            var obj = new AnswerCallbackQuery
            {
                CallbackQueryId = callbackQueryId,
                Text = text,
                ShowAlert = showAlert,
                Url = url,
                CacheTime = cacheTime,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sets the result of a shipping query; for bots only
        /// </summary>
        /// <param name="shippingQueryId">Identifier of the shipping query</param>
        /// <param name="shippingOptions">Available shipping options</param>
        /// <param name="errorMessage">An error message, empty on success</param>
        public static async Task AnswerShippingQuery(this Client client, long shippingQueryId = 0, ShippingOption[] shippingOptions = default, string errorMessage = default)
        {
            var obj = new AnswerShippingQuery
            {
                ShippingQueryId = shippingQueryId,
                ShippingOptions = shippingOptions,
                ErrorMessage = errorMessage,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sets the result of a pre-checkout query; for bots only
        /// </summary>
        /// <param name="preCheckoutQueryId">Identifier of the pre-checkout query</param>
        /// <param name="errorMessage">An error message, empty on success</param>
        public static async Task AnswerPreCheckoutQuery(this Client client, long preCheckoutQueryId = 0, string errorMessage = default)
        {
            var obj = new AnswerPreCheckoutQuery
            {
                PreCheckoutQueryId = preCheckoutQueryId,
                ErrorMessage = errorMessage,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Updates the game score of the specified user in the game; for bots only
        /// </summary>
        /// <param name="chatId">The chat to which the message with the game belongs</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="editMessage">True, if the message needs to be edited</param>
        /// <param name="userId">User identifier</param>
        /// <param name="score">The new score</param>
        /// <param name="force">Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table</param>
        public static async Task<Message> SetGameScore(this Client client, long chatId = 0, long messageId = 0, bool editMessage = false, long userId = 0, int score = 0, bool force = false)
        {
            var obj = new SetGameScore
            {
                ChatId = chatId,
                MessageId = messageId,
                EditMessage = editMessage,
                UserId = userId,
                Score = score,
                Force = force,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Updates the game score of the specified user in a game; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="editMessage">True, if the message needs to be edited</param>
        /// <param name="userId">User identifier</param>
        /// <param name="score">The new score</param>
        /// <param name="force">Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table</param>
        public static async Task SetInlineGameScore(this Client client, string inlineMessageId = default, bool editMessage = false, long userId = 0, int score = 0, bool force = false)
        {
            var obj = new SetInlineGameScore
            {
                InlineMessageId = inlineMessageId,
                EditMessage = editMessage,
                UserId = userId,
                Score = score,
                Force = force,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only
        /// </summary>
        /// <param name="chatId">The chat that contains the message with the game</param>
        /// <param name="messageId">Identifier of the message</param>
        /// <param name="userId">User identifier</param>
        public static async Task<GameHighScores> GetGameHighScores(this Client client, long chatId = 0, long messageId = 0, long userId = 0)
        {
            var obj = new GetGameHighScores
            {
                ChatId = chatId,
                MessageId = messageId,
                UserId = userId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns game high scores and some part of the high score table in the range of the specified user; for bots only
        /// </summary>
        /// <param name="inlineMessageId">Inline message identifier</param>
        /// <param name="userId">User identifier</param>
        public static async Task<GameHighScores> GetInlineGameHighScores(this Client client, string inlineMessageId = default, long userId = 0)
        {
            var obj = new GetInlineGameHighScores
            {
                InlineMessageId = inlineMessageId,
                UserId = userId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if the reply markup is changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">The message identifier of the used keyboard</param>
        public static async Task DeleteChatReplyMarkup(this Client client, long chatId = 0, long messageId = 0)
        {
            var obj = new DeleteChatReplyMarkup
            {
                ChatId = chatId,
                MessageId = messageId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sends a notification about user activity in a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the action was performed</param>
        /// <param name="action">The action description; pass null to cancel the currently active action</param>
        public static async Task SendChatAction(this Client client, long chatId = 0, long messageThreadId = 0, ChatAction action = default)
        {
            var obj = new SendChatAction
            {
                ChatId = chatId,
                MessageThreadId = messageThreadId,
                Action = action,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task OpenChat(this Client client, long chatId = 0)
        {
            var obj = new OpenChat
            {
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task CloseChat(this Client client, long chatId = 0)
        {
            var obj = new CloseChat
            {
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Informs TDLib that messages are being viewed by the user. Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels)
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the messages are being viewed</param>
        /// <param name="messageIds">The identifiers of the messages being viewed</param>
        /// <param name="forceRead">True, if messages in closed chats must be marked as read by the request</param>
        public static async Task ViewMessages(this Client client, long chatId = 0, long messageThreadId = 0, long[] messageIds = default, bool forceRead = false)
        {
            var obj = new ViewMessages
            {
                ChatId = chatId,
                MessageThreadId = messageThreadId,
                MessageIds = messageIds,
                ForceRead = forceRead,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message). An updateMessageContentOpened update will be generated if something has changed
        /// </summary>
        /// <param name="chatId">Chat identifier of the message</param>
        /// <param name="messageId">Identifier of the message with the opened content</param>
        public static async Task OpenMessageContent(this Client client, long chatId = 0, long messageId = 0)
        {
            var obj = new OpenMessageContent
            {
                ChatId = chatId,
                MessageId = messageId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Informs TDLib that a message with an animated emoji was clicked by the user. Returns a big animated sticker to be played or a 404 error if usual animation needs to be played
        /// </summary>
        /// <param name="chatId">Chat identifier of the message</param>
        /// <param name="messageId">Identifier of the clicked message</param>
        public static async Task<Sticker> ClickAnimatedEmojiMessage(this Client client, long chatId = 0, long messageId = 0)
        {
            var obj = new ClickAnimatedEmojiMessage
            {
                ChatId = chatId,
                MessageId = messageId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about the type of an internal link. Returns a 404 error if the link is not internal. Can be called before authorization
        /// </summary>
        /// <param name="link">The link</param>
        public static async Task<InternalLinkType> GetInternalLinkType(this Client client, string link = default)
        {
            var obj = new GetInternalLinkType
            {
                Link = link,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about an action to be done when the current user clicks an external link. Don't use this method for links from secret chats if web page preview is disabled in secret chats
        /// </summary>
        /// <param name="link">The link</param>
        public static async Task<LoginUrlInfo> GetExternalLinkInfo(this Client client, string link = default)
        {
            var obj = new GetExternalLinkInfo
            {
                Link = link,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns an HTTP URL which can be used to automatically authorize the current user on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find whether a prior user confirmation is needed
        /// </summary>
        /// <param name="link">The HTTP link</param>
        /// <param name="allowWriteAccess">True, if the current user allowed the bot, returned in getExternalLinkInfo, to send them messages</param>
        public static async Task<HttpUrl> GetExternalLink(this Client client, string link = default, bool allowWriteAccess = false)
        {
            var obj = new GetExternalLink
            {
                Link = link,
                AllowWriteAccess = allowWriteAccess,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Marks all mentions in a chat as read
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task ReadAllChatMentions(this Client client, long chatId = 0)
        {
            var obj = new ReadAllChatMentions
            {
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns an existing chat corresponding to a given user
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="force">If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect</param>
        public static async Task<Chat> CreatePrivateChat(this Client client, long userId = 0, bool force = false)
        {
            var obj = new CreatePrivateChat
            {
                UserId = userId,
                Force = force,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns an existing chat corresponding to a known basic group
        /// </summary>
        /// <param name="basicGroupId">Basic group identifier</param>
        /// <param name="force">If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect</param>
        public static async Task<Chat> CreateBasicGroupChat(this Client client, long basicGroupId = 0, bool force = false)
        {
            var obj = new CreateBasicGroupChat
            {
                BasicGroupId = basicGroupId,
                Force = force,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns an existing chat corresponding to a known supergroup or channel
        /// </summary>
        /// <param name="supergroupId">Supergroup or channel identifier</param>
        /// <param name="force">If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect</param>
        public static async Task<Chat> CreateSupergroupChat(this Client client, long supergroupId = 0, bool force = false)
        {
            var obj = new CreateSupergroupChat
            {
                SupergroupId = supergroupId,
                Force = force,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns an existing chat corresponding to a known secret chat
        /// </summary>
        /// <param name="secretChatId">Secret chat identifier</param>
        public static async Task<Chat> CreateSecretChat(this Client client, int secretChatId = 0)
        {
            var obj = new CreateSecretChat
            {
                SecretChatId = secretChatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
        /// </summary>
        /// <param name="userIds">Identifiers of users to be added to the basic group</param>
        /// <param name="title">Title of the new basic group; 1-128 characters</param>
        public static async Task<Chat> CreateNewBasicGroupChat(this Client client, long[] userIds = default, string title = default)
        {
            var obj = new CreateNewBasicGroupChat
            {
                UserIds = userIds,
                Title = title,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
        /// </summary>
        /// <param name="title">Title of the new chat; 1-128 characters</param>
        /// <param name="isChannel">True, if a channel chat needs to be created</param>
        /// <param name="description">Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat</param>
        /// <param name="location">Chat location if a location-based supergroup is being created; pass null to create an ordinary supergroup chat</param>
        /// <param name="forImport">True, if the supergroup is created for importing messages using importMessage</param>
        public static async Task<Chat> CreateNewSupergroupChat(this Client client, string title = default, bool isChannel = false, string description = default, ChatLocation location = default, bool forImport = false)
        {
            var obj = new CreateNewSupergroupChat
            {
                Title = title,
                IsChannel = isChannel,
                Description = description,
                Location = location,
                ForImport = forImport,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Creates a new secret chat. Returns the newly created chat
        /// </summary>
        /// <param name="userId">Identifier of the target user</param>
        public static async Task<Chat> CreateNewSecretChat(this Client client, long userId = 0)
        {
            var obj = new CreateNewSecretChat
            {
                UserId = userId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group
        /// </summary>
        /// <param name="chatId">Identifier of the chat to upgrade</param>
        public static async Task<Chat> UpgradeBasicGroupChatToSupergroupChat(this Client client, long chatId = 0)
        {
            var obj = new UpgradeBasicGroupChatToSupergroupChat
            {
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns chat lists to which the chat can be added. This is an offline request
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task<ChatLists> GetChatListsToAddChat(this Client client, long chatId = 0)
        {
            var obj = new GetChatListsToAddChat
            {
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="chatList">The chat list. Use getChatListsToAddChat to get suitable chat lists</param>
        public static async Task AddChatToList(this Client client, long chatId = 0, ChatList chatList = default)
        {
            var obj = new AddChatToList
            {
                ChatId = chatId,
                ChatList = chatList,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns information about a chat filter by its identifier
        /// </summary>
        /// <param name="chatFilterId">Chat filter identifier</param>
        public static async Task<ChatFilter> GetChatFilter(this Client client, int chatFilterId = 0)
        {
            var obj = new GetChatFilter
            {
                ChatFilterId = chatFilterId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Creates new chat filter. Returns information about the created chat filter
        /// </summary>
        /// <param name="filter">Chat filter</param>
        public static async Task<ChatFilterInfo> CreateChatFilter(this Client client, ChatFilter filter = default)
        {
            var obj = new CreateChatFilter
            {
                Filter = filter,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Edits existing chat filter. Returns information about the edited chat filter
        /// </summary>
        /// <param name="chatFilterId">Chat filter identifier</param>
        /// <param name="filter">The edited chat filter</param>
        public static async Task<ChatFilterInfo> EditChatFilter(this Client client, int chatFilterId = 0, ChatFilter filter = default)
        {
            var obj = new EditChatFilter
            {
                ChatFilterId = chatFilterId,
                Filter = filter,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Deletes existing chat filter
        /// </summary>
        /// <param name="chatFilterId">Chat filter identifier</param>
        public static async Task DeleteChatFilter(this Client client, int chatFilterId = 0)
        {
            var obj = new DeleteChatFilter
            {
                ChatFilterId = chatFilterId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the order of chat filters
        /// </summary>
        /// <param name="chatFilterIds">Identifiers of chat filters in the new correct order</param>
        public static async Task ReorderChatFilters(this Client client, int[] chatFilterIds = default)
        {
            var obj = new ReorderChatFilters
            {
                ChatFilterIds = chatFilterIds,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns recommended chat filters for the current user
        /// </summary>
        public static async Task<RecommendedChatFilters> GetRecommendedChatFilters(this Client client)
        {
            var obj = new GetRecommendedChatFilters();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns default icon name for a filter. Can be called synchronously
        /// </summary>
        /// <param name="filter">Chat filter</param>
        public static async Task<Text> GetChatFilterDefaultIconName(this Client client, ChatFilter filter = default)
        {
            var obj = new GetChatFilterDefaultIconName
            {
                Filter = filter,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns default icon name for a filter. Can be called synchronously
        /// </summary>
        /// <param name="filter">Chat filter</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static Text GetChatFilterDefaultIconNameSync(this Client client, ChatFilter filter = default)
        {
            var obj = new GetChatFilterDefaultIconName
            {
                Filter = filter,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="title">New title of the chat; 1-128 characters</param>
        public static async Task SetChatTitle(this Client client, long chatId = 0, string title = default)
        {
            var obj = new SetChatTitle
            {
                ChatId = chatId,
                Title = title,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="photo">New chat photo; pass null to delete the chat photo</param>
        public static async Task SetChatPhoto(this Client client, long chatId = 0, InputChatPhoto photo = default)
        {
            var obj = new SetChatPhoto
            {
                ChatId = chatId,
                Photo = photo,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the message TTL setting (sets a new self-destruct timer) in a chat. Requires can_delete_messages administrator right in basic groups, supergroups and channels -Message TTL setting of a chat with the current user (Saved Messages) and the chat 777000 (Telegram) can't be changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="ttl">New TTL value, in seconds; must be one of 0, 86400, 7 * 86400, or 31 * 86400 unless the chat is secret</param>
        public static async Task SetChatMessageTtlSetting(this Client client, long chatId = 0, int ttl = 0)
        {
            var obj = new SetChatMessageTtlSetting
            {
                ChatId = chatId,
                Ttl = ttl,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="permissions">New non-administrator members permissions in the chat</param>
        public static async Task SetChatPermissions(this Client client, long chatId = 0, ChatPermissions permissions = default)
        {
            var obj = new SetChatPermissions
            {
                ChatId = chatId,
                Permissions = permissions,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the chat theme. Supported only in private and secret chats
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="themeName">Name of the new chat theme; pass an empty string to return the default theme</param>
        public static async Task SetChatTheme(this Client client, long chatId = 0, string themeName = default)
        {
            var obj = new SetChatTheme
            {
                ChatId = chatId,
                ThemeName = themeName,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the draft message in a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageThreadId">If not 0, a message thread identifier in which the draft was changed</param>
        /// <param name="draftMessage">New draft message; pass null to remove the draft</param>
        public static async Task SetChatDraftMessage(this Client client, long chatId = 0, long messageThreadId = 0, DraftMessage draftMessage = default)
        {
            var obj = new SetChatDraftMessage
            {
                ChatId = chatId,
                MessageThreadId = messageThreadId,
                DraftMessage = draftMessage,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="notificationSettings">New notification settings for the chat. If the chat is muted for more than 1 week, it is considered to be muted forever</param>
        public static async Task SetChatNotificationSettings(this Client client, long chatId = 0, ChatNotificationSettings notificationSettings = default)
        {
            var obj = new SetChatNotificationSettings
            {
                ChatId = chatId,
                NotificationSettings = notificationSettings,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the marked as unread state of a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="isMarkedAsUnread">New value of is_marked_as_unread</param>
        public static async Task ToggleChatIsMarkedAsUnread(this Client client, long chatId = 0, bool isMarkedAsUnread = false)
        {
            var obj = new ToggleChatIsMarkedAsUnread
            {
                ChatId = chatId,
                IsMarkedAsUnread = isMarkedAsUnread,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the value of the default disable_notification parameter, used when a message is sent to a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="defaultDisableNotification">New value of default_disable_notification</param>
        public static async Task ToggleChatDefaultDisableNotification(this Client client, long chatId = 0, bool defaultDisableNotification = false)
        {
            var obj = new ToggleChatDefaultDisableNotification
            {
                ChatId = chatId,
                DefaultDisableNotification = defaultDisableNotification,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes application-specific data associated with a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="clientData">New value of client_data</param>
        public static async Task SetChatClientData(this Client client, long chatId = 0, string clientData = default)
        {
            var obj = new SetChatClientData
            {
                ChatId = chatId,
                ClientData = clientData,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
        /// </summary>
        /// <param name="chatId">Identifier of the chat</param>
        /// <param name="description">Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right</param>
        public static async Task SetChatDescription(this Client client, long chatId = 0, string description = default)
        {
            var obj = new SetChatDescription
            {
                ChatId = chatId,
                Description = description,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the discussion group of a channel chat; requires can_change_info administrator right in the channel if it is specified
        /// </summary>
        /// <param name="chatId">Identifier of the channel chat. Pass 0 to remove a link from the supergroup passed in the second argument to a linked channel chat (requires can_pin_messages rights in the supergroup)</param>
        /// <param name="discussionChatId">Identifier of a new channel's discussion group. Use 0 to remove the discussion group. -Use the method getSuitableDiscussionChats to find all suitable groups. Basic group chats must be first upgraded to supergroup chats. If new chat members don't have access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable must be used first to change that</param>
        public static async Task SetChatDiscussionGroup(this Client client, long chatId = 0, long discussionChatId = 0)
        {
            var obj = new SetChatDiscussionGroup
            {
                ChatId = chatId,
                DiscussionChatId = discussionChatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="location">New location for the chat; must be valid and not null</param>
        public static async Task SetChatLocation(this Client client, long chatId = 0, ChatLocation location = default)
        {
            var obj = new SetChatLocation
            {
                ChatId = chatId,
                Location = location,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="slowModeDelay">New slow mode delay for the chat, in seconds; must be one of 0, 10, 30, 60, 300, 900, 3600</param>
        public static async Task SetChatSlowModeDelay(this Client client, long chatId = 0, int slowModeDelay = 0)
        {
            var obj = new SetChatSlowModeDelay
            {
                ChatId = chatId,
                SlowModeDelay = slowModeDelay,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights in the channel
        /// </summary>
        /// <param name="chatId">Identifier of the chat</param>
        /// <param name="messageId">Identifier of the new pinned message</param>
        /// <param name="disableNotification">True, if there must be no notification about the pinned message. Notifications are always disabled in channels and private chats</param>
        /// <param name="onlyForSelf">True, if the message needs to be pinned for one side only; private chats only</param>
        public static async Task PinChatMessage(this Client client, long chatId = 0, long messageId = 0, bool disableNotification = false, bool onlyForSelf = false)
        {
            var obj = new PinChatMessage
            {
                ChatId = chatId,
                MessageId = messageId,
                DisableNotification = disableNotification,
                OnlyForSelf = onlyForSelf,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Removes a pinned message from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
        /// </summary>
        /// <param name="chatId">Identifier of the chat</param>
        /// <param name="messageId">Identifier of the removed pinned message</param>
        public static async Task UnpinChatMessage(this Client client, long chatId = 0, long messageId = 0)
        {
            var obj = new UnpinChatMessage
            {
                ChatId = chatId,
                MessageId = messageId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Removes all pinned messages from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
        /// </summary>
        /// <param name="chatId">Identifier of the chat</param>
        public static async Task UnpinAllChatMessages(this Client client, long chatId = 0)
        {
            var obj = new UnpinAllChatMessages
            {
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Adds the current user as a new member to a chat. Private and secret chats can't be joined using this method
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task JoinChat(this Client client, long chatId = 0)
        {
            var obj = new JoinChat
            {
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Removes the current user from chat members. Private and secret chats can't be left using this method
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task LeaveChat(this Client client, long chatId = 0)
        {
            var obj = new LeaveChat
            {
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Adds a new member to a chat. Members can't be added to private or secret chats
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userId">Identifier of the user</param>
        /// <param name="forwardLimit">The number of earlier messages from the chat to be forwarded to the new member; up to 100. Ignored for supergroups and channels, or if the added user is a bot</param>
        public static async Task AddChatMember(this Client client, long chatId = 0, long userId = 0, int forwardLimit = 0)
        {
            var obj = new AddChatMember
            {
                ChatId = chatId,
                UserId = userId,
                ForwardLimit = forwardLimit,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Adds multiple new members to a chat. Currently this method is only available for supergroups and channels. This method can't be used to join a chat. Members can't be added to a channel if it has more than 200 members
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userIds">Identifiers of the users to be added to the chat. The maximum number of added users is 20 for supergroups and 100 for channels</param>
        public static async Task AddChatMembers(this Client client, long chatId = 0, long[] userIds = default)
        {
            var obj = new AddChatMembers
            {
                ChatId = chatId,
                UserIds = userIds,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for transferring chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember if some additional parameters needs to be passed
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="memberId">Member identifier. Chats can be only banned and unbanned in supergroups and channels</param>
        /// <param name="status">The new status of the member in the chat</param>
        public static async Task SetChatMemberStatus(this Client client, long chatId = 0, MessageSender memberId = default, ChatMemberStatus status = default)
        {
            var obj = new SetChatMemberStatus
            {
                ChatId = chatId,
                MemberId = memberId,
                Status = status,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="memberId">Member identifier</param>
        /// <param name="bannedUntilDate">Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Ignored in basic groups</param>
        /// <param name="revokeMessages">Pass true to delete all messages in the chat for the user that is being removed. Always true for supergroups and channels</param>
        public static async Task BanChatMember(this Client client, long chatId = 0, MessageSender memberId = default, int bannedUntilDate = 0, bool revokeMessages = false)
        {
            var obj = new BanChatMember
            {
                ChatId = chatId,
                MemberId = memberId,
                BannedUntilDate = bannedUntilDate,
                RevokeMessages = revokeMessages,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Checks whether the current session can be used to transfer a chat ownership to another user
        /// </summary>
        public static async Task<CanTransferOwnershipResult> CanTransferOwnership(this Client client)
        {
            var obj = new CanTransferOwnership();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userId">Identifier of the user to which transfer the ownership. The ownership can't be transferred to a bot or to a deleted user</param>
        /// <param name="password">The password of the current user</param>
        public static async Task TransferChatOwnership(this Client client, long chatId = 0, long userId = 0, string password = default)
        {
            var obj = new TransferChatOwnership
            {
                ChatId = chatId,
                UserId = userId,
                Password = password,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns information about a single member of a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="memberId">Member identifier</param>
        public static async Task<ChatMember> GetChatMember(this Client client, long chatId = 0, MessageSender memberId = default)
        {
            var obj = new GetChatMember
            {
                ChatId = chatId,
                MemberId = memberId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for a specified query in the first name, last name and username of the members of a specified chat. Requires administrator rights in channels
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="query">Query to search for</param>
        /// <param name="limit">The maximum number of users to be returned; up to 200</param>
        /// <param name="filter">The type of users to search for; pass null to search among all chat members</param>
        public static async Task<ChatMembers> SearchChatMembers(this Client client, long chatId = 0, string query = default, int limit = 0, ChatMembersFilter filter = default)
        {
            var obj = new SearchChatMembers
            {
                ChatId = chatId,
                Query = query,
                Limit = limit,
                Filter = filter,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a list of administrators of the chat with their custom titles
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task<ChatAdministrators> GetChatAdministrators(this Client client, long chatId = 0)
        {
            var obj = new GetChatAdministrators
            {
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Clears draft messages in all chats
        /// </summary>
        /// <param name="excludeSecretChats">If true, local draft messages in secret chats will not be cleared</param>
        public static async Task ClearAllDraftMessages(this Client client, bool excludeSecretChats = false)
        {
            var obj = new ClearAllDraftMessages
            {
                ExcludeSecretChats = excludeSecretChats,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns list of chats with non-default notification settings
        /// </summary>
        /// <param name="scope">If specified, only chats from the scope will be returned; pass null to return chats from all scopes</param>
        /// <param name="compareSound">If true, also chats with non-default sound will be returned</param>
        public static async Task<Chats> GetChatNotificationSettingsExceptions(this Client client, NotificationSettingsScope scope = default, bool compareSound = false)
        {
            var obj = new GetChatNotificationSettingsExceptions
            {
                Scope = scope,
                CompareSound = compareSound,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the notification settings for chats of a given type
        /// </summary>
        /// <param name="scope">Types of chats for which to return the notification settings information</param>
        public static async Task<ScopeNotificationSettings> GetScopeNotificationSettings(this Client client, NotificationSettingsScope scope = default)
        {
            var obj = new GetScopeNotificationSettings
            {
                Scope = scope,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes notification settings for chats of a given type
        /// </summary>
        /// <param name="scope">Types of chats for which to change the notification settings</param>
        /// <param name="notificationSettings">The new notification settings for the given scope</param>
        public static async Task SetScopeNotificationSettings(this Client client, NotificationSettingsScope scope = default, ScopeNotificationSettings notificationSettings = default)
        {
            var obj = new SetScopeNotificationSettings
            {
                Scope = scope,
                NotificationSettings = notificationSettings,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Resets all notification settings to their default values. By default, all chats are unmuted, the sound is set to "default" and message previews are shown
        /// </summary>
        public static async Task ResetAllNotificationSettings(this Client client)
        {
            var obj = new ResetAllNotificationSettings();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the pinned state of a chat. There can be up to GetOption("pinned_chat_count_max")/GetOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/arhive chat list
        /// </summary>
        /// <param name="chatList">Chat list in which to change the pinned state of the chat</param>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="isPinned">True, if the chat is pinned</param>
        public static async Task ToggleChatIsPinned(this Client client, ChatList chatList = default, long chatId = 0, bool isPinned = false)
        {
            var obj = new ToggleChatIsPinned
            {
                ChatList = chatList,
                ChatId = chatId,
                IsPinned = isPinned,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the order of pinned chats
        /// </summary>
        /// <param name="chatList">Chat list in which to change the order of pinned chats</param>
        /// <param name="chatIds">The new list of pinned chats</param>
        public static async Task SetPinnedChats(this Client client, ChatList chatList = default, long[] chatIds = default)
        {
            var obj = new SetPinnedChats
            {
                ChatList = chatList,
                ChatIds = chatIds,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates
        /// </summary>
        /// <param name="fileId">Identifier of the file to download</param>
        /// <param name="priority">Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile was called will be downloaded first</param>
        /// <param name="offset">The starting position from which the file needs to be downloaded</param>
        /// <param name="limit">Number of bytes which need to be downloaded starting from the "offset" position before the download will be automatically canceled; use 0 to download without a limit</param>
        /// <param name="synchronous">If false, this request returns file state just after the download has been started. If true, this request returns file state only after -the download has succeeded, has failed, has been canceled or a new downloadFile request with different offset/limit parameters was sent</param>
        public static async Task<File> DownloadFile(this Client client, int fileId = 0, int priority = 0, int offset = 0, int limit = 0, bool synchronous = false)
        {
            var obj = new DownloadFile
            {
                FileId = fileId,
                Priority = priority,
                Offset = offset,
                Limit = limit,
                Synchronous = synchronous,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns file downloaded prefix size from a given offset, in bytes
        /// </summary>
        /// <param name="fileId">Identifier of the file</param>
        /// <param name="offset">Offset from which downloaded prefix size needs to be calculated</param>
        public static async Task<Count> GetFileDownloadedPrefixSize(this Client client, int fileId = 0, int offset = 0)
        {
            var obj = new GetFileDownloadedPrefixSize
            {
                FileId = fileId,
                Offset = offset,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Stops the downloading of a file. If a file has already been downloaded, does nothing
        /// </summary>
        /// <param name="fileId">Identifier of a file to stop downloading</param>
        /// <param name="onlyIfPending">Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server</param>
        public static async Task CancelDownloadFile(this Client client, int fileId = 0, bool onlyIfPending = false)
        {
            var obj = new CancelDownloadFile
            {
                FileId = fileId,
                OnlyIfPending = onlyIfPending,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns suggested name for saving a file in a given directory
        /// </summary>
        /// <param name="fileId">Identifier of the file</param>
        /// <param name="directory">Directory in which the file is supposed to be saved</param>
        public static async Task<Text> GetSuggestedFileName(this Client client, int fileId = 0, string directory = default)
        {
            var obj = new GetSuggestedFileName
            {
                FileId = fileId,
                Directory = directory,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Asynchronously uploads a file to the cloud without sending it in a message. updateFile will be used to notify about upload progress and successful completion of the upload. The file will not have a persistent remote identifier until it will be sent in a message
        /// </summary>
        /// <param name="file">File to upload</param>
        /// <param name="fileType">File type; pass null if unknown</param>
        /// <param name="priority">Priority of the upload (1-32). The higher the priority, the earlier the file will be uploaded. If the priorities of two files are equal, then the first one for which uploadFile was called will be uploaded first</param>
        public static async Task<File> UploadFile(this Client client, InputFile file = default, FileType fileType = default, int priority = 0)
        {
            var obj = new UploadFile
            {
                File = file,
                FileType = fileType,
                Priority = priority,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Stops the uploading of a file. Supported only for files uploaded by using uploadFile. For other files the behavior is undefined
        /// </summary>
        /// <param name="fileId">Identifier of the file to stop uploading</param>
        public static async Task CancelUploadFile(this Client client, int fileId = 0)
        {
            var obj = new CancelUploadFile
            {
                FileId = fileId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file
        /// </summary>
        /// <param name="generationId">The identifier of the generation process</param>
        /// <param name="offset">The offset from which to write the data to the file</param>
        /// <param name="data">The data to write</param>
        public static async Task WriteGeneratedFilePart(this Client client, long generationId = 0, int offset = 0, Memory<byte> data = default)
        {
            var obj = new WriteGeneratedFilePart
            {
                GenerationId = generationId,
                Offset = offset,
                Data = data,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Informs TDLib on a file generation progress
        /// </summary>
        /// <param name="generationId">The identifier of the generation process</param>
        /// <param name="expectedSize">Expected size of the generated file, in bytes; 0 if unknown</param>
        /// <param name="localPrefixSize">The number of bytes already generated</param>
        public static async Task SetFileGenerationProgress(this Client client, long generationId = 0, int expectedSize = 0, int localPrefixSize = 0)
        {
            var obj = new SetFileGenerationProgress
            {
                GenerationId = generationId,
                ExpectedSize = expectedSize,
                LocalPrefixSize = localPrefixSize,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Finishes the file generation
        /// </summary>
        /// <param name="generationId">The identifier of the generation process</param>
        /// <param name="error">If passed, the file generation has failed and must be terminated; pass null if the file generation succeeded</param>
        public static async Task FinishFileGeneration(this Client client, long generationId = 0, Error error = default)
        {
            var obj = new FinishFileGeneration
            {
                GenerationId = generationId,
                Error = error,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file
        /// </summary>
        /// <param name="fileId">Identifier of the file. The file must be located in the TDLib file cache</param>
        /// <param name="offset">The offset from which to read the file</param>
        /// <param name="count">Number of bytes to read. An error will be returned if there are not enough bytes available in the file from the specified position. Pass 0 to read all available data from the specified position</param>
        public static async Task<FilePart> ReadFilePart(this Client client, int fileId = 0, int offset = 0, int count = 0)
        {
            var obj = new ReadFilePart
            {
                FileId = fileId,
                Offset = offset,
                Count = count,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Deletes a file from the TDLib file cache
        /// </summary>
        /// <param name="fileId">Identifier of the file to delete</param>
        public static async Task DeleteFile(this Client client, int fileId = 0)
        {
            var obj = new DeleteFile
            {
                FileId = fileId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns information about a file with messages exported from another app
        /// </summary>
        /// <param name="messageFileHead">Beginning of the message file; up to 100 first lines</param>
        public static async Task<MessageFileType> GetMessageFileType(this Client client, string messageFileHead = default)
        {
            var obj = new GetMessageFileType
            {
                MessageFileHead = messageFileHead,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a confirmation text to be shown to the user before starting message import
        /// </summary>
        /// <param name="chatId">Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right</param>
        public static async Task<Text> GetMessageImportConfirmationText(this Client client, long chatId = 0)
        {
            var obj = new GetMessageImportConfirmationText
            {
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Imports messages exported from another app
        /// </summary>
        /// <param name="chatId">Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right</param>
        /// <param name="messageFile">File with messages to import. Only inputFileLocal and inputFileGenerated are supported. The file must not be previously uploaded</param>
        /// <param name="attachedFiles">Files used in the imported messages. Only inputFileLocal and inputFileGenerated are supported. The files must not be previously uploaded</param>
        public static async Task ImportMessages(this Client client, long chatId = 0, InputFile messageFile = default, InputFile[] attachedFiles = default)
        {
            var obj = new ImportMessages
            {
                ChatId = chatId,
                MessageFile = messageFile,
                AttachedFiles = attachedFiles,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Replaces current primary invite link for a chat with a new primary invite link. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task<ChatInviteLink> ReplacePrimaryChatInviteLink(this Client client, long chatId = 0)
        {
            var obj = new ReplacePrimaryChatInviteLink
            {
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Creates a new invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="name">Invite link name; 0-32 characters</param>
        /// <param name="expireDate">Point in time (Unix timestamp) when the link will expire; pass 0 if never</param>
        /// <param name="memberLimit">The maximum number of chat members that can join the chat by the link simultaneously; 0-99999; pass 0 if not limited</param>
        /// <param name="createsJoinRequest">True, if the link only creates join request. If true, member_limit must not be specified</param>
        public static async Task<ChatInviteLink> CreateChatInviteLink(this Client client, long chatId = 0, string name = default, int expireDate = 0, int memberLimit = 0, bool createsJoinRequest = false)
        {
            var obj = new CreateChatInviteLink
            {
                ChatId = chatId,
                Name = name,
                ExpireDate = expireDate,
                MemberLimit = memberLimit,
                CreatesJoinRequest = createsJoinRequest,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Edits a non-primary invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="inviteLink">Invite link to be edited</param>
        /// <param name="name">Invite link name; 0-32 characters</param>
        /// <param name="expireDate">Point in time (Unix timestamp) when the link will expire; pass 0 if never</param>
        /// <param name="memberLimit">The maximum number of chat members that can join the chat by the link simultaneously; 0-99999; pass 0 if not limited</param>
        /// <param name="createsJoinRequest">True, if the link only creates join request. If true, member_limit must not be specified</param>
        public static async Task<ChatInviteLink> EditChatInviteLink(this Client client, long chatId = 0, string inviteLink = default, string name = default, int expireDate = 0, int memberLimit = 0, bool createsJoinRequest = false)
        {
            var obj = new EditChatInviteLink
            {
                ChatId = chatId,
                InviteLink = inviteLink,
                Name = name,
                ExpireDate = expireDate,
                MemberLimit = memberLimit,
                CreatesJoinRequest = createsJoinRequest,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about an invite link. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="inviteLink">Invite link to get</param>
        public static async Task<ChatInviteLink> GetChatInviteLink(this Client client, long chatId = 0, string inviteLink = default)
        {
            var obj = new GetChatInviteLink
            {
                ChatId = chatId,
                InviteLink = inviteLink,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns list of chat administrators with number of their invite links. Requires owner privileges in the chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task<ChatInviteLinkCounts> GetChatInviteLinkCounts(this Client client, long chatId = 0)
        {
            var obj = new GetChatInviteLinkCounts
            {
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns invite links for a chat created by specified administrator. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="creatorUserId">User identifier of a chat administrator. Must be an identifier of the current user for non-owner</param>
        /// <param name="isRevoked">Pass true if revoked links needs to be returned instead of active or expired</param>
        /// <param name="offsetDate">Creation date of an invite link starting after which to return invite links; use 0 to get results from the beginning</param>
        /// <param name="offsetInviteLink">Invite link starting after which to return invite links; use empty string to get results from the beginning</param>
        /// <param name="limit">The maximum number of invite links to return; up to 100</param>
        public static async Task<ChatInviteLinks> GetChatInviteLinks(this Client client, long chatId = 0, long creatorUserId = 0, bool isRevoked = false, int offsetDate = 0, string offsetInviteLink = default, int limit = 0)
        {
            var obj = new GetChatInviteLinks
            {
                ChatId = chatId,
                CreatorUserId = creatorUserId,
                IsRevoked = isRevoked,
                OffsetDate = offsetDate,
                OffsetInviteLink = offsetInviteLink,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns chat members joined a chat by an invite link. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="inviteLink">Invite link for which to return chat members</param>
        /// <param name="offsetMember">A chat member from which to return next chat members; pass null to get results from the beginning</param>
        /// <param name="limit">The maximum number of chat members to return; up to 100</param>
        public static async Task<ChatInviteLinkMembers> GetChatInviteLinkMembers(this Client client, long chatId = 0, string inviteLink = default, ChatInviteLinkMember offsetMember = default, int limit = 0)
        {
            var obj = new GetChatInviteLinkMembers
            {
                ChatId = chatId,
                InviteLink = inviteLink,
                OffsetMember = offsetMember,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Revokes invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links. -If a primary link is revoked, then additionally to the revoked link returns new primary link
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="inviteLink">Invite link to be revoked</param>
        public static async Task<ChatInviteLinks> RevokeChatInviteLink(this Client client, long chatId = 0, string inviteLink = default)
        {
            var obj = new RevokeChatInviteLink
            {
                ChatId = chatId,
                InviteLink = inviteLink,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Deletes revoked chat invite links. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="inviteLink">Invite link to revoke</param>
        public static async Task DeleteRevokedChatInviteLink(this Client client, long chatId = 0, string inviteLink = default)
        {
            var obj = new DeleteRevokedChatInviteLink
            {
                ChatId = chatId,
                InviteLink = inviteLink,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Deletes all revoked chat invite links created by a given chat administrator. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="creatorUserId">User identifier of a chat administrator, which links will be deleted. Must be an identifier of the current user for non-owner</param>
        public static async Task DeleteAllRevokedChatInviteLinks(this Client client, long chatId = 0, long creatorUserId = 0)
        {
            var obj = new DeleteAllRevokedChatInviteLinks
            {
                ChatId = chatId,
                CreatorUserId = creatorUserId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Checks the validity of an invite link for a chat and returns information about the corresponding chat
        /// </summary>
        /// <param name="inviteLink">Invite link to be checked</param>
        public static async Task<ChatInviteLinkInfo> CheckChatInviteLink(this Client client, string inviteLink = default)
        {
            var obj = new CheckChatInviteLink
            {
                InviteLink = inviteLink,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Uses an invite link to add the current user to the chat if possible
        /// </summary>
        /// <param name="inviteLink">Invite link to use</param>
        public static async Task<Chat> JoinChatByInviteLink(this Client client, string inviteLink = default)
        {
            var obj = new JoinChatByInviteLink
            {
                InviteLink = inviteLink,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns pending join requests in a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="inviteLink">Invite link for which to return join requests. If empty, all join requests will be returned. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links</param>
        /// <param name="query">A query to search for in the first names, last names and usernames of the users to return</param>
        /// <param name="offsetRequest">A chat join request from which to return next requests; pass null to get results from the beginning</param>
        /// <param name="limit">The maximum number of chat join requests to return</param>
        public static async Task<ChatJoinRequests> GetChatJoinRequests(this Client client, long chatId = 0, string inviteLink = default, string query = default, ChatJoinRequest offsetRequest = default, int limit = 0)
        {
            var obj = new GetChatJoinRequests
            {
                ChatId = chatId,
                InviteLink = inviteLink,
                Query = query,
                OffsetRequest = offsetRequest,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Approves pending join request in a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userId">Identifier of the user, which request will be approved</param>
        public static async Task ApproveChatJoinRequest(this Client client, long chatId = 0, long userId = 0)
        {
            var obj = new ApproveChatJoinRequest
            {
                ChatId = chatId,
                UserId = userId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Declines pending join request in a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="userId">Identifier of the user, which request will be declined</param>
        public static async Task DeclineChatJoinRequest(this Client client, long chatId = 0, long userId = 0)
        {
            var obj = new DeclineChatJoinRequest
            {
                ChatId = chatId,
                UserId = userId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Creates a new call
        /// </summary>
        /// <param name="userId">Identifier of the user to be called</param>
        /// <param name="protocol">The call protocols supported by the application</param>
        /// <param name="isVideo">True, if a video call needs to be created</param>
        public static async Task<CallId> CreateCall(this Client client, long userId = 0, CallProtocol protocol = default, bool isVideo = false)
        {
            var obj = new CreateCall
            {
                UserId = userId,
                Protocol = protocol,
                IsVideo = isVideo,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Accepts an incoming call
        /// </summary>
        /// <param name="callId">Call identifier</param>
        /// <param name="protocol">The call protocols supported by the application</param>
        public static async Task AcceptCall(this Client client, int callId = 0, CallProtocol protocol = default)
        {
            var obj = new AcceptCall
            {
                CallId = callId,
                Protocol = protocol,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sends call signaling data
        /// </summary>
        /// <param name="callId">Call identifier</param>
        /// <param name="data">The data</param>
        public static async Task SendCallSignalingData(this Client client, int callId = 0, Memory<byte> data = default)
        {
            var obj = new SendCallSignalingData
            {
                CallId = callId,
                Data = data,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Discards a call
        /// </summary>
        /// <param name="callId">Call identifier</param>
        /// <param name="isDisconnected">True, if the user was disconnected</param>
        /// <param name="duration">The call duration, in seconds</param>
        /// <param name="isVideo">True, if the call was a video call</param>
        /// <param name="connectionId">Identifier of the connection used during the call</param>
        public static async Task DiscardCall(this Client client, int callId = 0, bool isDisconnected = false, int duration = 0, bool isVideo = false, long connectionId = 0)
        {
            var obj = new DiscardCall
            {
                CallId = callId,
                IsDisconnected = isDisconnected,
                Duration = duration,
                IsVideo = isVideo,
                ConnectionId = connectionId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sends a call rating
        /// </summary>
        /// <param name="callId">Call identifier</param>
        /// <param name="rating">Call rating; 1-5</param>
        /// <param name="comment">An optional user comment if the rating is less than 5</param>
        /// <param name="problems">List of the exact types of problems with the call, specified by the user</param>
        public static async Task SendCallRating(this Client client, int callId = 0, int rating = 0, string comment = default, CallProblem[] problems = default)
        {
            var obj = new SendCallRating
            {
                CallId = callId,
                Rating = rating,
                Comment = comment,
                Problems = problems,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sends debug information for a call
        /// </summary>
        /// <param name="callId">Call identifier</param>
        /// <param name="debugInformation">Debug information in application-specific format</param>
        public static async Task SendCallDebugInformation(this Client client, int callId = 0, string debugInformation = default)
        {
            var obj = new SendCallDebugInformation
            {
                CallId = callId,
                DebugInformation = debugInformation,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns list of participant identifiers, which can be used to join video chats in a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task<MessageSenders> GetVideoChatAvailableParticipants(this Client client, long chatId = 0)
        {
            var obj = new GetVideoChatAvailableParticipants
            {
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes default participant identifier, which can be used to join video chats in a chat
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="defaultParticipantId">Default group call participant identifier to join the video chats</param>
        public static async Task SetVideoChatDefaultParticipant(this Client client, long chatId = 0, MessageSender defaultParticipantId = default)
        {
            var obj = new SetVideoChatDefaultParticipant
            {
                ChatId = chatId,
                DefaultParticipantId = defaultParticipantId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Creates a video chat (a group call bound to a chat). Available only for basic groups, supergroups and channels; requires can_manage_video_chats rights
        /// </summary>
        /// <param name="chatId">Chat identifier, in which the video chat will be created</param>
        /// <param name="title">Group call title; if empty, chat title will be used</param>
        /// <param name="startDate">Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 to start the video chat immediately. The date must be at least 10 seconds and at most 8 days in the future</param>
        public static async Task<GroupCallId> CreateVideoChat(this Client client, long chatId = 0, string title = default, int startDate = 0)
        {
            var obj = new CreateVideoChat
            {
                ChatId = chatId,
                Title = title,
                StartDate = startDate,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a group call
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        public static async Task<GroupCall> GetGroupCall(this Client client, int groupCallId = 0)
        {
            var obj = new GetGroupCall
            {
                GroupCallId = groupCallId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Starts a scheduled group call
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        public static async Task StartScheduledGroupCall(this Client client, int groupCallId = 0)
        {
            var obj = new StartScheduledGroupCall
            {
                GroupCallId = groupCallId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Toggles whether the current user will receive a notification when the group call will start; scheduled group calls only
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="enabledStartNotification">New value of the enabled_start_notification setting</param>
        public static async Task ToggleGroupCallEnabledStartNotification(this Client client, int groupCallId = 0, bool enabledStartNotification = false)
        {
            var obj = new ToggleGroupCallEnabledStartNotification
            {
                GroupCallId = groupCallId,
                EnabledStartNotification = enabledStartNotification,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Joins an active group call. Returns join response payload for tgcalls
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="participantId">Identifier of a group call participant, which will be used to join the call; pass null to join as self; video chats only</param>
        /// <param name="audioSourceId">Caller audio channel synchronization source identifier; received from tgcalls</param>
        /// <param name="payload">Group call join payload; received from tgcalls</param>
        /// <param name="isMuted">True, if the user's microphone is muted</param>
        /// <param name="isMyVideoEnabled">True, if the user's video is enabled</param>
        /// <param name="inviteHash">If non-empty, invite hash to be used to join the group call without being muted by administrators</param>
        public static async Task<Text> JoinGroupCall(this Client client, int groupCallId = 0, MessageSender participantId = default, int audioSourceId = 0, string payload = default, bool isMuted = false, bool isMyVideoEnabled = false, string inviteHash = default)
        {
            var obj = new JoinGroupCall
            {
                GroupCallId = groupCallId,
                ParticipantId = participantId,
                AudioSourceId = audioSourceId,
                Payload = payload,
                IsMuted = isMuted,
                IsMyVideoEnabled = isMyVideoEnabled,
                InviteHash = inviteHash,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Starts screen sharing in a joined group call. Returns join response payload for tgcalls
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="audioSourceId">Screen sharing audio channel synchronization source identifier; received from tgcalls</param>
        /// <param name="payload">Group call join payload; received from tgcalls</param>
        public static async Task<Text> StartGroupCallScreenSharing(this Client client, int groupCallId = 0, int audioSourceId = 0, string payload = default)
        {
            var obj = new StartGroupCallScreenSharing
            {
                GroupCallId = groupCallId,
                AudioSourceId = audioSourceId,
                Payload = payload,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Pauses or unpauses screen sharing in a joined group call
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="isPaused">True if screen sharing is paused</param>
        public static async Task ToggleGroupCallScreenSharingIsPaused(this Client client, int groupCallId = 0, bool isPaused = false)
        {
            var obj = new ToggleGroupCallScreenSharingIsPaused
            {
                GroupCallId = groupCallId,
                IsPaused = isPaused,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Ends screen sharing in a joined group call
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        public static async Task EndGroupCallScreenSharing(this Client client, int groupCallId = 0)
        {
            var obj = new EndGroupCallScreenSharing
            {
                GroupCallId = groupCallId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sets group call title. Requires groupCall.can_be_managed group call flag
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="title">New group call title; 1-64 characters</param>
        public static async Task SetGroupCallTitle(this Client client, int groupCallId = 0, string title = default)
        {
            var obj = new SetGroupCallTitle
            {
                GroupCallId = groupCallId,
                Title = title,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Toggles whether new participants of a group call can be unmuted only by administrators of the group call. Requires groupCall.can_toggle_mute_new_participants group call flag
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="muteNewParticipants">New value of the mute_new_participants setting</param>
        public static async Task ToggleGroupCallMuteNewParticipants(this Client client, int groupCallId = 0, bool muteNewParticipants = false)
        {
            var obj = new ToggleGroupCallMuteNewParticipants
            {
                GroupCallId = groupCallId,
                MuteNewParticipants = muteNewParticipants,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Revokes invite link for a group call. Requires groupCall.can_be_managed group call flag
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        public static async Task RevokeGroupCallInviteLink(this Client client, int groupCallId = 0)
        {
            var obj = new RevokeGroupCallInviteLink
            {
                GroupCallId = groupCallId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Invites users to an active group call. Sends a service message of type messageInviteToGroupCall for video chats
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="userIds">User identifiers. At most 10 users can be invited simultaneously</param>
        public static async Task InviteGroupCallParticipants(this Client client, int groupCallId = 0, long[] userIds = default)
        {
            var obj = new InviteGroupCallParticipants
            {
                GroupCallId = groupCallId,
                UserIds = userIds,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns invite link to a video chat in a public chat
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="canSelfUnmute">Pass true if the invite link needs to contain an invite hash, passing which to joinGroupCall would allow the invited user to unmute themselves. Requires groupCall.can_be_managed group call flag</param>
        public static async Task<HttpUrl> GetGroupCallInviteLink(this Client client, int groupCallId = 0, bool canSelfUnmute = false)
        {
            var obj = new GetGroupCallInviteLink
            {
                GroupCallId = groupCallId,
                CanSelfUnmute = canSelfUnmute,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Starts recording of an active group call. Requires groupCall.can_be_managed group call flag
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="title">Group call recording title; 0-64 characters</param>
        /// <param name="recordVideo">Pass true to record a video file instead of an audio file</param>
        /// <param name="usePortraitOrientation">Pass true to use portrait orientation for video instead of landscape one</param>
        public static async Task StartGroupCallRecording(this Client client, int groupCallId = 0, string title = default, bool recordVideo = false, bool usePortraitOrientation = false)
        {
            var obj = new StartGroupCallRecording
            {
                GroupCallId = groupCallId,
                Title = title,
                RecordVideo = recordVideo,
                UsePortraitOrientation = usePortraitOrientation,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Ends recording of an active group call. Requires groupCall.can_be_managed group call flag
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        public static async Task EndGroupCallRecording(this Client client, int groupCallId = 0)
        {
            var obj = new EndGroupCallRecording
            {
                GroupCallId = groupCallId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Toggles whether current user's video is paused
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="isMyVideoPaused">Pass true if the current user's video is paused</param>
        public static async Task ToggleGroupCallIsMyVideoPaused(this Client client, int groupCallId = 0, bool isMyVideoPaused = false)
        {
            var obj = new ToggleGroupCallIsMyVideoPaused
            {
                GroupCallId = groupCallId,
                IsMyVideoPaused = isMyVideoPaused,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Toggles whether current user's video is enabled
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="isMyVideoEnabled">Pass true if the current user's video is enabled</param>
        public static async Task ToggleGroupCallIsMyVideoEnabled(this Client client, int groupCallId = 0, bool isMyVideoEnabled = false)
        {
            var obj = new ToggleGroupCallIsMyVideoEnabled
            {
                GroupCallId = groupCallId,
                IsMyVideoEnabled = isMyVideoEnabled,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Informs TDLib that speaking state of a participant of an active group has changed
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="audioSource">Group call participant's synchronization audio source identifier, or 0 for the current user</param>
        /// <param name="isSpeaking">True, if the user is speaking</param>
        public static async Task SetGroupCallParticipantIsSpeaking(this Client client, int groupCallId = 0, int audioSource = 0, bool isSpeaking = false)
        {
            var obj = new SetGroupCallParticipantIsSpeaking
            {
                GroupCallId = groupCallId,
                AudioSource = audioSource,
                IsSpeaking = isSpeaking,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Toggles whether a participant of an active group call is muted, unmuted, or allowed to unmute themselves
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="participantId">Participant identifier</param>
        /// <param name="isMuted">Pass true if the user must be muted and false otherwise</param>
        public static async Task ToggleGroupCallParticipantIsMuted(this Client client, int groupCallId = 0, MessageSender participantId = default, bool isMuted = false)
        {
            var obj = new ToggleGroupCallParticipantIsMuted
            {
                GroupCallId = groupCallId,
                ParticipantId = participantId,
                IsMuted = isMuted,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes volume level of a participant of an active group call. If the current user can manage the group call, then the participant's volume level will be changed for all users with the default volume level
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="participantId">Participant identifier</param>
        /// <param name="volumeLevel">New participant's volume level; 1-20000 in hundreds of percents</param>
        public static async Task SetGroupCallParticipantVolumeLevel(this Client client, int groupCallId = 0, MessageSender participantId = default, int volumeLevel = 0)
        {
            var obj = new SetGroupCallParticipantVolumeLevel
            {
                GroupCallId = groupCallId,
                ParticipantId = participantId,
                VolumeLevel = volumeLevel,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Toggles whether a group call participant hand is rased
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="participantId">Participant identifier</param>
        /// <param name="isHandRaised">Pass true if the user's hand needs to be raised. Only self hand can be raised. Requires groupCall.can_be_managed group call flag to lower other's hand</param>
        public static async Task ToggleGroupCallParticipantIsHandRaised(this Client client, int groupCallId = 0, MessageSender participantId = default, bool isHandRaised = false)
        {
            var obj = new ToggleGroupCallParticipantIsHandRaised
            {
                GroupCallId = groupCallId,
                ParticipantId = participantId,
                IsHandRaised = isHandRaised,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Loads more participants of a group call. The loaded participants will be received through updates. Use the field groupCall.loaded_all_participants to check whether all participants have already been loaded
        /// </summary>
        /// <param name="groupCallId">Group call identifier. The group call must be previously received through getGroupCall and must be joined or being joined</param>
        /// <param name="limit">The maximum number of participants to load; up to 100</param>
        public static async Task LoadGroupCallParticipants(this Client client, int groupCallId = 0, int limit = 0)
        {
            var obj = new LoadGroupCallParticipants
            {
                GroupCallId = groupCallId,
                Limit = limit,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Leaves a group call
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        public static async Task LeaveGroupCall(this Client client, int groupCallId = 0)
        {
            var obj = new LeaveGroupCall
            {
                GroupCallId = groupCallId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Discards a group call. Requires groupCall.can_be_managed
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        public static async Task DiscardGroupCall(this Client client, int groupCallId = 0)
        {
            var obj = new DiscardGroupCall
            {
                GroupCallId = groupCallId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns a file with a segment of a group call stream in a modified OGG format for audio or MPEG-4 format for video
        /// </summary>
        /// <param name="groupCallId">Group call identifier</param>
        /// <param name="timeOffset">Point in time when the stream segment begins; Unix timestamp in milliseconds</param>
        /// <param name="scale">Segment duration scale; 0-1. Segment's duration is 1000/(2**scale) milliseconds</param>
        /// <param name="channelId">Identifier of an audio/video channel to get as received from tgcalls</param>
        /// <param name="videoQuality">Video quality as received from tgcalls; pass null to get the worst available quality</param>
        public static async Task<FilePart> GetGroupCallStreamSegment(this Client client, int groupCallId = 0, long timeOffset = 0, int scale = 0, int channelId = 0, GroupCallVideoQuality videoQuality = default)
        {
            var obj = new GetGroupCallStreamSegment
            {
                GroupCallId = groupCallId,
                TimeOffset = timeOffset,
                Scale = scale,
                ChannelId = channelId,
                VideoQuality = videoQuality,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes the block state of a message sender. Currently, only users and supergroup chats can be blocked
        /// </summary>
        /// <param name="sender">Message Sender</param>
        /// <param name="isBlocked">New value of is_blocked</param>
        public static async Task ToggleMessageSenderIsBlocked(this Client client, MessageSender sender = default, bool isBlocked = false)
        {
            var obj = new ToggleMessageSenderIsBlocked
            {
                Sender = sender,
                IsBlocked = isBlocked,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Blocks an original sender of a message in the Replies chat
        /// </summary>
        /// <param name="messageId">The identifier of an incoming message in the Replies chat</param>
        /// <param name="deleteMessage">Pass true if the message must be deleted</param>
        /// <param name="deleteAllMessages">Pass true if all messages from the same sender must be deleted</param>
        /// <param name="reportSpam">Pass true if the sender must be reported to the Telegram moderators</param>
        public static async Task BlockMessageSenderFromReplies(this Client client, long messageId = 0, bool deleteMessage = false, bool deleteAllMessages = false, bool reportSpam = false)
        {
            var obj = new BlockMessageSenderFromReplies
            {
                MessageId = messageId,
                DeleteMessage = deleteMessage,
                DeleteAllMessages = deleteAllMessages,
                ReportSpam = reportSpam,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns users and chats that were blocked by the current user
        /// </summary>
        /// <param name="offset">Number of users and chats to skip in the result; must be non-negative</param>
        /// <param name="limit">The maximum number of users and chats to return; up to 100</param>
        public static async Task<MessageSenders> GetBlockedMessageSenders(this Client client, int offset = 0, int limit = 0)
        {
            var obj = new GetBlockedMessageSenders
            {
                Offset = offset,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Adds a user to the contact list or edits an existing contact by their user identifier
        /// </summary>
        /// <param name="contact">The contact to add or edit; phone number can be empty and needs to be specified only if known, vCard is ignored</param>
        /// <param name="sharePhoneNumber">True, if the new contact needs to be allowed to see current user's phone number. A corresponding rule to userPrivacySettingShowPhoneNumber will be added if needed. Use the field userFullInfo.need_phone_number_privacy_exception to check whether the current user needs to be asked to share their phone number</param>
        public static async Task AddContact(this Client client, Contact contact = default, bool sharePhoneNumber = false)
        {
            var obj = new AddContact
            {
                Contact = contact,
                SharePhoneNumber = sharePhoneNumber,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored
        /// </summary>
        /// <param name="contacts">The list of contacts to import or edit; contacts' vCard are ignored and are not imported</param>
        public static async Task<ImportedContacts> ImportContacts(this Client client, Contact[] contacts = default)
        {
            var obj = new ImportContacts
            {
                Contacts = contacts,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns all user contacts
        /// </summary>
        public static async Task<Users> GetContacts(this Client client)
        {
            var obj = new GetContacts();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for the specified query in the first names, last names and usernames of the known user contacts
        /// </summary>
        /// <param name="query">Query to search for; may be empty to return all contacts</param>
        /// <param name="limit">The maximum number of users to be returned</param>
        public static async Task<Users> SearchContacts(this Client client, string query = default, int limit = 0)
        {
            var obj = new SearchContacts
            {
                Query = query,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Removes users from the contact list
        /// </summary>
        /// <param name="userIds">Identifiers of users to be deleted</param>
        public static async Task RemoveContacts(this Client client, long[] userIds = default)
        {
            var obj = new RemoveContacts
            {
                UserIds = userIds,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns the total number of imported contacts
        /// </summary>
        public static async Task<Count> GetImportedContactCount(this Client client)
        {
            var obj = new GetImportedContactCount();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes imported contacts using the list of contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts. -Query result depends on the result of the previous query, so only one query is possible at the same time
        /// </summary>
        /// <param name="contacts">The new list of contacts, contact's vCard are ignored and are not imported</param>
        public static async Task<ImportedContacts> ChangeImportedContacts(this Client client, Contact[] contacts = default)
        {
            var obj = new ChangeImportedContacts
            {
                Contacts = contacts,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Clears all imported contacts, contact list remains unchanged
        /// </summary>
        public static async Task ClearImportedContacts(this Client client)
        {
            var obj = new ClearImportedContacts();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber
        /// </summary>
        /// <param name="userId">Identifier of the user with whom to share the phone number. The user must be a mutual contact</param>
        public static async Task SharePhoneNumber(this Client client, long userId = 0)
        {
            var obj = new SharePhoneNumber
            {
                UserId = userId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns the profile photos of a user. The result of this query may be outdated: some photos might have been deleted already
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="offset">The number of photos to skip; must be non-negative</param>
        /// <param name="limit">The maximum number of photos to be returned; up to 100</param>
        public static async Task<ChatPhotos> GetUserProfilePhotos(this Client client, long userId = 0, int offset = 0, int limit = 0)
        {
            var obj = new GetUserProfilePhotos
            {
                UserId = userId,
                Offset = offset,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns stickers from the installed sticker sets that correspond to a given emoji. If the emoji is non-empty, favorite and recently used stickers may also be returned
        /// </summary>
        /// <param name="emoji">String representation of emoji. If empty, returns all known installed stickers</param>
        /// <param name="limit">The maximum number of stickers to be returned</param>
        public static async Task<Stickers> GetStickers(this Client client, string emoji = default, int limit = 0)
        {
            var obj = new GetStickers
            {
                Emoji = emoji,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for stickers from public sticker sets that correspond to a given emoji
        /// </summary>
        /// <param name="emoji">String representation of emoji; must be non-empty</param>
        /// <param name="limit">The maximum number of stickers to be returned</param>
        public static async Task<Stickers> SearchStickers(this Client client, string emoji = default, int limit = 0)
        {
            var obj = new SearchStickers
            {
                Emoji = emoji,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a list of installed sticker sets
        /// </summary>
        /// <param name="isMasks">Pass true to return mask sticker sets; pass false to return ordinary sticker sets</param>
        public static async Task<StickerSets> GetInstalledStickerSets(this Client client, bool isMasks = false)
        {
            var obj = new GetInstalledStickerSets
            {
                IsMasks = isMasks,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a list of archived sticker sets
        /// </summary>
        /// <param name="isMasks">Pass true to return mask stickers sets; pass false to return ordinary sticker sets</param>
        /// <param name="offsetStickerSetId">Identifier of the sticker set from which to return the result</param>
        /// <param name="limit">The maximum number of sticker sets to return; up to 100</param>
        public static async Task<StickerSets> GetArchivedStickerSets(this Client client, bool isMasks = false, long offsetStickerSetId = 0, int limit = 0)
        {
            var obj = new GetArchivedStickerSets
            {
                IsMasks = isMasks,
                OffsetStickerSetId = offsetStickerSetId,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a list of trending sticker sets. For optimal performance, the number of returned sticker sets is chosen by TDLib
        /// </summary>
        /// <param name="offset">The offset from which to return the sticker sets; must be non-negative</param>
        /// <param name="limit">The maximum number of sticker sets to be returned; up to 100. For optimal performance, the number of returned sticker sets is chosen by TDLib and can be smaller than the specified limit, even if the end of the list has not been reached</param>
        public static async Task<StickerSets> GetTrendingStickerSets(this Client client, int offset = 0, int limit = 0)
        {
            var obj = new GetTrendingStickerSets
            {
                Offset = offset,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a list of sticker sets attached to a file. Currently only photos and videos can have attached sticker sets
        /// </summary>
        /// <param name="fileId">File identifier</param>
        public static async Task<StickerSets> GetAttachedStickerSets(this Client client, int fileId = 0)
        {
            var obj = new GetAttachedStickerSets
            {
                FileId = fileId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a sticker set by its identifier
        /// </summary>
        /// <param name="setId">Identifier of the sticker set</param>
        public static async Task<StickerSet> GetStickerSet(this Client client, long setId = 0)
        {
            var obj = new GetStickerSet
            {
                SetId = setId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for a sticker set by its name
        /// </summary>
        /// <param name="name">Name of the sticker set</param>
        public static async Task<StickerSet> SearchStickerSet(this Client client, string name = default)
        {
            var obj = new SearchStickerSet
            {
                Name = name,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for installed sticker sets by looking for specified query in their title and name
        /// </summary>
        /// <param name="isMasks">Pass true to return mask sticker sets; pass false to return ordinary sticker sets</param>
        /// <param name="query">Query to search for</param>
        /// <param name="limit">The maximum number of sticker sets to return</param>
        public static async Task<StickerSets> SearchInstalledStickerSets(this Client client, bool isMasks = false, string query = default, int limit = 0)
        {
            var obj = new SearchInstalledStickerSets
            {
                IsMasks = isMasks,
                Query = query,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results
        /// </summary>
        /// <param name="query">Query to search for</param>
        public static async Task<StickerSets> SearchStickerSets(this Client client, string query = default)
        {
            var obj = new SearchStickerSets
            {
                Query = query,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Installs/uninstalls or activates/archives a sticker set
        /// </summary>
        /// <param name="setId">Identifier of the sticker set</param>
        /// <param name="isInstalled">The new value of is_installed</param>
        /// <param name="isArchived">The new value of is_archived. A sticker set can't be installed and archived simultaneously</param>
        public static async Task ChangeStickerSet(this Client client, long setId = 0, bool isInstalled = false, bool isArchived = false)
        {
            var obj = new ChangeStickerSet
            {
                SetId = setId,
                IsInstalled = isInstalled,
                IsArchived = isArchived,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Informs the server that some trending sticker sets have been viewed by the user
        /// </summary>
        /// <param name="stickerSetIds">Identifiers of viewed trending sticker sets</param>
        public static async Task ViewTrendingStickerSets(this Client client, long[] stickerSetIds = default)
        {
            var obj = new ViewTrendingStickerSets
            {
                StickerSetIds = stickerSetIds,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the order of installed sticker sets
        /// </summary>
        /// <param name="isMasks">Pass true to change the order of mask sticker sets; pass false to change the order of ordinary sticker sets</param>
        /// <param name="stickerSetIds">Identifiers of installed sticker sets in the new correct order</param>
        public static async Task ReorderInstalledStickerSets(this Client client, bool isMasks = false, long[] stickerSetIds = default)
        {
            var obj = new ReorderInstalledStickerSets
            {
                IsMasks = isMasks,
                StickerSetIds = stickerSetIds,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns a list of recently used stickers
        /// </summary>
        /// <param name="isAttached">Pass true to return stickers and masks that were recently attached to photos or video files; pass false to return recently sent stickers</param>
        public static async Task<Stickers> GetRecentStickers(this Client client, bool isAttached = false)
        {
            var obj = new GetRecentStickers
            {
                IsAttached = isAttached,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list
        /// </summary>
        /// <param name="isAttached">Pass true to add the sticker to the list of stickers recently attached to photo or video files; pass false to add the sticker to the list of recently sent stickers</param>
        /// <param name="sticker">Sticker file to add</param>
        public static async Task<Stickers> AddRecentSticker(this Client client, bool isAttached = false, InputFile sticker = default)
        {
            var obj = new AddRecentSticker
            {
                IsAttached = isAttached,
                Sticker = sticker,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Removes a sticker from the list of recently used stickers
        /// </summary>
        /// <param name="isAttached">Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers</param>
        /// <param name="sticker">Sticker file to delete</param>
        public static async Task RemoveRecentSticker(this Client client, bool isAttached = false, InputFile sticker = default)
        {
            var obj = new RemoveRecentSticker
            {
                IsAttached = isAttached,
                Sticker = sticker,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Clears the list of recently used stickers
        /// </summary>
        /// <param name="isAttached">Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers</param>
        public static async Task ClearRecentStickers(this Client client, bool isAttached = false)
        {
            var obj = new ClearRecentStickers
            {
                IsAttached = isAttached,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns favorite stickers
        /// </summary>
        public static async Task<Stickers> GetFavoriteStickers(this Client client)
        {
            var obj = new GetFavoriteStickers();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list
        /// </summary>
        /// <param name="sticker">Sticker file to add</param>
        public static async Task AddFavoriteSticker(this Client client, InputFile sticker = default)
        {
            var obj = new AddFavoriteSticker
            {
                Sticker = sticker,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Removes a sticker from the list of favorite stickers
        /// </summary>
        /// <param name="sticker">Sticker file to delete from the list</param>
        public static async Task RemoveFavoriteSticker(this Client client, InputFile sticker = default)
        {
            var obj = new RemoveFavoriteSticker
            {
                Sticker = sticker,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
        /// </summary>
        /// <param name="sticker">Sticker file identifier</param>
        public static async Task<Emojis> GetStickerEmojis(this Client client, InputFile sticker = default)
        {
            var obj = new GetStickerEmojis
            {
                Sticker = sticker,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for emojis by keywords. Supported only if the file database is enabled
        /// </summary>
        /// <param name="text">Text to search for</param>
        /// <param name="exactMatch">True, if only emojis, which exactly match text needs to be returned</param>
        /// <param name="inputLanguageCodes">List of possible IETF language tags of the user's input language; may be empty if unknown</param>
        public static async Task<Emojis> SearchEmojis(this Client client, string text = default, bool exactMatch = false, string[] inputLanguageCodes = default)
        {
            var obj = new SearchEmojis
            {
                Text = text,
                ExactMatch = exactMatch,
                InputLanguageCodes = inputLanguageCodes,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns an animated emoji corresponding to a given emoji. Returns a 404 error if the emoji has no animated emoji
        /// </summary>
        /// <param name="emoji">The emoji</param>
        public static async Task<AnimatedEmoji> GetAnimatedEmoji(this Client client, string emoji = default)
        {
            var obj = new GetAnimatedEmoji
            {
                Emoji = emoji,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation
        /// </summary>
        /// <param name="languageCode">Language code for which the emoji replacements will be suggested</param>
        public static async Task<HttpUrl> GetEmojiSuggestionsUrl(this Client client, string languageCode = default)
        {
            var obj = new GetEmojiSuggestionsUrl
            {
                LanguageCode = languageCode,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns saved animations
        /// </summary>
        public static async Task<Animations> GetSavedAnimations(this Client client)
        {
            var obj = new GetSavedAnimations();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
        /// </summary>
        /// <param name="animation">The animation file to be added. Only animations known to the server (i.e., successfully sent via a message) can be added to the list</param>
        public static async Task AddSavedAnimation(this Client client, InputFile animation = default)
        {
            var obj = new AddSavedAnimation
            {
                Animation = animation,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Removes an animation from the list of saved animations
        /// </summary>
        /// <param name="animation">Animation file to be removed</param>
        public static async Task RemoveSavedAnimation(this Client client, InputFile animation = default)
        {
            var obj = new RemoveSavedAnimation
            {
                Animation = animation,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns up to 20 recently used inline bots in the order of their last usage
        /// </summary>
        public static async Task<Users> GetRecentInlineBots(this Client client)
        {
            var obj = new GetRecentInlineBots();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for recently used hashtags by their prefix
        /// </summary>
        /// <param name="prefix">Hashtag prefix to search for</param>
        /// <param name="limit">The maximum number of hashtags to be returned</param>
        public static async Task<Hashtags> SearchHashtags(this Client client, string prefix = default, int limit = 0)
        {
            var obj = new SearchHashtags
            {
                Prefix = prefix,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Removes a hashtag from the list of recently used hashtags
        /// </summary>
        /// <param name="hashtag">Hashtag to delete</param>
        public static async Task RemoveRecentHashtag(this Client client, string hashtag = default)
        {
            var obj = new RemoveRecentHashtag
            {
                Hashtag = hashtag,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview
        /// </summary>
        /// <param name="text">Message text with formatting</param>
        public static async Task<WebPage> GetWebPagePreview(this Client client, FormattedText text = default)
        {
            var obj = new GetWebPagePreview
            {
                Text = text,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page
        /// </summary>
        /// <param name="url">The web page URL</param>
        /// <param name="forceFull">If true, the full instant view for the web page will be returned</param>
        public static async Task<WebPageInstantView> GetWebPageInstantView(this Client client, string url = default, bool forceFull = false)
        {
            var obj = new GetWebPageInstantView
            {
                Url = url,
                ForceFull = forceFull,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes a profile photo for the current user
        /// </summary>
        /// <param name="photo">Profile photo to set</param>
        public static async Task SetProfilePhoto(this Client client, InputChatPhoto photo = default)
        {
            var obj = new SetProfilePhoto
            {
                Photo = photo,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Deletes a profile photo
        /// </summary>
        /// <param name="profilePhotoId">Identifier of the profile photo to delete</param>
        public static async Task DeleteProfilePhoto(this Client client, long profilePhotoId = 0)
        {
            var obj = new DeleteProfilePhoto
            {
                ProfilePhotoId = profilePhotoId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the first and last name of the current user
        /// </summary>
        /// <param name="firstName">The new value of the first name for the current user; 1-64 characters</param>
        /// <param name="lastName">The new value of the optional last name for the current user; 0-64 characters</param>
        public static async Task SetName(this Client client, string firstName = default, string lastName = default)
        {
            var obj = new SetName
            {
                FirstName = firstName,
                LastName = lastName,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the bio of the current user
        /// </summary>
        /// <param name="bio">The new value of the user bio; 0-70 characters without line feeds</param>
        public static async Task SetBio(this Client client, string bio = default)
        {
            var obj = new SetBio
            {
                Bio = bio,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the username of the current user
        /// </summary>
        /// <param name="username">The new value of the username. Use an empty string to remove the username</param>
        public static async Task SetUsername(this Client client, string username = default)
        {
            var obj = new SetUsername
            {
                Username = username,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the location of the current user. Needs to be called if GetOption("is_location_visible") is true and location changes for more than 1 kilometer
        /// </summary>
        /// <param name="location">The new location of the user</param>
        public static async Task SetLocation(this Client client, Location location = default)
        {
            var obj = new SetLocation
            {
                Location = location,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the phone number of the user and sends an authentication code to the user's new phone number. On success, returns information about the sent code
        /// </summary>
        /// <param name="phoneNumber">The new phone number of the user in international format</param>
        /// <param name="settings">Settings for the authentication of the user's phone number; pass null to use default settings</param>
        public static async Task<AuthenticationCodeInfo> ChangePhoneNumber(this Client client, string phoneNumber = default, PhoneNumberAuthenticationSettings settings = default)
        {
            var obj = new ChangePhoneNumber
            {
                PhoneNumber = phoneNumber,
                Settings = settings,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Re-sends the authentication code sent to confirm a new phone number for the current user. Works only if the previously received authenticationCodeInfo next_code_type was not null and the server-specified timeout has passed
        /// </summary>
        public static async Task<AuthenticationCodeInfo> ResendChangePhoneNumberCode(this Client client)
        {
            var obj = new ResendChangePhoneNumberCode();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Checks the authentication code sent to confirm a new phone number of the user
        /// </summary>
        /// <param name="code">Verification code received by SMS, phone call or flash call</param>
        public static async Task CheckChangePhoneNumberCode(this Client client, string code = default)
        {
            var obj = new CheckChangePhoneNumberCode
            {
                Code = code,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sets the list of commands supported by the bot for the given user scope and language; for bots only
        /// </summary>
        /// <param name="scope">The scope to which the commands are relevant; pass null to change commands in the default bot command scope</param>
        /// <param name="languageCode">A two-letter ISO 639-1 country code. If empty, the commands will be applied to all users from the given scope, for which language there are no dedicated commands</param>
        /// <param name="commands">List of the bot's commands</param>
        public static async Task SetCommands(this Client client, BotCommandScope scope = default, string languageCode = default, BotCommand[] commands = default)
        {
            var obj = new SetCommands
            {
                Scope = scope,
                LanguageCode = languageCode,
                Commands = commands,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Deletes commands supported by the bot for the given user scope and language; for bots only
        /// </summary>
        /// <param name="scope">The scope to which the commands are relevant; pass null to delete commands in the default bot command scope</param>
        /// <param name="languageCode">A two-letter ISO 639-1 country code or an empty string</param>
        public static async Task DeleteCommands(this Client client, BotCommandScope scope = default, string languageCode = default)
        {
            var obj = new DeleteCommands
            {
                Scope = scope,
                LanguageCode = languageCode,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns the list of commands supported by the bot for the given user scope and language; for bots only
        /// </summary>
        /// <param name="scope">The scope to which the commands are relevant; pass null to get commands in the default bot command scope</param>
        /// <param name="languageCode">A two-letter ISO 639-1 country code or an empty string</param>
        public static async Task<BotCommands> GetCommands(this Client client, BotCommandScope scope = default, string languageCode = default)
        {
            var obj = new GetCommands
            {
                Scope = scope,
                LanguageCode = languageCode,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns all active sessions of the current user
        /// </summary>
        public static async Task<Sessions> GetActiveSessions(this Client client)
        {
            var obj = new GetActiveSessions();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Terminates a session of the current user
        /// </summary>
        /// <param name="sessionId">Session identifier</param>
        public static async Task TerminateSession(this Client client, long sessionId = 0)
        {
            var obj = new TerminateSession
            {
                SessionId = sessionId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Terminates all other sessions of the current user
        /// </summary>
        public static async Task TerminateAllOtherSessions(this Client client)
        {
            var obj = new TerminateAllOtherSessions();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns all website where the current user used Telegram to log in
        /// </summary>
        public static async Task<ConnectedWebsites> GetConnectedWebsites(this Client client)
        {
            var obj = new GetConnectedWebsites();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Disconnects website from the current user's Telegram account
        /// </summary>
        /// <param name="websiteId">Website identifier</param>
        public static async Task DisconnectWebsite(this Client client, long websiteId = 0)
        {
            var obj = new DisconnectWebsite
            {
                WebsiteId = websiteId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Disconnects all websites from the current user's Telegram account
        /// </summary>
        public static async Task DisconnectAllWebsites(this Client client)
        {
            var obj = new DisconnectAllWebsites();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the username of a supergroup or channel, requires owner privileges in the supergroup or channel
        /// </summary>
        /// <param name="supergroupId">Identifier of the supergroup or channel</param>
        /// <param name="username">New value of the username. Use an empty string to remove the username</param>
        public static async Task SetSupergroupUsername(this Client client, long supergroupId = 0, string username = default)
        {
            var obj = new SetSupergroupUsername
            {
                SupergroupId = supergroupId,
                Username = username,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the sticker set of a supergroup; requires can_change_info administrator right
        /// </summary>
        /// <param name="supergroupId">Identifier of the supergroup</param>
        /// <param name="stickerSetId">New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set</param>
        public static async Task SetSupergroupStickerSet(this Client client, long supergroupId = 0, long stickerSetId = 0)
        {
            var obj = new SetSupergroupStickerSet
            {
                SupergroupId = supergroupId,
                StickerSetId = stickerSetId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Toggles sender signatures messages sent in a channel; requires can_change_info administrator right
        /// </summary>
        /// <param name="supergroupId">Identifier of the channel</param>
        /// <param name="signMessages">New value of sign_messages</param>
        public static async Task ToggleSupergroupSignMessages(this Client client, long supergroupId = 0, bool signMessages = false)
        {
            var obj = new ToggleSupergroupSignMessages
            {
                SupergroupId = supergroupId,
                SignMessages = signMessages,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Toggles whether the message history of a supergroup is available to new members; requires can_change_info administrator right
        /// </summary>
        /// <param name="supergroupId">The identifier of the supergroup</param>
        /// <param name="isAllHistoryAvailable">The new value of is_all_history_available</param>
        public static async Task ToggleSupergroupIsAllHistoryAvailable(this Client client, long supergroupId = 0, bool isAllHistoryAvailable = false)
        {
            var obj = new ToggleSupergroupIsAllHistoryAvailable
            {
                SupergroupId = supergroupId,
                IsAllHistoryAvailable = isAllHistoryAvailable,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup
        /// </summary>
        /// <param name="supergroupId">Identifier of the supergroup</param>
        public static async Task ToggleSupergroupIsBroadcastGroup(this Client client, long supergroupId = 0)
        {
            var obj = new ToggleSupergroupIsBroadcastGroup
            {
                SupergroupId = supergroupId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Reports some messages from a user in a supergroup as spam; requires administrator rights in the supergroup
        /// </summary>
        /// <param name="supergroupId">Supergroup identifier</param>
        /// <param name="userId">User identifier</param>
        /// <param name="messageIds">Identifiers of messages sent in the supergroup by the user. This list must be non-empty</param>
        public static async Task ReportSupergroupSpam(this Client client, long supergroupId = 0, long userId = 0, long[] messageIds = default)
        {
            var obj = new ReportSupergroupSpam
            {
                SupergroupId = supergroupId,
                UserId = userId,
                MessageIds = messageIds,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns information about members or banned users in a supergroup or channel. Can be used only if supergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters
        /// </summary>
        /// <param name="supergroupId">Identifier of the supergroup or channel</param>
        /// <param name="filter">The type of users to return; pass null to use supergroupMembersFilterRecent</param>
        /// <param name="offset">Number of users to skip</param>
        /// <param name="limit">The maximum number of users be returned; up to 200</param>
        public static async Task<ChatMembers> GetSupergroupMembers(this Client client, long supergroupId = 0, SupergroupMembersFilter filter = default, int offset = 0, int limit = 0)
        {
            var obj = new GetSupergroupMembers
            {
                SupergroupId = supergroupId,
                Filter = filter,
                Offset = offset,
                Limit = limit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Closes a secret chat, effectively transferring its state to secretChatStateClosed
        /// </summary>
        /// <param name="secretChatId">Secret chat identifier</param>
        public static async Task CloseSecretChat(this Client client, int secretChatId = 0)
        {
            var obj = new CloseSecretChat
            {
                SecretChatId = secretChatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i. e., in order of decreasing event_id)
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="query">Search query by which to filter events</param>
        /// <param name="fromEventId">Identifier of an event from which to return results. Use 0 to get results from the latest events</param>
        /// <param name="limit">The maximum number of events to return; up to 100</param>
        /// <param name="filters">The types of events to return; pass null to get chat events of all types</param>
        /// <param name="userIds">User identifiers by which to filter events. By default, events relating to all users will be returned</param>
        public static async Task<ChatEvents> GetChatEventLog(this Client client, long chatId = 0, string query = default, long fromEventId = 0, int limit = 0, ChatEventLogFilters filters = default, long[] userIds = default)
        {
            var obj = new GetChatEventLog
            {
                ChatId = chatId,
                Query = query,
                FromEventId = fromEventId,
                Limit = limit,
                Filters = filters,
                UserIds = userIds,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns an invoice payment form. This method must be called when the user presses inlineKeyboardButtonBuy
        /// </summary>
        /// <param name="chatId">Chat identifier of the Invoice message</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="theme">Preferred payment form theme; pass null to use the default theme</param>
        public static async Task<PaymentForm> GetPaymentForm(this Client client, long chatId = 0, long messageId = 0, PaymentFormTheme theme = default)
        {
            var obj = new GetPaymentForm
            {
                ChatId = chatId,
                MessageId = messageId,
                Theme = theme,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Validates the order information provided by a user and returns the available shipping options for a flexible invoice
        /// </summary>
        /// <param name="chatId">Chat identifier of the Invoice message</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="orderInfo">The order information, provided by the user; pass null if empty</param>
        /// <param name="allowSave">True, if the order information can be saved</param>
        public static async Task<ValidatedOrderInfo> ValidateOrderInfo(this Client client, long chatId = 0, long messageId = 0, OrderInfo orderInfo = default, bool allowSave = false)
        {
            var obj = new ValidateOrderInfo
            {
                ChatId = chatId,
                MessageId = messageId,
                OrderInfo = orderInfo,
                AllowSave = allowSave,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sends a filled-out payment form to the bot for final verification
        /// </summary>
        /// <param name="chatId">Chat identifier of the Invoice message</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="paymentFormId">Payment form identifier returned by getPaymentForm</param>
        /// <param name="orderInfoId">Identifier returned by validateOrderInfo, or an empty string</param>
        /// <param name="shippingOptionId">Identifier of a chosen shipping option, if applicable</param>
        /// <param name="credentials">The credentials chosen by user for payment</param>
        /// <param name="tipAmount">Chosen by the user amount of tip in the smallest units of the currency</param>
        public static async Task<PaymentResult> SendPaymentForm(this Client client, long chatId = 0, long messageId = 0, long paymentFormId = 0, string orderInfoId = default, string shippingOptionId = default, InputCredentials credentials = default, long tipAmount = 0)
        {
            var obj = new SendPaymentForm
            {
                ChatId = chatId,
                MessageId = messageId,
                PaymentFormId = paymentFormId,
                OrderInfoId = orderInfoId,
                ShippingOptionId = shippingOptionId,
                Credentials = credentials,
                TipAmount = tipAmount,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a successful payment
        /// </summary>
        /// <param name="chatId">Chat identifier of the PaymentSuccessful message</param>
        /// <param name="messageId">Message identifier</param>
        public static async Task<PaymentReceipt> GetPaymentReceipt(this Client client, long chatId = 0, long messageId = 0)
        {
            var obj = new GetPaymentReceipt
            {
                ChatId = chatId,
                MessageId = messageId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns saved order info, if any
        /// </summary>
        public static async Task<OrderInfo> GetSavedOrderInfo(this Client client)
        {
            var obj = new GetSavedOrderInfo();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Deletes saved order info
        /// </summary>
        public static async Task DeleteSavedOrderInfo(this Client client)
        {
            var obj = new DeleteSavedOrderInfo();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Deletes saved credentials for all payment provider bots
        /// </summary>
        public static async Task DeleteSavedCredentials(this Client client)
        {
            var obj = new DeleteSavedCredentials();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns a user that can be contacted to get support
        /// </summary>
        public static async Task<User> GetSupportUser(this Client client)
        {
            var obj = new GetSupportUser();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns backgrounds installed by the user
        /// </summary>
        /// <param name="forDarkTheme">True, if the backgrounds must be ordered for dark theme</param>
        public static async Task<Backgrounds> GetBackgrounds(this Client client, bool forDarkTheme = false)
        {
            var obj = new GetBackgrounds
            {
                ForDarkTheme = forDarkTheme,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Constructs a persistent HTTP URL for a background
        /// </summary>
        /// <param name="name">Background name</param>
        /// <param name="type">Background type</param>
        public static async Task<HttpUrl> GetBackgroundUrl(this Client client, string name = default, BackgroundType type = default)
        {
            var obj = new GetBackgroundUrl
            {
                Name = name,
                Type = type,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Searches for a background by its name
        /// </summary>
        /// <param name="name">The name of the background</param>
        public static async Task<Background> SearchBackground(this Client client, string name = default)
        {
            var obj = new SearchBackground
            {
                Name = name,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes the background selected by the user; adds background to the list of installed backgrounds
        /// </summary>
        /// <param name="background">The input background to use; pass null to create a new filled backgrounds or to remove the current background</param>
        /// <param name="type">Background type; pass null to use the default type of the remote background or to remove the current background</param>
        /// <param name="forDarkTheme">True, if the background is chosen for dark theme</param>
        public static async Task<Background> SetBackground(this Client client, InputBackground background = default, BackgroundType type = default, bool forDarkTheme = false)
        {
            var obj = new SetBackground
            {
                Background = background,
                Type = type,
                ForDarkTheme = forDarkTheme,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Removes background from the list of installed backgrounds
        /// </summary>
        /// <param name="backgroundId">The background identifier</param>
        public static async Task RemoveBackground(this Client client, long backgroundId = 0)
        {
            var obj = new RemoveBackground
            {
                BackgroundId = backgroundId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Resets list of installed backgrounds to its default value
        /// </summary>
        public static async Task ResetBackgrounds(this Client client)
        {
            var obj = new ResetBackgrounds();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization
        /// </summary>
        /// <param name="onlyLocal">If true, returns only locally available information without sending network requests</param>
        public static async Task<LocalizationTargetInfo> GetLocalizationTargetInfo(this Client client, bool onlyLocal = false)
        {
            var obj = new GetLocalizationTargetInfo
            {
                OnlyLocal = onlyLocal,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Language pack identifier</param>
        public static async Task<LanguagePackInfo> GetLanguagePackInfo(this Client client, string languagePackId = default)
        {
            var obj = new GetLanguagePackInfo
            {
                LanguagePackId = languagePackId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns strings from a language pack in the current localization target by their keys. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Language pack identifier of the strings to be returned</param>
        /// <param name="keys">Language pack keys of the strings to be returned; leave empty to request all available strings</param>
        public static async Task<LanguagePackStrings> GetLanguagePackStrings(this Client client, string languagePackId = default, string[] keys = default)
        {
            var obj = new GetLanguagePackStrings
            {
                LanguagePackId = languagePackId,
                Keys = keys,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Fetches the latest versions of all strings from a language pack in the current localization target from the server. This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Language pack identifier</param>
        public static async Task SynchronizeLanguagePack(this Client client, string languagePackId = default)
        {
            var obj = new SynchronizeLanguagePack
            {
                LanguagePackId = languagePackId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Identifier of a language pack to be added; may be different from a name that is used in an "https://t.me/setlanguage/" link</param>
        public static async Task AddCustomServerLanguagePack(this Client client, string languagePackId = default)
        {
            var obj = new AddCustomServerLanguagePack
            {
                LanguagePackId = languagePackId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Adds or changes a custom local language pack to the current localization target
        /// </summary>
        /// <param name="info">Information about the language pack. Language pack ID must start with 'X', consist only of English letters, digits and hyphens, and must not exceed 64 characters. Can be called before authorization</param>
        /// <param name="strings">Strings of the new language pack</param>
        public static async Task SetCustomLanguagePack(this Client client, LanguagePackInfo info = default, LanguagePackString[] strings = default)
        {
            var obj = new SetCustomLanguagePack
            {
                Info = info,
                Strings = strings,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Edits information about a custom local language pack in the current localization target. Can be called before authorization
        /// </summary>
        /// <param name="info">New information about the custom local language pack</param>
        public static async Task EditCustomLanguagePackInfo(this Client client, LanguagePackInfo info = default)
        {
            var obj = new EditCustomLanguagePackInfo
            {
                Info = info,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Adds, edits or deletes a string in a custom local language pack. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Identifier of a previously added custom local language pack in the current localization target</param>
        /// <param name="newString">New language pack string</param>
        public static async Task SetCustomLanguagePackString(this Client client, string languagePackId = default, LanguagePackString newString = default)
        {
            var obj = new SetCustomLanguagePackString
            {
                LanguagePackId = languagePackId,
                NewString = newString,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted. Can be called before authorization
        /// </summary>
        /// <param name="languagePackId">Identifier of the language pack to delete</param>
        public static async Task DeleteLanguagePack(this Client client, string languagePackId = default)
        {
            var obj = new DeleteLanguagePack
            {
                LanguagePackId = languagePackId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription
        /// </summary>
        /// <param name="deviceToken">Device token</param>
        /// <param name="otherUserIds">List of user identifiers of other users currently using the application</param>
        public static async Task<PushReceiverId> RegisterDevice(this Client client, DeviceToken deviceToken = default, long[] otherUserIds = default)
        {
            var obj = new RegisterDevice
            {
                DeviceToken = deviceToken,
                OtherUserIds = otherUserIds,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization
        /// </summary>
        /// <param name="payload">JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time" and "google.notification.sound" fields added</param>
        public static async Task ProcessPushNotification(this Client client, string payload = default)
        {
            var obj = new ProcessPushNotification
            {
                Payload = payload,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
        /// </summary>
        /// <param name="payload">JSON-encoded push notification payload</param>
        public static async Task<PushReceiverId> GetPushReceiverId(this Client client, string payload = default)
        {
            var obj = new GetPushReceiverId
            {
                Payload = payload,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
        /// </summary>
        /// <param name="payload">JSON-encoded push notification payload</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static PushReceiverId GetPushReceiverIdSync(this Client client, string payload = default)
        {
            var obj = new GetPushReceiverId
            {
                Payload = payload,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Returns t.me URLs recently visited by a newly registered user
        /// </summary>
        /// <param name="referrer">Google Play referrer to identify the user</param>
        public static async Task<TMeUrls> GetRecentlyVisitedTMeUrls(this Client client, string referrer = default)
        {
            var obj = new GetRecentlyVisitedTMeUrls
            {
                Referrer = referrer,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes user privacy settings
        /// </summary>
        /// <param name="setting">The privacy setting</param>
        /// <param name="rules">The new privacy rules</param>
        public static async Task SetUserPrivacySettingRules(this Client client, UserPrivacySetting setting = default, UserPrivacySettingRules rules = default)
        {
            var obj = new SetUserPrivacySettingRules
            {
                Setting = setting,
                Rules = rules,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns the current privacy settings
        /// </summary>
        /// <param name="setting">The privacy setting</param>
        public static async Task<UserPrivacySettingRules> GetUserPrivacySettingRules(this Client client, UserPrivacySetting setting = default)
        {
            var obj = new GetUserPrivacySettingRules
            {
                Setting = setting,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization
        /// </summary>
        /// <param name="name">The name of the option</param>
        public static async Task<OptionValue> GetOption(this Client client, string name = default)
        {
            var obj = new GetOption
            {
                Name = name,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
        /// </summary>
        /// <param name="name">The name of the option</param>
        /// <param name="value">The new value of the option; pass null to reset option value to a default value</param>
        public static async Task SetOption(this Client client, string name = default, OptionValue value = default)
        {
            var obj = new SetOption
            {
                Name = name,
                Value = value,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Changes the period of inactivity after which the account of the current user will automatically be deleted
        /// </summary>
        /// <param name="ttl">New account TTL</param>
        public static async Task SetAccountTtl(this Client client, AccountTtl ttl = default)
        {
            var obj = new SetAccountTtl
            {
                Ttl = ttl,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns the period of inactivity after which the account of the current user will automatically be deleted
        /// </summary>
        public static async Task<AccountTtl> GetAccountTtl(this Client client)
        {
            var obj = new GetAccountTtl();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account. Can be called before authorization when the current authorization state is authorizationStateWaitPassword
        /// </summary>
        /// <param name="reason">The reason why the account was deleted; optional</param>
        public static async Task DeleteAccount(this Client client, string reason = default)
        {
            var obj = new DeleteAccount
            {
                Reason = reason,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Removes a chat action bar without any other action
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        public static async Task RemoveChatActionBar(this Client client, long chatId = 0)
        {
            var obj = new RemoveChatActionBar
            {
                ChatId = chatId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if this is a private chat with a bot, a private chat with a user sharing their location, a supergroup, or a channel, since other chats can't be checked by moderators
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageIds">Identifiers of reported messages, if any</param>
        /// <param name="reason">The reason for reporting the chat</param>
        /// <param name="text">Additional report details; 0-1024 characters</param>
        public static async Task ReportChat(this Client client, long chatId = 0, long[] messageIds = default, ChatReportReason reason = default, string text = default)
        {
            var obj = new ReportChat
            {
                ChatId = chatId,
                MessageIds = messageIds,
                Reason = reason,
                Text = text,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Reports a chat photo to the Telegram moderators. A chat photo can be reported only if this is a private chat with a bot, a private chat with a user sharing their location, a supergroup, or a channel, since other chats can't be checked by moderators
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="fileId">Identifier of the photo to report. Only full photos from chatPhoto can be reported</param>
        /// <param name="reason">The reason for reporting the chat photo</param>
        /// <param name="text">Additional report details; 0-1024 characters</param>
        public static async Task ReportChatPhoto(this Client client, long chatId = 0, int fileId = 0, ChatReportReason reason = default, string text = default)
        {
            var obj = new ReportChatPhoto
            {
                ChatId = chatId,
                FileId = fileId,
                Reason = reason,
                Text = text,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns detailed statistics about a chat. Currently this method can be used only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics == true
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="isDark">Pass true if a dark theme is used by the application</param>
        public static async Task<ChatStatistics> GetChatStatistics(this Client client, long chatId = 0, bool isDark = false)
        {
            var obj = new GetChatStatistics
            {
                ChatId = chatId,
                IsDark = isDark,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns detailed statistics about a message. Can be used only if message.can_get_statistics == true
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="messageId">Message identifier</param>
        /// <param name="isDark">Pass true if a dark theme is used by the application</param>
        public static async Task<MessageStatistics> GetMessageStatistics(this Client client, long chatId = 0, long messageId = 0, bool isDark = false)
        {
            var obj = new GetMessageStatistics
            {
                ChatId = chatId,
                MessageId = messageId,
                IsDark = isDark,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Loads an asynchronous or a zoomed in statistical graph
        /// </summary>
        /// <param name="chatId">Chat identifier</param>
        /// <param name="token">The token for graph loading</param>
        /// <param name="x">X-value for zoomed in graph or 0 otherwise</param>
        public static async Task<StatisticalGraph> GetStatisticalGraph(this Client client, long chatId = 0, string token = default, long x = 0)
        {
            var obj = new GetStatisticalGraph
            {
                ChatId = chatId,
                Token = token,
                X = x,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns storage usage statistics. Can be called before authorization
        /// </summary>
        /// <param name="chatLimit">The maximum number of chats with the largest storage usage for which separate statistics need to be returned. All other chats will be grouped in entries with chat_id == 0. If the chat info database is not used, the chat_limit is ignored and is always set to 0</param>
        public static async Task<StorageStatistics> GetStorageStatistics(this Client client, int chatLimit = 0)
        {
            var obj = new GetStorageStatistics
            {
                ChatLimit = chatLimit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Quickly returns approximate storage usage statistics. Can be called before authorization
        /// </summary>
        public static async Task<StorageStatisticsFast> GetStorageStatisticsFast(this Client client)
        {
            var obj = new GetStorageStatisticsFast();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns database statistics
        /// </summary>
        public static async Task<DatabaseStatistics> GetDatabaseStatistics(this Client client)
        {
            var obj = new GetDatabaseStatistics();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted
        /// </summary>
        /// <param name="size">Limit on the total size of files after deletion, in bytes. Pass -1 to use the default limit</param>
        /// <param name="ttl">Limit on the time that has passed since the last time a file was accessed (or creation time for some filesystems). Pass -1 to use the default limit</param>
        /// <param name="count">Limit on the total count of files after deletion. Pass -1 to use the default limit</param>
        /// <param name="immunityDelay">The amount of time after the creation of a file during which it can't be deleted, in seconds. Pass -1 to use the default value</param>
        /// <param name="fileTypes">If non-empty, only files with the given types are considered. By default, all types except thumbnails, profile photos, stickers and wallpapers are deleted</param>
        /// <param name="chatIds">If non-empty, only files from the given chats are considered. Use 0 as chat identifier to delete files not belonging to any chat (e.g., profile photos)</param>
        /// <param name="excludeChatIds">If non-empty, files from the given chats are excluded. Use 0 as chat identifier to exclude all files not belonging to any chat (e.g., profile photos)</param>
        /// <param name="returnDeletedFileStatistics">Pass true if statistics about the files that were deleted must be returned instead of the whole storage usage statistics. Affects only returned statistics</param>
        /// <param name="chatLimit">Same as in getStorageStatistics. Affects only returned statistics</param>
        public static async Task<StorageStatistics> OptimizeStorage(this Client client, long size = 0, int ttl = 0, int count = 0, int immunityDelay = 0, FileType[] fileTypes = default, long[] chatIds = default, long[] excludeChatIds = default, bool returnDeletedFileStatistics = false, int chatLimit = 0)
        {
            var obj = new OptimizeStorage
            {
                Size = size,
                Ttl = ttl,
                Count = count,
                ImmunityDelay = immunityDelay,
                FileTypes = fileTypes,
                ChatIds = chatIds,
                ExcludeChatIds = excludeChatIds,
                ReturnDeletedFileStatistics = returnDeletedFileStatistics,
                ChatLimit = chatLimit,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks, so it must be called whenever the network is changed, even if the network type remains the same. -Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics
        /// </summary>
        /// <param name="type">The new network type; pass null to set network type to networkTypeOther</param>
        public static async Task SetNetworkType(this Client client, NetworkType type = default)
        {
            var obj = new SetNetworkType
            {
                Type = type,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns network data usage statistics. Can be called before authorization
        /// </summary>
        /// <param name="onlyCurrent">If true, returns only data for the current library launch</param>
        public static async Task<NetworkStatistics> GetNetworkStatistics(this Client client, bool onlyCurrent = false)
        {
            var obj = new GetNetworkStatistics
            {
                OnlyCurrent = onlyCurrent,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Adds the specified data to data usage statistics. Can be called before authorization
        /// </summary>
        /// <param name="entry">The network statistics entry with the data to be added to statistics</param>
        public static async Task AddNetworkStatistics(this Client client, NetworkStatisticsEntry entry = default)
        {
            var obj = new AddNetworkStatistics
            {
                Entry = entry,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Resets all network data usage statistics to zero. Can be called before authorization
        /// </summary>
        public static async Task ResetNetworkStatistics(this Client client)
        {
            var obj = new ResetNetworkStatistics();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns auto-download settings presets for the current user
        /// </summary>
        public static async Task<AutoDownloadSettingsPresets> GetAutoDownloadSettingsPresets(this Client client)
        {
            var obj = new GetAutoDownloadSettingsPresets();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sets auto-download settings
        /// </summary>
        /// <param name="settings">New user auto-download settings</param>
        /// <param name="type">Type of the network for which the new settings are relevant</param>
        public static async Task SetAutoDownloadSettings(this Client client, AutoDownloadSettings settings = default, NetworkType type = default)
        {
            var obj = new SetAutoDownloadSettings
            {
                Settings = settings,
                Type = type,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns information about a bank card
        /// </summary>
        /// <param name="bankCardNumber">The bank card number</param>
        public static async Task<BankCardInfo> GetBankCardInfo(this Client client, string bankCardNumber = default)
        {
            var obj = new GetBankCardInfo
            {
                BankCardNumber = bankCardNumber,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns one of the available Telegram Passport elements
        /// </summary>
        /// <param name="type">Telegram Passport element type</param>
        /// <param name="password">Password of the current user</param>
        public static async Task<PassportElement> GetPassportElement(this Client client, PassportElementType type = default, string password = default)
        {
            var obj = new GetPassportElement
            {
                Type = type,
                Password = password,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns all available Telegram Passport elements
        /// </summary>
        /// <param name="password">Password of the current user</param>
        public static async Task<PassportElements> GetAllPassportElements(this Client client, string password = default)
        {
            var obj = new GetAllPassportElements
            {
                Password = password,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first
        /// </summary>
        /// <param name="element">Input Telegram Passport element</param>
        /// <param name="password">Password of the current user</param>
        public static async Task<PassportElement> SetPassportElement(this Client client, InputPassportElement element = default, string password = default)
        {
            var obj = new SetPassportElement
            {
                Element = element,
                Password = password,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Deletes a Telegram Passport element
        /// </summary>
        /// <param name="type">Element type</param>
        public static async Task DeletePassportElement(this Client client, PassportElementType type = default)
        {
            var obj = new DeletePassportElement
            {
                Type = type,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed
        /// </summary>
        /// <param name="userId">User identifier</param>
        /// <param name="errors">The errors</param>
        public static async Task SetPassportElementErrors(this Client client, long userId = 0, InputPassportElementError[] errors = default)
        {
            var obj = new SetPassportElementErrors
            {
                UserId = userId,
                Errors = errors,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns an IETF language tag of the language preferred in the country, which must be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown
        /// </summary>
        /// <param name="countryCode">A two-letter ISO 3166-1 alpha-2 country code</param>
        public static async Task<Text> GetPreferredCountryLanguage(this Client client, string countryCode = default)
        {
            var obj = new GetPreferredCountryLanguage
            {
                CountryCode = countryCode,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sends a code to verify a phone number to be added to a user's Telegram Passport
        /// </summary>
        /// <param name="phoneNumber">The phone number of the user, in international format</param>
        /// <param name="settings">Settings for the authentication of the user's phone number; pass null to use default settings</param>
        public static async Task<AuthenticationCodeInfo> SendPhoneNumberVerificationCode(this Client client, string phoneNumber = default, PhoneNumberAuthenticationSettings settings = default)
        {
            var obj = new SendPhoneNumberVerificationCode
            {
                PhoneNumber = phoneNumber,
                Settings = settings,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Re-sends the code to verify a phone number to be added to a user's Telegram Passport
        /// </summary>
        public static async Task<AuthenticationCodeInfo> ResendPhoneNumberVerificationCode(this Client client)
        {
            var obj = new ResendPhoneNumberVerificationCode();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Checks the phone number verification code for Telegram Passport
        /// </summary>
        /// <param name="code">Verification code</param>
        public static async Task CheckPhoneNumberVerificationCode(this Client client, string code = default)
        {
            var obj = new CheckPhoneNumberVerificationCode
            {
                Code = code,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sends a code to verify an email address to be added to a user's Telegram Passport
        /// </summary>
        /// <param name="emailAddress">Email address</param>
        public static async Task<EmailAddressAuthenticationCodeInfo> SendEmailAddressVerificationCode(this Client client, string emailAddress = default)
        {
            var obj = new SendEmailAddressVerificationCode
            {
                EmailAddress = emailAddress,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Re-sends the code to verify an email address to be added to a user's Telegram Passport
        /// </summary>
        public static async Task<EmailAddressAuthenticationCodeInfo> ResendEmailAddressVerificationCode(this Client client)
        {
            var obj = new ResendEmailAddressVerificationCode();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Checks the email address verification code for Telegram Passport
        /// </summary>
        /// <param name="code">Verification code</param>
        public static async Task CheckEmailAddressVerificationCode(this Client client, string code = default)
        {
            var obj = new CheckEmailAddressVerificationCode
            {
                Code = code,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns a Telegram Passport authorization form for sharing data with a service
        /// </summary>
        /// <param name="botUserId">User identifier of the service's bot</param>
        /// <param name="scope">Telegram Passport element types requested by the service</param>
        /// <param name="publicKey">Service's public key</param>
        /// <param name="nonce">Unique request identifier provided by the service</param>
        public static async Task<PassportAuthorizationForm> GetPassportAuthorizationForm(this Client client, long botUserId = 0, string scope = default, string publicKey = default, string nonce = default)
        {
            var obj = new GetPassportAuthorizationForm
            {
                BotUserId = botUserId,
                Scope = scope,
                PublicKey = publicKey,
                Nonce = nonce,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form
        /// </summary>
        /// <param name="autorizationFormId">Authorization form identifier</param>
        /// <param name="password">Password of the current user</param>
        public static async Task<PassportElementsWithErrors> GetPassportAuthorizationFormAvailableElements(this Client client, int autorizationFormId = 0, string password = default)
        {
            var obj = new GetPassportAuthorizationFormAvailableElements
            {
                AutorizationFormId = autorizationFormId,
                Password = password,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements are going to be reused
        /// </summary>
        /// <param name="autorizationFormId">Authorization form identifier</param>
        /// <param name="types">Types of Telegram Passport elements chosen by user to complete the authorization form</param>
        public static async Task SendPassportAuthorizationForm(this Client client, int autorizationFormId = 0, PassportElementType[] types = default)
        {
            var obj = new SendPassportAuthorizationForm
            {
                AutorizationFormId = autorizationFormId,
                Types = types,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation
        /// </summary>
        /// <param name="hash">Hash value from the link</param>
        /// <param name="phoneNumber">Phone number value from the link</param>
        /// <param name="settings">Settings for the authentication of the user's phone number; pass null to use default settings</param>
        public static async Task<AuthenticationCodeInfo> SendPhoneNumberConfirmationCode(this Client client, string hash = default, string phoneNumber = default, PhoneNumberAuthenticationSettings settings = default)
        {
            var obj = new SendPhoneNumberConfirmationCode
            {
                Hash = hash,
                PhoneNumber = phoneNumber,
                Settings = settings,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Resends phone number confirmation code
        /// </summary>
        public static async Task<AuthenticationCodeInfo> ResendPhoneNumberConfirmationCode(this Client client)
        {
            var obj = new ResendPhoneNumberConfirmationCode();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Checks phone number confirmation code
        /// </summary>
        /// <param name="code">The phone number confirmation code</param>
        public static async Task CheckPhoneNumberConfirmationCode(this Client client, string code = default)
        {
            var obj = new CheckPhoneNumberConfirmationCode
            {
                Code = code,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
        /// </summary>
        /// <param name="pendingUpdateCount">The number of pending updates</param>
        /// <param name="errorMessage">The last error message</param>
        public static async Task SetBotUpdatesStatus(this Client client, int pendingUpdateCount = 0, string errorMessage = default)
        {
            var obj = new SetBotUpdatesStatus
            {
                PendingUpdateCount = pendingUpdateCount,
                ErrorMessage = errorMessage,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Uploads a PNG image with a sticker; returns the uploaded file
        /// </summary>
        /// <param name="userId">Sticker file owner; ignored for regular users</param>
        /// <param name="sticker">Sticker file to upload</param>
        public static async Task<File> UploadStickerFile(this Client client, long userId = 0, InputSticker sticker = default)
        {
            var obj = new UploadStickerFile
            {
                UserId = userId,
                Sticker = sticker,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns a suggested name for a new sticker set with a given title
        /// </summary>
        /// <param name="title">Sticker set title; 1-64 characters</param>
        public static async Task<Text> GetSuggestedStickerSetName(this Client client, string title = default)
        {
            var obj = new GetSuggestedStickerSetName
            {
                Title = title,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Checks whether a name can be used for a new sticker set
        /// </summary>
        /// <param name="name">Name to be checked</param>
        public static async Task<CheckStickerSetNameResult> CheckStickerSetName(this Client client, string name = default)
        {
            var obj = new CheckStickerSetName
            {
                Name = name,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Creates a new sticker set. Returns the newly created sticker set
        /// </summary>
        /// <param name="userId">Sticker set owner; ignored for regular users</param>
        /// <param name="title">Sticker set title; 1-64 characters</param>
        /// <param name="name">Sticker set name. Can contain only English letters, digits and underscores. Must end with *"_by_&lt;bot username&gt;"* (*&lt;bot_username&gt;* is case insensitive) for bots; 1-64 characters</param>
        /// <param name="isMasks">True, if stickers are masks. Animated stickers can't be masks</param>
        /// <param name="stickers">List of stickers to be added to the set; must be non-empty. All stickers must be of the same type. For animated stickers, uploadStickerFile must be used before the sticker is shown</param>
        /// <param name="source">Source of the sticker set; may be empty if unknown</param>
        public static async Task<StickerSet> CreateNewStickerSet(this Client client, long userId = 0, string title = default, string name = default, bool isMasks = false, InputSticker[] stickers = default, string source = default)
        {
            var obj = new CreateNewStickerSet
            {
                UserId = userId,
                Title = title,
                Name = name,
                IsMasks = isMasks,
                Stickers = stickers,
                Source = source,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Adds a new sticker to a set; for bots only. Returns the sticker set
        /// </summary>
        /// <param name="userId">Sticker set owner</param>
        /// <param name="name">Sticker set name</param>
        /// <param name="sticker">Sticker to add to the set</param>
        public static async Task<StickerSet> AddStickerToSet(this Client client, long userId = 0, string name = default, InputSticker sticker = default)
        {
            var obj = new AddStickerToSet
            {
                UserId = userId,
                Name = name,
                Sticker = sticker,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sets a sticker set thumbnail; for bots only. Returns the sticker set
        /// </summary>
        /// <param name="userId">Sticker set owner</param>
        /// <param name="name">Sticker set name</param>
        /// <param name="thumbnail">Thumbnail to set in PNG or TGS format; pass null to remove the sticker set thumbnail. Animated thumbnail must be set for animated sticker sets and only for them</param>
        public static async Task<StickerSet> SetStickerSetThumbnail(this Client client, long userId = 0, string name = default, InputFile thumbnail = default)
        {
            var obj = new SetStickerSetThumbnail
            {
                UserId = userId,
                Name = name,
                Thumbnail = thumbnail,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
        /// </summary>
        /// <param name="sticker">Sticker</param>
        /// <param name="position">New position of the sticker in the set, zero-based</param>
        public static async Task SetStickerPositionInSet(this Client client, InputFile sticker = default, int position = 0)
        {
            var obj = new SetStickerPositionInSet
            {
                Sticker = sticker,
                Position = position,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
        /// </summary>
        /// <param name="sticker">Sticker</param>
        public static async Task RemoveStickerFromSet(this Client client, InputFile sticker = default)
        {
            var obj = new RemoveStickerFromSet
            {
                Sticker = sticker,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded
        /// </summary>
        /// <param name="location">Location of the map center</param>
        /// <param name="zoom">Map zoom level; 13-20</param>
        /// <param name="width">Map width in pixels before applying scale; 16-1024</param>
        /// <param name="height">Map height in pixels before applying scale; 16-1024</param>
        /// <param name="scale">Map scale; 1-3</param>
        /// <param name="chatId">Identifier of a chat, in which the thumbnail will be shown. Use 0 if unknown</param>
        public static async Task<File> GetMapThumbnailFile(this Client client, Location location = default, int zoom = 0, int width = 0, int height = 0, int scale = 0, long chatId = 0)
        {
            var obj = new GetMapThumbnailFile
            {
                Location = location,
                Zoom = zoom,
                Width = width,
                Height = height,
                Scale = scale,
                ChatId = chatId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Accepts Telegram terms of services
        /// </summary>
        /// <param name="termsOfServiceId">Terms of service identifier</param>
        public static async Task AcceptTermsOfService(this Client client, string termsOfServiceId = default)
        {
            var obj = new AcceptTermsOfService
            {
                TermsOfServiceId = termsOfServiceId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sends a custom request; for bots only
        /// </summary>
        /// <param name="method">The method name</param>
        /// <param name="parameters">JSON-serialized method parameters</param>
        public static async Task<CustomRequestResult> SendCustomRequest(this Client client, string method = default, string parameters = default)
        {
            var obj = new SendCustomRequest
            {
                Method = method,
                Parameters = parameters,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Answers a custom query; for bots only
        /// </summary>
        /// <param name="customQueryId">Identifier of a custom query</param>
        /// <param name="data">JSON-serialized answer to the query</param>
        public static async Task AnswerCustomQuery(this Client client, long customQueryId = 0, string data = default)
        {
            var obj = new AnswerCustomQuery
            {
                CustomQueryId = customQueryId,
                Data = data,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Succeeds after a specified amount of time has passed. Can be called before initialization
        /// </summary>
        /// <param name="seconds">Number of seconds before the function returns</param>
        public static async Task SetAlarm(this Client client, double seconds = 0.0)
        {
            var obj = new SetAlarm
            {
                Seconds = seconds,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns information about existing countries. Can be called before authorization
        /// </summary>
        public static async Task<Countries> GetCountries(this Client client)
        {
            var obj = new GetCountries();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Uses the current IP address to find the current country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization
        /// </summary>
        public static async Task<Text> GetCountryCode(this Client client)
        {
            var obj = new GetCountryCode();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a phone number by its prefix. Can be called before authorization
        /// </summary>
        /// <param name="phoneNumberPrefix">The phone number prefix</param>
        public static async Task<PhoneNumberInfo> GetPhoneNumberInfo(this Client client, string phoneNumberPrefix = default)
        {
            var obj = new GetPhoneNumberInfo
            {
                PhoneNumberPrefix = phoneNumberPrefix,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously
        /// </summary>
        /// <param name="languageCode">A two-letter ISO 639-1 country code for country information localization</param>
        /// <param name="phoneNumberPrefix">The phone number prefix</param>
        public static async Task<PhoneNumberInfo> GetPhoneNumberInfoSync(this Client client, string languageCode = default, string phoneNumberPrefix = default)
        {
            var obj = new GetPhoneNumberInfoSync
            {
                LanguageCode = languageCode,
                PhoneNumberPrefix = phoneNumberPrefix,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously
        /// </summary>
        /// <param name="languageCode">A two-letter ISO 639-1 country code for country information localization</param>
        /// <param name="phoneNumberPrefix">The phone number prefix</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static PhoneNumberInfo GetPhoneNumberInfoSyncSync(this Client client, string languageCode = default, string phoneNumberPrefix = default)
        {
            var obj = new GetPhoneNumberInfoSync
            {
                LanguageCode = languageCode,
                PhoneNumberPrefix = phoneNumberPrefix,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Returns the link for downloading official Telegram application to be used when the current user invites friends to Telegram
        /// </summary>
        public static async Task<HttpUrl> GetApplicationDownloadLink(this Client client)
        {
            var obj = new GetApplicationDownloadLink();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization
        /// </summary>
        /// <param name="link">The link</param>
        public static async Task<DeepLinkInfo> GetDeepLinkInfo(this Client client, string link = default)
        {
            var obj = new GetDeepLinkInfo
            {
                Link = link,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns application config, provided by the server. Can be called before authorization
        /// </summary>
        public static async Task<JsonValue> GetApplicationConfig(this Client client)
        {
            var obj = new GetApplicationConfig();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Saves application log event on the server. Can be called before authorization
        /// </summary>
        /// <param name="type">Event type</param>
        /// <param name="chatId">Optional chat identifier, associated with the event</param>
        /// <param name="data">The log event data</param>
        public static async Task SaveApplicationLogEvent(this Client client, string type = default, long chatId = 0, JsonValue data = default)
        {
            var obj = new SaveApplicationLogEvent
            {
                Type = type,
                ChatId = chatId,
                Data = data,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Adds a proxy server for network requests. Can be called before authorization
        /// </summary>
        /// <param name="server">Proxy server IP address</param>
        /// <param name="port">Proxy server port</param>
        /// <param name="enable">True, if the proxy needs to be enabled</param>
        /// <param name="type">Proxy type</param>
        public static async Task<Proxy> AddProxy(this Client client, string server = default, int port = 0, bool enable = false, ProxyType type = default)
        {
            var obj = new AddProxy
            {
                Server = server,
                Port = port,
                Enable = enable,
                Type = type,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Edits an existing proxy server for network requests. Can be called before authorization
        /// </summary>
        /// <param name="proxyId">Proxy identifier</param>
        /// <param name="server">Proxy server IP address</param>
        /// <param name="port">Proxy server port</param>
        /// <param name="enable">True, if the proxy needs to be enabled</param>
        /// <param name="type">Proxy type</param>
        public static async Task<Proxy> EditProxy(this Client client, int proxyId = 0, string server = default, int port = 0, bool enable = false, ProxyType type = default)
        {
            var obj = new EditProxy
            {
                ProxyId = proxyId,
                Server = server,
                Port = port,
                Enable = enable,
                Type = type,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization
        /// </summary>
        /// <param name="proxyId">Proxy identifier</param>
        public static async Task EnableProxy(this Client client, int proxyId = 0)
        {
            var obj = new EnableProxy
            {
                ProxyId = proxyId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Disables the currently enabled proxy. Can be called before authorization
        /// </summary>
        public static async Task DisableProxy(this Client client)
        {
            var obj = new DisableProxy();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Removes a proxy server. Can be called before authorization
        /// </summary>
        /// <param name="proxyId">Proxy identifier</param>
        public static async Task RemoveProxy(this Client client, int proxyId = 0)
        {
            var obj = new RemoveProxy
            {
                ProxyId = proxyId,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns list of proxies that are currently set up. Can be called before authorization
        /// </summary>
        public static async Task<Proxies> GetProxies(this Client client)
        {
            var obj = new GetProxies();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization
        /// </summary>
        /// <param name="proxyId">Proxy identifier</param>
        public static async Task<HttpUrl> GetProxyLink(this Client client, int proxyId = 0)
        {
            var obj = new GetProxyLink
            {
                ProxyId = proxyId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization
        /// </summary>
        /// <param name="proxyId">Proxy identifier. Use 0 to ping a Telegram server without a proxy</param>
        public static async Task<Seconds> PingProxy(this Client client, int proxyId = 0)
        {
            var obj = new PingProxy
            {
                ProxyId = proxyId,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sets new log stream for internal logging of TDLib. Can be called synchronously
        /// </summary>
        /// <param name="logStream">New log stream</param>
        public static async Task SetLogStream(this Client client, LogStream logStream = default)
        {
            var obj = new SetLogStream
            {
                LogStream = logStream,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sets new log stream for internal logging of TDLib. Can be called synchronously
        /// </summary>
        /// <param name="logStream">New log stream</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static void SetLogStreamSync(this Client client, LogStream logStream = default)
        {
            var obj = new SetLogStream
            {
                LogStream = logStream,
            };
            _ = client.Execute<Ok>(obj);
        }

        /// <summary>
        /// Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously
        /// </summary>
        public static async Task<LogStream> GetLogStream(this Client client)
        {
            var obj = new GetLogStream();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously
        /// </summary>
        /// <remarks>This extension method is synchronous.</remarks>
        public static LogStream GetLogStreamSync(this Client client)
        {
            var obj = new GetLogStream();
            return client.Execute(obj);
        }

        /// <summary>
        /// Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
        /// </summary>
        /// <param name="newVerbosityLevel">New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings, value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds to verbose debug, value greater than 5 and up to 1023 can be used to enable even more logging</param>
        public static async Task SetLogVerbosityLevel(this Client client, int newVerbosityLevel = 0)
        {
            var obj = new SetLogVerbosityLevel
            {
                NewVerbosityLevel = newVerbosityLevel,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
        /// </summary>
        /// <param name="newVerbosityLevel">New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings, value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds to verbose debug, value greater than 5 and up to 1023 can be used to enable even more logging</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static void SetLogVerbosityLevelSync(this Client client, int newVerbosityLevel = 0)
        {
            var obj = new SetLogVerbosityLevel
            {
                NewVerbosityLevel = newVerbosityLevel,
            };
            _ = client.Execute<Ok>(obj);
        }

        /// <summary>
        /// Returns current verbosity level of the internal logging of TDLib. Can be called synchronously
        /// </summary>
        public static async Task<LogVerbosityLevel> GetLogVerbosityLevel(this Client client)
        {
            var obj = new GetLogVerbosityLevel();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns current verbosity level of the internal logging of TDLib. Can be called synchronously
        /// </summary>
        /// <remarks>This extension method is synchronous.</remarks>
        public static LogVerbosityLevel GetLogVerbosityLevelSync(this Client client)
        {
            var obj = new GetLogVerbosityLevel();
            return client.Execute(obj);
        }

        /// <summary>
        /// Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
        /// </summary>
        public static async Task<LogTags> GetLogTags(this Client client)
        {
            var obj = new GetLogTags();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
        /// </summary>
        /// <remarks>This extension method is synchronous.</remarks>
        public static LogTags GetLogTagsSync(this Client client)
        {
            var obj = new GetLogTags();
            return client.Execute(obj);
        }

        /// <summary>
        /// Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
        /// </summary>
        /// <param name="tag">Logging tag to change verbosity level</param>
        /// <param name="newVerbosityLevel">New verbosity level; 1-1024</param>
        public static async Task SetLogTagVerbosityLevel(this Client client, string tag = default, int newVerbosityLevel = 0)
        {
            var obj = new SetLogTagVerbosityLevel
            {
                Tag = tag,
                NewVerbosityLevel = newVerbosityLevel,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
        /// </summary>
        /// <param name="tag">Logging tag to change verbosity level</param>
        /// <param name="newVerbosityLevel">New verbosity level; 1-1024</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static void SetLogTagVerbosityLevelSync(this Client client, string tag = default, int newVerbosityLevel = 0)
        {
            var obj = new SetLogTagVerbosityLevel
            {
                Tag = tag,
                NewVerbosityLevel = newVerbosityLevel,
            };
            _ = client.Execute<Ok>(obj);
        }

        /// <summary>
        /// Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
        /// </summary>
        /// <param name="tag">Logging tag to change verbosity level</param>
        public static async Task<LogVerbosityLevel> GetLogTagVerbosityLevel(this Client client, string tag = default)
        {
            var obj = new GetLogTagVerbosityLevel
            {
                Tag = tag,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
        /// </summary>
        /// <param name="tag">Logging tag to change verbosity level</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static LogVerbosityLevel GetLogTagVerbosityLevelSync(this Client client, string tag = default)
        {
            var obj = new GetLogTagVerbosityLevel
            {
                Tag = tag,
            };
            return client.Execute(obj);
        }

        /// <summary>
        /// Adds a message to TDLib internal log. Can be called synchronously
        /// </summary>
        /// <param name="verbosityLevel">The minimum verbosity level needed for the message to be logged; 0-1023</param>
        /// <param name="text">Text of a message to log</param>
        public static async Task AddLogMessage(this Client client, int verbosityLevel = 0, string text = default)
        {
            var obj = new AddLogMessage
            {
                VerbosityLevel = verbosityLevel,
                Text = text,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Adds a message to TDLib internal log. Can be called synchronously
        /// </summary>
        /// <param name="verbosityLevel">The minimum verbosity level needed for the message to be logged; 0-1023</param>
        /// <param name="text">Text of a message to log</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static void AddLogMessageSync(this Client client, int verbosityLevel = 0, string text = default)
        {
            var obj = new AddLogMessage
            {
                VerbosityLevel = verbosityLevel,
                Text = text,
            };
            _ = client.Execute<Ok>(obj);
        }

        /// <summary>
        /// Does nothing; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        public static async Task TestCallEmpty(this Client client)
        {
            var obj = new TestCallEmpty();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Returns the received string; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">String to return</param>
        public static async Task<TestString> TestCallString(this Client client, string x = default)
        {
            var obj = new TestCallString
            {
                X = x,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the received bytes; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Bytes to return</param>
        public static async Task<TestBytes> TestCallBytes(this Client client, Memory<byte> x = default)
        {
            var obj = new TestCallBytes
            {
                X = x,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Vector of numbers to return</param>
        public static async Task<TestVectorInt> TestCallVectorInt(this Client client, int[] x = default)
        {
            var obj = new TestCallVectorInt
            {
                X = x,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Vector of objects to return</param>
        public static async Task<TestVectorIntObject> TestCallVectorIntObject(this Client client, TestInt[] x = default)
        {
            var obj = new TestCallVectorIntObject
            {
                X = x,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Vector of strings to return</param>
        public static async Task<TestVectorString> TestCallVectorString(this Client client, string[] x = default)
        {
            var obj = new TestCallVectorString
            {
                X = x,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Vector of objects to return</param>
        public static async Task<TestVectorStringObject> TestCallVectorStringObject(this Client client, TestString[] x = default)
        {
            var obj = new TestCallVectorStringObject
            {
                X = x,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the squared received number; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        /// <param name="x">Number to square</param>
        public static async Task<TestInt> TestSquareInt(this Client client, int x = 0)
        {
            var obj = new TestSquareInt
            {
                X = x,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization
        /// </summary>
        public static async Task TestNetwork(this Client client)
        {
            var obj = new TestNetwork();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization
        /// </summary>
        /// <param name="server">Proxy server IP address</param>
        /// <param name="port">Proxy server port</param>
        /// <param name="type">Proxy type</param>
        /// <param name="dcId">Identifier of a datacenter, with which to test connection</param>
        /// <param name="timeout">The maximum overall timeout for the request</param>
        public static async Task TestProxy(this Client client, string server = default, int port = 0, ProxyType type = default, int dcId = 0, double timeout = 0.0)
        {
            var obj = new TestProxy
            {
                Server = server,
                Port = port,
                Type = type,
                DcId = dcId,
                Timeout = timeout,
            };
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Forces an updates.getDifference call to the Telegram servers; for testing only
        /// </summary>
        public static async Task TestGetDifference(this Client client)
        {
            var obj = new TestGetDifference();
            _ = await client.InvokeAsync<Ok>(obj);
        }

        /// <summary>
        /// Does nothing and ensures that the Update object is used; for testing only. This is an offline method. Can be called before authorization
        /// </summary>
        public static async Task<Update> TestUseUpdate(this Client client)
        {
            var obj = new TestUseUpdate();
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
        /// </summary>
        /// <param name="error">The error to be returned</param>
        public static async Task<Error> TestReturnError(this Client client, Error error = default)
        {
            var obj = new TestReturnError
            {
                Error = error,
            };
            return await client.InvokeAsync(obj);
        }

        /// <summary>
        /// Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
        /// </summary>
        /// <param name="error">The error to be returned</param>
        /// <remarks>This extension method is synchronous.</remarks>
        public static Error TestReturnErrorSync(this Client client, Error error = default)
        {
            var obj = new TestReturnError
            {
                Error = error,
            };
            return client.Execute(obj);
        }

    }
}
