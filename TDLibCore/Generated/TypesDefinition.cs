// Generated by codegen/gentypes.rb
using System;

namespace TDLibCore.Api
{
    /// <summary>
    /// Provides information about the method by which an authentication code is delivered to the user
    /// </summary>
    public abstract class AuthenticationCodeType : TLObject { }

    /// <summary>
    /// Represents the current authorization state of the TDLib client
    /// </summary>
    public abstract class AuthorizationState : TLObject { }

    /// <summary>
    /// Points to a file
    /// </summary>
    public abstract class InputFile : TLObject { }

    /// <summary>
    /// Describes format of the thumbnail
    /// </summary>
    public abstract class ThumbnailFormat : TLObject { }

    /// <summary>
    /// Part of the face, relative to which a mask is placed
    /// </summary>
    public abstract class MaskPoint : TLObject { }

    /// <summary>
    /// Describes the type of a poll
    /// </summary>
    public abstract class PollType : TLObject { }

    /// <summary>
    /// Represents the type of a user. The following types are possible: regular users, deleted users and bots
    /// </summary>
    public abstract class UserType : TLObject { }

    /// <summary>
    /// Describes a photo to be set as a user profile or chat photo
    /// </summary>
    public abstract class InputChatPhoto : TLObject { }

    /// <summary>
    /// Provides information about the status of a member in a chat
    /// </summary>
    public abstract class ChatMemberStatus : TLObject { }

    /// <summary>
    /// Specifies the kind of chat members to return in searchChatMembers
    /// </summary>
    public abstract class ChatMembersFilter : TLObject { }

    /// <summary>
    /// Specifies the kind of chat members to return in getSupergroupMembers
    /// </summary>
    public abstract class SupergroupMembersFilter : TLObject { }

    /// <summary>
    /// Describes the current secret chat state
    /// </summary>
    public abstract class SecretChatState : TLObject { }

    /// <summary>
    /// Contains information about the sender of a message
    /// </summary>
    public abstract class MessageSender : TLObject { }

    /// <summary>
    /// Contains information about the origin of a forwarded message
    /// </summary>
    public abstract class MessageForwardOrigin : TLObject { }

    /// <summary>
    /// Contains information about the sending state of the message
    /// </summary>
    public abstract class MessageSendingState : TLObject { }

    /// <summary>
    /// Describes the types of chats to which notification settings are relevant
    /// </summary>
    public abstract class NotificationSettingsScope : TLObject { }

    /// <summary>
    /// Describes the type of a chat
    /// </summary>
    public abstract class ChatType : TLObject { }

    /// <summary>
    /// Describes a list of chats
    /// </summary>
    public abstract class ChatList : TLObject { }

    /// <summary>
    /// Describes a reason why an external chat is shown in a chat list
    /// </summary>
    public abstract class ChatSource : TLObject { }

    /// <summary>
    /// Describes a type of public chats
    /// </summary>
    public abstract class PublicChatType : TLObject { }

    /// <summary>
    /// Describes actions which must be possible to do through a chat action bar
    /// </summary>
    public abstract class ChatActionBar : TLObject { }

    /// <summary>
    /// Describes a keyboard button type
    /// </summary>
    public abstract class KeyboardButtonType : TLObject { }

    /// <summary>
    /// Describes the type of an inline keyboard button
    /// </summary>
    public abstract class InlineKeyboardButtonType : TLObject { }

    /// <summary>
    /// Contains a description of a custom keyboard and actions that can be done with it to quickly reply to bots
    /// </summary>
    public abstract class ReplyMarkup : TLObject { }

    /// <summary>
    /// Contains information about an inline button of type inlineKeyboardButtonTypeLoginUrl
    /// </summary>
    public abstract class LoginUrlInfo : TLObject { }

    /// <summary>
    /// Describes a text object inside an instant-view web page
    /// </summary>
    public abstract class RichText : TLObject { }

    /// <summary>
    /// Describes a horizontal alignment of a table cell content
    /// </summary>
    public abstract class PageBlockHorizontalAlignment : TLObject { }

    /// <summary>
    /// Describes a Vertical alignment of a table cell content
    /// </summary>
    public abstract class PageBlockVerticalAlignment : TLObject { }

    /// <summary>
    /// Describes a block of an instant view web page
    /// </summary>
    public abstract class PageBlock : TLObject { }

    /// <summary>
    /// Contains information about the payment method chosen by the user
    /// </summary>
    public abstract class InputCredentials : TLObject { }

    /// <summary>
    /// Contains the type of a Telegram Passport element
    /// </summary>
    public abstract class PassportElementType : TLObject { }

    /// <summary>
    /// Contains information about a Telegram Passport element
    /// </summary>
    public abstract class PassportElement : TLObject { }

    /// <summary>
    /// Contains information about a Telegram Passport element to be saved
    /// </summary>
    public abstract class InputPassportElement : TLObject { }

    /// <summary>
    /// Contains the description of an error in a Telegram Passport element
    /// </summary>
    public abstract class PassportElementErrorSource : TLObject { }

    /// <summary>
    /// Contains the description of an error in a Telegram Passport element; for bots only
    /// </summary>
    public abstract class InputPassportElementErrorSource : TLObject { }

    /// <summary>
    /// Contains the content of a message
    /// </summary>
    public abstract class MessageContent : TLObject { }

    /// <summary>
    /// Represents a part of the text which must be formatted differently
    /// </summary>
    public abstract class TextEntityType : TLObject { }

    /// <summary>
    /// Contains information about the time when a scheduled message will be sent
    /// </summary>
    public abstract class MessageSchedulingState : TLObject { }

    /// <summary>
    /// The content of a message to send
    /// </summary>
    public abstract class InputMessageContent : TLObject { }

    /// <summary>
    /// Represents a filter for message search results
    /// </summary>
    public abstract class SearchMessagesFilter : TLObject { }

    /// <summary>
    /// Describes the different types of activity in a chat
    /// </summary>
    public abstract class ChatAction : TLObject { }

    /// <summary>
    /// Describes the last time the user was online
    /// </summary>
    public abstract class UserStatus : TLObject { }

    /// <summary>
    /// Describes the reason why a call was discarded
    /// </summary>
    public abstract class CallDiscardReason : TLObject { }

    /// <summary>
    /// Describes the type of a call server
    /// </summary>
    public abstract class CallServerType : TLObject { }

    /// <summary>
    /// Describes the current call state
    /// </summary>
    public abstract class CallState : TLObject { }

    /// <summary>
    /// Describes the quality of a group call video
    /// </summary>
    public abstract class GroupCallVideoQuality : TLObject { }

    /// <summary>
    /// Describes the exact type of a problem with a call
    /// </summary>
    public abstract class CallProblem : TLObject { }

    /// <summary>
    /// Contains animated stickers which must be used for dice animation rendering
    /// </summary>
    public abstract class DiceStickers : TLObject { }

    /// <summary>
    /// Represents a single result of an inline query; for bots only
    /// </summary>
    public abstract class InputInlineQueryResult : TLObject { }

    /// <summary>
    /// Represents a single result of an inline query
    /// </summary>
    public abstract class InlineQueryResult : TLObject { }

    /// <summary>
    /// Represents a payload of a callback query
    /// </summary>
    public abstract class CallbackQueryPayload : TLObject { }

    /// <summary>
    /// Represents a chat event
    /// </summary>
    public abstract class ChatEventAction : TLObject { }

    /// <summary>
    /// Represents the value of a string in a language pack
    /// </summary>
    public abstract class LanguagePackStringValue : TLObject { }

    /// <summary>
    /// Represents a data needed to subscribe for push notifications through registerDevice method. To use specific push notification service, the correct application platform must be specified and a valid server authentication data must be uploaded at https://my.telegram.org
    /// </summary>
    public abstract class DeviceToken : TLObject { }

    /// <summary>
    /// Describes a fill of a background
    /// </summary>
    public abstract class BackgroundFill : TLObject { }

    /// <summary>
    /// Describes the type of a background
    /// </summary>
    public abstract class BackgroundType : TLObject { }

    /// <summary>
    /// Contains information about background to set
    /// </summary>
    public abstract class InputBackground : TLObject { }

    /// <summary>
    /// Represents result of checking whether the current session can be used to transfer a chat ownership to another user
    /// </summary>
    public abstract class CanTransferOwnershipResult : TLObject { }

    /// <summary>
    /// Represents result of checking whether a username can be set for a chat
    /// </summary>
    public abstract class CheckChatUsernameResult : TLObject { }

    /// <summary>
    /// Represents result of checking whether a name can be used for a new sticker set
    /// </summary>
    public abstract class CheckStickerSetNameResult : TLObject { }

    /// <summary>
    /// Represents result of 2-step verification password reset
    /// </summary>
    public abstract class ResetPasswordResult : TLObject { }

    /// <summary>
    /// Contains information about a file with messages exported from another app
    /// </summary>
    public abstract class MessageFileType : TLObject { }

    /// <summary>
    /// Contains content of a push message notification
    /// </summary>
    public abstract class PushMessageContent : TLObject { }

    /// <summary>
    /// Contains detailed information about a notification
    /// </summary>
    public abstract class NotificationType : TLObject { }

    /// <summary>
    /// Describes the type of notifications in a notification group
    /// </summary>
    public abstract class NotificationGroupType : TLObject { }

    /// <summary>
    /// Represents the value of an option
    /// </summary>
    public abstract class OptionValue : TLObject { }

    /// <summary>
    /// Represents a JSON value
    /// </summary>
    public abstract class JsonValue : TLObject { }

    /// <summary>
    /// Represents a single rule for managing privacy settings
    /// </summary>
    public abstract class UserPrivacySettingRule : TLObject { }

    /// <summary>
    /// Describes available user privacy settings
    /// </summary>
    public abstract class UserPrivacySetting : TLObject { }

    /// <summary>
    /// Describes the reason why a chat is reported
    /// </summary>
    public abstract class ChatReportReason : TLObject { }

    /// <summary>
    /// Describes an internal https://t.me or tg: link, which must be processed by the app in a special way
    /// </summary>
    public abstract class InternalLinkType : TLObject { }

    /// <summary>
    /// Represents the type of a file
    /// </summary>
    public abstract class FileType : TLObject { }

    /// <summary>
    /// Represents the type of a network
    /// </summary>
    public abstract class NetworkType : TLObject { }

    /// <summary>
    /// Contains statistics about network usage
    /// </summary>
    public abstract class NetworkStatisticsEntry : TLObject { }

    /// <summary>
    /// Describes the current state of the connection to Telegram servers
    /// </summary>
    public abstract class ConnectionState : TLObject { }

    /// <summary>
    /// Represents the categories of chats for which a list of frequently used chats can be retrieved
    /// </summary>
    public abstract class TopChatCategory : TLObject { }

    /// <summary>
    /// Describes the type of a URL linking to an internal Telegram entity
    /// </summary>
    public abstract class TMeUrlType : TLObject { }

    /// <summary>
    /// Describes an action suggested to the current user
    /// </summary>
    public abstract class SuggestedAction : TLObject { }

    /// <summary>
    /// Describes the way the text needs to be parsed for TextEntities
    /// </summary>
    public abstract class TextParseMode : TLObject { }

    /// <summary>
    /// Describes the type of a proxy server
    /// </summary>
    public abstract class ProxyType : TLObject { }

    /// <summary>
    /// Describes a sticker that needs to be added to a sticker set
    /// </summary>
    public abstract class InputSticker : TLObject { }

    /// <summary>
    /// Describes a statistical graph
    /// </summary>
    public abstract class StatisticalGraph : TLObject { }

    /// <summary>
    /// Contains a detailed statistics about a chat
    /// </summary>
    public abstract class ChatStatistics : TLObject { }

    /// <summary>
    /// Represents a vector path command
    /// </summary>
    public abstract class VectorPathCommand : TLObject { }

    /// <summary>
    /// Represents the scope to which bot commands are relevant
    /// </summary>
    public abstract class BotCommandScope : TLObject { }

    /// <summary>
    /// Contains notifications about data changes
    /// </summary>
    public abstract class Update : TLObject { }

    /// <summary>
    /// Describes a stream to which TDLib internal log is written
    /// </summary>
    public abstract class LogStream : TLObject { }

    /// <summary>
    /// An object of this type can be returned on every function call, in case of an error
    /// </summary>
    public partial class Error : TLObject
    {
        /// <summary>
        /// Error code; subject to future changes. If the error code is 406, the error message must not be processed in any way and must not be displayed to the user
        /// </summary>
        public int Code { get; set; }

        /// <summary>
        /// Error message; subject to future changes
        /// </summary>
        public string Message { get; set; }

    }

    /// <summary>
    /// An object of this type is returned on a successful function call for certain functions
    /// </summary>
    public partial class Ok : TLObject
    {
    }

    /// <summary>
    /// Contains parameters for TDLib initialization
    /// </summary>
    public partial class TdlibParameters : TLObject
    {
        /// <summary>
        /// If set to true, the Telegram test environment will be used instead of the production environment
        /// </summary>
        public bool UseTestDc { get; set; }

        /// <summary>
        /// The path to the directory for the persistent database; if empty, the current working directory will be used
        /// </summary>
        public string DatabaseDirectory { get; set; }

        /// <summary>
        /// The path to the directory for storing files; if empty, database_directory will be used
        /// </summary>
        public string FilesDirectory { get; set; }

        /// <summary>
        /// If set to true, information about downloaded and uploaded files will be saved between application restarts
        /// </summary>
        public bool UseFileDatabase { get; set; }

        /// <summary>
        /// If set to true, the library will maintain a cache of users, basic groups, supergroups, channels and secret chats. Implies use_file_database
        /// </summary>
        public bool UseChatInfoDatabase { get; set; }

        /// <summary>
        /// If set to true, the library will maintain a cache of chats and messages. Implies use_chat_info_database
        /// </summary>
        public bool UseMessageDatabase { get; set; }

        /// <summary>
        /// If set to true, support for secret chats will be enabled
        /// </summary>
        public bool UseSecretChats { get; set; }

        /// <summary>
        /// Application identifier for Telegram API access, which can be obtained at https://my.telegram.org
        /// </summary>
        public int ApiId { get; set; }

        /// <summary>
        /// Application identifier hash for Telegram API access, which can be obtained at https://my.telegram.org
        /// </summary>
        public string ApiHash { get; set; }

        /// <summary>
        /// IETF language tag of the user's operating system language; must be non-empty
        /// </summary>
        public string SystemLanguageCode { get; set; }

        /// <summary>
        /// Model of the device the application is being run on; must be non-empty
        /// </summary>
        public string DeviceModel { get; set; }

        /// <summary>
        /// Version of the operating system the application is being run on. If empty, the version is automatically detected by TDLib
        /// </summary>
        public string SystemVersion { get; set; }

        /// <summary>
        /// Application version; must be non-empty
        /// </summary>
        public string ApplicationVersion { get; set; }

        /// <summary>
        /// If set to true, old files will automatically be deleted
        /// </summary>
        public bool EnableStorageOptimizer { get; set; }

        /// <summary>
        /// If set to true, original file names will be ignored. Otherwise, downloaded files will be saved under names as close as possible to the original name
        /// </summary>
        public bool IgnoreFileNames { get; set; }

    }

    /// <summary>
    /// An authentication code is delivered via a private Telegram message, which can be viewed from another active session
    /// </summary>
    public partial class AuthenticationCodeTypeTelegramMessage : AuthenticationCodeType
    {
        /// <summary>
        /// Length of the code
        /// </summary>
        public int Length { get; set; }

    }

    /// <summary>
    /// An authentication code is delivered via an SMS message to the specified phone number
    /// </summary>
    public partial class AuthenticationCodeTypeSms : AuthenticationCodeType
    {
        /// <summary>
        /// Length of the code
        /// </summary>
        public int Length { get; set; }

    }

    /// <summary>
    /// An authentication code is delivered via a phone call to the specified phone number
    /// </summary>
    public partial class AuthenticationCodeTypeCall : AuthenticationCodeType
    {
        /// <summary>
        /// Length of the code
        /// </summary>
        public int Length { get; set; }

    }

    /// <summary>
    /// An authentication code is delivered by an immediately canceled call to the specified phone number. The number from which the call was made is the code
    /// </summary>
    public partial class AuthenticationCodeTypeFlashCall : AuthenticationCodeType
    {
        /// <summary>
        /// Pattern of the phone number from which the call will be made
        /// </summary>
        public string Pattern { get; set; }

    }

    /// <summary>
    /// Information about the authentication code that was sent
    /// </summary>
    public partial class AuthenticationCodeInfo : TLObject
    {
        /// <summary>
        /// A phone number that is being authenticated
        /// </summary>
        public string PhoneNumber { get; set; }

        /// <summary>
        /// The way the code was sent to the user
        /// </summary>
        public AuthenticationCodeType Type { get; set; }

        /// <summary>
        /// The way the next code will be sent to the user; may be null
        /// </summary>
        public AuthenticationCodeType NextType { get; set; }

        /// <summary>
        /// Timeout before the code can be re-sent, in seconds
        /// </summary>
        public int Timeout { get; set; }

    }

    /// <summary>
    /// Information about the email address authentication code that was sent
    /// </summary>
    public partial class EmailAddressAuthenticationCodeInfo : TLObject
    {
        /// <summary>
        /// Pattern of the email address to which an authentication code was sent
        /// </summary>
        public string EmailAddressPattern { get; set; }

        /// <summary>
        /// Length of the code; 0 if unknown
        /// </summary>
        public int Length { get; set; }

    }

    /// <summary>
    /// Represents a part of the text that needs to be formatted in some unusual way
    /// </summary>
    public partial class TextEntity : TLObject
    {
        /// <summary>
        /// Offset of the entity, in UTF-16 code units
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// Length of the entity, in UTF-16 code units
        /// </summary>
        public int Length { get; set; }

        /// <summary>
        /// Type of the entity
        /// </summary>
        public TextEntityType Type { get; set; }

    }

    /// <summary>
    /// Contains a list of text entities
    /// </summary>
    public partial class TextEntities : TLObject
    {
        /// <summary>
        /// List of text entities
        /// </summary>
        public TextEntity[] Entities { get; set; }

    }

    /// <summary>
    /// A text with some entities
    /// </summary>
    public partial class FormattedText : TLObject
    {
        /// <summary>
        /// The text
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Entities contained in the text. Entities can be nested, but must not mutually intersect with each other. -Pre, Code and PreCode entities can't contain other entities. Bold, Italic, Underline and Strikethrough entities can contain and to be contained in all other entities. All other entities can't contain each other
        /// </summary>
        public TextEntity[] Entities { get; set; }

    }

    /// <summary>
    /// Contains Telegram terms of service
    /// </summary>
    public partial class TermsOfService : TLObject
    {
        /// <summary>
        /// Text of the terms of service
        /// </summary>
        public FormattedText Text { get; set; }

        /// <summary>
        /// The minimum age of a user to be able to accept the terms; 0 if any
        /// </summary>
        public int MinUserAge { get; set; }

        /// <summary>
        /// True, if a blocking popup with terms of service must be shown to the user
        /// </summary>
        public bool ShowPopup { get; set; }

    }

    /// <summary>
    /// TDLib needs TdlibParameters for initialization
    /// </summary>
    public partial class AuthorizationStateWaitTdlibParameters : AuthorizationState
    {
    }

    /// <summary>
    /// TDLib needs an encryption key to decrypt the local database
    /// </summary>
    public partial class AuthorizationStateWaitEncryptionKey : AuthorizationState
    {
        /// <summary>
        /// True, if the database is currently encrypted
        /// </summary>
        public bool IsEncrypted { get; set; }

    }

    /// <summary>
    /// TDLib needs the user's phone number to authorize. Call `setAuthenticationPhoneNumber` to provide the phone number, or use `requestQrCodeAuthentication`, or `checkAuthenticationBotToken` for other authentication options
    /// </summary>
    public partial class AuthorizationStateWaitPhoneNumber : AuthorizationState
    {
    }

    /// <summary>
    /// TDLib needs the user's authentication code to authorize
    /// </summary>
    public partial class AuthorizationStateWaitCode : AuthorizationState
    {
        /// <summary>
        /// Information about the authorization code that was sent
        /// </summary>
        public AuthenticationCodeInfo CodeInfo { get; set; }

    }

    /// <summary>
    /// The user needs to confirm authorization on another logged in device by scanning a QR code with the provided link
    /// </summary>
    public partial class AuthorizationStateWaitOtherDeviceConfirmation : AuthorizationState
    {
        /// <summary>
        /// A tg:// URL for the QR code. The link will be updated frequently
        /// </summary>
        public string Link { get; set; }

    }

    /// <summary>
    /// The user is unregistered and need to accept terms of service and enter their first name and last name to finish registration
    /// </summary>
    public partial class AuthorizationStateWaitRegistration : AuthorizationState
    {
        /// <summary>
        /// Telegram terms of service
        /// </summary>
        public TermsOfService TermsOfService { get; set; }

    }

    /// <summary>
    /// The user has been authorized, but needs to enter a password to start using the application
    /// </summary>
    public partial class AuthorizationStateWaitPassword : AuthorizationState
    {
        /// <summary>
        /// Hint for the password; may be empty
        /// </summary>
        public string PasswordHint { get; set; }

        /// <summary>
        /// True, if a recovery email address has been set up
        /// </summary>
        public bool HasRecoveryEmailAddress { get; set; }

        /// <summary>
        /// Pattern of the email address to which the recovery email was sent; empty until a recovery email has been sent
        /// </summary>
        public string RecoveryEmailAddressPattern { get; set; }

    }

    /// <summary>
    /// The user has been successfully authorized. TDLib is now ready to answer queries
    /// </summary>
    public partial class AuthorizationStateReady : AuthorizationState
    {
    }

    /// <summary>
    /// The user is currently logging out
    /// </summary>
    public partial class AuthorizationStateLoggingOut : AuthorizationState
    {
    }

    /// <summary>
    /// TDLib is closing, all subsequent queries will be answered with the error 500. Note that closing TDLib can take a while. All resources will be freed only after authorizationStateClosed has been received
    /// </summary>
    public partial class AuthorizationStateClosing : AuthorizationState
    {
    }

    /// <summary>
    /// TDLib client is in its final state. All databases are closed and all resources are released. No other updates will be received after this. All queries will be responded to -with error code 500. To continue working, one must create a new instance of the TDLib client
    /// </summary>
    public partial class AuthorizationStateClosed : AuthorizationState
    {
    }

    /// <summary>
    /// Represents the current state of 2-step verification
    /// </summary>
    public partial class PasswordState : TLObject
    {
        /// <summary>
        /// True, if a 2-step verification password is set
        /// </summary>
        public bool HasPassword { get; set; }

        /// <summary>
        /// Hint for the password; may be empty
        /// </summary>
        public string PasswordHint { get; set; }

        /// <summary>
        /// True, if a recovery email is set
        /// </summary>
        public bool HasRecoveryEmailAddress { get; set; }

        /// <summary>
        /// True, if some Telegram Passport elements were saved
        /// </summary>
        public bool HasPassportData { get; set; }

        /// <summary>
        /// Information about the recovery email address to which the confirmation email was sent; may be null
        /// </summary>
        public EmailAddressAuthenticationCodeInfo RecoveryEmailAddressCodeInfo { get; set; }

        /// <summary>
        /// If not 0, point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
        /// </summary>
        public int PendingResetDate { get; set; }

    }

    /// <summary>
    /// Contains information about the current recovery email address
    /// </summary>
    public partial class RecoveryEmailAddress : TLObject
    {
        /// <summary>
        /// Recovery email address
        /// </summary>
        public string RecoveryEmailAddress_ { get; set; }

    }

    /// <summary>
    /// Returns information about the availability of a temporary password, which can be used for payments
    /// </summary>
    public partial class TemporaryPasswordState : TLObject
    {
        /// <summary>
        /// True, if a temporary password is available
        /// </summary>
        public bool HasPassword { get; set; }

        /// <summary>
        /// Time left before the temporary password expires, in seconds
        /// </summary>
        public int ValidFor { get; set; }

    }

    /// <summary>
    /// Represents a local file
    /// </summary>
    public partial class LocalFile : TLObject
    {
        /// <summary>
        /// Local path to the locally available file part; may be empty
        /// </summary>
        public string Path { get; set; }

        /// <summary>
        /// True, if it is possible to try to download or generate the file
        /// </summary>
        public bool CanBeDownloaded { get; set; }

        /// <summary>
        /// True, if the file can be deleted
        /// </summary>
        public bool CanBeDeleted { get; set; }

        /// <summary>
        /// True, if the file is currently being downloaded (or a local copy is being generated by some other means)
        /// </summary>
        public bool IsDownloadingActive { get; set; }

        /// <summary>
        /// True, if the local copy is fully available
        /// </summary>
        public bool IsDownloadingCompleted { get; set; }

        /// <summary>
        /// Download will be started from this offset. downloaded_prefix_size is calculated from this offset
        /// </summary>
        public int DownloadOffset { get; set; }

        /// <summary>
        /// If is_downloading_completed is false, then only some prefix of the file starting from download_offset is ready to be read. downloaded_prefix_size is the size of that prefix in bytes
        /// </summary>
        public int DownloadedPrefixSize { get; set; }

        /// <summary>
        /// Total downloaded file size, in bytes. Can be used only for calculating download progress. The actual file size may be bigger, and some parts of it may contain garbage
        /// </summary>
        public int DownloadedSize { get; set; }

    }

    /// <summary>
    /// Represents a remote file
    /// </summary>
    public partial class RemoteFile : TLObject
    {
        /// <summary>
        /// Remote file identifier; may be empty. Can be used by the current user across application restarts or even from other devices. Uniquely identifies a file, but a file can have a lot of different valid identifiers. -If the ID starts with "http://" or "https://", it represents the HTTP URL of the file. TDLib is currently unable to download files if only their URL is known. -If downloadFile is called on such a file or if it is sent to a secret chat, TDLib starts a file generation process by sending updateFileGenerationStart to the application with the HTTP URL in the original_path and "#url#" as the conversion string. Application must generate the file by downloading it to the specified location
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Unique file identifier; may be empty if unknown. The unique file identifier which is the same for the same file even for different users and is persistent over time
        /// </summary>
        public string UniqueId { get; set; }

        /// <summary>
        /// True, if the file is currently being uploaded (or a remote copy is being generated by some other means)
        /// </summary>
        public bool IsUploadingActive { get; set; }

        /// <summary>
        /// True, if a remote copy is fully available
        /// </summary>
        public bool IsUploadingCompleted { get; set; }

        /// <summary>
        /// Size of the remote available part of the file, in bytes; 0 if unknown
        /// </summary>
        public int UploadedSize { get; set; }

    }

    /// <summary>
    /// Represents a file
    /// </summary>
    public partial class File : TLObject
    {
        /// <summary>
        /// Unique file identifier
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// File size, in bytes; 0 if unknown
        /// </summary>
        public int Size { get; set; }

        /// <summary>
        /// Approximate file size in bytes in case the exact file size is unknown. Can be used to show download/upload progress
        /// </summary>
        public int ExpectedSize { get; set; }

        /// <summary>
        /// Information about the local copy of the file
        /// </summary>
        public LocalFile Local { get; set; }

        /// <summary>
        /// Information about the remote copy of the file
        /// </summary>
        public RemoteFile Remote { get; set; }

    }

    /// <summary>
    /// A file defined by its unique ID
    /// </summary>
    public partial class InputFileId : InputFile
    {
        /// <summary>
        /// Unique file identifier
        /// </summary>
        public int Id { get; set; }

    }

    /// <summary>
    /// A file defined by its remote ID. The remote ID is guaranteed to be usable only if the corresponding file is still accessible to the user and known to TDLib. -For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
    /// </summary>
    public partial class InputFileRemote : InputFile
    {
        /// <summary>
        /// Remote file identifier
        /// </summary>
        public string Id { get; set; }

    }

    /// <summary>
    /// A file defined by a local path
    /// </summary>
    public partial class InputFileLocal : InputFile
    {
        /// <summary>
        /// Local path to the file
        /// </summary>
        public string Path { get; set; }

    }

    /// <summary>
    /// A file generated by the application
    /// </summary>
    public partial class InputFileGenerated : InputFile
    {
        /// <summary>
        /// Local path to a file from which the file is generated; may be empty if there is no such file
        /// </summary>
        public string OriginalPath { get; set; }

        /// <summary>
        /// String specifying the conversion applied to the original file; must be persistent across application restarts. Conversions beginning with '#' are reserved for internal TDLib usage
        /// </summary>
        public string Conversion { get; set; }

        /// <summary>
        /// Expected size of the generated file, in bytes; 0 if unknown
        /// </summary>
        public int ExpectedSize { get; set; }

    }

    /// <summary>
    /// Describes an image in JPEG format
    /// </summary>
    public partial class PhotoSize : TLObject
    {
        /// <summary>
        /// Image type (see https://core.telegram.org/constructor/photoSize)
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Information about the image file
        /// </summary>
        public File Photo { get; set; }

        /// <summary>
        /// Image width
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Image height
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// Sizes of progressive JPEG file prefixes, which can be used to preliminarily show the image; in bytes
        /// </summary>
        public int[] ProgressiveSizes { get; set; }

    }

    /// <summary>
    /// Thumbnail image of a very poor quality and low resolution
    /// </summary>
    public partial class Minithumbnail : TLObject
    {
        /// <summary>
        /// Thumbnail width, usually doesn't exceed 40
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Thumbnail height, usually doesn't exceed 40
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// The thumbnail in JPEG format
        /// </summary>
        public Memory<byte> Data { get; set; }

    }

    /// <summary>
    /// The thumbnail is in JPEG format
    /// </summary>
    public partial class ThumbnailFormatJpeg : ThumbnailFormat
    {
    }

    /// <summary>
    /// The thumbnail is in PNG format. It will be used only for background patterns
    /// </summary>
    public partial class ThumbnailFormatPng : ThumbnailFormat
    {
    }

    /// <summary>
    /// The thumbnail is in WEBP format. It will be used only for some stickers
    /// </summary>
    public partial class ThumbnailFormatWebp : ThumbnailFormat
    {
    }

    /// <summary>
    /// The thumbnail is in static GIF format. It will be used only for some bot inline results
    /// </summary>
    public partial class ThumbnailFormatGif : ThumbnailFormat
    {
    }

    /// <summary>
    /// The thumbnail is in TGS format. It will be used only for animated sticker sets
    /// </summary>
    public partial class ThumbnailFormatTgs : ThumbnailFormat
    {
    }

    /// <summary>
    /// The thumbnail is in MPEG4 format. It will be used only for some animations and videos
    /// </summary>
    public partial class ThumbnailFormatMpeg4 : ThumbnailFormat
    {
    }

    /// <summary>
    /// Represents a thumbnail
    /// </summary>
    public partial class Thumbnail : TLObject
    {
        /// <summary>
        /// Thumbnail format
        /// </summary>
        public ThumbnailFormat Format { get; set; }

        /// <summary>
        /// Thumbnail width
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Thumbnail height
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// The thumbnail
        /// </summary>
        public File File { get; set; }

    }

    /// <summary>
    /// The mask is placed relatively to the forehead
    /// </summary>
    public partial class MaskPointForehead : MaskPoint
    {
    }

    /// <summary>
    /// The mask is placed relatively to the eyes
    /// </summary>
    public partial class MaskPointEyes : MaskPoint
    {
    }

    /// <summary>
    /// The mask is placed relatively to the mouth
    /// </summary>
    public partial class MaskPointMouth : MaskPoint
    {
    }

    /// <summary>
    /// The mask is placed relatively to the chin
    /// </summary>
    public partial class MaskPointChin : MaskPoint
    {
    }

    /// <summary>
    /// Position on a photo where a mask is placed
    /// </summary>
    public partial class MaskPosition : TLObject
    {
        /// <summary>
        /// Part of the face, relative to which the mask is placed
        /// </summary>
        public MaskPoint Point { get; set; }

        /// <summary>
        /// Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. (For example, -1.0 will place the mask just to the left of the default mask position)
        /// </summary>
        public double XShift { get; set; }

        /// <summary>
        /// Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. (For example, 1.0 will place the mask just below the default mask position)
        /// </summary>
        public double YShift { get; set; }

        /// <summary>
        /// Mask scaling coefficient. (For example, 2.0 means a doubled size)
        /// </summary>
        public double Scale { get; set; }

    }

    /// <summary>
    /// Describes a color replacement for animated emoji
    /// </summary>
    public partial class ColorReplacement : TLObject
    {
        /// <summary>
        /// Original animated emoji color in the RGB24 format
        /// </summary>
        public int OldColor { get; set; }

        /// <summary>
        /// Replacement animated emoji color in the RGB24 format
        /// </summary>
        public int NewColor { get; set; }

    }

    /// <summary>
    /// Represents a closed vector path. The path begins at the end point of the last command
    /// </summary>
    public partial class ClosedVectorPath : TLObject
    {
        /// <summary>
        /// List of vector path commands
        /// </summary>
        public VectorPathCommand[] Commands { get; set; }

    }

    /// <summary>
    /// Describes one answer option of a poll
    /// </summary>
    public partial class PollOption : TLObject
    {
        /// <summary>
        /// Option text; 1-100 characters
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Number of voters for this option, available only for closed or voted polls
        /// </summary>
        public int VoterCount { get; set; }

        /// <summary>
        /// The percentage of votes for this option; 0-100
        /// </summary>
        public int VotePercentage { get; set; }

        /// <summary>
        /// True, if the option was chosen by the user
        /// </summary>
        public bool IsChosen { get; set; }

        /// <summary>
        /// True, if the option is being chosen by a pending setPollAnswer request
        /// </summary>
        public bool IsBeingChosen { get; set; }

    }

    /// <summary>
    /// A regular poll
    /// </summary>
    public partial class PollTypeRegular : PollType
    {
        /// <summary>
        /// True, if multiple answer options can be chosen simultaneously
        /// </summary>
        public bool AllowMultipleAnswers { get; set; }

    }

    /// <summary>
    /// A poll in quiz mode, which has exactly one correct answer option and can be answered only once
    /// </summary>
    public partial class PollTypeQuiz : PollType
    {
        /// <summary>
        /// 0-based identifier of the correct answer option; -1 for a yet unanswered poll
        /// </summary>
        public int CorrectOptionId { get; set; }

        /// <summary>
        /// Text that is shown when the user chooses an incorrect answer or taps on the lamp icon; 0-200 characters with at most 2 line feeds; empty for a yet unanswered poll
        /// </summary>
        public FormattedText Explanation { get; set; }

    }

    /// <summary>
    /// Describes an animation file. The animation must be encoded in GIF or MPEG4 format
    /// </summary>
    public partial class Animation : TLObject
    {
        /// <summary>
        /// Duration of the animation, in seconds; as defined by the sender
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// Width of the animation
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Height of the animation
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// Original name of the file; as defined by the sender
        /// </summary>
        public string FileName { get; set; }

        /// <summary>
        /// MIME type of the file, usually "image/gif" or "video/mp4"
        /// </summary>
        public string MimeType { get; set; }

        /// <summary>
        /// True, if stickers were added to the animation. The list of corresponding sticker set can be received using getAttachedStickerSets
        /// </summary>
        public bool HasStickers { get; set; }

        /// <summary>
        /// Animation minithumbnail; may be null
        /// </summary>
        public Minithumbnail Minithumbnail { get; set; }

        /// <summary>
        /// Animation thumbnail in JPEG or MPEG4 format; may be null
        /// </summary>
        public Thumbnail Thumbnail { get; set; }

        /// <summary>
        /// File containing the animation
        /// </summary>
        public File Animation_ { get; set; }

    }

    /// <summary>
    /// Describes an audio file. Audio is usually in MP3 or M4A format
    /// </summary>
    public partial class Audio : TLObject
    {
        /// <summary>
        /// Duration of the audio, in seconds; as defined by the sender
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// Title of the audio; as defined by the sender
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Performer of the audio; as defined by the sender
        /// </summary>
        public string Performer { get; set; }

        /// <summary>
        /// Original name of the file; as defined by the sender
        /// </summary>
        public string FileName { get; set; }

        /// <summary>
        /// The MIME type of the file; as defined by the sender
        /// </summary>
        public string MimeType { get; set; }

        /// <summary>
        /// The minithumbnail of the album cover; may be null
        /// </summary>
        public Minithumbnail AlbumCoverMinithumbnail { get; set; }

        /// <summary>
        /// The thumbnail of the album cover in JPEG format; as defined by the sender. The full size thumbnail is supposed to be extracted from the downloaded file; may be null
        /// </summary>
        public Thumbnail AlbumCoverThumbnail { get; set; }

        /// <summary>
        /// File containing the audio
        /// </summary>
        public File Audio_ { get; set; }

    }

    /// <summary>
    /// Describes a document of any type
    /// </summary>
    public partial class Document : TLObject
    {
        /// <summary>
        /// Original name of the file; as defined by the sender
        /// </summary>
        public string FileName { get; set; }

        /// <summary>
        /// MIME type of the file; as defined by the sender
        /// </summary>
        public string MimeType { get; set; }

        /// <summary>
        /// Document minithumbnail; may be null
        /// </summary>
        public Minithumbnail Minithumbnail { get; set; }

        /// <summary>
        /// Document thumbnail in JPEG or PNG format (PNG will be used only for background patterns); as defined by the sender; may be null
        /// </summary>
        public Thumbnail Thumbnail { get; set; }

        /// <summary>
        /// File containing the document
        /// </summary>
        public File Document_ { get; set; }

    }

    /// <summary>
    /// Describes a photo
    /// </summary>
    public partial class Photo : TLObject
    {
        /// <summary>
        /// True, if stickers were added to the photo. The list of corresponding sticker sets can be received using getAttachedStickerSets
        /// </summary>
        public bool HasStickers { get; set; }

        /// <summary>
        /// Photo minithumbnail; may be null
        /// </summary>
        public Minithumbnail Minithumbnail { get; set; }

        /// <summary>
        /// Available variants of the photo, in different sizes
        /// </summary>
        public PhotoSize[] Sizes { get; set; }

    }

    /// <summary>
    /// Describes a sticker
    /// </summary>
    public partial class Sticker : TLObject
    {
        /// <summary>
        /// The identifier of the sticker set to which the sticker belongs; 0 if none
        /// </summary>
        public long SetId { get; set; }

        /// <summary>
        /// Sticker width; as defined by the sender
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Sticker height; as defined by the sender
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// Emoji corresponding to the sticker
        /// </summary>
        public string Emoji { get; set; }

        /// <summary>
        /// True, if the sticker is an animated sticker in TGS format
        /// </summary>
        public bool IsAnimated { get; set; }

        /// <summary>
        /// True, if the sticker is a mask
        /// </summary>
        public bool IsMask { get; set; }

        /// <summary>
        /// Position where the mask is placed; may be null
        /// </summary>
        public MaskPosition MaskPosition { get; set; }

        /// <summary>
        /// Sticker's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
        /// </summary>
        public ClosedVectorPath[] Outline { get; set; }

        /// <summary>
        /// Sticker thumbnail in WEBP or JPEG format; may be null
        /// </summary>
        public Thumbnail Thumbnail { get; set; }

        /// <summary>
        /// File containing the sticker
        /// </summary>
        public File Sticker_ { get; set; }

    }

    /// <summary>
    /// Describes a video file
    /// </summary>
    public partial class Video : TLObject
    {
        /// <summary>
        /// Duration of the video, in seconds; as defined by the sender
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// Video width; as defined by the sender
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Video height; as defined by the sender
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// Original name of the file; as defined by the sender
        /// </summary>
        public string FileName { get; set; }

        /// <summary>
        /// MIME type of the file; as defined by the sender
        /// </summary>
        public string MimeType { get; set; }

        /// <summary>
        /// True, if stickers were added to the video. The list of corresponding sticker sets can be received using getAttachedStickerSets
        /// </summary>
        public bool HasStickers { get; set; }

        /// <summary>
        /// True, if the video is supposed to be streamed
        /// </summary>
        public bool SupportsStreaming { get; set; }

        /// <summary>
        /// Video minithumbnail; may be null
        /// </summary>
        public Minithumbnail Minithumbnail { get; set; }

        /// <summary>
        /// Video thumbnail in JPEG or MPEG4 format; as defined by the sender; may be null
        /// </summary>
        public Thumbnail Thumbnail { get; set; }

        /// <summary>
        /// File containing the video
        /// </summary>
        public File Video_ { get; set; }

    }

    /// <summary>
    /// Describes a video note. The video must be equal in width and height, cropped to a circle, and stored in MPEG4 format
    /// </summary>
    public partial class VideoNote : TLObject
    {
        /// <summary>
        /// Duration of the video, in seconds; as defined by the sender
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// Video width and height; as defined by the sender
        /// </summary>
        public int Length { get; set; }

        /// <summary>
        /// Video minithumbnail; may be null
        /// </summary>
        public Minithumbnail Minithumbnail { get; set; }

        /// <summary>
        /// Video thumbnail in JPEG format; as defined by the sender; may be null
        /// </summary>
        public Thumbnail Thumbnail { get; set; }

        /// <summary>
        /// File containing the video
        /// </summary>
        public File Video { get; set; }

    }

    /// <summary>
    /// Describes a voice note. The voice note must be encoded with the Opus codec, and stored inside an OGG container. Voice notes can have only a single audio channel
    /// </summary>
    public partial class VoiceNote : TLObject
    {
        /// <summary>
        /// Duration of the voice note, in seconds; as defined by the sender
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// A waveform representation of the voice note in 5-bit format
        /// </summary>
        public Memory<byte> Waveform { get; set; }

        /// <summary>
        /// MIME type of the file; as defined by the sender
        /// </summary>
        public string MimeType { get; set; }

        /// <summary>
        /// File containing the voice note
        /// </summary>
        public File Voice { get; set; }

    }

    /// <summary>
    /// Describes an animated representation of an emoji
    /// </summary>
    public partial class AnimatedEmoji : TLObject
    {
        /// <summary>
        /// Animated sticker for the emoji
        /// </summary>
        public Sticker Sticker { get; set; }

        /// <summary>
        /// List of colors to be replaced while the sticker is rendered
        /// </summary>
        public ColorReplacement[] ColorReplacements { get; set; }

        /// <summary>
        /// File containing the sound to be played when the animated emoji is clicked if any; may be null. The sound is encoded with the Opus codec, and stored inside an OGG container
        /// </summary>
        public File Sound { get; set; }

    }

    /// <summary>
    /// Describes a user contact
    /// </summary>
    public partial class Contact : TLObject
    {
        /// <summary>
        /// Phone number of the user
        /// </summary>
        public string PhoneNumber { get; set; }

        /// <summary>
        /// First name of the user; 1-255 characters in length
        /// </summary>
        public string FirstName { get; set; }

        /// <summary>
        /// Last name of the user
        /// </summary>
        public string LastName { get; set; }

        /// <summary>
        /// Additional data about the user in a form of vCard; 0-2048 bytes in length
        /// </summary>
        public string Vcard { get; set; }

        /// <summary>
        /// Identifier of the user, if known; otherwise 0
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// Describes a location on planet Earth
    /// </summary>
    public partial class Location : TLObject
    {
        /// <summary>
        /// Latitude of the location in degrees; as defined by the sender
        /// </summary>
        public double Latitude { get; set; }

        /// <summary>
        /// Longitude of the location, in degrees; as defined by the sender
        /// </summary>
        public double Longitude { get; set; }

        /// <summary>
        /// The estimated horizontal accuracy of the location, in meters; as defined by the sender. 0 if unknown
        /// </summary>
        public double HorizontalAccuracy { get; set; }

    }

    /// <summary>
    /// Describes a venue
    /// </summary>
    public partial class Venue : TLObject
    {
        /// <summary>
        /// Venue location; as defined by the sender
        /// </summary>
        public Location Location { get; set; }

        /// <summary>
        /// Venue name; as defined by the sender
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Venue address; as defined by the sender
        /// </summary>
        public string Address { get; set; }

        /// <summary>
        /// Provider of the venue database; as defined by the sender. Currently only "foursquare" and "gplaces" (Google Places) need to be supported
        /// </summary>
        public string Provider { get; set; }

        /// <summary>
        /// Identifier of the venue in the provider database; as defined by the sender
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Type of the venue in the provider database; as defined by the sender
        /// </summary>
        public string Type { get; set; }

    }

    /// <summary>
    /// Describes a game
    /// </summary>
    public partial class Game : TLObject
    {
        /// <summary>
        /// Game ID
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Game short name. To share a game use the URL https://t.me/{bot_username}?game={game_short_name}
        /// </summary>
        public string ShortName { get; set; }

        /// <summary>
        /// Game title
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Game text, usually containing scoreboards for a game
        /// </summary>
        public FormattedText Text { get; set; }

        /// <summary>
        /// Describes a game
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Game photo
        /// </summary>
        public Photo Photo { get; set; }

        /// <summary>
        /// Game animation; may be null
        /// </summary>
        public Animation Animation { get; set; }

    }

    /// <summary>
    /// Describes a poll
    /// </summary>
    public partial class Poll : TLObject
    {
        /// <summary>
        /// Unique poll identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Poll question; 1-300 characters
        /// </summary>
        public string Question { get; set; }

        /// <summary>
        /// List of poll answer options
        /// </summary>
        public PollOption[] Options { get; set; }

        /// <summary>
        /// Total number of voters, participating in the poll
        /// </summary>
        public int TotalVoterCount { get; set; }

        /// <summary>
        /// User identifiers of recent voters, if the poll is non-anonymous
        /// </summary>
        public long[] RecentVoterUserIds { get; set; }

        /// <summary>
        /// True, if the poll is anonymous
        /// </summary>
        public bool IsAnonymous { get; set; }

        /// <summary>
        /// Type of the poll
        /// </summary>
        public PollType Type { get; set; }

        /// <summary>
        /// Amount of time the poll will be active after creation, in seconds
        /// </summary>
        public int OpenPeriod { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the poll will be automatically closed
        /// </summary>
        public int CloseDate { get; set; }

        /// <summary>
        /// True, if the poll is closed
        /// </summary>
        public bool IsClosed { get; set; }

    }

    /// <summary>
    /// Describes a user profile photo
    /// </summary>
    public partial class ProfilePhoto : TLObject
    {
        /// <summary>
        /// Photo identifier; 0 for an empty photo. Can be used to find a photo in a list of user profile photos
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// A small (160x160) user profile photo. The file can be downloaded only before the photo is changed
        /// </summary>
        public File Small { get; set; }

        /// <summary>
        /// A big (640x640) user profile photo. The file can be downloaded only before the photo is changed
        /// </summary>
        public File Big { get; set; }

        /// <summary>
        /// User profile photo minithumbnail; may be null
        /// </summary>
        public Minithumbnail Minithumbnail { get; set; }

        /// <summary>
        /// True, if the photo has animated variant
        /// </summary>
        public bool HasAnimation { get; set; }

    }

    /// <summary>
    /// Contains basic information about the photo of a chat
    /// </summary>
    public partial class ChatPhotoInfo : TLObject
    {
        /// <summary>
        /// A small (160x160) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
        /// </summary>
        public File Small { get; set; }

        /// <summary>
        /// A big (640x640) chat photo variant in JPEG format. The file can be downloaded only before the photo is changed
        /// </summary>
        public File Big { get; set; }

        /// <summary>
        /// Chat photo minithumbnail; may be null
        /// </summary>
        public Minithumbnail Minithumbnail { get; set; }

        /// <summary>
        /// True, if the photo has animated variant
        /// </summary>
        public bool HasAnimation { get; set; }

    }

    /// <summary>
    /// A regular user
    /// </summary>
    public partial class UserTypeRegular : UserType
    {
    }

    /// <summary>
    /// A deleted user or deleted bot. No information on the user besides the user identifier is available. It is not possible to perform any active actions on this type of user
    /// </summary>
    public partial class UserTypeDeleted : UserType
    {
    }

    /// <summary>
    /// A bot (see https://core.telegram.org/bots)
    /// </summary>
    public partial class UserTypeBot : UserType
    {
        /// <summary>
        /// True, if the bot can be invited to basic group and supergroup chats
        /// </summary>
        public bool CanJoinGroups { get; set; }

        /// <summary>
        /// True, if the bot can read all messages in basic group or supergroup chats and not just those addressed to the bot. In private and channel chats a bot can always read all messages
        /// </summary>
        public bool CanReadAllGroupMessages { get; set; }

        /// <summary>
        /// True, if the bot supports inline queries
        /// </summary>
        public bool IsInline { get; set; }

        /// <summary>
        /// Placeholder for inline queries (displayed on the application input field)
        /// </summary>
        public string InlineQueryPlaceholder { get; set; }

        /// <summary>
        /// True, if the location of the user is expected to be sent with every inline query to this bot
        /// </summary>
        public bool NeedLocation { get; set; }

    }

    /// <summary>
    /// No information on the user besides the user identifier is available, yet this user has not been deleted. This object is extremely rare and must be handled like a deleted user. It is not possible to perform any actions on users of this type
    /// </summary>
    public partial class UserTypeUnknown : UserType
    {
    }

    /// <summary>
    /// Represents a command supported by a bot
    /// </summary>
    public partial class BotCommand : TLObject
    {
        /// <summary>
        /// Text of the bot command
        /// </summary>
        public string Command { get; set; }

        /// <summary>
        /// Represents a command supported by a bot
        /// </summary>
        public string Description { get; set; }

    }

    /// <summary>
    /// Contains a list of bot commands
    /// </summary>
    public partial class BotCommands : TLObject
    {
        /// <summary>
        /// Bot's user identifier
        /// </summary>
        public long BotUserId { get; set; }

        /// <summary>
        /// List of bot commands
        /// </summary>
        public BotCommand[] Commands { get; set; }

    }

    /// <summary>
    /// Represents a location to which a chat is connected
    /// </summary>
    public partial class ChatLocation : TLObject
    {
        /// <summary>
        /// The location
        /// </summary>
        public Location Location { get; set; }

        /// <summary>
        /// Location address; 1-64 characters, as defined by the chat owner
        /// </summary>
        public string Address { get; set; }

    }

    /// <summary>
    /// Animated variant of a chat photo in MPEG4 format
    /// </summary>
    public partial class AnimatedChatPhoto : TLObject
    {
        /// <summary>
        /// Animation width and height
        /// </summary>
        public int Length { get; set; }

        /// <summary>
        /// Information about the animation file
        /// </summary>
        public File File { get; set; }

        /// <summary>
        /// Timestamp of the frame, used as a static chat photo
        /// </summary>
        public double MainFrameTimestamp { get; set; }

    }

    /// <summary>
    /// Describes a chat or user profile photo
    /// </summary>
    public partial class ChatPhoto : TLObject
    {
        /// <summary>
        /// Unique photo identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the photo has been added
        /// </summary>
        public int AddedDate { get; set; }

        /// <summary>
        /// Photo minithumbnail; may be null
        /// </summary>
        public Minithumbnail Minithumbnail { get; set; }

        /// <summary>
        /// Available variants of the photo in JPEG format, in different size
        /// </summary>
        public PhotoSize[] Sizes { get; set; }

        /// <summary>
        /// Animated variant of the photo in MPEG4 format; may be null
        /// </summary>
        public AnimatedChatPhoto Animation { get; set; }

    }

    /// <summary>
    /// Contains a list of chat or user profile photos
    /// </summary>
    public partial class ChatPhotos : TLObject
    {
        /// <summary>
        /// Total number of photos
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// List of photos
        /// </summary>
        public ChatPhoto[] Photos { get; set; }

    }

    /// <summary>
    /// A previously used profile photo of the current user
    /// </summary>
    public partial class InputChatPhotoPrevious : InputChatPhoto
    {
        /// <summary>
        /// Identifier of the current user's profile photo to reuse
        /// </summary>
        public long ChatPhotoId { get; set; }

    }

    /// <summary>
    /// A static photo in JPEG format
    /// </summary>
    public partial class InputChatPhotoStatic : InputChatPhoto
    {
        /// <summary>
        /// Photo to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
        /// </summary>
        public InputFile Photo { get; set; }

    }

    /// <summary>
    /// An animation in MPEG4 format; must be square, at most 10 seconds long, have width between 160 and 800 and be at most 2MB in size
    /// </summary>
    public partial class InputChatPhotoAnimation : InputChatPhoto
    {
        /// <summary>
        /// Animation to be set as profile photo. Only inputFileLocal and inputFileGenerated are allowed
        /// </summary>
        public InputFile Animation { get; set; }

        /// <summary>
        /// Timestamp of the frame, which will be used as static chat photo
        /// </summary>
        public double MainFrameTimestamp { get; set; }

    }

    /// <summary>
    /// Represents a user
    /// </summary>
    public partial class User : TLObject
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// First name of the user
        /// </summary>
        public string FirstName { get; set; }

        /// <summary>
        /// Last name of the user
        /// </summary>
        public string LastName { get; set; }

        /// <summary>
        /// Username of the user
        /// </summary>
        public string Username { get; set; }

        /// <summary>
        /// Phone number of the user
        /// </summary>
        public string PhoneNumber { get; set; }

        /// <summary>
        /// Current online status of the user
        /// </summary>
        public UserStatus Status { get; set; }

        /// <summary>
        /// Profile photo of the user; may be null
        /// </summary>
        public ProfilePhoto ProfilePhoto { get; set; }

        /// <summary>
        /// The user is a contact of the current user
        /// </summary>
        public bool IsContact { get; set; }

        /// <summary>
        /// The user is a contact of the current user and the current user is a contact of the user
        /// </summary>
        public bool IsMutualContact { get; set; }

        /// <summary>
        /// True, if the user is verified
        /// </summary>
        public bool IsVerified { get; set; }

        /// <summary>
        /// True, if the user is Telegram support account
        /// </summary>
        public bool IsSupport { get; set; }

        /// <summary>
        /// If non-empty, it contains a human-readable description of the reason why access to this user must be restricted
        /// </summary>
        public string RestrictionReason { get; set; }

        /// <summary>
        /// True, if many users reported this user as a scam
        /// </summary>
        public bool IsScam { get; set; }

        /// <summary>
        /// True, if many users reported this user as a fake account
        /// </summary>
        public bool IsFake { get; set; }

        /// <summary>
        /// If false, the user is inaccessible, and the only information known about the user is inside this class. It can't be passed to any method except GetUser
        /// </summary>
        public bool HaveAccess { get; set; }

        /// <summary>
        /// Type of the user
        /// </summary>
        public UserType Type { get; set; }

        /// <summary>
        /// IETF language tag of the user's language; only available to bots
        /// </summary>
        public string LanguageCode { get; set; }

    }

    /// <summary>
    /// Contains full information about a user
    /// </summary>
    public partial class UserFullInfo : TLObject
    {
        /// <summary>
        /// User profile photo; may be null
        /// </summary>
        public ChatPhoto Photo { get; set; }

        /// <summary>
        /// True, if the user is blocked by the current user
        /// </summary>
        public bool IsBlocked { get; set; }

        /// <summary>
        /// True, if the user can be called
        /// </summary>
        public bool CanBeCalled { get; set; }

        /// <summary>
        /// True, if a video call can be created with the user
        /// </summary>
        public bool SupportsVideoCalls { get; set; }

        /// <summary>
        /// True, if the user can't be called due to their privacy settings
        /// </summary>
        public bool HasPrivateCalls { get; set; }

        /// <summary>
        /// True, if the current user needs to explicitly allow to share their phone number with the user when the method addContact is used
        /// </summary>
        public bool NeedPhoneNumberPrivacyException { get; set; }

        /// <summary>
        /// A short user bio
        /// </summary>
        public string Bio { get; set; }

        /// <summary>
        /// For bots, the text that is shown on the bot's profile page and is sent together with the link when users share the bot
        /// </summary>
        public string ShareText { get; set; }

        /// <summary>
        /// Contains full information about a user
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Number of group chats where both the other user and the current user are a member; 0 for the current user
        /// </summary>
        public int GroupInCommonCount { get; set; }

        /// <summary>
        /// For bots, list of the bot commands
        /// </summary>
        public BotCommand[] Commands { get; set; }

    }

    /// <summary>
    /// Represents a list of users
    /// </summary>
    public partial class Users : TLObject
    {
        /// <summary>
        /// Approximate total count of users found
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// A list of user identifiers
        /// </summary>
        public long[] UserIds { get; set; }

    }

    /// <summary>
    /// Contains information about a chat administrator
    /// </summary>
    public partial class ChatAdministrator : TLObject
    {
        /// <summary>
        /// User identifier of the administrator
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Custom title of the administrator
        /// </summary>
        public string CustomTitle { get; set; }

        /// <summary>
        /// True, if the user is the owner of the chat
        /// </summary>
        public bool IsOwner { get; set; }

    }

    /// <summary>
    /// Represents a list of chat administrators
    /// </summary>
    public partial class ChatAdministrators : TLObject
    {
        /// <summary>
        /// A list of chat administrators
        /// </summary>
        public ChatAdministrator[] Administrators { get; set; }

    }

    /// <summary>
    /// Describes actions that a user is allowed to take in a chat
    /// </summary>
    public partial class ChatPermissions : TLObject
    {
        /// <summary>
        /// True, if the user can send text messages, contacts, locations, and venues
        /// </summary>
        public bool CanSendMessages { get; set; }

        /// <summary>
        /// True, if the user can send audio files, documents, photos, videos, video notes, and voice notes. Implies can_send_messages permissions
        /// </summary>
        public bool CanSendMediaMessages { get; set; }

        /// <summary>
        /// True, if the user can send polls. Implies can_send_messages permissions
        /// </summary>
        public bool CanSendPolls { get; set; }

        /// <summary>
        /// True, if the user can send animations, games, stickers, and dice and use inline bots. Implies can_send_messages permissions
        /// </summary>
        public bool CanSendOtherMessages { get; set; }

        /// <summary>
        /// True, if the user may add a web page preview to their messages. Implies can_send_messages permissions
        /// </summary>
        public bool CanAddWebPagePreviews { get; set; }

        /// <summary>
        /// True, if the user can change the chat title, photo, and other settings
        /// </summary>
        public bool CanChangeInfo { get; set; }

        /// <summary>
        /// True, if the user can invite new users to the chat
        /// </summary>
        public bool CanInviteUsers { get; set; }

        /// <summary>
        /// True, if the user can pin messages
        /// </summary>
        public bool CanPinMessages { get; set; }

    }

    /// <summary>
    /// The user is the owner of the chat and has all the administrator privileges
    /// </summary>
    public partial class ChatMemberStatusCreator : ChatMemberStatus
    {
        /// <summary>
        /// A custom title of the owner; 0-16 characters without emojis; applicable to supergroups only
        /// </summary>
        public string CustomTitle { get; set; }

        /// <summary>
        /// True, if the creator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
        /// </summary>
        public bool IsAnonymous { get; set; }

        /// <summary>
        /// True, if the user is a member of the chat
        /// </summary>
        public bool IsMember { get; set; }

    }

    /// <summary>
    /// The user is a member of the chat and has some additional privileges. In basic groups, administrators can edit and delete messages sent by others, add new members, ban unprivileged members, and manage video chats. In supergroups and channels, there are more detailed options for administrator privileges
    /// </summary>
    public partial class ChatMemberStatusAdministrator : ChatMemberStatus
    {
        /// <summary>
        /// A custom title of the administrator; 0-16 characters without emojis; applicable to supergroups only
        /// </summary>
        public string CustomTitle { get; set; }

        /// <summary>
        /// True, if the current user can edit the administrator privileges for the called user
        /// </summary>
        public bool CanBeEdited { get; set; }

        /// <summary>
        /// True, if the administrator can get chat event log, get chat statistics, get message statistics in channels, get channel members, see anonymous administrators in supergroups and ignore slow mode. Implied by any other privilege; applicable to supergroups and channels only
        /// </summary>
        public bool CanManageChat { get; set; }

        /// <summary>
        /// True, if the administrator can change the chat title, photo, and other settings
        /// </summary>
        public bool CanChangeInfo { get; set; }

        /// <summary>
        /// True, if the administrator can create channel posts; applicable to channels only
        /// </summary>
        public bool CanPostMessages { get; set; }

        /// <summary>
        /// True, if the administrator can edit messages of other users and pin messages; applicable to channels only
        /// </summary>
        public bool CanEditMessages { get; set; }

        /// <summary>
        /// True, if the administrator can delete messages of other users
        /// </summary>
        public bool CanDeleteMessages { get; set; }

        /// <summary>
        /// True, if the administrator can invite new users to the chat
        /// </summary>
        public bool CanInviteUsers { get; set; }

        /// <summary>
        /// True, if the administrator can restrict, ban, or unban chat members; always true for channels
        /// </summary>
        public bool CanRestrictMembers { get; set; }

        /// <summary>
        /// True, if the administrator can pin messages; applicable to basic groups and supergroups only
        /// </summary>
        public bool CanPinMessages { get; set; }

        /// <summary>
        /// True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that were directly or indirectly promoted by them
        /// </summary>
        public bool CanPromoteMembers { get; set; }

        /// <summary>
        /// True, if the administrator can manage video chats
        /// </summary>
        public bool CanManageVideoChats { get; set; }

        /// <summary>
        /// True, if the administrator isn't shown in the chat member list and sends messages anonymously; applicable to supergroups only
        /// </summary>
        public bool IsAnonymous { get; set; }

    }

    /// <summary>
    /// The user is a member of the chat, without any additional privileges or restrictions
    /// </summary>
    public partial class ChatMemberStatusMember : ChatMemberStatus
    {
    }

    /// <summary>
    /// The user is under certain restrictions in the chat. Not supported in basic groups and channels
    /// </summary>
    public partial class ChatMemberStatusRestricted : ChatMemberStatus
    {
        /// <summary>
        /// True, if the user is a member of the chat
        /// </summary>
        public bool IsMember { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when restrictions will be lifted from the user; 0 if never. If the user is restricted for more than 366 days or for less than 30 seconds from the current time, the user is considered to be restricted forever
        /// </summary>
        public int RestrictedUntilDate { get; set; }

        /// <summary>
        /// User permissions in the chat
        /// </summary>
        public ChatPermissions Permissions { get; set; }

    }

    /// <summary>
    /// The user or the chat is not a chat member
    /// </summary>
    public partial class ChatMemberStatusLeft : ChatMemberStatus
    {
    }

    /// <summary>
    /// The user or the chat was banned (and hence is not a member of the chat). Implies the user can't return to the chat, view messages, or be used as a participant identifier to join a video chat of the chat
    /// </summary>
    public partial class ChatMemberStatusBanned : ChatMemberStatus
    {
        /// <summary>
        /// Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Always 0 in basic groups
        /// </summary>
        public int BannedUntilDate { get; set; }

    }

    /// <summary>
    /// Describes a user or a chat as a member of another chat
    /// </summary>
    public partial class ChatMember : TLObject
    {
        /// <summary>
        /// Identifier of the chat member. Currently, other chats can be only Left or Banned. Only supergroups and channels can have other chats as Left or Banned members and these chats must be supergroups or channels
        /// </summary>
        public MessageSender MemberId { get; set; }

        /// <summary>
        /// Identifier of a user that invited/promoted/banned this member in the chat; 0 if unknown
        /// </summary>
        public long InviterUserId { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the user joined the chat
        /// </summary>
        public int JoinedChatDate { get; set; }

        /// <summary>
        /// Status of the member in the chat
        /// </summary>
        public ChatMemberStatus Status { get; set; }

    }

    /// <summary>
    /// Contains a list of chat members
    /// </summary>
    public partial class ChatMembers : TLObject
    {
        /// <summary>
        /// Approximate total count of chat members found
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// A list of chat members
        /// </summary>
        public ChatMember[] Members { get; set; }

    }

    /// <summary>
    /// Returns contacts of the user
    /// </summary>
    public partial class ChatMembersFilterContacts : ChatMembersFilter
    {
    }

    /// <summary>
    /// Returns the owner and administrators
    /// </summary>
    public partial class ChatMembersFilterAdministrators : ChatMembersFilter
    {
    }

    /// <summary>
    /// Returns all chat members, including restricted chat members
    /// </summary>
    public partial class ChatMembersFilterMembers : ChatMembersFilter
    {
    }

    /// <summary>
    /// Returns users which can be mentioned in the chat
    /// </summary>
    public partial class ChatMembersFilterMention : ChatMembersFilter
    {
        /// <summary>
        /// If non-zero, the identifier of the current message thread
        /// </summary>
        public long MessageThreadId { get; set; }

    }

    /// <summary>
    /// Returns users under certain restrictions in the chat; can be used only by administrators in a supergroup
    /// </summary>
    public partial class ChatMembersFilterRestricted : ChatMembersFilter
    {
    }

    /// <summary>
    /// Returns users banned from the chat; can be used only by administrators in a supergroup or in a channel
    /// </summary>
    public partial class ChatMembersFilterBanned : ChatMembersFilter
    {
    }

    /// <summary>
    /// Returns bot members of the chat
    /// </summary>
    public partial class ChatMembersFilterBots : ChatMembersFilter
    {
    }

    /// <summary>
    /// Returns recently active users in reverse chronological order
    /// </summary>
    public partial class SupergroupMembersFilterRecent : SupergroupMembersFilter
    {
    }

    /// <summary>
    /// Returns contacts of the user, which are members of the supergroup or channel
    /// </summary>
    public partial class SupergroupMembersFilterContacts : SupergroupMembersFilter
    {
        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

    }

    /// <summary>
    /// Returns the owner and administrators
    /// </summary>
    public partial class SupergroupMembersFilterAdministrators : SupergroupMembersFilter
    {
    }

    /// <summary>
    /// Used to search for supergroup or channel members via a (string) query
    /// </summary>
    public partial class SupergroupMembersFilterSearch : SupergroupMembersFilter
    {
        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

    }

    /// <summary>
    /// Returns restricted supergroup members; can be used only by administrators
    /// </summary>
    public partial class SupergroupMembersFilterRestricted : SupergroupMembersFilter
    {
        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

    }

    /// <summary>
    /// Returns users banned from the supergroup or channel; can be used only by administrators
    /// </summary>
    public partial class SupergroupMembersFilterBanned : SupergroupMembersFilter
    {
        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

    }

    /// <summary>
    /// Returns users which can be mentioned in the supergroup
    /// </summary>
    public partial class SupergroupMembersFilterMention : SupergroupMembersFilter
    {
        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// If non-zero, the identifier of the current message thread
        /// </summary>
        public long MessageThreadId { get; set; }

    }

    /// <summary>
    /// Returns bot members of the supergroup or channel
    /// </summary>
    public partial class SupergroupMembersFilterBots : SupergroupMembersFilter
    {
    }

    /// <summary>
    /// Contains a chat invite link
    /// </summary>
    public partial class ChatInviteLink : TLObject
    {
        /// <summary>
        /// Chat invite link
        /// </summary>
        public string InviteLink { get; set; }

        /// <summary>
        /// Name of the link
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// User identifier of an administrator created the link
        /// </summary>
        public long CreatorUserId { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the link was created
        /// </summary>
        public int Date { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the link was last edited; 0 if never or unknown
        /// </summary>
        public int EditDate { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the link will expire; 0 if never
        /// </summary>
        public int ExpireDate { get; set; }

        /// <summary>
        /// The maximum number of members, which can join the chat using the link simultaneously; 0 if not limited. Always 0 if the link requires approval
        /// </summary>
        public int MemberLimit { get; set; }

        /// <summary>
        /// Number of chat members, which joined the chat using the link
        /// </summary>
        public int MemberCount { get; set; }

        /// <summary>
        /// Number of pending join requests created using this link
        /// </summary>
        public int PendingJoinRequestCount { get; set; }

        /// <summary>
        /// True, if the link only creates join request. If true, total number of joining members will be unlimited
        /// </summary>
        public bool CreatesJoinRequest { get; set; }

        /// <summary>
        /// True, if the link is primary. Primary invite link can't have name, expire date or usage limit. There is exactly one primary invite link for each administrator with can_invite_users right at a given time
        /// </summary>
        public bool IsPrimary { get; set; }

        /// <summary>
        /// True, if the link was revoked
        /// </summary>
        public bool IsRevoked { get; set; }

    }

    /// <summary>
    /// Contains a list of chat invite links
    /// </summary>
    public partial class ChatInviteLinks : TLObject
    {
        /// <summary>
        /// Approximate total count of chat invite links found
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// List of invite links
        /// </summary>
        public ChatInviteLink[] InviteLinks { get; set; }

    }

    /// <summary>
    /// Describes a chat administrator with a number of active and revoked chat invite links
    /// </summary>
    public partial class ChatInviteLinkCount : TLObject
    {
        /// <summary>
        /// Administrator's user identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Number of active invite links
        /// </summary>
        public int InviteLinkCount { get; set; }

        /// <summary>
        /// Number of revoked invite links
        /// </summary>
        public int RevokedInviteLinkCount { get; set; }

    }

    /// <summary>
    /// Contains a list of chat invite link counts
    /// </summary>
    public partial class ChatInviteLinkCounts : TLObject
    {
        /// <summary>
        /// List of invite link counts
        /// </summary>
        public ChatInviteLinkCount[] InviteLinkCounts { get; set; }

    }

    /// <summary>
    /// Describes a chat member joined a chat by an invite link
    /// </summary>
    public partial class ChatInviteLinkMember : TLObject
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the user joined the chat
        /// </summary>
        public int JoinedChatDate { get; set; }

        /// <summary>
        /// User identifier of the chat administrator, approved user join request
        /// </summary>
        public long ApproverUserId { get; set; }

    }

    /// <summary>
    /// Contains a list of chat members joined a chat by an invite link
    /// </summary>
    public partial class ChatInviteLinkMembers : TLObject
    {
        /// <summary>
        /// Approximate total count of chat members found
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// List of chat members, joined a chat by an invite link
        /// </summary>
        public ChatInviteLinkMember[] Members { get; set; }

    }

    /// <summary>
    /// Contains information about a chat invite link
    /// </summary>
    public partial class ChatInviteLinkInfo : TLObject
    {
        /// <summary>
        /// Chat identifier of the invite link; 0 if the user has no access to the chat before joining
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// If non-zero, the amount of time for which read access to the chat will remain available, in seconds
        /// </summary>
        public int AccessibleFor { get; set; }

        /// <summary>
        /// Type of the chat
        /// </summary>
        public ChatType Type { get; set; }

        /// <summary>
        /// Title of the chat
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Chat photo; may be null
        /// </summary>
        public ChatPhotoInfo Photo { get; set; }

        /// <summary>
        /// Contains information about a chat invite link
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Number of members in the chat
        /// </summary>
        public int MemberCount { get; set; }

        /// <summary>
        /// User identifiers of some chat members that may be known to the current user
        /// </summary>
        public long[] MemberUserIds { get; set; }

        /// <summary>
        /// True, if the link only creates join request
        /// </summary>
        public bool CreatesJoinRequest { get; set; }

        /// <summary>
        /// True, if the chat is a public supergroup or channel, i.e. it has a username or it is a location-based supergroup
        /// </summary>
        public bool IsPublic { get; set; }

    }

    /// <summary>
    /// Describes a user that sent a join request and waits for administrator approval
    /// </summary>
    public partial class ChatJoinRequest : TLObject
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the user sent the join request
        /// </summary>
        public int Date { get; set; }

        /// <summary>
        /// A short bio of the user
        /// </summary>
        public string Bio { get; set; }

    }

    /// <summary>
    /// Contains a list of chat join requests
    /// </summary>
    public partial class ChatJoinRequests : TLObject
    {
        /// <summary>
        /// Approximate total count of requests found
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// List of the requests
        /// </summary>
        public ChatJoinRequest[] Requests { get; set; }

    }

    /// <summary>
    /// Contains information about pending chat join requests
    /// </summary>
    public partial class ChatJoinRequestsInfo : TLObject
    {
        /// <summary>
        /// Total number of pending join requests
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// Identifiers of users sent the newest pending join requests
        /// </summary>
        public long[] UserIds { get; set; }

    }

    /// <summary>
    /// Represents a basic group of 0-200 users (must be upgraded to a supergroup to accommodate more than 200 users)
    /// </summary>
    public partial class BasicGroup : TLObject
    {
        /// <summary>
        /// Group identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Number of members in the group
        /// </summary>
        public int MemberCount { get; set; }

        /// <summary>
        /// Status of the current user in the group
        /// </summary>
        public ChatMemberStatus Status { get; set; }

        /// <summary>
        /// True, if the group is active
        /// </summary>
        public bool IsActive { get; set; }

        /// <summary>
        /// Identifier of the supergroup to which this group was upgraded; 0 if none
        /// </summary>
        public long UpgradedToSupergroupId { get; set; }

    }

    /// <summary>
    /// Contains full information about a basic group
    /// </summary>
    public partial class BasicGroupFullInfo : TLObject
    {
        /// <summary>
        /// Chat photo; may be null
        /// </summary>
        public ChatPhoto Photo { get; set; }

        /// <summary>
        /// Contains full information about a basic group
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// User identifier of the creator of the group; 0 if unknown
        /// </summary>
        public long CreatorUserId { get; set; }

        /// <summary>
        /// Group members
        /// </summary>
        public ChatMember[] Members { get; set; }

        /// <summary>
        /// Primary invite link for this group; may be null. For chat administrators with can_invite_users right only. Updated only after the basic group is opened
        /// </summary>
        public ChatInviteLink InviteLink { get; set; }

        /// <summary>
        /// List of commands of bots in the group
        /// </summary>
        public BotCommands[] BotCommands { get; set; }

    }

    /// <summary>
    /// Represents a supergroup or channel with zero or more members (subscribers in the case of channels). From the point of view of the system, a channel is a special kind of a supergroup: only administrators can post and see the list of members, and posts from all administrators use the name and photo of the channel instead of individual names and profile photos. Unlike supergroups, channels can have an unlimited number of subscribers
    /// </summary>
    public partial class Supergroup : TLObject
    {
        /// <summary>
        /// Supergroup or channel identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Username of the supergroup or channel; empty for private supergroups or channels
        /// </summary>
        public string Username { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the current user joined, or the point in time when the supergroup or channel was created, in case the user is not a member
        /// </summary>
        public int Date { get; set; }

        /// <summary>
        /// Status of the current user in the supergroup or channel; custom title will be always empty
        /// </summary>
        public ChatMemberStatus Status { get; set; }

        /// <summary>
        /// Number of members in the supergroup or channel; 0 if unknown. Currently it is guaranteed to be known only if the supergroup or channel was received through searchPublicChats, searchChatsNearby, getInactiveSupergroupChats, getSuitableDiscussionChats, getGroupsInCommon, or getUserPrivacySettingRules
        /// </summary>
        public int MemberCount { get; set; }

        /// <summary>
        /// True, if the channel has a discussion group, or the supergroup is the designated discussion group for a channel
        /// </summary>
        public bool HasLinkedChat { get; set; }

        /// <summary>
        /// True, if the supergroup is connected to a location, i.e. the supergroup is a location-based supergroup
        /// </summary>
        public bool HasLocation { get; set; }

        /// <summary>
        /// True, if messages sent to the channel need to contain information about the sender. This field is only applicable to channels
        /// </summary>
        public bool SignMessages { get; set; }

        /// <summary>
        /// True, if the slow mode is enabled in the supergroup
        /// </summary>
        public bool IsSlowModeEnabled { get; set; }

        /// <summary>
        /// True, if the supergroup is a channel
        /// </summary>
        public bool IsChannel { get; set; }

        /// <summary>
        /// True, if the supergroup is a broadcast group, i.e. only administrators can send messages and there is no limit on number of members
        /// </summary>
        public bool IsBroadcastGroup { get; set; }

        /// <summary>
        /// True, if the supergroup or channel is verified
        /// </summary>
        public bool IsVerified { get; set; }

        /// <summary>
        /// If non-empty, contains a human-readable description of the reason why access to this supergroup or channel must be restricted
        /// </summary>
        public string RestrictionReason { get; set; }

        /// <summary>
        /// True, if many users reported this supergroup or channel as a scam
        /// </summary>
        public bool IsScam { get; set; }

        /// <summary>
        /// True, if many users reported this supergroup or channel as a fake account
        /// </summary>
        public bool IsFake { get; set; }

    }

    /// <summary>
    /// Contains full information about a supergroup or channel
    /// </summary>
    public partial class SupergroupFullInfo : TLObject
    {
        /// <summary>
        /// Chat photo; may be null
        /// </summary>
        public ChatPhoto Photo { get; set; }

        /// <summary>
        /// Contains full information about a supergroup or channel
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Number of members in the supergroup or channel; 0 if unknown
        /// </summary>
        public int MemberCount { get; set; }

        /// <summary>
        /// Number of privileged users in the supergroup or channel; 0 if unknown
        /// </summary>
        public int AdministratorCount { get; set; }

        /// <summary>
        /// Number of restricted users in the supergroup; 0 if unknown
        /// </summary>
        public int RestrictedCount { get; set; }

        /// <summary>
        /// Number of users banned from chat; 0 if unknown
        /// </summary>
        public int BannedCount { get; set; }

        /// <summary>
        /// Chat identifier of a discussion group for the channel, or a channel, for which the supergroup is the designated discussion group; 0 if none or unknown
        /// </summary>
        public long LinkedChatId { get; set; }

        /// <summary>
        /// Delay between consecutive sent messages for non-administrator supergroup members, in seconds
        /// </summary>
        public int SlowModeDelay { get; set; }

        /// <summary>
        /// Time left before next message can be sent in the supergroup, in seconds. An updateSupergroupFullInfo update is not triggered when value of this field changes, but both new and old values are non-zero
        /// </summary>
        public double SlowModeDelayExpiresIn { get; set; }

        /// <summary>
        /// True, if members of the chat can be retrieved
        /// </summary>
        public bool CanGetMembers { get; set; }

        /// <summary>
        /// True, if the chat username can be changed
        /// </summary>
        public bool CanSetUsername { get; set; }

        /// <summary>
        /// True, if the supergroup sticker set can be changed
        /// </summary>
        public bool CanSetStickerSet { get; set; }

        /// <summary>
        /// True, if the supergroup location can be changed
        /// </summary>
        public bool CanSetLocation { get; set; }

        /// <summary>
        /// True, if the supergroup or channel statistics are available
        /// </summary>
        public bool CanGetStatistics { get; set; }

        /// <summary>
        /// True, if new chat members will have access to old messages. In public or discussion groups and both public and private channels, old messages are always available, so this option affects only private supergroups without a linked chat. The value of this field is only available for chat administrators
        /// </summary>
        public bool IsAllHistoryAvailable { get; set; }

        /// <summary>
        /// Identifier of the supergroup sticker set; 0 if none
        /// </summary>
        public long StickerSetId { get; set; }

        /// <summary>
        /// Location to which the supergroup is connected; may be null
        /// </summary>
        public ChatLocation Location { get; set; }

        /// <summary>
        /// Primary invite link for this chat; may be null. For chat administrators with can_invite_users right only
        /// </summary>
        public ChatInviteLink InviteLink { get; set; }

        /// <summary>
        /// List of commands of bots in the group
        /// </summary>
        public BotCommands[] BotCommands { get; set; }

        /// <summary>
        /// Identifier of the basic group from which supergroup was upgraded; 0 if none
        /// </summary>
        public long UpgradedFromBasicGroupId { get; set; }

        /// <summary>
        /// Identifier of the last message in the basic group from which supergroup was upgraded; 0 if none
        /// </summary>
        public long UpgradedFromMaxMessageId { get; set; }

    }

    /// <summary>
    /// The secret chat is not yet created; waiting for the other user to get online
    /// </summary>
    public partial class SecretChatStatePending : SecretChatState
    {
    }

    /// <summary>
    /// The secret chat is ready to use
    /// </summary>
    public partial class SecretChatStateReady : SecretChatState
    {
    }

    /// <summary>
    /// The secret chat is closed
    /// </summary>
    public partial class SecretChatStateClosed : SecretChatState
    {
    }

    /// <summary>
    /// Represents a secret chat
    /// </summary>
    public partial class SecretChat : TLObject
    {
        /// <summary>
        /// Secret chat identifier
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Identifier of the chat partner
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// State of the secret chat
        /// </summary>
        public SecretChatState State { get; set; }

        /// <summary>
        /// True, if the chat was created by the current user; otherwise false
        /// </summary>
        public bool IsOutbound { get; set; }

        /// <summary>
        /// Hash of the currently used key for comparison with the hash of the chat partner's key. This is a string of 36 little-endian bytes, which must be split into groups of 2 bits, each denoting a pixel of one of 4 colors FFFFFF, D5E6F3, 2D5775, and 2F99C9. -The pixels must be used to make a 12x12 square image filled from left to right, top to bottom. Alternatively, the first 32 bytes of the hash can be converted to the hexadecimal format and printed as 32 2-digit hex numbers
        /// </summary>
        public Memory<byte> KeyHash { get; set; }

        /// <summary>
        /// Secret chat layer; determines features supported by the chat partner's application. Nested text entities and underline and strikethrough entities are supported if the layer &gt;= 101
        /// </summary>
        public int Layer { get; set; }

    }

    /// <summary>
    /// The message was sent by a known user
    /// </summary>
    public partial class MessageSenderUser : MessageSender
    {
        /// <summary>
        /// Identifier of the user that sent the message
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// The message was sent on behalf of a chat
    /// </summary>
    public partial class MessageSenderChat : MessageSender
    {
        /// <summary>
        /// Identifier of the chat that sent the message
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Represents a list of message senders
    /// </summary>
    public partial class MessageSenders : TLObject
    {
        /// <summary>
        /// Approximate total count of messages senders found
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// List of message senders
        /// </summary>
        public MessageSender[] Senders { get; set; }

    }

    /// <summary>
    /// The message was originally sent by a known user
    /// </summary>
    public partial class MessageForwardOriginUser : MessageForwardOrigin
    {
        /// <summary>
        /// Identifier of the user that originally sent the message
        /// </summary>
        public long SenderUserId { get; set; }

    }

    /// <summary>
    /// The message was originally sent by an anonymous chat administrator on behalf of the chat
    /// </summary>
    public partial class MessageForwardOriginChat : MessageForwardOrigin
    {
        /// <summary>
        /// Identifier of the chat that originally sent the message
        /// </summary>
        public long SenderChatId { get; set; }

        /// <summary>
        /// Original message author signature
        /// </summary>
        public string AuthorSignature { get; set; }

    }

    /// <summary>
    /// The message was originally sent by a user, which is hidden by their privacy settings
    /// </summary>
    public partial class MessageForwardOriginHiddenUser : MessageForwardOrigin
    {
        /// <summary>
        /// Name of the sender
        /// </summary>
        public string SenderName { get; set; }

    }

    /// <summary>
    /// The message was originally a post in a channel
    /// </summary>
    public partial class MessageForwardOriginChannel : MessageForwardOrigin
    {
        /// <summary>
        /// Identifier of the chat from which the message was originally forwarded
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier of the original message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Original post author signature
        /// </summary>
        public string AuthorSignature { get; set; }

    }

    /// <summary>
    /// The message was imported from an exported message history
    /// </summary>
    public partial class MessageForwardOriginMessageImport : MessageForwardOrigin
    {
        /// <summary>
        /// Name of the sender
        /// </summary>
        public string SenderName { get; set; }

    }

    /// <summary>
    /// Contains information about a forwarded message
    /// </summary>
    public partial class MessageForwardInfo : TLObject
    {
        /// <summary>
        /// Origin of a forwarded message
        /// </summary>
        public MessageForwardOrigin Origin { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the message was originally sent
        /// </summary>
        public int Date { get; set; }

        /// <summary>
        /// The type of a public service announcement for the forwarded message
        /// </summary>
        public string PublicServiceAnnouncementType { get; set; }

        /// <summary>
        /// For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the chat from which the message was forwarded last time; 0 if unknown
        /// </summary>
        public long FromChatId { get; set; }

        /// <summary>
        /// For messages forwarded to the chat with the current user (Saved Messages), to the Replies bot chat, or to the channel's discussion group, the identifier of the original message from which the new message was forwarded last time; 0 if unknown
        /// </summary>
        public long FromMessageId { get; set; }

    }

    /// <summary>
    /// Contains information about replies to a message
    /// </summary>
    public partial class MessageReplyInfo : TLObject
    {
        /// <summary>
        /// Number of times the message was directly or indirectly replied
        /// </summary>
        public int ReplyCount { get; set; }

        /// <summary>
        /// Recent repliers to the message; available in channels with a discussion supergroup
        /// </summary>
        public MessageSender[] RecentRepliers { get; set; }

        /// <summary>
        /// Identifier of the last read incoming reply to the message
        /// </summary>
        public long LastReadInboxMessageId { get; set; }

        /// <summary>
        /// Identifier of the last read outgoing reply to the message
        /// </summary>
        public long LastReadOutboxMessageId { get; set; }

        /// <summary>
        /// Identifier of the last reply to the message
        /// </summary>
        public long LastMessageId { get; set; }

    }

    /// <summary>
    /// Contains information about interactions with a message
    /// </summary>
    public partial class MessageInteractionInfo : TLObject
    {
        /// <summary>
        /// Number of times the message was viewed
        /// </summary>
        public int ViewCount { get; set; }

        /// <summary>
        /// Number of times the message was forwarded
        /// </summary>
        public int ForwardCount { get; set; }

        /// <summary>
        /// Information about direct or indirect replies to the message; may be null. Currently, available only in channels with a discussion supergroup and discussion supergroups for messages, which are not replies itself
        /// </summary>
        public MessageReplyInfo ReplyInfo { get; set; }

    }

    /// <summary>
    /// The message is being sent now, but has not yet been delivered to the server
    /// </summary>
    public partial class MessageSendingStatePending : MessageSendingState
    {
    }

    /// <summary>
    /// The message failed to be sent
    /// </summary>
    public partial class MessageSendingStateFailed : MessageSendingState
    {
        /// <summary>
        /// An error code; 0 if unknown
        /// </summary>
        public int ErrorCode { get; set; }

        /// <summary>
        /// Error message
        /// </summary>
        public string ErrorMessage { get; set; }

        /// <summary>
        /// True, if the message can be re-sent
        /// </summary>
        public bool CanRetry { get; set; }

        /// <summary>
        /// Time left before the message can be re-sent, in seconds. No update is sent when this field changes
        /// </summary>
        public double RetryAfter { get; set; }

    }

    /// <summary>
    /// Describes a message
    /// </summary>
    public partial class Message : TLObject
    {
        /// <summary>
        /// Message identifier; unique for the chat to which the message belongs
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// The sender of the message
        /// </summary>
        public MessageSender Sender { get; set; }

        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The sending state of the message; may be null
        /// </summary>
        public MessageSendingState SendingState { get; set; }

        /// <summary>
        /// The scheduling state of the message; may be null
        /// </summary>
        public MessageSchedulingState SchedulingState { get; set; }

        /// <summary>
        /// True, if the message is outgoing
        /// </summary>
        public bool IsOutgoing { get; set; }

        /// <summary>
        /// True, if the message is pinned
        /// </summary>
        public bool IsPinned { get; set; }

        /// <summary>
        /// True, if the message can be edited. For live location and poll messages this fields shows whether editMessageLiveLocation or stopPoll can be used with this message by the application
        /// </summary>
        public bool CanBeEdited { get; set; }

        /// <summary>
        /// True, if the message can be forwarded
        /// </summary>
        public bool CanBeForwarded { get; set; }

        /// <summary>
        /// True, if the message can be deleted only for the current user while other users will continue to see it
        /// </summary>
        public bool CanBeDeletedOnlyForSelf { get; set; }

        /// <summary>
        /// True, if the message can be deleted for all users
        /// </summary>
        public bool CanBeDeletedForAllUsers { get; set; }

        /// <summary>
        /// True, if the message statistics are available
        /// </summary>
        public bool CanGetStatistics { get; set; }

        /// <summary>
        /// True, if the message thread info is available
        /// </summary>
        public bool CanGetMessageThread { get; set; }

        /// <summary>
        /// True, if chat members already viewed the message can be received through getMessageViewers
        /// </summary>
        public bool CanGetViewers { get; set; }

        /// <summary>
        /// True, if media timestamp links can be generated for media timestamp entities in the message text, caption or web page description
        /// </summary>
        public bool CanGetMediaTimestampLinks { get; set; }

        /// <summary>
        /// True, if media timestamp entities refers to a media in this message as opposed to a media in the replied message
        /// </summary>
        public bool HasTimestampedMedia { get; set; }

        /// <summary>
        /// True, if the message is a channel post. All messages to channels are channel posts, all other messages are not channel posts
        /// </summary>
        public bool IsChannelPost { get; set; }

        /// <summary>
        /// True, if the message contains an unread mention for the current user
        /// </summary>
        public bool ContainsUnreadMention { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the message was sent
        /// </summary>
        public int Date { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the message was last edited
        /// </summary>
        public int EditDate { get; set; }

        /// <summary>
        /// Information about the initial message sender; may be null
        /// </summary>
        public MessageForwardInfo ForwardInfo { get; set; }

        /// <summary>
        /// Information about interactions with the message; may be null
        /// </summary>
        public MessageInteractionInfo InteractionInfo { get; set; }

        /// <summary>
        /// If non-zero, the identifier of the chat to which the replied message belongs; Currently, only messages in the Replies chat can have different reply_in_chat_id and chat_id
        /// </summary>
        public long ReplyInChatId { get; set; }

        /// <summary>
        /// If non-zero, the identifier of the message this message is replying to; can be the identifier of a deleted message
        /// </summary>
        public long ReplyToMessageId { get; set; }

        /// <summary>
        /// If non-zero, the identifier of the message thread the message belongs to; unique within the chat to which the message belongs
        /// </summary>
        public long MessageThreadId { get; set; }

        /// <summary>
        /// For self-destructing messages, the message's TTL (Time To Live), in seconds; 0 if none. TDLib will send updateDeleteMessages or updateMessageContent once the TTL expires
        /// </summary>
        public int Ttl { get; set; }

        /// <summary>
        /// Time left before the message expires, in seconds. If the TTL timer isn't started yet, equals to the value of the ttl field
        /// </summary>
        public double TtlExpiresIn { get; set; }

        /// <summary>
        /// If non-zero, the user identifier of the bot through which this message was sent
        /// </summary>
        public long ViaBotUserId { get; set; }

        /// <summary>
        /// For channel posts and anonymous group messages, optional author signature
        /// </summary>
        public string AuthorSignature { get; set; }

        /// <summary>
        /// Unique identifier of an album this message belongs to. Only audios, documents, photos and videos can be grouped together in albums
        /// </summary>
        public long MediaAlbumId { get; set; }

        /// <summary>
        /// If non-empty, contains a human-readable description of the reason why access to this message must be restricted
        /// </summary>
        public string RestrictionReason { get; set; }

        /// <summary>
        /// Content of the message
        /// </summary>
        public MessageContent Content { get; set; }

        /// <summary>
        /// Reply markup for the message; may be null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

    }

    /// <summary>
    /// Contains a list of messages
    /// </summary>
    public partial class Messages : TLObject
    {
        /// <summary>
        /// Approximate total count of messages found
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// List of messages; messages may be null
        /// </summary>
        public Message[] Messages_ { get; set; }

    }

    /// <summary>
    /// Contains a list of messages found by a search
    /// </summary>
    public partial class FoundMessages : TLObject
    {
        /// <summary>
        /// Approximate total count of messages found; -1 if unknown
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// List of messages
        /// </summary>
        public Message[] Messages { get; set; }

        /// <summary>
        /// The offset for the next request. If empty, there are no more results
        /// </summary>
        public string NextOffset { get; set; }

    }

    /// <summary>
    /// Contains information about a message in a specific position
    /// </summary>
    public partial class MessagePosition : TLObject
    {
        /// <summary>
        /// 0-based message position in the full list of suitable messages
        /// </summary>
        public int Position { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the message was sent
        /// </summary>
        public int Date { get; set; }

    }

    /// <summary>
    /// Contains a list of message positions
    /// </summary>
    public partial class MessagePositions : TLObject
    {
        /// <summary>
        /// Total count of messages found
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// List of message positions
        /// </summary>
        public MessagePosition[] Positions { get; set; }

    }

    /// <summary>
    /// Contains information about found messages sent in a specific day
    /// </summary>
    public partial class MessageCalendarDay : TLObject
    {
        /// <summary>
        /// Total number of found messages sent in the day
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// First message sent in the day
        /// </summary>
        public Message Message { get; set; }

    }

    /// <summary>
    /// Contains information about found messages, splitted by days according to the option "utc_time_offset"
    /// </summary>
    public partial class MessageCalendar : TLObject
    {
        /// <summary>
        /// Total number of found messages
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// Information about messages sent
        /// </summary>
        public MessageCalendarDay[] Days { get; set; }

    }

    /// <summary>
    /// Describes a sponsored message
    /// </summary>
    public partial class SponsoredMessage : TLObject
    {
        /// <summary>
        /// Unique sponsored message identifier
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Chat identifier
        /// </summary>
        public long SponsorChatId { get; set; }

        /// <summary>
        /// An internal link to be opened when the sponsored message is clicked; may be null. If null, the sponsor chat needs to be opened instead
        /// </summary>
        public InternalLinkType Link { get; set; }

        /// <summary>
        /// Content of the message
        /// </summary>
        public MessageContent Content { get; set; }

    }

    /// <summary>
    /// Contains a list of sponsored messages
    /// </summary>
    public partial class SponsoredMessages : TLObject
    {
        /// <summary>
        /// List of sponsored messages
        /// </summary>
        public SponsoredMessage[] Messages { get; set; }

    }

    /// <summary>
    /// Notification settings applied to all private and secret chats when the corresponding chat setting has a default value
    /// </summary>
    public partial class NotificationSettingsScopePrivateChats : NotificationSettingsScope
    {
    }

    /// <summary>
    /// Notification settings applied to all basic groups and supergroups when the corresponding chat setting has a default value
    /// </summary>
    public partial class NotificationSettingsScopeGroupChats : NotificationSettingsScope
    {
    }

    /// <summary>
    /// Notification settings applied to all channels when the corresponding chat setting has a default value
    /// </summary>
    public partial class NotificationSettingsScopeChannelChats : NotificationSettingsScope
    {
    }

    /// <summary>
    /// Contains information about notification settings for a chat
    /// </summary>
    public partial class ChatNotificationSettings : TLObject
    {
        /// <summary>
        /// If true, mute_for is ignored and the value for the relevant type of chat is used instead
        /// </summary>
        public bool UseDefaultMuteFor { get; set; }

        /// <summary>
        /// Time left before notifications will be unmuted, in seconds
        /// </summary>
        public int MuteFor { get; set; }

        /// <summary>
        /// If true, sound is ignored and the value for the relevant type of chat is used instead
        /// </summary>
        public bool UseDefaultSound { get; set; }

        /// <summary>
        /// The name of an audio file to be used for notification sounds; only applies to iOS applications
        /// </summary>
        public string Sound { get; set; }

        /// <summary>
        /// If true, show_preview is ignored and the value for the relevant type of chat is used instead
        /// </summary>
        public bool UseDefaultShowPreview { get; set; }

        /// <summary>
        /// True, if message content must be displayed in notifications
        /// </summary>
        public bool ShowPreview { get; set; }

        /// <summary>
        /// If true, disable_pinned_message_notifications is ignored and the value for the relevant type of chat is used instead
        /// </summary>
        public bool UseDefaultDisablePinnedMessageNotifications { get; set; }

        /// <summary>
        /// If true, notifications for incoming pinned messages will be created as for an ordinary unread message
        /// </summary>
        public bool DisablePinnedMessageNotifications { get; set; }

        /// <summary>
        /// If true, disable_mention_notifications is ignored and the value for the relevant type of chat is used instead
        /// </summary>
        public bool UseDefaultDisableMentionNotifications { get; set; }

        /// <summary>
        /// If true, notifications for messages with mentions will be created as for an ordinary unread message
        /// </summary>
        public bool DisableMentionNotifications { get; set; }

    }

    /// <summary>
    /// Contains information about notification settings for several chats
    /// </summary>
    public partial class ScopeNotificationSettings : TLObject
    {
        /// <summary>
        /// Time left before notifications will be unmuted, in seconds
        /// </summary>
        public int MuteFor { get; set; }

        /// <summary>
        /// The name of an audio file to be used for notification sounds; only applies to iOS applications
        /// </summary>
        public string Sound { get; set; }

        /// <summary>
        /// True, if message content must be displayed in notifications
        /// </summary>
        public bool ShowPreview { get; set; }

        /// <summary>
        /// True, if notifications for incoming pinned messages will be created as for an ordinary unread message
        /// </summary>
        public bool DisablePinnedMessageNotifications { get; set; }

        /// <summary>
        /// True, if notifications for messages with mentions will be created as for an ordinary unread message
        /// </summary>
        public bool DisableMentionNotifications { get; set; }

    }

    /// <summary>
    /// Contains information about a message draft
    /// </summary>
    public partial class DraftMessage : TLObject
    {
        /// <summary>
        /// Identifier of the message to reply to; 0 if none
        /// </summary>
        public long ReplyToMessageId { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the draft was created
        /// </summary>
        public int Date { get; set; }

        /// <summary>
        /// Content of the message draft; must be of the type inputMessageText
        /// </summary>
        public InputMessageContent InputMessageText { get; set; }

    }

    /// <summary>
    /// An ordinary chat with a user
    /// </summary>
    public partial class ChatTypePrivate : ChatType
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// A basic group (a chat with 0-200 other users)
    /// </summary>
    public partial class ChatTypeBasicGroup : ChatType
    {
        /// <summary>
        /// Basic group identifier
        /// </summary>
        public long BasicGroupId { get; set; }

    }

    /// <summary>
    /// A supergroup or channel (with unlimited members)
    /// </summary>
    public partial class ChatTypeSupergroup : ChatType
    {
        /// <summary>
        /// Supergroup or channel identifier
        /// </summary>
        public long SupergroupId { get; set; }

        /// <summary>
        /// True, if the supergroup is a channel
        /// </summary>
        public bool IsChannel { get; set; }

    }

    /// <summary>
    /// A secret chat with a user
    /// </summary>
    public partial class ChatTypeSecret : ChatType
    {
        /// <summary>
        /// Secret chat identifier
        /// </summary>
        public int SecretChatId { get; set; }

        /// <summary>
        /// User identifier of the secret chat peer
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// Represents a filter of user chats
    /// </summary>
    public partial class ChatFilter : TLObject
    {
        /// <summary>
        /// The title of the filter; 1-12 characters without line feeds
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// The icon name for short filter representation. If non-empty, must be one of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work". -If empty, use getChatFilterDefaultIconName to get default icon name for the filter
        /// </summary>
        public string IconName { get; set; }

        /// <summary>
        /// The chat identifiers of pinned chats in the filtered chat list
        /// </summary>
        public long[] PinnedChatIds { get; set; }

        /// <summary>
        /// The chat identifiers of always included chats in the filtered chat list
        /// </summary>
        public long[] IncludedChatIds { get; set; }

        /// <summary>
        /// The chat identifiers of always excluded chats in the filtered chat list
        /// </summary>
        public long[] ExcludedChatIds { get; set; }

        /// <summary>
        /// True, if muted chats need to be excluded
        /// </summary>
        public bool ExcludeMuted { get; set; }

        /// <summary>
        /// True, if read chats need to be excluded
        /// </summary>
        public bool ExcludeRead { get; set; }

        /// <summary>
        /// True, if archived chats need to be excluded
        /// </summary>
        public bool ExcludeArchived { get; set; }

        /// <summary>
        /// True, if contacts need to be included
        /// </summary>
        public bool IncludeContacts { get; set; }

        /// <summary>
        /// True, if non-contact users need to be included
        /// </summary>
        public bool IncludeNonContacts { get; set; }

        /// <summary>
        /// True, if bots need to be included
        /// </summary>
        public bool IncludeBots { get; set; }

        /// <summary>
        /// True, if basic groups and supergroups need to be included
        /// </summary>
        public bool IncludeGroups { get; set; }

        /// <summary>
        /// True, if channels need to be included
        /// </summary>
        public bool IncludeChannels { get; set; }

    }

    /// <summary>
    /// Contains basic information about a chat filter
    /// </summary>
    public partial class ChatFilterInfo : TLObject
    {
        /// <summary>
        /// Unique chat filter identifier
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// The title of the filter; 1-12 characters without line feeds
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// The icon name for short filter representation. One of "All", "Unread", "Unmuted", "Bots", "Channels", "Groups", "Private", "Custom", "Setup", "Cat", "Crown", "Favorite", "Flower", "Game", "Home", "Love", "Mask", "Party", "Sport", "Study", "Trade", "Travel", "Work"
        /// </summary>
        public string IconName { get; set; }

    }

    /// <summary>
    /// Describes a recommended chat filter
    /// </summary>
    public partial class RecommendedChatFilter : TLObject
    {
        /// <summary>
        /// The chat filter
        /// </summary>
        public ChatFilter Filter { get; set; }

        /// <summary>
        /// Describes a recommended chat filter
        /// </summary>
        public string Description { get; set; }

    }

    /// <summary>
    /// Contains a list of recommended chat filters
    /// </summary>
    public partial class RecommendedChatFilters : TLObject
    {
        /// <summary>
        /// List of recommended chat filters
        /// </summary>
        public RecommendedChatFilter[] ChatFilters { get; set; }

    }

    /// <summary>
    /// A main list of chats
    /// </summary>
    public partial class ChatListMain : ChatList
    {
    }

    /// <summary>
    /// A list of chats usually located at the top of the main chat list. Unmuted chats are automatically moved from the Archive to the Main chat list when a new message arrives
    /// </summary>
    public partial class ChatListArchive : ChatList
    {
    }

    /// <summary>
    /// A list of chats belonging to a chat filter
    /// </summary>
    public partial class ChatListFilter : ChatList
    {
        /// <summary>
        /// Chat filter identifier
        /// </summary>
        public int ChatFilterId { get; set; }

    }

    /// <summary>
    /// Contains a list of chat lists
    /// </summary>
    public partial class ChatLists : TLObject
    {
        /// <summary>
        /// List of chat lists
        /// </summary>
        public ChatList[] ChatLists_ { get; set; }

    }

    /// <summary>
    /// The chat is sponsored by the user's MTProxy server
    /// </summary>
    public partial class ChatSourceMtprotoProxy : ChatSource
    {
    }

    /// <summary>
    /// The chat contains a public service announcement
    /// </summary>
    public partial class ChatSourcePublicServiceAnnouncement : ChatSource
    {
        /// <summary>
        /// The type of the announcement
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// The text of the announcement
        /// </summary>
        public string Text { get; set; }

    }

    /// <summary>
    /// Describes a position of a chat in a chat list
    /// </summary>
    public partial class ChatPosition : TLObject
    {
        /// <summary>
        /// The chat list
        /// </summary>
        public ChatList List { get; set; }

        /// <summary>
        /// A parameter used to determine order of the chat in the chat list. Chats must be sorted by the pair (order, chat.id) in descending order
        /// </summary>
        public long Order { get; set; }

        /// <summary>
        /// True, if the chat is pinned in the chat list
        /// </summary>
        public bool IsPinned { get; set; }

        /// <summary>
        /// Source of the chat in the chat list; may be null
        /// </summary>
        public ChatSource Source { get; set; }

    }

    /// <summary>
    /// Describes a video chat
    /// </summary>
    public partial class VideoChat : TLObject
    {
        /// <summary>
        /// Group call identifier of an active video chat; 0 if none. Full information about the video chat can be received through the method getGroupCall
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// True, if the video chat has participants
        /// </summary>
        public bool HasParticipants { get; set; }

        /// <summary>
        /// Default group call participant identifier to join the video chat; may be null
        /// </summary>
        public MessageSender DefaultParticipantId { get; set; }

    }

    /// <summary>
    /// A chat. (Can be a private chat, basic group, supergroup, or secret chat)
    /// </summary>
    public partial class Chat : TLObject
    {
        /// <summary>
        /// Chat unique identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Type of the chat
        /// </summary>
        public ChatType Type { get; set; }

        /// <summary>
        /// Chat title
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Chat photo; may be null
        /// </summary>
        public ChatPhotoInfo Photo { get; set; }

        /// <summary>
        /// Actions that non-administrator chat members are allowed to take in the chat
        /// </summary>
        public ChatPermissions Permissions { get; set; }

        /// <summary>
        /// Last message in the chat; may be null
        /// </summary>
        public Message LastMessage { get; set; }

        /// <summary>
        /// Positions of the chat in chat lists
        /// </summary>
        public ChatPosition[] Positions { get; set; }

        /// <summary>
        /// True, if the chat is marked as unread
        /// </summary>
        public bool IsMarkedAsUnread { get; set; }

        /// <summary>
        /// True, if the chat is blocked by the current user and private messages from the chat can't be received
        /// </summary>
        public bool IsBlocked { get; set; }

        /// <summary>
        /// True, if the chat has scheduled messages
        /// </summary>
        public bool HasScheduledMessages { get; set; }

        /// <summary>
        /// True, if the chat messages can be deleted only for the current user while other users will continue to see the messages
        /// </summary>
        public bool CanBeDeletedOnlyForSelf { get; set; }

        /// <summary>
        /// True, if the chat messages can be deleted for all users
        /// </summary>
        public bool CanBeDeletedForAllUsers { get; set; }

        /// <summary>
        /// True, if the chat can be reported to Telegram moderators through reportChat or reportChatPhoto
        /// </summary>
        public bool CanBeReported { get; set; }

        /// <summary>
        /// Default value of the disable_notification parameter, used when a message is sent to the chat
        /// </summary>
        public bool DefaultDisableNotification { get; set; }

        /// <summary>
        /// Number of unread messages in the chat
        /// </summary>
        public int UnreadCount { get; set; }

        /// <summary>
        /// Identifier of the last read incoming message
        /// </summary>
        public long LastReadInboxMessageId { get; set; }

        /// <summary>
        /// Identifier of the last read outgoing message
        /// </summary>
        public long LastReadOutboxMessageId { get; set; }

        /// <summary>
        /// Number of unread messages with a mention/reply in the chat
        /// </summary>
        public int UnreadMentionCount { get; set; }

        /// <summary>
        /// Notification settings for this chat
        /// </summary>
        public ChatNotificationSettings NotificationSettings { get; set; }

        /// <summary>
        /// Current message Time To Live setting (self-destruct timer) for the chat; 0 if not defined. TTL is counted from the time message or its content is viewed in secret chats and from the send date in other chats
        /// </summary>
        public int MessageTtlSetting { get; set; }

        /// <summary>
        /// If non-empty, name of a theme, set for the chat
        /// </summary>
        public string ThemeName { get; set; }

        /// <summary>
        /// Information about actions which must be possible to do through the chat action bar; may be null
        /// </summary>
        public ChatActionBar ActionBar { get; set; }

        /// <summary>
        /// Information about video chat of the chat
        /// </summary>
        public VideoChat VideoChat { get; set; }

        /// <summary>
        /// Information about pending join requests; may be null
        /// </summary>
        public ChatJoinRequestsInfo PendingJoinRequests { get; set; }

        /// <summary>
        /// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
        /// </summary>
        public long ReplyMarkupMessageId { get; set; }

        /// <summary>
        /// A draft of a message in the chat; may be null
        /// </summary>
        public DraftMessage DraftMessage { get; set; }

        /// <summary>
        /// Application-specific data associated with the chat. (For example, the chat scroll position or local chat notification settings can be stored here.) Persistent if the message database is used
        /// </summary>
        public string ClientData { get; set; }

    }

    /// <summary>
    /// Represents a list of chats
    /// </summary>
    public partial class Chats : TLObject
    {
        /// <summary>
        /// Approximate total count of chats found
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// List of chat identifiers
        /// </summary>
        public long[] ChatIds { get; set; }

    }

    /// <summary>
    /// Describes a chat located nearby
    /// </summary>
    public partial class ChatNearby : TLObject
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Distance to the chat location, in meters
        /// </summary>
        public int Distance { get; set; }

    }

    /// <summary>
    /// Represents a list of chats located nearby
    /// </summary>
    public partial class ChatsNearby : TLObject
    {
        /// <summary>
        /// List of users nearby
        /// </summary>
        public ChatNearby[] UsersNearby { get; set; }

        /// <summary>
        /// List of location-based supergroups nearby
        /// </summary>
        public ChatNearby[] SupergroupsNearby { get; set; }

    }

    /// <summary>
    /// The chat is public, because it has username
    /// </summary>
    public partial class PublicChatTypeHasUsername : PublicChatType
    {
    }

    /// <summary>
    /// The chat is public, because it is a location-based supergroup
    /// </summary>
    public partial class PublicChatTypeIsLocationBased : PublicChatType
    {
    }

    /// <summary>
    /// The chat can be reported as spam using the method reportChat with the reason chatReportReasonSpam
    /// </summary>
    public partial class ChatActionBarReportSpam : ChatActionBar
    {
        /// <summary>
        /// If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
        /// </summary>
        public bool CanUnarchive { get; set; }

    }

    /// <summary>
    /// The chat is a location-based supergroup, which can be reported as having unrelated location using the method reportChat with the reason chatReportReasonUnrelatedLocation
    /// </summary>
    public partial class ChatActionBarReportUnrelatedLocation : ChatActionBar
    {
    }

    /// <summary>
    /// The chat is a recently created group chat, to which new members can be invited
    /// </summary>
    public partial class ChatActionBarInviteMembers : ChatActionBar
    {
    }

    /// <summary>
    /// The chat is a private or secret chat, which can be reported using the method reportChat, or the other user can be blocked using the method toggleMessageSenderIsBlocked, or the other user can be added to the contact list using the method addContact
    /// </summary>
    public partial class ChatActionBarReportAddBlock : ChatActionBar
    {
        /// <summary>
        /// If true, the chat was automatically archived and can be moved back to the main chat list using addChatToList simultaneously with setting chat notification settings to default using setChatNotificationSettings
        /// </summary>
        public bool CanUnarchive { get; set; }

        /// <summary>
        /// If non-negative, the current user was found by the peer through searchChatsNearby and this is the distance between the users
        /// </summary>
        public int Distance { get; set; }

    }

    /// <summary>
    /// The chat is a private or secret chat and the other user can be added to the contact list using the method addContact
    /// </summary>
    public partial class ChatActionBarAddContact : ChatActionBar
    {
    }

    /// <summary>
    /// The chat is a private or secret chat with a mutual contact and the user's phone number can be shared with the other user using the method sharePhoneNumber
    /// </summary>
    public partial class ChatActionBarSharePhoneNumber : ChatActionBar
    {
    }

    /// <summary>
    /// A simple button, with text that must be sent when the button is pressed
    /// </summary>
    public partial class KeyboardButtonTypeText : KeyboardButtonType
    {
    }

    /// <summary>
    /// A button that sends the user's phone number when pressed; available only in private chats
    /// </summary>
    public partial class KeyboardButtonTypeRequestPhoneNumber : KeyboardButtonType
    {
    }

    /// <summary>
    /// A button that sends the user's location when pressed; available only in private chats
    /// </summary>
    public partial class KeyboardButtonTypeRequestLocation : KeyboardButtonType
    {
    }

    /// <summary>
    /// A button that allows the user to create and send a poll when pressed; available only in private chats
    /// </summary>
    public partial class KeyboardButtonTypeRequestPoll : KeyboardButtonType
    {
        /// <summary>
        /// If true, only regular polls must be allowed to create
        /// </summary>
        public bool ForceRegular { get; set; }

        /// <summary>
        /// If true, only polls in quiz mode must be allowed to create
        /// </summary>
        public bool ForceQuiz { get; set; }

    }

    /// <summary>
    /// Represents a single button in a bot keyboard
    /// </summary>
    public partial class KeyboardButton : TLObject
    {
        /// <summary>
        /// Text of the button
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Type of the button
        /// </summary>
        public KeyboardButtonType Type { get; set; }

    }

    /// <summary>
    /// A button that opens a specified URL
    /// </summary>
    public partial class InlineKeyboardButtonTypeUrl : InlineKeyboardButtonType
    {
        /// <summary>
        /// HTTP or tg:// URL to open
        /// </summary>
        public string Url { get; set; }

    }

    /// <summary>
    /// A button that opens a specified URL and automatically authorize the current user if allowed to do so
    /// </summary>
    public partial class InlineKeyboardButtonTypeLoginUrl : InlineKeyboardButtonType
    {
        /// <summary>
        /// An HTTP URL to open
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// Unique button identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// If non-empty, new text of the button in forwarded messages
        /// </summary>
        public string ForwardText { get; set; }

    }

    /// <summary>
    /// A button that sends a callback query to a bot
    /// </summary>
    public partial class InlineKeyboardButtonTypeCallback : InlineKeyboardButtonType
    {
        /// <summary>
        /// Data to be sent to the bot via a callback query
        /// </summary>
        public Memory<byte> Data { get; set; }

    }

    /// <summary>
    /// A button that asks for password of the current user and then sends a callback query to a bot
    /// </summary>
    public partial class InlineKeyboardButtonTypeCallbackWithPassword : InlineKeyboardButtonType
    {
        /// <summary>
        /// Data to be sent to the bot via a callback query
        /// </summary>
        public Memory<byte> Data { get; set; }

    }

    /// <summary>
    /// A button with a game that sends a callback query to a bot. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageGame
    /// </summary>
    public partial class InlineKeyboardButtonTypeCallbackGame : InlineKeyboardButtonType
    {
    }

    /// <summary>
    /// A button that forces an inline query to the bot to be inserted in the input field
    /// </summary>
    public partial class InlineKeyboardButtonTypeSwitchInline : InlineKeyboardButtonType
    {
        /// <summary>
        /// Inline query to be sent to the bot
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// True, if the inline query must be sent from the current chat
        /// </summary>
        public bool InCurrentChat { get; set; }

    }

    /// <summary>
    /// A button to buy something. This button must be in the first column and row of the keyboard and can be attached only to a message with content of the type messageInvoice
    /// </summary>
    public partial class InlineKeyboardButtonTypeBuy : InlineKeyboardButtonType
    {
    }

    /// <summary>
    /// Represents a single button in an inline keyboard
    /// </summary>
    public partial class InlineKeyboardButton : TLObject
    {
        /// <summary>
        /// Text of the button
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Type of the button
        /// </summary>
        public InlineKeyboardButtonType Type { get; set; }

    }

    /// <summary>
    /// Instructs application to remove the keyboard once this message has been received. This kind of keyboard can't be received in an incoming message; instead, UpdateChatReplyMarkup with message_id == 0 will be sent
    /// </summary>
    public partial class ReplyMarkupRemoveKeyboard : ReplyMarkup
    {
        /// <summary>
        /// True, if the keyboard is removed only for the mentioned users or the target user of a reply
        /// </summary>
        public bool IsPersonal { get; set; }

    }

    /// <summary>
    /// Instructs application to force a reply to this message
    /// </summary>
    public partial class ReplyMarkupForceReply : ReplyMarkup
    {
        /// <summary>
        /// True, if a forced reply must automatically be shown to the current user. For outgoing messages, specify true to show the forced reply only for the mentioned users and for the target user of a reply
        /// </summary>
        public bool IsPersonal { get; set; }

        /// <summary>
        /// If non-empty, the placeholder to be shown in the input field when the reply is active; 0-64 characters
        /// </summary>
        public string InputFieldPlaceholder { get; set; }

    }

    /// <summary>
    /// Contains a custom keyboard layout to quickly reply to bots
    /// </summary>
    public partial class ReplyMarkupShowKeyboard : ReplyMarkup
    {
        /// <summary>
        /// A list of rows of bot keyboard buttons
        /// </summary>
        public KeyboardButton[][] Rows { get; set; }

        /// <summary>
        /// True, if the application needs to resize the keyboard vertically
        /// </summary>
        public bool ResizeKeyboard { get; set; }

        /// <summary>
        /// True, if the application needs to hide the keyboard after use
        /// </summary>
        public bool OneTime { get; set; }

        /// <summary>
        /// True, if the keyboard must automatically be shown to the current user. For outgoing messages, specify true to show the keyboard only for the mentioned users and for the target user of a reply
        /// </summary>
        public bool IsPersonal { get; set; }

        /// <summary>
        /// If non-empty, the placeholder to be shown in the input field when the keyboard is active; 0-64 characters
        /// </summary>
        public string InputFieldPlaceholder { get; set; }

    }

    /// <summary>
    /// Contains an inline keyboard layout
    /// </summary>
    public partial class ReplyMarkupInlineKeyboard : ReplyMarkup
    {
        /// <summary>
        /// A list of rows of inline keyboard buttons
        /// </summary>
        public InlineKeyboardButton[][] Rows { get; set; }

    }

    /// <summary>
    /// An HTTP url needs to be open
    /// </summary>
    public partial class LoginUrlInfoOpen : LoginUrlInfo
    {
        /// <summary>
        /// The URL to open
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// True, if there is no need to show an ordinary open URL confirm
        /// </summary>
        public bool SkipConfirm { get; set; }

    }

    /// <summary>
    /// An authorization confirmation dialog needs to be shown to the user
    /// </summary>
    public partial class LoginUrlInfoRequestConfirmation : LoginUrlInfo
    {
        /// <summary>
        /// An HTTP URL to be opened
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// A domain of the URL
        /// </summary>
        public string Domain { get; set; }

        /// <summary>
        /// User identifier of a bot linked with the website
        /// </summary>
        public long BotUserId { get; set; }

        /// <summary>
        /// True, if the user needs to be requested to give the permission to the bot to send them messages
        /// </summary>
        public bool RequestWriteAccess { get; set; }

    }

    /// <summary>
    /// Contains information about a message thread
    /// </summary>
    public partial class MessageThreadInfo : TLObject
    {
        /// <summary>
        /// Identifier of the chat to which the message thread belongs
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message thread identifier, unique within the chat
        /// </summary>
        public long MessageThreadId { get; set; }

        /// <summary>
        /// Information about the message thread
        /// </summary>
        public MessageReplyInfo ReplyInfo { get; set; }

        /// <summary>
        /// Approximate number of unread messages in the message thread
        /// </summary>
        public int UnreadMessageCount { get; set; }

        /// <summary>
        /// The messages from which the thread starts. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
        /// </summary>
        public Message[] Messages { get; set; }

        /// <summary>
        /// A draft of a message in the message thread; may be null
        /// </summary>
        public DraftMessage DraftMessage { get; set; }

    }

    /// <summary>
    /// A plain text
    /// </summary>
    public partial class RichTextPlain : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public string Text { get; set; }

    }

    /// <summary>
    /// A bold rich text
    /// </summary>
    public partial class RichTextBold : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public RichText Text { get; set; }

    }

    /// <summary>
    /// An italicized rich text
    /// </summary>
    public partial class RichTextItalic : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public RichText Text { get; set; }

    }

    /// <summary>
    /// An underlined rich text
    /// </summary>
    public partial class RichTextUnderline : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public RichText Text { get; set; }

    }

    /// <summary>
    /// A strikethrough rich text
    /// </summary>
    public partial class RichTextStrikethrough : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public RichText Text { get; set; }

    }

    /// <summary>
    /// A fixed-width rich text
    /// </summary>
    public partial class RichTextFixed : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public RichText Text { get; set; }

    }

    /// <summary>
    /// A rich text URL link
    /// </summary>
    public partial class RichTextUrl : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public RichText Text { get; set; }

        /// <summary>
        /// URL
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// True, if the URL has cached instant view server-side
        /// </summary>
        public bool IsCached { get; set; }

    }

    /// <summary>
    /// A rich text email link
    /// </summary>
    public partial class RichTextEmailAddress : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public RichText Text { get; set; }

        /// <summary>
        /// Email address
        /// </summary>
        public string EmailAddress { get; set; }

    }

    /// <summary>
    /// A subscript rich text
    /// </summary>
    public partial class RichTextSubscript : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public RichText Text { get; set; }

    }

    /// <summary>
    /// A superscript rich text
    /// </summary>
    public partial class RichTextSuperscript : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public RichText Text { get; set; }

    }

    /// <summary>
    /// A marked rich text
    /// </summary>
    public partial class RichTextMarked : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public RichText Text { get; set; }

    }

    /// <summary>
    /// A rich text phone number
    /// </summary>
    public partial class RichTextPhoneNumber : RichText
    {
        /// <summary>
        /// Text
        /// </summary>
        public RichText Text { get; set; }

        /// <summary>
        /// Phone number
        /// </summary>
        public string PhoneNumber { get; set; }

    }

    /// <summary>
    /// A small image inside the text
    /// </summary>
    public partial class RichTextIcon : RichText
    {
        /// <summary>
        /// The image represented as a document. The image can be in GIF, JPEG or PNG format
        /// </summary>
        public Document Document { get; set; }

        /// <summary>
        /// Width of a bounding box in which the image must be shown; 0 if unknown
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Height of a bounding box in which the image must be shown; 0 if unknown
        /// </summary>
        public int Height { get; set; }

    }

    /// <summary>
    /// A reference to a richTexts object on the same web page
    /// </summary>
    public partial class RichTextReference : RichText
    {
        /// <summary>
        /// The text
        /// </summary>
        public RichText Text { get; set; }

        /// <summary>
        /// The name of a richTextAnchor object, which is the first element of the target richTexts object
        /// </summary>
        public string AnchorName { get; set; }

        /// <summary>
        /// An HTTP URL, opening the reference
        /// </summary>
        public string Url { get; set; }

    }

    /// <summary>
    /// An anchor
    /// </summary>
    public partial class RichTextAnchor : RichText
    {
        /// <summary>
        /// Anchor name
        /// </summary>
        public string Name { get; set; }

    }

    /// <summary>
    /// A link to an anchor on the same web page
    /// </summary>
    public partial class RichTextAnchorLink : RichText
    {
        /// <summary>
        /// The link text
        /// </summary>
        public RichText Text { get; set; }

        /// <summary>
        /// The anchor name. If the name is empty, the link must bring back to top
        /// </summary>
        public string AnchorName { get; set; }

        /// <summary>
        /// An HTTP URL, opening the anchor
        /// </summary>
        public string Url { get; set; }

    }

    /// <summary>
    /// A concatenation of rich texts
    /// </summary>
    public partial class RichTexts : RichText
    {
        /// <summary>
        /// Texts
        /// </summary>
        public RichText[] Texts { get; set; }

    }

    /// <summary>
    /// Contains a caption of an instant view web page block, consisting of a text and a trailing credit
    /// </summary>
    public partial class PageBlockCaption : TLObject
    {
        /// <summary>
        /// Content of the caption
        /// </summary>
        public RichText Text { get; set; }

        /// <summary>
        /// Block credit (like HTML tag &lt;cite&gt;)
        /// </summary>
        public RichText Credit { get; set; }

    }

    /// <summary>
    /// Describes an item of a list page block
    /// </summary>
    public partial class PageBlockListItem : TLObject
    {
        /// <summary>
        /// Item label
        /// </summary>
        public string Label { get; set; }

        /// <summary>
        /// Item blocks
        /// </summary>
        public PageBlock[] PageBlocks { get; set; }

    }

    /// <summary>
    /// The content must be left-aligned
    /// </summary>
    public partial class PageBlockHorizontalAlignmentLeft : PageBlockHorizontalAlignment
    {
    }

    /// <summary>
    /// The content must be center-aligned
    /// </summary>
    public partial class PageBlockHorizontalAlignmentCenter : PageBlockHorizontalAlignment
    {
    }

    /// <summary>
    /// The content must be right-aligned
    /// </summary>
    public partial class PageBlockHorizontalAlignmentRight : PageBlockHorizontalAlignment
    {
    }

    /// <summary>
    /// The content must be top-aligned
    /// </summary>
    public partial class PageBlockVerticalAlignmentTop : PageBlockVerticalAlignment
    {
    }

    /// <summary>
    /// The content must be middle-aligned
    /// </summary>
    public partial class PageBlockVerticalAlignmentMiddle : PageBlockVerticalAlignment
    {
    }

    /// <summary>
    /// The content must be bottom-aligned
    /// </summary>
    public partial class PageBlockVerticalAlignmentBottom : PageBlockVerticalAlignment
    {
    }

    /// <summary>
    /// Represents a cell of a table
    /// </summary>
    public partial class PageBlockTableCell : TLObject
    {
        /// <summary>
        /// Cell text; may be null. If the text is null, then the cell must be invisible
        /// </summary>
        public RichText Text { get; set; }

        /// <summary>
        /// True, if it is a header cell
        /// </summary>
        public bool IsHeader { get; set; }

        /// <summary>
        /// The number of columns the cell spans
        /// </summary>
        public int Colspan { get; set; }

        /// <summary>
        /// The number of rows the cell spans
        /// </summary>
        public int Rowspan { get; set; }

        /// <summary>
        /// Horizontal cell content alignment
        /// </summary>
        public PageBlockHorizontalAlignment Align { get; set; }

        /// <summary>
        /// Vertical cell content alignment
        /// </summary>
        public PageBlockVerticalAlignment Valign { get; set; }

    }

    /// <summary>
    /// Contains information about a related article
    /// </summary>
    public partial class PageBlockRelatedArticle : TLObject
    {
        /// <summary>
        /// Related article URL
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// Article title; may be empty
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Contains information about a related article
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Article photo; may be null
        /// </summary>
        public Photo Photo { get; set; }

        /// <summary>
        /// Article author; may be empty
        /// </summary>
        public string Author { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the article was published; 0 if unknown
        /// </summary>
        public int PublishDate { get; set; }

    }

    /// <summary>
    /// The title of a page
    /// </summary>
    public partial class PageBlockTitle : PageBlock
    {
        /// <summary>
        /// Title
        /// </summary>
        public RichText Title { get; set; }

    }

    /// <summary>
    /// The subtitle of a page
    /// </summary>
    public partial class PageBlockSubtitle : PageBlock
    {
        /// <summary>
        /// Subtitle
        /// </summary>
        public RichText Subtitle { get; set; }

    }

    /// <summary>
    /// The author and publishing date of a page
    /// </summary>
    public partial class PageBlockAuthorDate : PageBlock
    {
        /// <summary>
        /// Author
        /// </summary>
        public RichText Author { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the article was published; 0 if unknown
        /// </summary>
        public int PublishDate { get; set; }

    }

    /// <summary>
    /// A header
    /// </summary>
    public partial class PageBlockHeader : PageBlock
    {
        /// <summary>
        /// Header
        /// </summary>
        public RichText Header { get; set; }

    }

    /// <summary>
    /// A subheader
    /// </summary>
    public partial class PageBlockSubheader : PageBlock
    {
        /// <summary>
        /// Subheader
        /// </summary>
        public RichText Subheader { get; set; }

    }

    /// <summary>
    /// A kicker
    /// </summary>
    public partial class PageBlockKicker : PageBlock
    {
        /// <summary>
        /// Kicker
        /// </summary>
        public RichText Kicker { get; set; }

    }

    /// <summary>
    /// A text paragraph
    /// </summary>
    public partial class PageBlockParagraph : PageBlock
    {
        /// <summary>
        /// Paragraph text
        /// </summary>
        public RichText Text { get; set; }

    }

    /// <summary>
    /// A preformatted text paragraph
    /// </summary>
    public partial class PageBlockPreformatted : PageBlock
    {
        /// <summary>
        /// Paragraph text
        /// </summary>
        public RichText Text { get; set; }

        /// <summary>
        /// Programming language for which the text needs to be formatted
        /// </summary>
        public string Language { get; set; }

    }

    /// <summary>
    /// The footer of a page
    /// </summary>
    public partial class PageBlockFooter : PageBlock
    {
        /// <summary>
        /// Footer
        /// </summary>
        public RichText Footer { get; set; }

    }

    /// <summary>
    /// An empty block separating a page
    /// </summary>
    public partial class PageBlockDivider : PageBlock
    {
    }

    /// <summary>
    /// An invisible anchor on a page, which can be used in a URL to open the page from the specified anchor
    /// </summary>
    public partial class PageBlockAnchor : PageBlock
    {
        /// <summary>
        /// Name of the anchor
        /// </summary>
        public string Name { get; set; }

    }

    /// <summary>
    /// A list of data blocks
    /// </summary>
    public partial class PageBlockList : PageBlock
    {
        /// <summary>
        /// The items of the list
        /// </summary>
        public PageBlockListItem[] Items { get; set; }

    }

    /// <summary>
    /// A block quote
    /// </summary>
    public partial class PageBlockBlockQuote : PageBlock
    {
        /// <summary>
        /// Quote text
        /// </summary>
        public RichText Text { get; set; }

        /// <summary>
        /// Quote credit
        /// </summary>
        public RichText Credit { get; set; }

    }

    /// <summary>
    /// A pull quote
    /// </summary>
    public partial class PageBlockPullQuote : PageBlock
    {
        /// <summary>
        /// Quote text
        /// </summary>
        public RichText Text { get; set; }

        /// <summary>
        /// Quote credit
        /// </summary>
        public RichText Credit { get; set; }

    }

    /// <summary>
    /// An animation
    /// </summary>
    public partial class PageBlockAnimation : PageBlock
    {
        /// <summary>
        /// Animation file; may be null
        /// </summary>
        public Animation Animation { get; set; }

        /// <summary>
        /// Animation caption
        /// </summary>
        public PageBlockCaption Caption { get; set; }

        /// <summary>
        /// True, if the animation must be played automatically
        /// </summary>
        public bool NeedAutoplay { get; set; }

    }

    /// <summary>
    /// An audio file
    /// </summary>
    public partial class PageBlockAudio : PageBlock
    {
        /// <summary>
        /// Audio file; may be null
        /// </summary>
        public Audio Audio { get; set; }

        /// <summary>
        /// Audio file caption
        /// </summary>
        public PageBlockCaption Caption { get; set; }

    }

    /// <summary>
    /// A photo
    /// </summary>
    public partial class PageBlockPhoto : PageBlock
    {
        /// <summary>
        /// Photo file; may be null
        /// </summary>
        public Photo Photo { get; set; }

        /// <summary>
        /// Photo caption
        /// </summary>
        public PageBlockCaption Caption { get; set; }

        /// <summary>
        /// URL that needs to be opened when the photo is clicked
        /// </summary>
        public string Url { get; set; }

    }

    /// <summary>
    /// A video
    /// </summary>
    public partial class PageBlockVideo : PageBlock
    {
        /// <summary>
        /// Video file; may be null
        /// </summary>
        public Video Video { get; set; }

        /// <summary>
        /// Video caption
        /// </summary>
        public PageBlockCaption Caption { get; set; }

        /// <summary>
        /// True, if the video must be played automatically
        /// </summary>
        public bool NeedAutoplay { get; set; }

        /// <summary>
        /// True, if the video must be looped
        /// </summary>
        public bool IsLooped { get; set; }

    }

    /// <summary>
    /// A voice note
    /// </summary>
    public partial class PageBlockVoiceNote : PageBlock
    {
        /// <summary>
        /// Voice note; may be null
        /// </summary>
        public VoiceNote VoiceNote { get; set; }

        /// <summary>
        /// Voice note caption
        /// </summary>
        public PageBlockCaption Caption { get; set; }

    }

    /// <summary>
    /// A page cover
    /// </summary>
    public partial class PageBlockCover : PageBlock
    {
        /// <summary>
        /// Cover
        /// </summary>
        public PageBlock Cover { get; set; }

    }

    /// <summary>
    /// An embedded web page
    /// </summary>
    public partial class PageBlockEmbedded : PageBlock
    {
        /// <summary>
        /// Web page URL, if available
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// HTML-markup of the embedded page
        /// </summary>
        public string Html { get; set; }

        /// <summary>
        /// Poster photo, if available; may be null
        /// </summary>
        public Photo PosterPhoto { get; set; }

        /// <summary>
        /// Block width; 0 if unknown
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Block height; 0 if unknown
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// Block caption
        /// </summary>
        public PageBlockCaption Caption { get; set; }

        /// <summary>
        /// True, if the block must be full width
        /// </summary>
        public bool IsFullWidth { get; set; }

        /// <summary>
        /// True, if scrolling needs to be allowed
        /// </summary>
        public bool AllowScrolling { get; set; }

    }

    /// <summary>
    /// An embedded post
    /// </summary>
    public partial class PageBlockEmbeddedPost : PageBlock
    {
        /// <summary>
        /// Web page URL
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// Post author
        /// </summary>
        public string Author { get; set; }

        /// <summary>
        /// Post author photo; may be null
        /// </summary>
        public Photo AuthorPhoto { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the post was created; 0 if unknown
        /// </summary>
        public int Date { get; set; }

        /// <summary>
        /// Post content
        /// </summary>
        public PageBlock[] PageBlocks { get; set; }

        /// <summary>
        /// Post caption
        /// </summary>
        public PageBlockCaption Caption { get; set; }

    }

    /// <summary>
    /// A collage
    /// </summary>
    public partial class PageBlockCollage : PageBlock
    {
        /// <summary>
        /// Collage item contents
        /// </summary>
        public PageBlock[] PageBlocks { get; set; }

        /// <summary>
        /// Block caption
        /// </summary>
        public PageBlockCaption Caption { get; set; }

    }

    /// <summary>
    /// A slideshow
    /// </summary>
    public partial class PageBlockSlideshow : PageBlock
    {
        /// <summary>
        /// Slideshow item contents
        /// </summary>
        public PageBlock[] PageBlocks { get; set; }

        /// <summary>
        /// Block caption
        /// </summary>
        public PageBlockCaption Caption { get; set; }

    }

    /// <summary>
    /// A link to a chat
    /// </summary>
    public partial class PageBlockChatLink : PageBlock
    {
        /// <summary>
        /// Chat title
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Chat photo; may be null
        /// </summary>
        public ChatPhotoInfo Photo { get; set; }

        /// <summary>
        /// Chat username, by which all other information about the chat can be resolved
        /// </summary>
        public string Username { get; set; }

    }

    /// <summary>
    /// A table
    /// </summary>
    public partial class PageBlockTable : PageBlock
    {
        /// <summary>
        /// Table caption
        /// </summary>
        public RichText Caption { get; set; }

        /// <summary>
        /// Table cells
        /// </summary>
        public PageBlockTableCell[][] Cells { get; set; }

        /// <summary>
        /// True, if the table is bordered
        /// </summary>
        public bool IsBordered { get; set; }

        /// <summary>
        /// True, if the table is striped
        /// </summary>
        public bool IsStriped { get; set; }

    }

    /// <summary>
    /// A collapsible block
    /// </summary>
    public partial class PageBlockDetails : PageBlock
    {
        /// <summary>
        /// Always visible heading for the block
        /// </summary>
        public RichText Header { get; set; }

        /// <summary>
        /// Block contents
        /// </summary>
        public PageBlock[] PageBlocks { get; set; }

        /// <summary>
        /// True, if the block is open by default
        /// </summary>
        public bool IsOpen { get; set; }

    }

    /// <summary>
    /// Related articles
    /// </summary>
    public partial class PageBlockRelatedArticles : PageBlock
    {
        /// <summary>
        /// Block header
        /// </summary>
        public RichText Header { get; set; }

        /// <summary>
        /// List of related articles
        /// </summary>
        public PageBlockRelatedArticle[] Articles { get; set; }

    }

    /// <summary>
    /// A map
    /// </summary>
    public partial class PageBlockMap : PageBlock
    {
        /// <summary>
        /// Location of the map center
        /// </summary>
        public Location Location { get; set; }

        /// <summary>
        /// Map zoom level
        /// </summary>
        public int Zoom { get; set; }

        /// <summary>
        /// Map width
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Map height
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// Block caption
        /// </summary>
        public PageBlockCaption Caption { get; set; }

    }

    /// <summary>
    /// Describes an instant view page for a web page
    /// </summary>
    public partial class WebPageInstantView : TLObject
    {
        /// <summary>
        /// Content of the web page
        /// </summary>
        public PageBlock[] PageBlocks { get; set; }

        /// <summary>
        /// Number of the instant view views; 0 if unknown
        /// </summary>
        public int ViewCount { get; set; }

        /// <summary>
        /// Version of the instant view, currently can be 1 or 2
        /// </summary>
        public int Version { get; set; }

        /// <summary>
        /// True, if the instant view must be shown from right to left
        /// </summary>
        public bool IsRtl { get; set; }

        /// <summary>
        /// True, if the instant view contains the full page. A network request might be needed to get the full web page instant view
        /// </summary>
        public bool IsFull { get; set; }

        /// <summary>
        /// An internal link to be opened to leave feedback about the instant view
        /// </summary>
        public InternalLinkType FeedbackLink { get; set; }

    }

    /// <summary>
    /// Describes a web page preview
    /// </summary>
    public partial class WebPage : TLObject
    {
        /// <summary>
        /// Original URL of the link
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// URL to display
        /// </summary>
        public string DisplayUrl { get; set; }

        /// <summary>
        /// Type of the web page. Can be: article, photo, audio, video, document, profile, app, or something else
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Short name of the site (e.g., Google Docs, App Store)
        /// </summary>
        public string SiteName { get; set; }

        /// <summary>
        /// Title of the content
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Describes a web page preview
        /// </summary>
        public FormattedText Description { get; set; }

        /// <summary>
        /// Image representing the content; may be null
        /// </summary>
        public Photo Photo { get; set; }

        /// <summary>
        /// URL to show in the embedded preview
        /// </summary>
        public string EmbedUrl { get; set; }

        /// <summary>
        /// MIME type of the embedded preview, (e.g., text/html or video/mp4)
        /// </summary>
        public string EmbedType { get; set; }

        /// <summary>
        /// Width of the embedded preview
        /// </summary>
        public int EmbedWidth { get; set; }

        /// <summary>
        /// Height of the embedded preview
        /// </summary>
        public int EmbedHeight { get; set; }

        /// <summary>
        /// Duration of the content, in seconds
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// Author of the content
        /// </summary>
        public string Author { get; set; }

        /// <summary>
        /// Preview of the content as an animation, if available; may be null
        /// </summary>
        public Animation Animation { get; set; }

        /// <summary>
        /// Preview of the content as an audio file, if available; may be null
        /// </summary>
        public Audio Audio { get; set; }

        /// <summary>
        /// Preview of the content as a document, if available (currently only available for small PDF files and ZIP archives); may be null
        /// </summary>
        public Document Document { get; set; }

        /// <summary>
        /// Preview of the content as a sticker for small WEBP files, if available; may be null
        /// </summary>
        public Sticker Sticker { get; set; }

        /// <summary>
        /// Preview of the content as a video, if available; may be null
        /// </summary>
        public Video Video { get; set; }

        /// <summary>
        /// Preview of the content as a video note, if available; may be null
        /// </summary>
        public VideoNote VideoNote { get; set; }

        /// <summary>
        /// Preview of the content as a voice note, if available; may be null
        /// </summary>
        public VoiceNote VoiceNote { get; set; }

        /// <summary>
        /// Version of instant view, available for the web page (currently can be 1 or 2), 0 if none
        /// </summary>
        public int InstantViewVersion { get; set; }

    }

    /// <summary>
    /// Contains information about a country
    /// </summary>
    public partial class CountryInfo : TLObject
    {
        /// <summary>
        /// A two-letter ISO 3166-1 alpha-2 country code
        /// </summary>
        public string CountryCode { get; set; }

        /// <summary>
        /// Native name of the country
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// English name of the country
        /// </summary>
        public string EnglishName { get; set; }

        /// <summary>
        /// True, if the country must be hidden from the list of all countries
        /// </summary>
        public bool IsHidden { get; set; }

        /// <summary>
        /// List of country calling codes
        /// </summary>
        public string[] CallingCodes { get; set; }

    }

    /// <summary>
    /// Contains information about countries
    /// </summary>
    public partial class Countries : TLObject
    {
        /// <summary>
        /// The list of countries
        /// </summary>
        public CountryInfo[] Countries_ { get; set; }

    }

    /// <summary>
    /// Contains information about a phone number
    /// </summary>
    public partial class PhoneNumberInfo : TLObject
    {
        /// <summary>
        /// Information about the country to which the phone number belongs; may be null
        /// </summary>
        public CountryInfo Country { get; set; }

        /// <summary>
        /// The part of the phone number denoting country calling code or its part
        /// </summary>
        public string CountryCallingCode { get; set; }

        /// <summary>
        /// The phone number without country calling code formatted accordingly to local rules. Expected digits are returned as '-', but even more digits might be entered by the user
        /// </summary>
        public string FormattedPhoneNumber { get; set; }

    }

    /// <summary>
    /// Describes an action associated with a bank card number
    /// </summary>
    public partial class BankCardActionOpenUrl : TLObject
    {
        /// <summary>
        /// Action text
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// The URL to be opened
        /// </summary>
        public string Url { get; set; }

    }

    /// <summary>
    /// Information about a bank card
    /// </summary>
    public partial class BankCardInfo : TLObject
    {
        /// <summary>
        /// Title of the bank card description
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Actions that can be done with the bank card number
        /// </summary>
        public BankCardActionOpenUrl[] Actions { get; set; }

    }

    /// <summary>
    /// Describes an address
    /// </summary>
    public partial class Address : TLObject
    {
        /// <summary>
        /// A two-letter ISO 3166-1 alpha-2 country code
        /// </summary>
        public string CountryCode { get; set; }

        /// <summary>
        /// State, if applicable
        /// </summary>
        public string State { get; set; }

        /// <summary>
        /// City
        /// </summary>
        public string City { get; set; }

        /// <summary>
        /// First line of the address
        /// </summary>
        public string StreetLine1 { get; set; }

        /// <summary>
        /// Second line of the address
        /// </summary>
        public string StreetLine2 { get; set; }

        /// <summary>
        /// Address postal code
        /// </summary>
        public string PostalCode { get; set; }

    }

    /// <summary>
    /// Portion of the price of a product (e.g., "delivery cost", "tax amount")
    /// </summary>
    public partial class LabeledPricePart : TLObject
    {
        /// <summary>
        /// Label for this portion of the product price
        /// </summary>
        public string Label { get; set; }

        /// <summary>
        /// Currency amount in the smallest units of the currency
        /// </summary>
        public long Amount { get; set; }

    }

    /// <summary>
    /// Product invoice
    /// </summary>
    public partial class Invoice : TLObject
    {
        /// <summary>
        /// ISO 4217 currency code
        /// </summary>
        public string Currency { get; set; }

        /// <summary>
        /// A list of objects used to calculate the total price of the product
        /// </summary>
        public LabeledPricePart[] PriceParts { get; set; }

        /// <summary>
        /// The maximum allowed amount of tip in the smallest units of the currency
        /// </summary>
        public long MaxTipAmount { get; set; }

        /// <summary>
        /// Suggested amounts of tip in the smallest units of the currency
        /// </summary>
        public long[] SuggestedTipAmounts { get; set; }

        /// <summary>
        /// True, if the payment is a test payment
        /// </summary>
        public bool IsTest { get; set; }

        /// <summary>
        /// True, if the user's name is needed for payment
        /// </summary>
        public bool NeedName { get; set; }

        /// <summary>
        /// True, if the user's phone number is needed for payment
        /// </summary>
        public bool NeedPhoneNumber { get; set; }

        /// <summary>
        /// True, if the user's email address is needed for payment
        /// </summary>
        public bool NeedEmailAddress { get; set; }

        /// <summary>
        /// True, if the user's shipping address is needed for payment
        /// </summary>
        public bool NeedShippingAddress { get; set; }

        /// <summary>
        /// True, if the user's phone number will be sent to the provider
        /// </summary>
        public bool SendPhoneNumberToProvider { get; set; }

        /// <summary>
        /// True, if the user's email address will be sent to the provider
        /// </summary>
        public bool SendEmailAddressToProvider { get; set; }

        /// <summary>
        /// True, if the total price depends on the shipping method
        /// </summary>
        public bool IsFlexible { get; set; }

    }

    /// <summary>
    /// Order information
    /// </summary>
    public partial class OrderInfo : TLObject
    {
        /// <summary>
        /// Name of the user
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Phone number of the user
        /// </summary>
        public string PhoneNumber { get; set; }

        /// <summary>
        /// Email address of the user
        /// </summary>
        public string EmailAddress { get; set; }

        /// <summary>
        /// Shipping address for this order; may be null
        /// </summary>
        public Address ShippingAddress { get; set; }

    }

    /// <summary>
    /// One shipping option
    /// </summary>
    public partial class ShippingOption : TLObject
    {
        /// <summary>
        /// Shipping option identifier
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Option title
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// A list of objects used to calculate the total shipping costs
        /// </summary>
        public LabeledPricePart[] PriceParts { get; set; }

    }

    /// <summary>
    /// Contains information about saved card credentials
    /// </summary>
    public partial class SavedCredentials : TLObject
    {
        /// <summary>
        /// Unique identifier of the saved credentials
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Title of the saved credentials
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// Applies if a user chooses some previously saved payment credentials. To use their previously saved credentials, the user must have a valid temporary password
    /// </summary>
    public partial class InputCredentialsSaved : InputCredentials
    {
        /// <summary>
        /// Identifier of the saved credentials
        /// </summary>
        public string SavedCredentialsId { get; set; }

    }

    /// <summary>
    /// Applies if a user enters new credentials on a payment provider website
    /// </summary>
    public partial class InputCredentialsNew : InputCredentials
    {
        /// <summary>
        /// JSON-encoded data with the credential identifier from the payment provider
        /// </summary>
        public string Data { get; set; }

        /// <summary>
        /// True, if the credential identifier can be saved on the server side
        /// </summary>
        public bool AllowSave { get; set; }

    }

    /// <summary>
    /// Applies if a user enters new credentials using Apple Pay
    /// </summary>
    public partial class InputCredentialsApplePay : InputCredentials
    {
        /// <summary>
        /// JSON-encoded data with the credential identifier
        /// </summary>
        public string Data { get; set; }

    }

    /// <summary>
    /// Applies if a user enters new credentials using Google Pay
    /// </summary>
    public partial class InputCredentialsGooglePay : InputCredentials
    {
        /// <summary>
        /// JSON-encoded data with the credential identifier
        /// </summary>
        public string Data { get; set; }

    }

    /// <summary>
    /// Stripe payment provider
    /// </summary>
    public partial class PaymentsProviderStripe : TLObject
    {
        /// <summary>
        /// Stripe API publishable key
        /// </summary>
        public string PublishableKey { get; set; }

        /// <summary>
        /// True, if the user country must be provided
        /// </summary>
        public bool NeedCountry { get; set; }

        /// <summary>
        /// True, if the user ZIP/postal code must be provided
        /// </summary>
        public bool NeedPostalCode { get; set; }

        /// <summary>
        /// True, if the cardholder name must be provided
        /// </summary>
        public bool NeedCardholderName { get; set; }

    }

    /// <summary>
    /// Theme colors for a payment form
    /// </summary>
    public partial class PaymentFormTheme : TLObject
    {
        /// <summary>
        /// A color of the payment form background in the RGB24 format
        /// </summary>
        public int BackgroundColor { get; set; }

        /// <summary>
        /// A color of text in the RGB24 format
        /// </summary>
        public int TextColor { get; set; }

        /// <summary>
        /// A color of hints in the RGB24 format
        /// </summary>
        public int HintColor { get; set; }

        /// <summary>
        /// A color of links in the RGB24 format
        /// </summary>
        public int LinkColor { get; set; }

        /// <summary>
        /// A color of the buttons in the RGB24 format
        /// </summary>
        public int ButtonColor { get; set; }

        /// <summary>
        /// A color of text on the buttons in the RGB24 format
        /// </summary>
        public int ButtonTextColor { get; set; }

    }

    /// <summary>
    /// Contains information about an invoice payment form
    /// </summary>
    public partial class PaymentForm : TLObject
    {
        /// <summary>
        /// The payment form identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Full information of the invoice
        /// </summary>
        public Invoice Invoice { get; set; }

        /// <summary>
        /// Payment form URL
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// User identifier of the seller bot
        /// </summary>
        public long SellerBotUserId { get; set; }

        /// <summary>
        /// User identifier of the payment provider bot
        /// </summary>
        public long PaymentsProviderUserId { get; set; }

        /// <summary>
        /// Information about the payment provider, if available, to support it natively without the need for opening the URL; may be null
        /// </summary>
        public PaymentsProviderStripe PaymentsProvider { get; set; }

        /// <summary>
        /// Saved server-side order information; may be null
        /// </summary>
        public OrderInfo SavedOrderInfo { get; set; }

        /// <summary>
        /// Information about saved card credentials; may be null
        /// </summary>
        public SavedCredentials SavedCredentials { get; set; }

        /// <summary>
        /// True, if the user can choose to save credentials
        /// </summary>
        public bool CanSaveCredentials { get; set; }

        /// <summary>
        /// True, if the user will be able to save credentials protected by a password they set up
        /// </summary>
        public bool NeedPassword { get; set; }

    }

    /// <summary>
    /// Contains a temporary identifier of validated order information, which is stored for one hour. Also contains the available shipping options
    /// </summary>
    public partial class ValidatedOrderInfo : TLObject
    {
        /// <summary>
        /// Temporary identifier of the order information
        /// </summary>
        public string OrderInfoId { get; set; }

        /// <summary>
        /// Available shipping options
        /// </summary>
        public ShippingOption[] ShippingOptions { get; set; }

    }

    /// <summary>
    /// Contains the result of a payment request
    /// </summary>
    public partial class PaymentResult : TLObject
    {
        /// <summary>
        /// True, if the payment request was successful; otherwise the verification_url will be non-empty
        /// </summary>
        public bool Success { get; set; }

        /// <summary>
        /// URL for additional payment credentials verification
        /// </summary>
        public string VerificationUrl { get; set; }

    }

    /// <summary>
    /// Contains information about a successful payment
    /// </summary>
    public partial class PaymentReceipt : TLObject
    {
        /// <summary>
        /// Product title
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Contains information about a successful payment
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Product photo; may be null
        /// </summary>
        public Photo Photo { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the payment was made
        /// </summary>
        public int Date { get; set; }

        /// <summary>
        /// User identifier of the seller bot
        /// </summary>
        public long SellerBotUserId { get; set; }

        /// <summary>
        /// User identifier of the payment provider bot
        /// </summary>
        public long PaymentsProviderUserId { get; set; }

        /// <summary>
        /// Information about the invoice
        /// </summary>
        public Invoice Invoice { get; set; }

        /// <summary>
        /// Order information; may be null
        /// </summary>
        public OrderInfo OrderInfo { get; set; }

        /// <summary>
        /// Chosen shipping option; may be null
        /// </summary>
        public ShippingOption ShippingOption { get; set; }

        /// <summary>
        /// Title of the saved credentials chosen by the buyer
        /// </summary>
        public string CredentialsTitle { get; set; }

        /// <summary>
        /// The amount of tip chosen by the buyer in the smallest units of the currency
        /// </summary>
        public long TipAmount { get; set; }

    }

    /// <summary>
    /// File with the date it was uploaded
    /// </summary>
    public partial class DatedFile : TLObject
    {
        /// <summary>
        /// The file
        /// </summary>
        public File File { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the file was uploaded
        /// </summary>
        public int Date { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's personal details
    /// </summary>
    public partial class PassportElementTypePersonalDetails : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the user's passport
    /// </summary>
    public partial class PassportElementTypePassport : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the user's driver license
    /// </summary>
    public partial class PassportElementTypeDriverLicense : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the user's identity card
    /// </summary>
    public partial class PassportElementTypeIdentityCard : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the user's internal passport
    /// </summary>
    public partial class PassportElementTypeInternalPassport : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the user's address
    /// </summary>
    public partial class PassportElementTypeAddress : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the user's utility bill
    /// </summary>
    public partial class PassportElementTypeUtilityBill : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the user's bank statement
    /// </summary>
    public partial class PassportElementTypeBankStatement : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the user's rental agreement
    /// </summary>
    public partial class PassportElementTypeRentalAgreement : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the registration page of the user's passport
    /// </summary>
    public partial class PassportElementTypePassportRegistration : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the user's temporary registration
    /// </summary>
    public partial class PassportElementTypeTemporaryRegistration : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the user's phone number
    /// </summary>
    public partial class PassportElementTypePhoneNumber : PassportElementType
    {
    }

    /// <summary>
    /// A Telegram Passport element containing the user's email address
    /// </summary>
    public partial class PassportElementTypeEmailAddress : PassportElementType
    {
    }

    /// <summary>
    /// Represents a date according to the Gregorian calendar
    /// </summary>
    public partial class Date : TLObject
    {
        /// <summary>
        /// Day of the month; 1-31
        /// </summary>
        public int Day { get; set; }

        /// <summary>
        /// Month; 1-12
        /// </summary>
        public int Month { get; set; }

        /// <summary>
        /// Year; 1-9999
        /// </summary>
        public int Year { get; set; }

    }

    /// <summary>
    /// Contains the user's personal details
    /// </summary>
    public partial class PersonalDetails : TLObject
    {
        /// <summary>
        /// First name of the user written in English; 1-255 characters
        /// </summary>
        public string FirstName { get; set; }

        /// <summary>
        /// Middle name of the user written in English; 0-255 characters
        /// </summary>
        public string MiddleName { get; set; }

        /// <summary>
        /// Last name of the user written in English; 1-255 characters
        /// </summary>
        public string LastName { get; set; }

        /// <summary>
        /// Native first name of the user; 1-255 characters
        /// </summary>
        public string NativeFirstName { get; set; }

        /// <summary>
        /// Native middle name of the user; 0-255 characters
        /// </summary>
        public string NativeMiddleName { get; set; }

        /// <summary>
        /// Native last name of the user; 1-255 characters
        /// </summary>
        public string NativeLastName { get; set; }

        /// <summary>
        /// Birthdate of the user
        /// </summary>
        public Date Birthdate { get; set; }

        /// <summary>
        /// Gender of the user, "male" or "female"
        /// </summary>
        public string Gender { get; set; }

        /// <summary>
        /// A two-letter ISO 3166-1 alpha-2 country code of the user's country
        /// </summary>
        public string CountryCode { get; set; }

        /// <summary>
        /// A two-letter ISO 3166-1 alpha-2 country code of the user's residence country
        /// </summary>
        public string ResidenceCountryCode { get; set; }

    }

    /// <summary>
    /// An identity document
    /// </summary>
    public partial class IdentityDocument : TLObject
    {
        /// <summary>
        /// Document number; 1-24 characters
        /// </summary>
        public string Number { get; set; }

        /// <summary>
        /// Document expiry date; may be null if not applicable
        /// </summary>
        public Date ExpiryDate { get; set; }

        /// <summary>
        /// Front side of the document
        /// </summary>
        public DatedFile FrontSide { get; set; }

        /// <summary>
        /// Reverse side of the document; only for driver license and identity card; may be null
        /// </summary>
        public DatedFile ReverseSide { get; set; }

        /// <summary>
        /// Selfie with the document; may be null
        /// </summary>
        public DatedFile Selfie { get; set; }

        /// <summary>
        /// List of files containing a certified English translation of the document
        /// </summary>
        public DatedFile[] Translation { get; set; }

    }

    /// <summary>
    /// An identity document to be saved to Telegram Passport
    /// </summary>
    public partial class InputIdentityDocument : TLObject
    {
        /// <summary>
        /// Document number; 1-24 characters
        /// </summary>
        public string Number { get; set; }

        /// <summary>
        /// Document expiry date; pass null if not applicable
        /// </summary>
        public Date ExpiryDate { get; set; }

        /// <summary>
        /// Front side of the document
        /// </summary>
        public InputFile FrontSide { get; set; }

        /// <summary>
        /// Reverse side of the document; only for driver license and identity card; pass null otherwise
        /// </summary>
        public InputFile ReverseSide { get; set; }

        /// <summary>
        /// Selfie with the document; pass null if unavailable
        /// </summary>
        public InputFile Selfie { get; set; }

        /// <summary>
        /// List of files containing a certified English translation of the document
        /// </summary>
        public InputFile[] Translation { get; set; }

    }

    /// <summary>
    /// A personal document, containing some information about a user
    /// </summary>
    public partial class PersonalDocument : TLObject
    {
        /// <summary>
        /// List of files containing the pages of the document
        /// </summary>
        public DatedFile[] Files { get; set; }

        /// <summary>
        /// List of files containing a certified English translation of the document
        /// </summary>
        public DatedFile[] Translation { get; set; }

    }

    /// <summary>
    /// A personal document to be saved to Telegram Passport
    /// </summary>
    public partial class InputPersonalDocument : TLObject
    {
        /// <summary>
        /// List of files containing the pages of the document
        /// </summary>
        public InputFile[] Files { get; set; }

        /// <summary>
        /// List of files containing a certified English translation of the document
        /// </summary>
        public InputFile[] Translation { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's personal details
    /// </summary>
    public partial class PassportElementPersonalDetails : PassportElement
    {
        /// <summary>
        /// Personal details of the user
        /// </summary>
        public PersonalDetails PersonalDetails { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's passport
    /// </summary>
    public partial class PassportElementPassport : PassportElement
    {
        /// <summary>
        /// Passport
        /// </summary>
        public IdentityDocument Passport { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's driver license
    /// </summary>
    public partial class PassportElementDriverLicense : PassportElement
    {
        /// <summary>
        /// Driver license
        /// </summary>
        public IdentityDocument DriverLicense { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's identity card
    /// </summary>
    public partial class PassportElementIdentityCard : PassportElement
    {
        /// <summary>
        /// Identity card
        /// </summary>
        public IdentityDocument IdentityCard { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's internal passport
    /// </summary>
    public partial class PassportElementInternalPassport : PassportElement
    {
        /// <summary>
        /// Internal passport
        /// </summary>
        public IdentityDocument InternalPassport { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's address
    /// </summary>
    public partial class PassportElementAddress : PassportElement
    {
        /// <summary>
        /// Address
        /// </summary>
        public Address Address { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's utility bill
    /// </summary>
    public partial class PassportElementUtilityBill : PassportElement
    {
        /// <summary>
        /// Utility bill
        /// </summary>
        public PersonalDocument UtilityBill { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's bank statement
    /// </summary>
    public partial class PassportElementBankStatement : PassportElement
    {
        /// <summary>
        /// Bank statement
        /// </summary>
        public PersonalDocument BankStatement { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's rental agreement
    /// </summary>
    public partial class PassportElementRentalAgreement : PassportElement
    {
        /// <summary>
        /// Rental agreement
        /// </summary>
        public PersonalDocument RentalAgreement { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's passport registration pages
    /// </summary>
    public partial class PassportElementPassportRegistration : PassportElement
    {
        /// <summary>
        /// Passport registration pages
        /// </summary>
        public PersonalDocument PassportRegistration { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's temporary registration
    /// </summary>
    public partial class PassportElementTemporaryRegistration : PassportElement
    {
        /// <summary>
        /// Temporary registration
        /// </summary>
        public PersonalDocument TemporaryRegistration { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's phone number
    /// </summary>
    public partial class PassportElementPhoneNumber : PassportElement
    {
        /// <summary>
        /// Phone number
        /// </summary>
        public string PhoneNumber { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element containing the user's email address
    /// </summary>
    public partial class PassportElementEmailAddress : PassportElement
    {
        /// <summary>
        /// Email address
        /// </summary>
        public string EmailAddress { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's personal details
    /// </summary>
    public partial class InputPassportElementPersonalDetails : InputPassportElement
    {
        /// <summary>
        /// Personal details of the user
        /// </summary>
        public PersonalDetails PersonalDetails { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's passport
    /// </summary>
    public partial class InputPassportElementPassport : InputPassportElement
    {
        /// <summary>
        /// The passport to be saved
        /// </summary>
        public InputIdentityDocument Passport { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's driver license
    /// </summary>
    public partial class InputPassportElementDriverLicense : InputPassportElement
    {
        /// <summary>
        /// The driver license to be saved
        /// </summary>
        public InputIdentityDocument DriverLicense { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's identity card
    /// </summary>
    public partial class InputPassportElementIdentityCard : InputPassportElement
    {
        /// <summary>
        /// The identity card to be saved
        /// </summary>
        public InputIdentityDocument IdentityCard { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's internal passport
    /// </summary>
    public partial class InputPassportElementInternalPassport : InputPassportElement
    {
        /// <summary>
        /// The internal passport to be saved
        /// </summary>
        public InputIdentityDocument InternalPassport { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's address
    /// </summary>
    public partial class InputPassportElementAddress : InputPassportElement
    {
        /// <summary>
        /// The address to be saved
        /// </summary>
        public Address Address { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's utility bill
    /// </summary>
    public partial class InputPassportElementUtilityBill : InputPassportElement
    {
        /// <summary>
        /// The utility bill to be saved
        /// </summary>
        public InputPersonalDocument UtilityBill { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's bank statement
    /// </summary>
    public partial class InputPassportElementBankStatement : InputPassportElement
    {
        /// <summary>
        /// The bank statement to be saved
        /// </summary>
        public InputPersonalDocument BankStatement { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's rental agreement
    /// </summary>
    public partial class InputPassportElementRentalAgreement : InputPassportElement
    {
        /// <summary>
        /// The rental agreement to be saved
        /// </summary>
        public InputPersonalDocument RentalAgreement { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's passport registration
    /// </summary>
    public partial class InputPassportElementPassportRegistration : InputPassportElement
    {
        /// <summary>
        /// The passport registration page to be saved
        /// </summary>
        public InputPersonalDocument PassportRegistration { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's temporary registration
    /// </summary>
    public partial class InputPassportElementTemporaryRegistration : InputPassportElement
    {
        /// <summary>
        /// The temporary registration document to be saved
        /// </summary>
        public InputPersonalDocument TemporaryRegistration { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's phone number
    /// </summary>
    public partial class InputPassportElementPhoneNumber : InputPassportElement
    {
        /// <summary>
        /// The phone number to be saved
        /// </summary>
        public string PhoneNumber { get; set; }

    }

    /// <summary>
    /// A Telegram Passport element to be saved containing the user's email address
    /// </summary>
    public partial class InputPassportElementEmailAddress : InputPassportElement
    {
        /// <summary>
        /// The email address to be saved
        /// </summary>
        public string EmailAddress { get; set; }

    }

    /// <summary>
    /// Contains information about saved Telegram Passport elements
    /// </summary>
    public partial class PassportElements : TLObject
    {
        /// <summary>
        /// Telegram Passport elements
        /// </summary>
        public PassportElement[] Elements { get; set; }

    }

    /// <summary>
    /// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
    /// </summary>
    public partial class PassportElementErrorSourceUnspecified : PassportElementErrorSource
    {
    }

    /// <summary>
    /// One of the data fields contains an error. The error will be considered resolved when the value of the field changes
    /// </summary>
    public partial class PassportElementErrorSourceDataField : PassportElementErrorSource
    {
        /// <summary>
        /// Field name
        /// </summary>
        public string FieldName { get; set; }

    }

    /// <summary>
    /// The front side of the document contains an error. The error will be considered resolved when the file with the front side changes
    /// </summary>
    public partial class PassportElementErrorSourceFrontSide : PassportElementErrorSource
    {
    }

    /// <summary>
    /// The reverse side of the document contains an error. The error will be considered resolved when the file with the reverse side changes
    /// </summary>
    public partial class PassportElementErrorSourceReverseSide : PassportElementErrorSource
    {
    }

    /// <summary>
    /// The selfie with the document contains an error. The error will be considered resolved when the file with the selfie changes
    /// </summary>
    public partial class PassportElementErrorSourceSelfie : PassportElementErrorSource
    {
    }

    /// <summary>
    /// One of files with the translation of the document contains an error. The error will be considered resolved when the file changes
    /// </summary>
    public partial class PassportElementErrorSourceTranslationFile : PassportElementErrorSource
    {
        /// <summary>
        /// Index of a file with the error
        /// </summary>
        public int FileIndex { get; set; }

    }

    /// <summary>
    /// The translation of the document contains an error. The error will be considered resolved when the list of translation files changes
    /// </summary>
    public partial class PassportElementErrorSourceTranslationFiles : PassportElementErrorSource
    {
    }

    /// <summary>
    /// The file contains an error. The error will be considered resolved when the file changes
    /// </summary>
    public partial class PassportElementErrorSourceFile : PassportElementErrorSource
    {
        /// <summary>
        /// Index of a file with the error
        /// </summary>
        public int FileIndex { get; set; }

    }

    /// <summary>
    /// The list of attached files contains an error. The error will be considered resolved when the list of files changes
    /// </summary>
    public partial class PassportElementErrorSourceFiles : PassportElementErrorSource
    {
    }

    /// <summary>
    /// Contains the description of an error in a Telegram Passport element
    /// </summary>
    public partial class PassportElementError : TLObject
    {
        /// <summary>
        /// Type of the Telegram Passport element which has the error
        /// </summary>
        public PassportElementType Type { get; set; }

        /// <summary>
        /// Error message
        /// </summary>
        public string Message { get; set; }

        /// <summary>
        /// Error source
        /// </summary>
        public PassportElementErrorSource Source { get; set; }

    }

    /// <summary>
    /// Contains information about a Telegram Passport element that was requested by a service
    /// </summary>
    public partial class PassportSuitableElement : TLObject
    {
        /// <summary>
        /// Type of the element
        /// </summary>
        public PassportElementType Type { get; set; }

        /// <summary>
        /// True, if a selfie is required with the identity document
        /// </summary>
        public bool IsSelfieRequired { get; set; }

        /// <summary>
        /// True, if a certified English translation is required with the document
        /// </summary>
        public bool IsTranslationRequired { get; set; }

        /// <summary>
        /// True, if personal details must include the user's name in the language of their country of residence
        /// </summary>
        public bool IsNativeNameRequired { get; set; }

    }

    /// <summary>
    /// Contains a description of the required Telegram Passport element that was requested by a service
    /// </summary>
    public partial class PassportRequiredElement : TLObject
    {
        /// <summary>
        /// List of Telegram Passport elements any of which is enough to provide
        /// </summary>
        public PassportSuitableElement[] SuitableElements { get; set; }

    }

    /// <summary>
    /// Contains information about a Telegram Passport authorization form that was requested
    /// </summary>
    public partial class PassportAuthorizationForm : TLObject
    {
        /// <summary>
        /// Unique identifier of the authorization form
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Telegram Passport elements that must be provided to complete the form
        /// </summary>
        public PassportRequiredElement[] RequiredElements { get; set; }

        /// <summary>
        /// URL for the privacy policy of the service; may be empty
        /// </summary>
        public string PrivacyPolicyUrl { get; set; }

    }

    /// <summary>
    /// Contains information about a Telegram Passport elements and corresponding errors
    /// </summary>
    public partial class PassportElementsWithErrors : TLObject
    {
        /// <summary>
        /// Telegram Passport elements
        /// </summary>
        public PassportElement[] Elements { get; set; }

        /// <summary>
        /// Errors in the elements that are already available
        /// </summary>
        public PassportElementError[] Errors { get; set; }

    }

    /// <summary>
    /// Contains encrypted Telegram Passport data credentials
    /// </summary>
    public partial class EncryptedCredentials : TLObject
    {
        /// <summary>
        /// The encrypted credentials
        /// </summary>
        public Memory<byte> Data { get; set; }

        /// <summary>
        /// The decrypted data hash
        /// </summary>
        public Memory<byte> Hash { get; set; }

        /// <summary>
        /// Secret for data decryption, encrypted with the service's public key
        /// </summary>
        public Memory<byte> Secret { get; set; }

    }

    /// <summary>
    /// Contains information about an encrypted Telegram Passport element; for bots only
    /// </summary>
    public partial class EncryptedPassportElement : TLObject
    {
        /// <summary>
        /// Type of Telegram Passport element
        /// </summary>
        public PassportElementType Type { get; set; }

        /// <summary>
        /// Encrypted JSON-encoded data about the user
        /// </summary>
        public Memory<byte> Data { get; set; }

        /// <summary>
        /// The front side of an identity document
        /// </summary>
        public DatedFile FrontSide { get; set; }

        /// <summary>
        /// The reverse side of an identity document; may be null
        /// </summary>
        public DatedFile ReverseSide { get; set; }

        /// <summary>
        /// Selfie with the document; may be null
        /// </summary>
        public DatedFile Selfie { get; set; }

        /// <summary>
        /// List of files containing a certified English translation of the document
        /// </summary>
        public DatedFile[] Translation { get; set; }

        /// <summary>
        /// List of attached files
        /// </summary>
        public DatedFile[] Files { get; set; }

        /// <summary>
        /// Unencrypted data, phone number or email address
        /// </summary>
        public string Value { get; set; }

        /// <summary>
        /// Hash of the entire element
        /// </summary>
        public string Hash { get; set; }

    }

    /// <summary>
    /// The element contains an error in an unspecified place. The error will be considered resolved when new data is added
    /// </summary>
    public partial class InputPassportElementErrorSourceUnspecified : InputPassportElementErrorSource
    {
        /// <summary>
        /// Current hash of the entire element
        /// </summary>
        public Memory<byte> ElementHash { get; set; }

    }

    /// <summary>
    /// A data field contains an error. The error is considered resolved when the field's value changes
    /// </summary>
    public partial class InputPassportElementErrorSourceDataField : InputPassportElementErrorSource
    {
        /// <summary>
        /// Field name
        /// </summary>
        public string FieldName { get; set; }

        /// <summary>
        /// Current data hash
        /// </summary>
        public Memory<byte> DataHash { get; set; }

    }

    /// <summary>
    /// The front side of the document contains an error. The error is considered resolved when the file with the front side of the document changes
    /// </summary>
    public partial class InputPassportElementErrorSourceFrontSide : InputPassportElementErrorSource
    {
        /// <summary>
        /// Current hash of the file containing the front side
        /// </summary>
        public Memory<byte> FileHash { get; set; }

    }

    /// <summary>
    /// The reverse side of the document contains an error. The error is considered resolved when the file with the reverse side of the document changes
    /// </summary>
    public partial class InputPassportElementErrorSourceReverseSide : InputPassportElementErrorSource
    {
        /// <summary>
        /// Current hash of the file containing the reverse side
        /// </summary>
        public Memory<byte> FileHash { get; set; }

    }

    /// <summary>
    /// The selfie contains an error. The error is considered resolved when the file with the selfie changes
    /// </summary>
    public partial class InputPassportElementErrorSourceSelfie : InputPassportElementErrorSource
    {
        /// <summary>
        /// Current hash of the file containing the selfie
        /// </summary>
        public Memory<byte> FileHash { get; set; }

    }

    /// <summary>
    /// One of the files containing the translation of the document contains an error. The error is considered resolved when the file with the translation changes
    /// </summary>
    public partial class InputPassportElementErrorSourceTranslationFile : InputPassportElementErrorSource
    {
        /// <summary>
        /// Current hash of the file containing the translation
        /// </summary>
        public Memory<byte> FileHash { get; set; }

    }

    /// <summary>
    /// The translation of the document contains an error. The error is considered resolved when the list of files changes
    /// </summary>
    public partial class InputPassportElementErrorSourceTranslationFiles : InputPassportElementErrorSource
    {
        /// <summary>
        /// Current hashes of all files with the translation
        /// </summary>
        public Memory<byte>[] FileHashes { get; set; }

    }

    /// <summary>
    /// The file contains an error. The error is considered resolved when the file changes
    /// </summary>
    public partial class InputPassportElementErrorSourceFile : InputPassportElementErrorSource
    {
        /// <summary>
        /// Current hash of the file which has the error
        /// </summary>
        public Memory<byte> FileHash { get; set; }

    }

    /// <summary>
    /// The list of attached files contains an error. The error is considered resolved when the file list changes
    /// </summary>
    public partial class InputPassportElementErrorSourceFiles : InputPassportElementErrorSource
    {
        /// <summary>
        /// Current hashes of all attached files
        /// </summary>
        public Memory<byte>[] FileHashes { get; set; }

    }

    /// <summary>
    /// Contains the description of an error in a Telegram Passport element; for bots only
    /// </summary>
    public partial class InputPassportElementError : TLObject
    {
        /// <summary>
        /// Type of Telegram Passport element that has the error
        /// </summary>
        public PassportElementType Type { get; set; }

        /// <summary>
        /// Error message
        /// </summary>
        public string Message { get; set; }

        /// <summary>
        /// Error source
        /// </summary>
        public InputPassportElementErrorSource Source { get; set; }

    }

    /// <summary>
    /// A text message
    /// </summary>
    public partial class MessageText : MessageContent
    {
        /// <summary>
        /// Text of the message
        /// </summary>
        public FormattedText Text { get; set; }

        /// <summary>
        /// A preview of the web page that's mentioned in the text; may be null
        /// </summary>
        public WebPage WebPage { get; set; }

    }

    /// <summary>
    /// An animation message (GIF-style).
    /// </summary>
    public partial class MessageAnimation : MessageContent
    {
        /// <summary>
        /// The animation description
        /// </summary>
        public Animation Animation { get; set; }

        /// <summary>
        /// Animation caption
        /// </summary>
        public FormattedText Caption { get; set; }

        /// <summary>
        /// True, if the animation thumbnail must be blurred and the animation must be shown only while tapped
        /// </summary>
        public bool IsSecret { get; set; }

    }

    /// <summary>
    /// An audio message
    /// </summary>
    public partial class MessageAudio : MessageContent
    {
        /// <summary>
        /// The audio description
        /// </summary>
        public Audio Audio { get; set; }

        /// <summary>
        /// Audio caption
        /// </summary>
        public FormattedText Caption { get; set; }

    }

    /// <summary>
    /// A document message (general file)
    /// </summary>
    public partial class MessageDocument : MessageContent
    {
        /// <summary>
        /// The document description
        /// </summary>
        public Document Document { get; set; }

        /// <summary>
        /// Document caption
        /// </summary>
        public FormattedText Caption { get; set; }

    }

    /// <summary>
    /// A photo message
    /// </summary>
    public partial class MessagePhoto : MessageContent
    {
        /// <summary>
        /// The photo description
        /// </summary>
        public Photo Photo { get; set; }

        /// <summary>
        /// Photo caption
        /// </summary>
        public FormattedText Caption { get; set; }

        /// <summary>
        /// True, if the photo must be blurred and must be shown only while tapped
        /// </summary>
        public bool IsSecret { get; set; }

    }

    /// <summary>
    /// An expired photo message (self-destructed after TTL has elapsed)
    /// </summary>
    public partial class MessageExpiredPhoto : MessageContent
    {
    }

    /// <summary>
    /// A sticker message
    /// </summary>
    public partial class MessageSticker : MessageContent
    {
        /// <summary>
        /// The sticker description
        /// </summary>
        public Sticker Sticker { get; set; }

    }

    /// <summary>
    /// A video message
    /// </summary>
    public partial class MessageVideo : MessageContent
    {
        /// <summary>
        /// The video description
        /// </summary>
        public Video Video { get; set; }

        /// <summary>
        /// Video caption
        /// </summary>
        public FormattedText Caption { get; set; }

        /// <summary>
        /// True, if the video thumbnail must be blurred and the video must be shown only while tapped
        /// </summary>
        public bool IsSecret { get; set; }

    }

    /// <summary>
    /// An expired video message (self-destructed after TTL has elapsed)
    /// </summary>
    public partial class MessageExpiredVideo : MessageContent
    {
    }

    /// <summary>
    /// A video note message
    /// </summary>
    public partial class MessageVideoNote : MessageContent
    {
        /// <summary>
        /// The video note description
        /// </summary>
        public VideoNote VideoNote { get; set; }

        /// <summary>
        /// True, if at least one of the recipients has viewed the video note
        /// </summary>
        public bool IsViewed { get; set; }

        /// <summary>
        /// True, if the video note thumbnail must be blurred and the video note must be shown only while tapped
        /// </summary>
        public bool IsSecret { get; set; }

    }

    /// <summary>
    /// A voice note message
    /// </summary>
    public partial class MessageVoiceNote : MessageContent
    {
        /// <summary>
        /// The voice note description
        /// </summary>
        public VoiceNote VoiceNote { get; set; }

        /// <summary>
        /// Voice note caption
        /// </summary>
        public FormattedText Caption { get; set; }

        /// <summary>
        /// True, if at least one of the recipients has listened to the voice note
        /// </summary>
        public bool IsListened { get; set; }

    }

    /// <summary>
    /// A message with a location
    /// </summary>
    public partial class MessageLocation : MessageContent
    {
        /// <summary>
        /// The location description
        /// </summary>
        public Location Location { get; set; }

        /// <summary>
        /// Time relative to the message send date, for which the location can be updated, in seconds
        /// </summary>
        public int LivePeriod { get; set; }

        /// <summary>
        /// Left time for which the location can be updated, in seconds. updateMessageContent is not sent when this field changes
        /// </summary>
        public int ExpiresIn { get; set; }

        /// <summary>
        /// For live locations, a direction in which the location moves, in degrees; 1-360. If 0 the direction is unknown
        /// </summary>
        public int Heading { get; set; }

        /// <summary>
        /// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). 0 if the notification is disabled. Available only for the message sender
        /// </summary>
        public int ProximityAlertRadius { get; set; }

    }

    /// <summary>
    /// A message with information about a venue
    /// </summary>
    public partial class MessageVenue : MessageContent
    {
        /// <summary>
        /// The venue description
        /// </summary>
        public Venue Venue { get; set; }

    }

    /// <summary>
    /// A message with a user contact
    /// </summary>
    public partial class MessageContact : MessageContent
    {
        /// <summary>
        /// The contact description
        /// </summary>
        public Contact Contact { get; set; }

    }

    /// <summary>
    /// A message with an animated emoji
    /// </summary>
    public partial class MessageAnimatedEmoji : MessageContent
    {
        /// <summary>
        /// The animated emoji
        /// </summary>
        public AnimatedEmoji AnimatedEmoji { get; set; }

        /// <summary>
        /// The corresponding emoji
        /// </summary>
        public string Emoji { get; set; }

    }

    /// <summary>
    /// A dice message. The dice value is randomly generated by the server
    /// </summary>
    public partial class MessageDice : MessageContent
    {
        /// <summary>
        /// The animated stickers with the initial dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
        /// </summary>
        public DiceStickers InitialState { get; set; }

        /// <summary>
        /// The animated stickers with the final dice animation; may be null if unknown. updateMessageContent will be sent when the sticker became known
        /// </summary>
        public DiceStickers FinalState { get; set; }

        /// <summary>
        /// Emoji on which the dice throw animation is based
        /// </summary>
        public string Emoji { get; set; }

        /// <summary>
        /// The dice value. If the value is 0, the dice don't have final state yet
        /// </summary>
        public int Value { get; set; }

        /// <summary>
        /// Number of frame after which a success animation like a shower of confetti needs to be shown on updateMessageSendSucceeded
        /// </summary>
        public int SuccessAnimationFrameNumber { get; set; }

    }

    /// <summary>
    /// A message with a game
    /// </summary>
    public partial class MessageGame : MessageContent
    {
        /// <summary>
        /// The game description
        /// </summary>
        public Game Game { get; set; }

    }

    /// <summary>
    /// A message with a poll
    /// </summary>
    public partial class MessagePoll : MessageContent
    {
        /// <summary>
        /// The poll description
        /// </summary>
        public Poll Poll { get; set; }

    }

    /// <summary>
    /// A message with an invoice from a bot
    /// </summary>
    public partial class MessageInvoice : MessageContent
    {
        /// <summary>
        /// Product title
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// A message with an invoice from a bot
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Product photo; may be null
        /// </summary>
        public Photo Photo { get; set; }

        /// <summary>
        /// Currency for the product price
        /// </summary>
        public string Currency { get; set; }

        /// <summary>
        /// Product total price in the smallest units of the currency
        /// </summary>
        public long TotalAmount { get; set; }

        /// <summary>
        /// Unique invoice bot start_parameter. To share an invoice use the URL https://t.me/{bot_username}?start={start_parameter}
        /// </summary>
        public string StartParameter { get; set; }

        /// <summary>
        /// True, if the invoice is a test invoice
        /// </summary>
        public bool IsTest { get; set; }

        /// <summary>
        /// True, if the shipping address must be specified
        /// </summary>
        public bool NeedShippingAddress { get; set; }

        /// <summary>
        /// The identifier of the message with the receipt, after the product has been purchased
        /// </summary>
        public long ReceiptMessageId { get; set; }

    }

    /// <summary>
    /// A message with information about an ended call
    /// </summary>
    public partial class MessageCall : MessageContent
    {
        /// <summary>
        /// True, if the call was a video call
        /// </summary>
        public bool IsVideo { get; set; }

        /// <summary>
        /// Reason why the call was discarded
        /// </summary>
        public CallDiscardReason DiscardReason { get; set; }

        /// <summary>
        /// Call duration, in seconds
        /// </summary>
        public int Duration { get; set; }

    }

    /// <summary>
    /// A new video chat was scheduled
    /// </summary>
    public partial class MessageVideoChatScheduled : MessageContent
    {
        /// <summary>
        /// Identifier of the video chat. The video chat can be received through the method getGroupCall
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the group call is supposed to be started by an administrator
        /// </summary>
        public int StartDate { get; set; }

    }

    /// <summary>
    /// A newly created video chat
    /// </summary>
    public partial class MessageVideoChatStarted : MessageContent
    {
        /// <summary>
        /// Identifier of the video chat. The video chat can be received through the method getGroupCall
        /// </summary>
        public int GroupCallId { get; set; }

    }

    /// <summary>
    /// A message with information about an ended video chat
    /// </summary>
    public partial class MessageVideoChatEnded : MessageContent
    {
        /// <summary>
        /// Call duration, in seconds
        /// </summary>
        public int Duration { get; set; }

    }

    /// <summary>
    /// A message with information about an invite to a video chat
    /// </summary>
    public partial class MessageInviteVideoChatParticipants : MessageContent
    {
        /// <summary>
        /// Identifier of the video chat. The video chat can be received through the method getGroupCall
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Invited user identifiers
        /// </summary>
        public long[] UserIds { get; set; }

    }

    /// <summary>
    /// A newly created basic group
    /// </summary>
    public partial class MessageBasicGroupChatCreate : MessageContent
    {
        /// <summary>
        /// Title of the basic group
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// User identifiers of members in the basic group
        /// </summary>
        public long[] MemberUserIds { get; set; }

    }

    /// <summary>
    /// A newly created supergroup or channel
    /// </summary>
    public partial class MessageSupergroupChatCreate : MessageContent
    {
        /// <summary>
        /// Title of the supergroup or channel
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// An updated chat title
    /// </summary>
    public partial class MessageChatChangeTitle : MessageContent
    {
        /// <summary>
        /// New chat title
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// An updated chat photo
    /// </summary>
    public partial class MessageChatChangePhoto : MessageContent
    {
        /// <summary>
        /// New chat photo
        /// </summary>
        public ChatPhoto Photo { get; set; }

    }

    /// <summary>
    /// A deleted chat photo
    /// </summary>
    public partial class MessageChatDeletePhoto : MessageContent
    {
    }

    /// <summary>
    /// New chat members were added
    /// </summary>
    public partial class MessageChatAddMembers : MessageContent
    {
        /// <summary>
        /// User identifiers of the new members
        /// </summary>
        public long[] MemberUserIds { get; set; }

    }

    /// <summary>
    /// A new member joined the chat by invite link
    /// </summary>
    public partial class MessageChatJoinByLink : MessageContent
    {
    }

    /// <summary>
    /// A new member was accepted to the chat by an administrator
    /// </summary>
    public partial class MessageChatJoinByRequest : MessageContent
    {
    }

    /// <summary>
    /// A chat member was deleted
    /// </summary>
    public partial class MessageChatDeleteMember : MessageContent
    {
        /// <summary>
        /// User identifier of the deleted chat member
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// A basic group was upgraded to a supergroup and was deactivated as the result
    /// </summary>
    public partial class MessageChatUpgradeTo : MessageContent
    {
        /// <summary>
        /// Identifier of the supergroup to which the basic group was upgraded
        /// </summary>
        public long SupergroupId { get; set; }

    }

    /// <summary>
    /// A supergroup has been created from a basic group
    /// </summary>
    public partial class MessageChatUpgradeFrom : MessageContent
    {
        /// <summary>
        /// Title of the newly created supergroup
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// The identifier of the original basic group
        /// </summary>
        public long BasicGroupId { get; set; }

    }

    /// <summary>
    /// A message has been pinned
    /// </summary>
    public partial class MessagePinMessage : MessageContent
    {
        /// <summary>
        /// Identifier of the pinned message, can be an identifier of a deleted message or 0
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// A screenshot of a message in the chat has been taken
    /// </summary>
    public partial class MessageScreenshotTaken : MessageContent
    {
    }

    /// <summary>
    /// A theme in the chat has been changed
    /// </summary>
    public partial class MessageChatSetTheme : MessageContent
    {
        /// <summary>
        /// If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset to the default one
        /// </summary>
        public string ThemeName { get; set; }

    }

    /// <summary>
    /// The TTL (Time To Live) setting for messages in the chat has been changed
    /// </summary>
    public partial class MessageChatSetTtl : MessageContent
    {
        /// <summary>
        /// New message TTL setting
        /// </summary>
        public int Ttl { get; set; }

    }

    /// <summary>
    /// A non-standard action has happened in the chat
    /// </summary>
    public partial class MessageCustomServiceAction : MessageContent
    {
        /// <summary>
        /// Message text to be shown in the chat
        /// </summary>
        public string Text { get; set; }

    }

    /// <summary>
    /// A new high score was achieved in a game
    /// </summary>
    public partial class MessageGameScore : MessageContent
    {
        /// <summary>
        /// Identifier of the message with the game, can be an identifier of a deleted message
        /// </summary>
        public long GameMessageId { get; set; }

        /// <summary>
        /// Identifier of the game; may be different from the games presented in the message with the game
        /// </summary>
        public long GameId { get; set; }

        /// <summary>
        /// New score
        /// </summary>
        public int Score { get; set; }

    }

    /// <summary>
    /// A payment has been completed
    /// </summary>
    public partial class MessagePaymentSuccessful : MessageContent
    {
        /// <summary>
        /// Identifier of the chat, containing the corresponding invoice message; 0 if unknown
        /// </summary>
        public long InvoiceChatId { get; set; }

        /// <summary>
        /// Identifier of the message with the corresponding invoice; can be an identifier of a deleted message
        /// </summary>
        public long InvoiceMessageId { get; set; }

        /// <summary>
        /// Currency for the price of the product
        /// </summary>
        public string Currency { get; set; }

        /// <summary>
        /// Total price for the product, in the smallest units of the currency
        /// </summary>
        public long TotalAmount { get; set; }

    }

    /// <summary>
    /// A payment has been completed; for bots only
    /// </summary>
    public partial class MessagePaymentSuccessfulBot : MessageContent
    {
        /// <summary>
        /// Currency for price of the product
        /// </summary>
        public string Currency { get; set; }

        /// <summary>
        /// Total price for the product, in the smallest units of the currency
        /// </summary>
        public long TotalAmount { get; set; }

        /// <summary>
        /// Invoice payload
        /// </summary>
        public Memory<byte> InvoicePayload { get; set; }

        /// <summary>
        /// Identifier of the shipping option chosen by the user; may be empty if not applicable
        /// </summary>
        public string ShippingOptionId { get; set; }

        /// <summary>
        /// Information about the order; may be null
        /// </summary>
        public OrderInfo OrderInfo { get; set; }

        /// <summary>
        /// Telegram payment identifier
        /// </summary>
        public string TelegramPaymentChargeId { get; set; }

        /// <summary>
        /// Provider payment identifier
        /// </summary>
        public string ProviderPaymentChargeId { get; set; }

    }

    /// <summary>
    /// A contact has registered with Telegram
    /// </summary>
    public partial class MessageContactRegistered : MessageContent
    {
    }

    /// <summary>
    /// The current user has connected a website by logging in using Telegram Login Widget on it
    /// </summary>
    public partial class MessageWebsiteConnected : MessageContent
    {
        /// <summary>
        /// Domain name of the connected website
        /// </summary>
        public string DomainName { get; set; }

    }

    /// <summary>
    /// Telegram Passport data has been sent
    /// </summary>
    public partial class MessagePassportDataSent : MessageContent
    {
        /// <summary>
        /// List of Telegram Passport element types sent
        /// </summary>
        public PassportElementType[] Types { get; set; }

    }

    /// <summary>
    /// Telegram Passport data has been received; for bots only
    /// </summary>
    public partial class MessagePassportDataReceived : MessageContent
    {
        /// <summary>
        /// List of received Telegram Passport elements
        /// </summary>
        public EncryptedPassportElement[] Elements { get; set; }

        /// <summary>
        /// Encrypted data credentials
        /// </summary>
        public EncryptedCredentials Credentials { get; set; }

    }

    /// <summary>
    /// A user in the chat came within proximity alert range
    /// </summary>
    public partial class MessageProximityAlertTriggered : MessageContent
    {
        /// <summary>
        /// The user or chat, which triggered the proximity alert
        /// </summary>
        public MessageSender Traveler { get; set; }

        /// <summary>
        /// The user or chat, which subscribed for the proximity alert
        /// </summary>
        public MessageSender Watcher { get; set; }

        /// <summary>
        /// The distance between the users
        /// </summary>
        public int Distance { get; set; }

    }

    /// <summary>
    /// Message content that is not supported in the current TDLib version
    /// </summary>
    public partial class MessageUnsupported : MessageContent
    {
    }

    /// <summary>
    /// A mention of a user by their username
    /// </summary>
    public partial class TextEntityTypeMention : TextEntityType
    {
    }

    /// <summary>
    /// A hashtag text, beginning with "#"
    /// </summary>
    public partial class TextEntityTypeHashtag : TextEntityType
    {
    }

    /// <summary>
    /// A cashtag text, beginning with "$" and consisting of capital English letters (e.g., "$USD")
    /// </summary>
    public partial class TextEntityTypeCashtag : TextEntityType
    {
    }

    /// <summary>
    /// A bot command, beginning with "/"
    /// </summary>
    public partial class TextEntityTypeBotCommand : TextEntityType
    {
    }

    /// <summary>
    /// An HTTP URL
    /// </summary>
    public partial class TextEntityTypeUrl : TextEntityType
    {
    }

    /// <summary>
    /// An email address
    /// </summary>
    public partial class TextEntityTypeEmailAddress : TextEntityType
    {
    }

    /// <summary>
    /// A phone number
    /// </summary>
    public partial class TextEntityTypePhoneNumber : TextEntityType
    {
    }

    /// <summary>
    /// A bank card number. The getBankCardInfo method can be used to get information about the bank card
    /// </summary>
    public partial class TextEntityTypeBankCardNumber : TextEntityType
    {
    }

    /// <summary>
    /// A bold text
    /// </summary>
    public partial class TextEntityTypeBold : TextEntityType
    {
    }

    /// <summary>
    /// An italic text
    /// </summary>
    public partial class TextEntityTypeItalic : TextEntityType
    {
    }

    /// <summary>
    /// An underlined text
    /// </summary>
    public partial class TextEntityTypeUnderline : TextEntityType
    {
    }

    /// <summary>
    /// A strikethrough text
    /// </summary>
    public partial class TextEntityTypeStrikethrough : TextEntityType
    {
    }

    /// <summary>
    /// Text that must be formatted as if inside a code HTML tag
    /// </summary>
    public partial class TextEntityTypeCode : TextEntityType
    {
    }

    /// <summary>
    /// Text that must be formatted as if inside a pre HTML tag
    /// </summary>
    public partial class TextEntityTypePre : TextEntityType
    {
    }

    /// <summary>
    /// Text that must be formatted as if inside pre, and code HTML tags
    /// </summary>
    public partial class TextEntityTypePreCode : TextEntityType
    {
        /// <summary>
        /// Programming language of the code; as defined by the sender
        /// </summary>
        public string Language { get; set; }

    }

    /// <summary>
    /// A text description shown instead of a raw URL
    /// </summary>
    public partial class TextEntityTypeTextUrl : TextEntityType
    {
        /// <summary>
        /// HTTP or tg:// URL to be opened when the link is clicked
        /// </summary>
        public string Url { get; set; }

    }

    /// <summary>
    /// A text shows instead of a raw mention of the user (e.g., when the user has no username)
    /// </summary>
    public partial class TextEntityTypeMentionName : TextEntityType
    {
        /// <summary>
        /// Identifier of the mentioned user
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// A media timestamp
    /// </summary>
    public partial class TextEntityTypeMediaTimestamp : TextEntityType
    {
        /// <summary>
        /// Timestamp from which a video/audio/video note/voice note playing must start, in seconds. The media can be in the content or the web page preview of the current message, or in the same places in the replied message
        /// </summary>
        public int MediaTimestamp { get; set; }

    }

    /// <summary>
    /// A thumbnail to be sent along with a file; must be in JPEG or WEBP format for stickers, and less than 200 KB in size
    /// </summary>
    public partial class InputThumbnail : TLObject
    {
        /// <summary>
        /// Thumbnail file to send. Sending thumbnails by file_id is currently not supported
        /// </summary>
        public InputFile Thumbnail { get; set; }

        /// <summary>
        /// Thumbnail width, usually shouldn't exceed 320. Use 0 if unknown
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Thumbnail height, usually shouldn't exceed 320. Use 0 if unknown
        /// </summary>
        public int Height { get; set; }

    }

    /// <summary>
    /// The message will be sent at the specified date
    /// </summary>
    public partial class MessageSchedulingStateSendAtDate : MessageSchedulingState
    {
        /// <summary>
        /// Date the message will be sent. The date must be within 367 days in the future
        /// </summary>
        public int SendDate { get; set; }

    }

    /// <summary>
    /// The message will be sent when the peer will be online. Applicable to private chats only and when the exact online status of the peer is known
    /// </summary>
    public partial class MessageSchedulingStateSendWhenOnline : MessageSchedulingState
    {
    }

    /// <summary>
    /// Options to be used when a message is sent
    /// </summary>
    public partial class MessageSendOptions : TLObject
    {
        /// <summary>
        /// Pass true to disable notification for the message
        /// </summary>
        public bool DisableNotification { get; set; }

        /// <summary>
        /// Pass true if the message is sent from the background
        /// </summary>
        public bool FromBackground { get; set; }

        /// <summary>
        /// Message scheduling state; pass null to send message immediately. Messages sent to a secret chat, live location messages and self-destructing messages can't be scheduled
        /// </summary>
        public MessageSchedulingState SchedulingState { get; set; }

    }

    /// <summary>
    /// Options to be used when a message content is copied without reference to the original sender. Service messages and messageInvoice can't be copied
    /// </summary>
    public partial class MessageCopyOptions : TLObject
    {
        /// <summary>
        /// True, if content of the message needs to be copied without reference to the original sender. Always true if the message is forwarded to a secret chat or is local
        /// </summary>
        public bool SendCopy { get; set; }

        /// <summary>
        /// True, if media caption of the message copy needs to be replaced. Ignored if send_copy is false
        /// </summary>
        public bool ReplaceCaption { get; set; }

        /// <summary>
        /// New message caption; pass null to copy message without caption. Ignored if replace_caption is false
        /// </summary>
        public FormattedText NewCaption { get; set; }

    }

    /// <summary>
    /// A text message
    /// </summary>
    public partial class InputMessageText : InputMessageContent
    {
        /// <summary>
        /// Formatted text to be sent; 1-GetOption("message_text_length_max") characters. Only Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and MentionName entities are allowed to be specified manually
        /// </summary>
        public FormattedText Text { get; set; }

        /// <summary>
        /// True, if rich web page previews for URLs in the message text must be disabled
        /// </summary>
        public bool DisableWebPagePreview { get; set; }

        /// <summary>
        /// True, if a chat message draft must be deleted
        /// </summary>
        public bool ClearDraft { get; set; }

    }

    /// <summary>
    /// An animation message (GIF-style).
    /// </summary>
    public partial class InputMessageAnimation : InputMessageContent
    {
        /// <summary>
        /// Animation file to be sent
        /// </summary>
        public InputFile Animation { get; set; }

        /// <summary>
        /// Animation thumbnail; pass null to skip thumbnail uploading
        /// </summary>
        public InputThumbnail Thumbnail { get; set; }

        /// <summary>
        /// File identifiers of the stickers added to the animation, if applicable
        /// </summary>
        public int[] AddedStickerFileIds { get; set; }

        /// <summary>
        /// Duration of the animation, in seconds
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// Width of the animation; may be replaced by the server
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Height of the animation; may be replaced by the server
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// Animation caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
        /// </summary>
        public FormattedText Caption { get; set; }

    }

    /// <summary>
    /// An audio message
    /// </summary>
    public partial class InputMessageAudio : InputMessageContent
    {
        /// <summary>
        /// Audio file to be sent
        /// </summary>
        public InputFile Audio { get; set; }

        /// <summary>
        /// Thumbnail of the cover for the album; pass null to skip thumbnail uploading
        /// </summary>
        public InputThumbnail AlbumCoverThumbnail { get; set; }

        /// <summary>
        /// Duration of the audio, in seconds; may be replaced by the server
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// Title of the audio; 0-64 characters; may be replaced by the server
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Performer of the audio; 0-64 characters, may be replaced by the server
        /// </summary>
        public string Performer { get; set; }

        /// <summary>
        /// Audio caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
        /// </summary>
        public FormattedText Caption { get; set; }

    }

    /// <summary>
    /// A document message (general file)
    /// </summary>
    public partial class InputMessageDocument : InputMessageContent
    {
        /// <summary>
        /// Document to be sent
        /// </summary>
        public InputFile Document { get; set; }

        /// <summary>
        /// Document thumbnail; pass null to skip thumbnail uploading
        /// </summary>
        public InputThumbnail Thumbnail { get; set; }

        /// <summary>
        /// If true, automatic file type detection will be disabled and the document will be always sent as file. Always true for files sent to secret chats
        /// </summary>
        public bool DisableContentTypeDetection { get; set; }

        /// <summary>
        /// Document caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
        /// </summary>
        public FormattedText Caption { get; set; }

    }

    /// <summary>
    /// A photo message
    /// </summary>
    public partial class InputMessagePhoto : InputMessageContent
    {
        /// <summary>
        /// Photo to send
        /// </summary>
        public InputFile Photo { get; set; }

        /// <summary>
        /// Photo thumbnail to be sent; pass null to skip thumbnail uploading. The thumbnail is sent to the other party only in secret chats
        /// </summary>
        public InputThumbnail Thumbnail { get; set; }

        /// <summary>
        /// File identifiers of the stickers added to the photo, if applicable
        /// </summary>
        public int[] AddedStickerFileIds { get; set; }

        /// <summary>
        /// Photo width
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Photo height
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// Photo caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
        /// </summary>
        public FormattedText Caption { get; set; }

        /// <summary>
        /// Photo TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats
        /// </summary>
        public int Ttl { get; set; }

    }

    /// <summary>
    /// A sticker message
    /// </summary>
    public partial class InputMessageSticker : InputMessageContent
    {
        /// <summary>
        /// Sticker to be sent
        /// </summary>
        public InputFile Sticker { get; set; }

        /// <summary>
        /// Sticker thumbnail; pass null to skip thumbnail uploading
        /// </summary>
        public InputThumbnail Thumbnail { get; set; }

        /// <summary>
        /// Sticker width
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Sticker height
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// Emoji used to choose the sticker
        /// </summary>
        public string Emoji { get; set; }

    }

    /// <summary>
    /// A video message
    /// </summary>
    public partial class InputMessageVideo : InputMessageContent
    {
        /// <summary>
        /// Video to be sent
        /// </summary>
        public InputFile Video { get; set; }

        /// <summary>
        /// Video thumbnail; pass null to skip thumbnail uploading
        /// </summary>
        public InputThumbnail Thumbnail { get; set; }

        /// <summary>
        /// File identifiers of the stickers added to the video, if applicable
        /// </summary>
        public int[] AddedStickerFileIds { get; set; }

        /// <summary>
        /// Duration of the video, in seconds
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// Video width
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Video height
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// True, if the video is supposed to be streamed
        /// </summary>
        public bool SupportsStreaming { get; set; }

        /// <summary>
        /// Video caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
        /// </summary>
        public FormattedText Caption { get; set; }

        /// <summary>
        /// Video TTL (Time To Live), in seconds (0-60). A non-zero TTL can be specified only in private chats
        /// </summary>
        public int Ttl { get; set; }

    }

    /// <summary>
    /// A video note message
    /// </summary>
    public partial class InputMessageVideoNote : InputMessageContent
    {
        /// <summary>
        /// Video note to be sent
        /// </summary>
        public InputFile VideoNote { get; set; }

        /// <summary>
        /// Video thumbnail; pass null to skip thumbnail uploading
        /// </summary>
        public InputThumbnail Thumbnail { get; set; }

        /// <summary>
        /// Duration of the video, in seconds
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// Video width and height; must be positive and not greater than 640
        /// </summary>
        public int Length { get; set; }

    }

    /// <summary>
    /// A voice note message
    /// </summary>
    public partial class InputMessageVoiceNote : InputMessageContent
    {
        /// <summary>
        /// Voice note to be sent
        /// </summary>
        public InputFile VoiceNote { get; set; }

        /// <summary>
        /// Duration of the voice note, in seconds
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// Waveform representation of the voice note, in 5-bit format
        /// </summary>
        public Memory<byte> Waveform { get; set; }

        /// <summary>
        /// Voice note caption; pass null to use an empty caption; 0-GetOption("message_caption_length_max") characters
        /// </summary>
        public FormattedText Caption { get; set; }

    }

    /// <summary>
    /// A message with a location
    /// </summary>
    public partial class InputMessageLocation : InputMessageContent
    {
        /// <summary>
        /// Location to be sent
        /// </summary>
        public Location Location { get; set; }

        /// <summary>
        /// Period for which the location can be updated, in seconds; must be between 60 and 86400 for a live location and 0 otherwise
        /// </summary>
        public int LivePeriod { get; set; }

        /// <summary>
        /// For live locations, a direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
        /// </summary>
        public int Heading { get; set; }

        /// <summary>
        /// For live locations, a maximum distance to another chat member for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled. Can't be enabled in channels and Saved Messages
        /// </summary>
        public int ProximityAlertRadius { get; set; }

    }

    /// <summary>
    /// A message with information about a venue
    /// </summary>
    public partial class InputMessageVenue : InputMessageContent
    {
        /// <summary>
        /// Venue to send
        /// </summary>
        public Venue Venue { get; set; }

    }

    /// <summary>
    /// A message containing a user contact
    /// </summary>
    public partial class InputMessageContact : InputMessageContent
    {
        /// <summary>
        /// Contact to send
        /// </summary>
        public Contact Contact { get; set; }

    }

    /// <summary>
    /// A dice message
    /// </summary>
    public partial class InputMessageDice : InputMessageContent
    {
        /// <summary>
        /// Emoji on which the dice throw animation is based
        /// </summary>
        public string Emoji { get; set; }

        /// <summary>
        /// True, if the chat message draft must be deleted
        /// </summary>
        public bool ClearDraft { get; set; }

    }

    /// <summary>
    /// A message with a game; not supported for channels or secret chats
    /// </summary>
    public partial class InputMessageGame : InputMessageContent
    {
        /// <summary>
        /// User identifier of the bot that owns the game
        /// </summary>
        public long BotUserId { get; set; }

        /// <summary>
        /// Short name of the game
        /// </summary>
        public string GameShortName { get; set; }

    }

    /// <summary>
    /// A message with an invoice; can be used only by bots
    /// </summary>
    public partial class InputMessageInvoice : InputMessageContent
    {
        /// <summary>
        /// Invoice
        /// </summary>
        public Invoice Invoice { get; set; }

        /// <summary>
        /// Product title; 1-32 characters
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// A message with an invoice; can be used only by bots
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Product photo URL; optional
        /// </summary>
        public string PhotoUrl { get; set; }

        /// <summary>
        /// Product photo size
        /// </summary>
        public int PhotoSize { get; set; }

        /// <summary>
        /// Product photo width
        /// </summary>
        public int PhotoWidth { get; set; }

        /// <summary>
        /// Product photo height
        /// </summary>
        public int PhotoHeight { get; set; }

        /// <summary>
        /// The invoice payload
        /// </summary>
        public Memory<byte> Payload { get; set; }

        /// <summary>
        /// Payment provider token
        /// </summary>
        public string ProviderToken { get; set; }

        /// <summary>
        /// JSON-encoded data about the invoice, which will be shared with the payment provider
        /// </summary>
        public string ProviderData { get; set; }

        /// <summary>
        /// Unique invoice bot deep link parameter for the generation of this invoice. If empty, it would be possible to pay directly from forwards of the invoice message
        /// </summary>
        public string StartParameter { get; set; }

    }

    /// <summary>
    /// A message with a poll. Polls can't be sent to secret chats. Polls can be sent only to a private chat with a bot
    /// </summary>
    public partial class InputMessagePoll : InputMessageContent
    {
        /// <summary>
        /// Poll question; 1-255 characters (up to 300 characters for bots)
        /// </summary>
        public string Question { get; set; }

        /// <summary>
        /// List of poll answer options, 2-10 strings 1-100 characters each
        /// </summary>
        public string[] Options { get; set; }

        /// <summary>
        /// True, if the poll voters are anonymous. Non-anonymous polls can't be sent or forwarded to channels
        /// </summary>
        public bool IsAnonymous { get; set; }

        /// <summary>
        /// Type of the poll
        /// </summary>
        public PollType Type { get; set; }

        /// <summary>
        /// Amount of time the poll will be active after creation, in seconds; for bots only
        /// </summary>
        public int OpenPeriod { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the poll will be automatically closed; for bots only
        /// </summary>
        public int CloseDate { get; set; }

        /// <summary>
        /// True, if the poll needs to be sent already closed; for bots only
        /// </summary>
        public bool IsClosed { get; set; }

    }

    /// <summary>
    /// A forwarded message
    /// </summary>
    public partial class InputMessageForwarded : InputMessageContent
    {
        /// <summary>
        /// Identifier for the chat this forwarded message came from
        /// </summary>
        public long FromChatId { get; set; }

        /// <summary>
        /// Identifier of the message to forward
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// True, if a game message is being shared from a launched game; applies only to game messages
        /// </summary>
        public bool InGameShare { get; set; }

        /// <summary>
        /// Options to be used to copy content of the message without reference to the original sender; pass null to try to forward the message as usual
        /// </summary>
        public MessageCopyOptions CopyOptions { get; set; }

    }

    /// <summary>
    /// Returns all found messages, no filter is applied
    /// </summary>
    public partial class SearchMessagesFilterEmpty : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only animation messages
    /// </summary>
    public partial class SearchMessagesFilterAnimation : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only audio messages
    /// </summary>
    public partial class SearchMessagesFilterAudio : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only document messages
    /// </summary>
    public partial class SearchMessagesFilterDocument : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only photo messages
    /// </summary>
    public partial class SearchMessagesFilterPhoto : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only video messages
    /// </summary>
    public partial class SearchMessagesFilterVideo : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only voice note messages
    /// </summary>
    public partial class SearchMessagesFilterVoiceNote : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only photo and video messages
    /// </summary>
    public partial class SearchMessagesFilterPhotoAndVideo : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only messages containing URLs
    /// </summary>
    public partial class SearchMessagesFilterUrl : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only messages containing chat photos
    /// </summary>
    public partial class SearchMessagesFilterChatPhoto : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only call messages
    /// </summary>
    public partial class SearchMessagesFilterCall : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only incoming call messages with missed/declined discard reasons
    /// </summary>
    public partial class SearchMessagesFilterMissedCall : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only video note messages
    /// </summary>
    public partial class SearchMessagesFilterVideoNote : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only voice and video note messages
    /// </summary>
    public partial class SearchMessagesFilterVoiceAndVideoNote : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only messages with mentions of the current user, or messages that are replies to their messages
    /// </summary>
    public partial class SearchMessagesFilterMention : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only messages with unread mentions of the current user, or messages that are replies to their messages. When using this filter the results can't be additionally filtered by a query, a message thread or by the sending user
    /// </summary>
    public partial class SearchMessagesFilterUnreadMention : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only failed to send messages. This filter can be used only if the message database is used
    /// </summary>
    public partial class SearchMessagesFilterFailedToSend : SearchMessagesFilter
    {
    }

    /// <summary>
    /// Returns only pinned messages
    /// </summary>
    public partial class SearchMessagesFilterPinned : SearchMessagesFilter
    {
    }

    /// <summary>
    /// The user is typing a message
    /// </summary>
    public partial class ChatActionTyping : ChatAction
    {
    }

    /// <summary>
    /// The user is recording a video
    /// </summary>
    public partial class ChatActionRecordingVideo : ChatAction
    {
    }

    /// <summary>
    /// The user is uploading a video
    /// </summary>
    public partial class ChatActionUploadingVideo : ChatAction
    {
        /// <summary>
        /// Upload progress, as a percentage
        /// </summary>
        public int Progress { get; set; }

    }

    /// <summary>
    /// The user is recording a voice note
    /// </summary>
    public partial class ChatActionRecordingVoiceNote : ChatAction
    {
    }

    /// <summary>
    /// The user is uploading a voice note
    /// </summary>
    public partial class ChatActionUploadingVoiceNote : ChatAction
    {
        /// <summary>
        /// Upload progress, as a percentage
        /// </summary>
        public int Progress { get; set; }

    }

    /// <summary>
    /// The user is uploading a photo
    /// </summary>
    public partial class ChatActionUploadingPhoto : ChatAction
    {
        /// <summary>
        /// Upload progress, as a percentage
        /// </summary>
        public int Progress { get; set; }

    }

    /// <summary>
    /// The user is uploading a document
    /// </summary>
    public partial class ChatActionUploadingDocument : ChatAction
    {
        /// <summary>
        /// Upload progress, as a percentage
        /// </summary>
        public int Progress { get; set; }

    }

    /// <summary>
    /// The user is picking a sticker to send
    /// </summary>
    public partial class ChatActionChoosingSticker : ChatAction
    {
    }

    /// <summary>
    /// The user is picking a location or venue to send
    /// </summary>
    public partial class ChatActionChoosingLocation : ChatAction
    {
    }

    /// <summary>
    /// The user is picking a contact to send
    /// </summary>
    public partial class ChatActionChoosingContact : ChatAction
    {
    }

    /// <summary>
    /// The user has started to play a game
    /// </summary>
    public partial class ChatActionStartPlayingGame : ChatAction
    {
    }

    /// <summary>
    /// The user is recording a video note
    /// </summary>
    public partial class ChatActionRecordingVideoNote : ChatAction
    {
    }

    /// <summary>
    /// The user is uploading a video note
    /// </summary>
    public partial class ChatActionUploadingVideoNote : ChatAction
    {
        /// <summary>
        /// Upload progress, as a percentage
        /// </summary>
        public int Progress { get; set; }

    }

    /// <summary>
    /// The user is watching animations sent by the other party by clicking on an animated emoji
    /// </summary>
    public partial class ChatActionWatchingAnimations : ChatAction
    {
        /// <summary>
        /// The animated emoji
        /// </summary>
        public string Emoji { get; set; }

    }

    /// <summary>
    /// The user has canceled the previous action
    /// </summary>
    public partial class ChatActionCancel : ChatAction
    {
    }

    /// <summary>
    /// The user status was never changed
    /// </summary>
    public partial class UserStatusEmpty : UserStatus
    {
    }

    /// <summary>
    /// The user is online
    /// </summary>
    public partial class UserStatusOnline : UserStatus
    {
        /// <summary>
        /// Point in time (Unix timestamp) when the user's online status will expire
        /// </summary>
        public int Expires { get; set; }

    }

    /// <summary>
    /// The user is offline
    /// </summary>
    public partial class UserStatusOffline : UserStatus
    {
        /// <summary>
        /// Point in time (Unix timestamp) when the user was last online
        /// </summary>
        public int WasOnline { get; set; }

    }

    /// <summary>
    /// The user was online recently
    /// </summary>
    public partial class UserStatusRecently : UserStatus
    {
    }

    /// <summary>
    /// The user is offline, but was online last week
    /// </summary>
    public partial class UserStatusLastWeek : UserStatus
    {
    }

    /// <summary>
    /// The user is offline, but was online last month
    /// </summary>
    public partial class UserStatusLastMonth : UserStatus
    {
    }

    /// <summary>
    /// Represents a list of stickers
    /// </summary>
    public partial class Stickers : TLObject
    {
        /// <summary>
        /// List of stickers
        /// </summary>
        public Sticker[] Stickers_ { get; set; }

    }

    /// <summary>
    /// Represents a list of emoji
    /// </summary>
    public partial class Emojis : TLObject
    {
        /// <summary>
        /// List of emojis
        /// </summary>
        public string[] Emojis_ { get; set; }

    }

    /// <summary>
    /// Represents a sticker set
    /// </summary>
    public partial class StickerSet : TLObject
    {
        /// <summary>
        /// Identifier of the sticker set
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Title of the sticker set
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Name of the sticker set
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Sticker set thumbnail in WEBP or TGS format with width and height 100; may be null. The file can be downloaded only before the thumbnail is changed
        /// </summary>
        public Thumbnail Thumbnail { get; set; }

        /// <summary>
        /// Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
        /// </summary>
        public ClosedVectorPath[] ThumbnailOutline { get; set; }

        /// <summary>
        /// True, if the sticker set has been installed by the current user
        /// </summary>
        public bool IsInstalled { get; set; }

        /// <summary>
        /// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
        /// </summary>
        public bool IsArchived { get; set; }

        /// <summary>
        /// True, if the sticker set is official
        /// </summary>
        public bool IsOfficial { get; set; }

        /// <summary>
        /// True, is the stickers in the set are animated
        /// </summary>
        public bool IsAnimated { get; set; }

        /// <summary>
        /// True, if the stickers in the set are masks
        /// </summary>
        public bool IsMasks { get; set; }

        /// <summary>
        /// True for already viewed trending sticker sets
        /// </summary>
        public bool IsViewed { get; set; }

        /// <summary>
        /// List of stickers in this set
        /// </summary>
        public Sticker[] Stickers { get; set; }

        /// <summary>
        /// A list of emoji corresponding to the stickers in the same order. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
        /// </summary>
        public Emojis[] Emojis { get; set; }

    }

    /// <summary>
    /// Represents short information about a sticker set
    /// </summary>
    public partial class StickerSetInfo : TLObject
    {
        /// <summary>
        /// Identifier of the sticker set
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Title of the sticker set
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Name of the sticker set
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Sticker set thumbnail in WEBP or TGS format with width and height 100; may be null
        /// </summary>
        public Thumbnail Thumbnail { get; set; }

        /// <summary>
        /// Sticker set thumbnail's outline represented as a list of closed vector paths; may be empty. The coordinate system origin is in the upper-left corner
        /// </summary>
        public ClosedVectorPath[] ThumbnailOutline { get; set; }

        /// <summary>
        /// True, if the sticker set has been installed by the current user
        /// </summary>
        public bool IsInstalled { get; set; }

        /// <summary>
        /// True, if the sticker set has been archived. A sticker set can't be installed and archived simultaneously
        /// </summary>
        public bool IsArchived { get; set; }

        /// <summary>
        /// True, if the sticker set is official
        /// </summary>
        public bool IsOfficial { get; set; }

        /// <summary>
        /// True, is the stickers in the set are animated
        /// </summary>
        public bool IsAnimated { get; set; }

        /// <summary>
        /// True, if the stickers in the set are masks
        /// </summary>
        public bool IsMasks { get; set; }

        /// <summary>
        /// True for already viewed trending sticker sets
        /// </summary>
        public bool IsViewed { get; set; }

        /// <summary>
        /// Total number of stickers in the set
        /// </summary>
        public int Size { get; set; }

        /// <summary>
        /// Up to the first 5 stickers from the set, depending on the context. If the application needs more stickers the full sticker set needs to be requested
        /// </summary>
        public Sticker[] Covers { get; set; }

    }

    /// <summary>
    /// Represents a list of sticker sets
    /// </summary>
    public partial class StickerSets : TLObject
    {
        /// <summary>
        /// Approximate total number of sticker sets found
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// List of sticker sets
        /// </summary>
        public StickerSetInfo[] Sets { get; set; }

    }

    /// <summary>
    /// The call wasn't discarded, or the reason is unknown
    /// </summary>
    public partial class CallDiscardReasonEmpty : CallDiscardReason
    {
    }

    /// <summary>
    /// The call was ended before the conversation started. It was canceled by the caller or missed by the other party
    /// </summary>
    public partial class CallDiscardReasonMissed : CallDiscardReason
    {
    }

    /// <summary>
    /// The call was ended before the conversation started. It was declined by the other party
    /// </summary>
    public partial class CallDiscardReasonDeclined : CallDiscardReason
    {
    }

    /// <summary>
    /// The call was ended during the conversation because the users were disconnected
    /// </summary>
    public partial class CallDiscardReasonDisconnected : CallDiscardReason
    {
    }

    /// <summary>
    /// The call was ended because one of the parties hung up
    /// </summary>
    public partial class CallDiscardReasonHungUp : CallDiscardReason
    {
    }

    /// <summary>
    /// Specifies the supported call protocols
    /// </summary>
    public partial class CallProtocol : TLObject
    {
        /// <summary>
        /// True, if UDP peer-to-peer connections are supported
        /// </summary>
        public bool UdpP2p { get; set; }

        /// <summary>
        /// True, if connection through UDP reflectors is supported
        /// </summary>
        public bool UdpReflector { get; set; }

        /// <summary>
        /// The minimum supported API layer; use 65
        /// </summary>
        public int MinLayer { get; set; }

        /// <summary>
        /// The maximum supported API layer; use 65
        /// </summary>
        public int MaxLayer { get; set; }

        /// <summary>
        /// List of supported tgcalls versions
        /// </summary>
        public string[] LibraryVersions { get; set; }

    }

    /// <summary>
    /// A Telegram call reflector
    /// </summary>
    public partial class CallServerTypeTelegramReflector : CallServerType
    {
        /// <summary>
        /// A peer tag to be used with the reflector
        /// </summary>
        public Memory<byte> PeerTag { get; set; }

    }

    /// <summary>
    /// A WebRTC server
    /// </summary>
    public partial class CallServerTypeWebrtc : CallServerType
    {
        /// <summary>
        /// Username to be used for authentication
        /// </summary>
        public string Username { get; set; }

        /// <summary>
        /// Authentication password
        /// </summary>
        public string Password { get; set; }

        /// <summary>
        /// True, if the server supports TURN
        /// </summary>
        public bool SupportsTurn { get; set; }

        /// <summary>
        /// True, if the server supports STUN
        /// </summary>
        public bool SupportsStun { get; set; }

    }

    /// <summary>
    /// Describes a server for relaying call data
    /// </summary>
    public partial class CallServer : TLObject
    {
        /// <summary>
        /// Server identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Server IPv4 address
        /// </summary>
        public string IpAddress { get; set; }

        /// <summary>
        /// Server IPv6 address
        /// </summary>
        public string Ipv6Address { get; set; }

        /// <summary>
        /// Server port number
        /// </summary>
        public int Port { get; set; }

        /// <summary>
        /// Server type
        /// </summary>
        public CallServerType Type { get; set; }

    }

    /// <summary>
    /// Contains the call identifier
    /// </summary>
    public partial class CallId : TLObject
    {
        /// <summary>
        /// Call identifier
        /// </summary>
        public int Id { get; set; }

    }

    /// <summary>
    /// Contains the group call identifier
    /// </summary>
    public partial class GroupCallId : TLObject
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int Id { get; set; }

    }

    /// <summary>
    /// The call is pending, waiting to be accepted by a user
    /// </summary>
    public partial class CallStatePending : CallState
    {
        /// <summary>
        /// True, if the call has already been created by the server
        /// </summary>
        public bool IsCreated { get; set; }

        /// <summary>
        /// True, if the call has already been received by the other party
        /// </summary>
        public bool IsReceived { get; set; }

    }

    /// <summary>
    /// The call has been answered and encryption keys are being exchanged
    /// </summary>
    public partial class CallStateExchangingKeys : CallState
    {
    }

    /// <summary>
    /// The call is ready to use
    /// </summary>
    public partial class CallStateReady : CallState
    {
        /// <summary>
        /// Call protocols supported by the peer
        /// </summary>
        public CallProtocol Protocol { get; set; }

        /// <summary>
        /// List of available call servers
        /// </summary>
        public CallServer[] Servers { get; set; }

        /// <summary>
        /// A JSON-encoded call config
        /// </summary>
        public string Config { get; set; }

        /// <summary>
        /// Call encryption key
        /// </summary>
        public Memory<byte> EncryptionKey { get; set; }

        /// <summary>
        /// Encryption key emojis fingerprint
        /// </summary>
        public string[] Emojis { get; set; }

        /// <summary>
        /// True, if peer-to-peer connection is allowed by users privacy settings
        /// </summary>
        public bool AllowP2p { get; set; }

    }

    /// <summary>
    /// The call is hanging up after discardCall has been called
    /// </summary>
    public partial class CallStateHangingUp : CallState
    {
    }

    /// <summary>
    /// The call has ended successfully
    /// </summary>
    public partial class CallStateDiscarded : CallState
    {
        /// <summary>
        /// The reason, why the call has ended
        /// </summary>
        public CallDiscardReason Reason { get; set; }

        /// <summary>
        /// True, if the call rating must be sent to the server
        /// </summary>
        public bool NeedRating { get; set; }

        /// <summary>
        /// True, if the call debug information must be sent to the server
        /// </summary>
        public bool NeedDebugInformation { get; set; }

    }

    /// <summary>
    /// The call has ended with an error
    /// </summary>
    public partial class CallStateError : CallState
    {
        /// <summary>
        /// Error. An error with the code 4005000 will be returned if an outgoing call is missed because of an expired timeout
        /// </summary>
        public Error Error { get; set; }

    }

    /// <summary>
    /// The worst available video quality
    /// </summary>
    public partial class GroupCallVideoQualityThumbnail : GroupCallVideoQuality
    {
    }

    /// <summary>
    /// The medium video quality
    /// </summary>
    public partial class GroupCallVideoQualityMedium : GroupCallVideoQuality
    {
    }

    /// <summary>
    /// The best available video quality
    /// </summary>
    public partial class GroupCallVideoQualityFull : GroupCallVideoQuality
    {
    }

    /// <summary>
    /// Describes a recently speaking participant in a group call
    /// </summary>
    public partial class GroupCallRecentSpeaker : TLObject
    {
        /// <summary>
        /// Group call participant identifier
        /// </summary>
        public MessageSender ParticipantId { get; set; }

        /// <summary>
        /// True, is the user has spoken recently
        /// </summary>
        public bool IsSpeaking { get; set; }

    }

    /// <summary>
    /// Describes a group call
    /// </summary>
    public partial class GroupCall : TLObject
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Group call title
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 if it is already active or was ended
        /// </summary>
        public int ScheduledStartDate { get; set; }

        /// <summary>
        /// True, if the group call is scheduled and the current user will receive a notification when the group call will start
        /// </summary>
        public bool EnabledStartNotification { get; set; }

        /// <summary>
        /// True, if the call is active
        /// </summary>
        public bool IsActive { get; set; }

        /// <summary>
        /// True, if the call is joined
        /// </summary>
        public bool IsJoined { get; set; }

        /// <summary>
        /// True, if user was kicked from the call because of network loss and the call needs to be rejoined
        /// </summary>
        public bool NeedRejoin { get; set; }

        /// <summary>
        /// True, if the current user can manage the group call
        /// </summary>
        public bool CanBeManaged { get; set; }

        /// <summary>
        /// Number of participants in the group call
        /// </summary>
        public int ParticipantCount { get; set; }

        /// <summary>
        /// True, if all group call participants are loaded
        /// </summary>
        public bool LoadedAllParticipants { get; set; }

        /// <summary>
        /// Recently speaking users in the group call
        /// </summary>
        public GroupCallRecentSpeaker[] RecentSpeakers { get; set; }

        /// <summary>
        /// True, if the current user's video is enabled
        /// </summary>
        public bool IsMyVideoEnabled { get; set; }

        /// <summary>
        /// True, if the current user's video is paused
        /// </summary>
        public bool IsMyVideoPaused { get; set; }

        /// <summary>
        /// True, if the current user can broadcast video or share screen
        /// </summary>
        public bool CanEnableVideo { get; set; }

        /// <summary>
        /// True, if only group call administrators can unmute new participants
        /// </summary>
        public bool MuteNewParticipants { get; set; }

        /// <summary>
        /// True, if the current user can enable or disable mute_new_participants setting
        /// </summary>
        public bool CanToggleMuteNewParticipants { get; set; }

        /// <summary>
        /// Duration of the ongoing group call recording, in seconds; 0 if none. An updateGroupCall update is not triggered when value of this field changes, but the same recording goes on
        /// </summary>
        public int RecordDuration { get; set; }

        /// <summary>
        /// True, if a video file is being recorded for the call
        /// </summary>
        public bool IsVideoRecorded { get; set; }

        /// <summary>
        /// Call duration, in seconds; for ended calls only
        /// </summary>
        public int Duration { get; set; }

    }

    /// <summary>
    /// Describes a group of video synchronization source identifiers
    /// </summary>
    public partial class GroupCallVideoSourceGroup : TLObject
    {
        /// <summary>
        /// The semantics of sources, one of "SIM" or "FID"
        /// </summary>
        public string Semantics { get; set; }

        /// <summary>
        /// The list of synchronization source identifiers
        /// </summary>
        public int[] SourceIds { get; set; }

    }

    /// <summary>
    /// Contains information about a group call participant's video channel
    /// </summary>
    public partial class GroupCallParticipantVideoInfo : TLObject
    {
        /// <summary>
        /// List of synchronization source groups of the video
        /// </summary>
        public GroupCallVideoSourceGroup[] SourceGroups { get; set; }

        /// <summary>
        /// Video channel endpoint identifier
        /// </summary>
        public string EndpointId { get; set; }

        /// <summary>
        /// True if the video is paused. This flag needs to be ignored, if new video frames are received
        /// </summary>
        public bool IsPaused { get; set; }

    }

    /// <summary>
    /// Represents a group call participant
    /// </summary>
    public partial class GroupCallParticipant : TLObject
    {
        /// <summary>
        /// Identifier of the group call participant
        /// </summary>
        public MessageSender ParticipantId { get; set; }

        /// <summary>
        /// User's audio channel synchronization source identifier
        /// </summary>
        public int AudioSourceId { get; set; }

        /// <summary>
        /// User's screen sharing audio channel synchronization source identifier
        /// </summary>
        public int ScreenSharingAudioSourceId { get; set; }

        /// <summary>
        /// Information about user's video channel; may be null if there is no active video
        /// </summary>
        public GroupCallParticipantVideoInfo VideoInfo { get; set; }

        /// <summary>
        /// Information about user's screen sharing video channel; may be null if there is no active screen sharing video
        /// </summary>
        public GroupCallParticipantVideoInfo ScreenSharingVideoInfo { get; set; }

        /// <summary>
        /// The participant user's bio or the participant chat's description
        /// </summary>
        public string Bio { get; set; }

        /// <summary>
        /// True, if the participant is the current user
        /// </summary>
        public bool IsCurrentUser { get; set; }

        /// <summary>
        /// True, if the participant is speaking as set by setGroupCallParticipantIsSpeaking
        /// </summary>
        public bool IsSpeaking { get; set; }

        /// <summary>
        /// True, if the participant hand is raised
        /// </summary>
        public bool IsHandRaised { get; set; }

        /// <summary>
        /// True, if the current user can mute the participant for all other group call participants
        /// </summary>
        public bool CanBeMutedForAllUsers { get; set; }

        /// <summary>
        /// True, if the current user can allow the participant to unmute themselves or unmute the participant (if the participant is the current user)
        /// </summary>
        public bool CanBeUnmutedForAllUsers { get; set; }

        /// <summary>
        /// True, if the current user can mute the participant only for self
        /// </summary>
        public bool CanBeMutedForCurrentUser { get; set; }

        /// <summary>
        /// True, if the current user can unmute the participant for self
        /// </summary>
        public bool CanBeUnmutedForCurrentUser { get; set; }

        /// <summary>
        /// True, if the participant is muted for all users
        /// </summary>
        public bool IsMutedForAllUsers { get; set; }

        /// <summary>
        /// True, if the participant is muted for the current user
        /// </summary>
        public bool IsMutedForCurrentUser { get; set; }

        /// <summary>
        /// True, if the participant is muted for all users, but can unmute themselves
        /// </summary>
        public bool CanUnmuteSelf { get; set; }

        /// <summary>
        /// Participant's volume level; 1-20000 in hundreds of percents
        /// </summary>
        public int VolumeLevel { get; set; }

        /// <summary>
        /// User's order in the group call participant list. Orders must be compared lexicographically. The bigger is order, the higher is user in the list. If order is empty, the user must be removed from the participant list
        /// </summary>
        public string Order { get; set; }

    }

    /// <summary>
    /// The user heard their own voice
    /// </summary>
    public partial class CallProblemEcho : CallProblem
    {
    }

    /// <summary>
    /// The user heard background noise
    /// </summary>
    public partial class CallProblemNoise : CallProblem
    {
    }

    /// <summary>
    /// The other side kept disappearing
    /// </summary>
    public partial class CallProblemInterruptions : CallProblem
    {
    }

    /// <summary>
    /// The speech was distorted
    /// </summary>
    public partial class CallProblemDistortedSpeech : CallProblem
    {
    }

    /// <summary>
    /// The user couldn't hear the other side
    /// </summary>
    public partial class CallProblemSilentLocal : CallProblem
    {
    }

    /// <summary>
    /// The other side couldn't hear the user
    /// </summary>
    public partial class CallProblemSilentRemote : CallProblem
    {
    }

    /// <summary>
    /// The call ended unexpectedly
    /// </summary>
    public partial class CallProblemDropped : CallProblem
    {
    }

    /// <summary>
    /// The video was distorted
    /// </summary>
    public partial class CallProblemDistortedVideo : CallProblem
    {
    }

    /// <summary>
    /// The video was pixelated
    /// </summary>
    public partial class CallProblemPixelatedVideo : CallProblem
    {
    }

    /// <summary>
    /// Describes a call
    /// </summary>
    public partial class Call : TLObject
    {
        /// <summary>
        /// Call identifier, not persistent
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Peer user identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// True, if the call is outgoing
        /// </summary>
        public bool IsOutgoing { get; set; }

        /// <summary>
        /// True, if the call is a video call
        /// </summary>
        public bool IsVideo { get; set; }

        /// <summary>
        /// Call state
        /// </summary>
        public CallState State { get; set; }

    }

    /// <summary>
    /// Contains settings for the authentication of the user's phone number
    /// </summary>
    public partial class PhoneNumberAuthenticationSettings : TLObject
    {
        /// <summary>
        /// Pass true if the authentication code may be sent via flash call to the specified phone number
        /// </summary>
        public bool AllowFlashCall { get; set; }

        /// <summary>
        /// Pass true if the authenticated phone number is used on the current device
        /// </summary>
        public bool IsCurrentPhoneNumber { get; set; }

        /// <summary>
        /// For official applications only. True, if the application can use Android SMS Retriever API (requires Google Play Services &gt;= 10.2) to automatically receive the authentication code from the SMS. See https://developers.google.com/identity/sms-retriever/ for more details
        /// </summary>
        public bool AllowSmsRetrieverApi { get; set; }

    }

    /// <summary>
    /// Represents a list of animations
    /// </summary>
    public partial class Animations : TLObject
    {
        /// <summary>
        /// List of animations
        /// </summary>
        public Animation[] Animations_ { get; set; }

    }

    /// <summary>
    /// A regular animated sticker
    /// </summary>
    public partial class DiceStickersRegular : DiceStickers
    {
        /// <summary>
        /// The animated sticker with the dice animation
        /// </summary>
        public Sticker Sticker { get; set; }

    }

    /// <summary>
    /// Animated stickers to be combined into a slot machine
    /// </summary>
    public partial class DiceStickersSlotMachine : DiceStickers
    {
        /// <summary>
        /// The animated sticker with the slot machine background. The background animation must start playing after all reel animations finish
        /// </summary>
        public Sticker Background { get; set; }

        /// <summary>
        /// The animated sticker with the lever animation. The lever animation must play once in the initial dice state
        /// </summary>
        public Sticker Lever { get; set; }

        /// <summary>
        /// The animated sticker with the left reel
        /// </summary>
        public Sticker LeftReel { get; set; }

        /// <summary>
        /// The animated sticker with the center reel
        /// </summary>
        public Sticker CenterReel { get; set; }

        /// <summary>
        /// The animated sticker with the right reel
        /// </summary>
        public Sticker RightReel { get; set; }

    }

    /// <summary>
    /// Represents the result of an ImportContacts request
    /// </summary>
    public partial class ImportedContacts : TLObject
    {
        /// <summary>
        /// User identifiers of the imported contacts in the same order as they were specified in the request; 0 if the contact is not yet a registered user
        /// </summary>
        public long[] UserIds { get; set; }

        /// <summary>
        /// The number of users that imported the corresponding contact; 0 for already registered users or if unavailable
        /// </summary>
        public int[] ImporterCount { get; set; }

    }

    /// <summary>
    /// Contains an HTTP URL
    /// </summary>
    public partial class HttpUrl : TLObject
    {
        /// <summary>
        /// The URL
        /// </summary>
        public string Url { get; set; }

    }

    /// <summary>
    /// Represents a link to an animated GIF or an animated (i.e., without sound) H.264/MPEG-4 AVC video
    /// </summary>
    public partial class InputInlineQueryResultAnimation : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Title of the query result
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// URL of the result thumbnail (JPEG, GIF, or MPEG4), if it exists
        /// </summary>
        public string ThumbnailUrl { get; set; }

        /// <summary>
        /// MIME type of the video thumbnail. If non-empty, must be one of "image/jpeg", "image/gif" and "video/mp4"
        /// </summary>
        public string ThumbnailMimeType { get; set; }

        /// <summary>
        /// The URL of the video file (file size must not exceed 1MB)
        /// </summary>
        public string VideoUrl { get; set; }

        /// <summary>
        /// MIME type of the video file. Must be one of "image/gif" and "video/mp4"
        /// </summary>
        public string VideoMimeType { get; set; }

        /// <summary>
        /// Duration of the video, in seconds
        /// </summary>
        public int VideoDuration { get; set; }

        /// <summary>
        /// Width of the video
        /// </summary>
        public int VideoWidth { get; set; }

        /// <summary>
        /// Height of the video
        /// </summary>
        public int VideoHeight { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAnimation, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Represents a link to an article or web page
    /// </summary>
    public partial class InputInlineQueryResultArticle : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// URL of the result, if it exists
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// True, if the URL must be not shown
        /// </summary>
        public bool HideUrl { get; set; }

        /// <summary>
        /// Title of the result
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Represents a link to an article or web page
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// URL of the result thumbnail, if it exists
        /// </summary>
        public string ThumbnailUrl { get; set; }

        /// <summary>
        /// Thumbnail width, if known
        /// </summary>
        public int ThumbnailWidth { get; set; }

        /// <summary>
        /// Thumbnail height, if known
        /// </summary>
        public int ThumbnailHeight { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Represents a link to an MP3 audio file
    /// </summary>
    public partial class InputInlineQueryResultAudio : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Title of the audio file
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Performer of the audio file
        /// </summary>
        public string Performer { get; set; }

        /// <summary>
        /// The URL of the audio file
        /// </summary>
        public string AudioUrl { get; set; }

        /// <summary>
        /// Audio file duration, in seconds
        /// </summary>
        public int AudioDuration { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageAudio, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Represents a user contact
    /// </summary>
    public partial class InputInlineQueryResultContact : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// User contact
        /// </summary>
        public Contact Contact { get; set; }

        /// <summary>
        /// URL of the result thumbnail, if it exists
        /// </summary>
        public string ThumbnailUrl { get; set; }

        /// <summary>
        /// Thumbnail width, if known
        /// </summary>
        public int ThumbnailWidth { get; set; }

        /// <summary>
        /// Thumbnail height, if known
        /// </summary>
        public int ThumbnailHeight { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Represents a link to a file
    /// </summary>
    public partial class InputInlineQueryResultDocument : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Title of the resulting file
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Represents a link to a file
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// URL of the file
        /// </summary>
        public string DocumentUrl { get; set; }

        /// <summary>
        /// MIME type of the file content; only "application/pdf" and "application/zip" are currently allowed
        /// </summary>
        public string MimeType { get; set; }

        /// <summary>
        /// The URL of the file thumbnail, if it exists
        /// </summary>
        public string ThumbnailUrl { get; set; }

        /// <summary>
        /// Width of the thumbnail
        /// </summary>
        public int ThumbnailWidth { get; set; }

        /// <summary>
        /// Height of the thumbnail
        /// </summary>
        public int ThumbnailHeight { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageDocument, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Represents a game
    /// </summary>
    public partial class InputInlineQueryResultGame : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Short name of the game
        /// </summary>
        public string GameShortName { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

    }

    /// <summary>
    /// Represents a point on the map
    /// </summary>
    public partial class InputInlineQueryResultLocation : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Location result
        /// </summary>
        public Location Location { get; set; }

        /// <summary>
        /// Amount of time relative to the message sent time until the location can be updated, in seconds
        /// </summary>
        public int LivePeriod { get; set; }

        /// <summary>
        /// Title of the result
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// URL of the result thumbnail, if it exists
        /// </summary>
        public string ThumbnailUrl { get; set; }

        /// <summary>
        /// Thumbnail width, if known
        /// </summary>
        public int ThumbnailWidth { get; set; }

        /// <summary>
        /// Thumbnail height, if known
        /// </summary>
        public int ThumbnailHeight { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Represents link to a JPEG image
    /// </summary>
    public partial class InputInlineQueryResultPhoto : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Title of the result, if known
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Represents link to a JPEG image
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// URL of the photo thumbnail, if it exists
        /// </summary>
        public string ThumbnailUrl { get; set; }

        /// <summary>
        /// The URL of the JPEG photo (photo size must not exceed 5MB)
        /// </summary>
        public string PhotoUrl { get; set; }

        /// <summary>
        /// Width of the photo
        /// </summary>
        public int PhotoWidth { get; set; }

        /// <summary>
        /// Height of the photo
        /// </summary>
        public int PhotoHeight { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessagePhoto, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Represents a link to a WEBP or TGS sticker
    /// </summary>
    public partial class InputInlineQueryResultSticker : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// URL of the sticker thumbnail, if it exists
        /// </summary>
        public string ThumbnailUrl { get; set; }

        /// <summary>
        /// The URL of the WEBP or TGS sticker (sticker file size must not exceed 5MB)
        /// </summary>
        public string StickerUrl { get; set; }

        /// <summary>
        /// Width of the sticker
        /// </summary>
        public int StickerWidth { get; set; }

        /// <summary>
        /// Height of the sticker
        /// </summary>
        public int StickerHeight { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageSticker, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Represents information about a venue
    /// </summary>
    public partial class InputInlineQueryResultVenue : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Venue result
        /// </summary>
        public Venue Venue { get; set; }

        /// <summary>
        /// URL of the result thumbnail, if it exists
        /// </summary>
        public string ThumbnailUrl { get; set; }

        /// <summary>
        /// Thumbnail width, if known
        /// </summary>
        public int ThumbnailWidth { get; set; }

        /// <summary>
        /// Thumbnail height, if known
        /// </summary>
        public int ThumbnailHeight { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Represents a link to a page containing an embedded video player or a video file
    /// </summary>
    public partial class InputInlineQueryResultVideo : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Title of the result
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Represents a link to a page containing an embedded video player or a video file
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// The URL of the video thumbnail (JPEG), if it exists
        /// </summary>
        public string ThumbnailUrl { get; set; }

        /// <summary>
        /// URL of the embedded video player or video file
        /// </summary>
        public string VideoUrl { get; set; }

        /// <summary>
        /// MIME type of the content of the video URL, only "text/html" or "video/mp4" are currently supported
        /// </summary>
        public string MimeType { get; set; }

        /// <summary>
        /// Width of the video
        /// </summary>
        public int VideoWidth { get; set; }

        /// <summary>
        /// Height of the video
        /// </summary>
        public int VideoHeight { get; set; }

        /// <summary>
        /// Video duration, in seconds
        /// </summary>
        public int VideoDuration { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVideo, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Represents a link to an opus-encoded audio file within an OGG container, single channel audio
    /// </summary>
    public partial class InputInlineQueryResultVoiceNote : InputInlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Title of the voice note
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// The URL of the voice note file
        /// </summary>
        public string VoiceNoteUrl { get; set; }

        /// <summary>
        /// Duration of the voice note, in seconds
        /// </summary>
        public int VoiceNoteDuration { get; set; }

        /// <summary>
        /// The message reply markup; pass null if none. Must be of type replyMarkupInlineKeyboard or null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent. Must be one of the following types: inputMessageText, inputMessageVoiceNote, inputMessageInvoice, inputMessageLocation, inputMessageVenue or inputMessageContact
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Represents a link to an article or web page
    /// </summary>
    public partial class InlineQueryResultArticle : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// URL of the result, if it exists
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// True, if the URL must be not shown
        /// </summary>
        public bool HideUrl { get; set; }

        /// <summary>
        /// Title of the result
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Represents a link to an article or web page
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Result thumbnail in JPEG format; may be null
        /// </summary>
        public Thumbnail Thumbnail { get; set; }

    }

    /// <summary>
    /// Represents a user contact
    /// </summary>
    public partial class InlineQueryResultContact : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// A user contact
        /// </summary>
        public Contact Contact { get; set; }

        /// <summary>
        /// Result thumbnail in JPEG format; may be null
        /// </summary>
        public Thumbnail Thumbnail { get; set; }

    }

    /// <summary>
    /// Represents a point on the map
    /// </summary>
    public partial class InlineQueryResultLocation : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Location result
        /// </summary>
        public Location Location { get; set; }

        /// <summary>
        /// Title of the result
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Result thumbnail in JPEG format; may be null
        /// </summary>
        public Thumbnail Thumbnail { get; set; }

    }

    /// <summary>
    /// Represents information about a venue
    /// </summary>
    public partial class InlineQueryResultVenue : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Venue result
        /// </summary>
        public Venue Venue { get; set; }

        /// <summary>
        /// Result thumbnail in JPEG format; may be null
        /// </summary>
        public Thumbnail Thumbnail { get; set; }

    }

    /// <summary>
    /// Represents information about a game
    /// </summary>
    public partial class InlineQueryResultGame : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Game result
        /// </summary>
        public Game Game { get; set; }

    }

    /// <summary>
    /// Represents an animation file
    /// </summary>
    public partial class InlineQueryResultAnimation : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Animation file
        /// </summary>
        public Animation Animation { get; set; }

        /// <summary>
        /// Animation title
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// Represents an audio file
    /// </summary>
    public partial class InlineQueryResultAudio : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Audio file
        /// </summary>
        public Audio Audio { get; set; }

    }

    /// <summary>
    /// Represents a document
    /// </summary>
    public partial class InlineQueryResultDocument : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Document
        /// </summary>
        public Document Document { get; set; }

        /// <summary>
        /// Document title
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Represents a document
        /// </summary>
        public string Description { get; set; }

    }

    /// <summary>
    /// Represents a photo
    /// </summary>
    public partial class InlineQueryResultPhoto : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Photo
        /// </summary>
        public Photo Photo { get; set; }

        /// <summary>
        /// Title of the result, if known
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Represents a photo
        /// </summary>
        public string Description { get; set; }

    }

    /// <summary>
    /// Represents a sticker
    /// </summary>
    public partial class InlineQueryResultSticker : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Sticker
        /// </summary>
        public Sticker Sticker { get; set; }

    }

    /// <summary>
    /// Represents a video
    /// </summary>
    public partial class InlineQueryResultVideo : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Video
        /// </summary>
        public Video Video { get; set; }

        /// <summary>
        /// Title of the video
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Represents a video
        /// </summary>
        public string Description { get; set; }

    }

    /// <summary>
    /// Represents a voice note
    /// </summary>
    public partial class InlineQueryResultVoiceNote : InlineQueryResult
    {
        /// <summary>
        /// Unique identifier of the query result
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Voice note
        /// </summary>
        public VoiceNote VoiceNote { get; set; }

        /// <summary>
        /// Title of the voice note
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// Represents the results of the inline query. Use sendInlineQueryResultMessage to send the result of the query
    /// </summary>
    public partial class InlineQueryResults : TLObject
    {
        /// <summary>
        /// Unique identifier of the inline query
        /// </summary>
        public long InlineQueryId { get; set; }

        /// <summary>
        /// The offset for the next request. If empty, there are no more results
        /// </summary>
        public string NextOffset { get; set; }

        /// <summary>
        /// Results of the query
        /// </summary>
        public InlineQueryResult[] Results { get; set; }

        /// <summary>
        /// If non-empty, this text must be shown on the button, which opens a private chat with the bot and sends the bot a start message with the switch_pm_parameter
        /// </summary>
        public string SwitchPmText { get; set; }

        /// <summary>
        /// Parameter for the bot start message
        /// </summary>
        public string SwitchPmParameter { get; set; }

    }

    /// <summary>
    /// The payload for a general callback button
    /// </summary>
    public partial class CallbackQueryPayloadData : CallbackQueryPayload
    {
        /// <summary>
        /// Data that was attached to the callback button
        /// </summary>
        public Memory<byte> Data { get; set; }

    }

    /// <summary>
    /// The payload for a callback button requiring password
    /// </summary>
    public partial class CallbackQueryPayloadDataWithPassword : CallbackQueryPayload
    {
        /// <summary>
        /// The password for the current user
        /// </summary>
        public string Password { get; set; }

        /// <summary>
        /// Data that was attached to the callback button
        /// </summary>
        public Memory<byte> Data { get; set; }

    }

    /// <summary>
    /// The payload for a game callback button
    /// </summary>
    public partial class CallbackQueryPayloadGame : CallbackQueryPayload
    {
        /// <summary>
        /// A short name of the game that was attached to the callback button
        /// </summary>
        public string GameShortName { get; set; }

    }

    /// <summary>
    /// Contains a bot's answer to a callback query
    /// </summary>
    public partial class CallbackQueryAnswer : TLObject
    {
        /// <summary>
        /// Text of the answer
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// True, if an alert must be shown to the user instead of a toast notification
        /// </summary>
        public bool ShowAlert { get; set; }

        /// <summary>
        /// URL to be opened
        /// </summary>
        public string Url { get; set; }

    }

    /// <summary>
    /// Contains the result of a custom request
    /// </summary>
    public partial class CustomRequestResult : TLObject
    {
        /// <summary>
        /// A JSON-serialized result
        /// </summary>
        public string Result { get; set; }

    }

    /// <summary>
    /// Contains one row of the game high score table
    /// </summary>
    public partial class GameHighScore : TLObject
    {
        /// <summary>
        /// Position in the high score table
        /// </summary>
        public int Position { get; set; }

        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// User score
        /// </summary>
        public int Score { get; set; }

    }

    /// <summary>
    /// Contains a list of game high scores
    /// </summary>
    public partial class GameHighScores : TLObject
    {
        /// <summary>
        /// A list of game high scores
        /// </summary>
        public GameHighScore[] Scores { get; set; }

    }

    /// <summary>
    /// A message was edited
    /// </summary>
    public partial class ChatEventMessageEdited : ChatEventAction
    {
        /// <summary>
        /// The original message before the edit
        /// </summary>
        public Message OldMessage { get; set; }

        /// <summary>
        /// The message after it was edited
        /// </summary>
        public Message NewMessage { get; set; }

    }

    /// <summary>
    /// A message was deleted
    /// </summary>
    public partial class ChatEventMessageDeleted : ChatEventAction
    {
        /// <summary>
        /// Deleted message
        /// </summary>
        public Message Message { get; set; }

    }

    /// <summary>
    /// A poll in a message was stopped
    /// </summary>
    public partial class ChatEventPollStopped : ChatEventAction
    {
        /// <summary>
        /// The message with the poll
        /// </summary>
        public Message Message { get; set; }

    }

    /// <summary>
    /// A message was pinned
    /// </summary>
    public partial class ChatEventMessagePinned : ChatEventAction
    {
        /// <summary>
        /// Pinned message
        /// </summary>
        public Message Message { get; set; }

    }

    /// <summary>
    /// A message was unpinned
    /// </summary>
    public partial class ChatEventMessageUnpinned : ChatEventAction
    {
        /// <summary>
        /// Unpinned message
        /// </summary>
        public Message Message { get; set; }

    }

    /// <summary>
    /// A new member joined the chat
    /// </summary>
    public partial class ChatEventMemberJoined : ChatEventAction
    {
    }

    /// <summary>
    /// A new member joined the chat by an invite link
    /// </summary>
    public partial class ChatEventMemberJoinedByInviteLink : ChatEventAction
    {
        /// <summary>
        /// Invite link used to join the chat
        /// </summary>
        public ChatInviteLink InviteLink { get; set; }

    }

    /// <summary>
    /// A new member was accepted to the chat by an administrator
    /// </summary>
    public partial class ChatEventMemberJoinedByRequest : ChatEventAction
    {
        /// <summary>
        /// User identifier of the chat administrator, approved user join request
        /// </summary>
        public long ApproverUserId { get; set; }

        /// <summary>
        /// Invite link used to join the chat; may be null
        /// </summary>
        public ChatInviteLink InviteLink { get; set; }

    }

    /// <summary>
    /// A member left the chat
    /// </summary>
    public partial class ChatEventMemberLeft : ChatEventAction
    {
    }

    /// <summary>
    /// A new chat member was invited
    /// </summary>
    public partial class ChatEventMemberInvited : ChatEventAction
    {
        /// <summary>
        /// New member user identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// New member status
        /// </summary>
        public ChatMemberStatus Status { get; set; }

    }

    /// <summary>
    /// A chat member has gained/lost administrator status, or the list of their administrator privileges has changed
    /// </summary>
    public partial class ChatEventMemberPromoted : ChatEventAction
    {
        /// <summary>
        /// Affected chat member user identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Previous status of the chat member
        /// </summary>
        public ChatMemberStatus OldStatus { get; set; }

        /// <summary>
        /// New status of the chat member
        /// </summary>
        public ChatMemberStatus NewStatus { get; set; }

    }

    /// <summary>
    /// A chat member was restricted/unrestricted or banned/unbanned, or the list of their restrictions has changed
    /// </summary>
    public partial class ChatEventMemberRestricted : ChatEventAction
    {
        /// <summary>
        /// Affected chat member identifier
        /// </summary>
        public MessageSender MemberId { get; set; }

        /// <summary>
        /// Previous status of the chat member
        /// </summary>
        public ChatMemberStatus OldStatus { get; set; }

        /// <summary>
        /// New status of the chat member
        /// </summary>
        public ChatMemberStatus NewStatus { get; set; }

    }

    /// <summary>
    /// The chat title was changed
    /// </summary>
    public partial class ChatEventTitleChanged : ChatEventAction
    {
        /// <summary>
        /// Previous chat title
        /// </summary>
        public string OldTitle { get; set; }

        /// <summary>
        /// New chat title
        /// </summary>
        public string NewTitle { get; set; }

    }

    /// <summary>
    /// The chat permissions was changed
    /// </summary>
    public partial class ChatEventPermissionsChanged : ChatEventAction
    {
        /// <summary>
        /// Previous chat permissions
        /// </summary>
        public ChatPermissions OldPermissions { get; set; }

        /// <summary>
        /// New chat permissions
        /// </summary>
        public ChatPermissions NewPermissions { get; set; }

    }

    /// <summary>
    /// The chat description was changed
    /// </summary>
    public partial class ChatEventDescriptionChanged : ChatEventAction
    {
        /// <summary>
        /// Previous chat description
        /// </summary>
        public string OldDescription { get; set; }

        /// <summary>
        /// New chat description
        /// </summary>
        public string NewDescription { get; set; }

    }

    /// <summary>
    /// The chat username was changed
    /// </summary>
    public partial class ChatEventUsernameChanged : ChatEventAction
    {
        /// <summary>
        /// Previous chat username
        /// </summary>
        public string OldUsername { get; set; }

        /// <summary>
        /// New chat username
        /// </summary>
        public string NewUsername { get; set; }

    }

    /// <summary>
    /// The chat photo was changed
    /// </summary>
    public partial class ChatEventPhotoChanged : ChatEventAction
    {
        /// <summary>
        /// Previous chat photo value; may be null
        /// </summary>
        public ChatPhoto OldPhoto { get; set; }

        /// <summary>
        /// New chat photo value; may be null
        /// </summary>
        public ChatPhoto NewPhoto { get; set; }

    }

    /// <summary>
    /// The can_invite_users permission of a supergroup chat was toggled
    /// </summary>
    public partial class ChatEventInvitesToggled : ChatEventAction
    {
        /// <summary>
        /// New value of can_invite_users permission
        /// </summary>
        public bool CanInviteUsers { get; set; }

    }

    /// <summary>
    /// The linked chat of a supergroup was changed
    /// </summary>
    public partial class ChatEventLinkedChatChanged : ChatEventAction
    {
        /// <summary>
        /// Previous supergroup linked chat identifier
        /// </summary>
        public long OldLinkedChatId { get; set; }

        /// <summary>
        /// New supergroup linked chat identifier
        /// </summary>
        public long NewLinkedChatId { get; set; }

    }

    /// <summary>
    /// The slow_mode_delay setting of a supergroup was changed
    /// </summary>
    public partial class ChatEventSlowModeDelayChanged : ChatEventAction
    {
        /// <summary>
        /// Previous value of slow_mode_delay, in seconds
        /// </summary>
        public int OldSlowModeDelay { get; set; }

        /// <summary>
        /// New value of slow_mode_delay, in seconds
        /// </summary>
        public int NewSlowModeDelay { get; set; }

    }

    /// <summary>
    /// The message TTL setting was changed
    /// </summary>
    public partial class ChatEventMessageTtlSettingChanged : ChatEventAction
    {
        /// <summary>
        /// Previous value of message_ttl_setting
        /// </summary>
        public int OldMessageTtlSetting { get; set; }

        /// <summary>
        /// New value of message_ttl_setting
        /// </summary>
        public int NewMessageTtlSetting { get; set; }

    }

    /// <summary>
    /// The sign_messages setting of a channel was toggled
    /// </summary>
    public partial class ChatEventSignMessagesToggled : ChatEventAction
    {
        /// <summary>
        /// New value of sign_messages
        /// </summary>
        public bool SignMessages { get; set; }

    }

    /// <summary>
    /// The supergroup sticker set was changed
    /// </summary>
    public partial class ChatEventStickerSetChanged : ChatEventAction
    {
        /// <summary>
        /// Previous identifier of the chat sticker set; 0 if none
        /// </summary>
        public long OldStickerSetId { get; set; }

        /// <summary>
        /// New identifier of the chat sticker set; 0 if none
        /// </summary>
        public long NewStickerSetId { get; set; }

    }

    /// <summary>
    /// The supergroup location was changed
    /// </summary>
    public partial class ChatEventLocationChanged : ChatEventAction
    {
        /// <summary>
        /// Previous location; may be null
        /// </summary>
        public ChatLocation OldLocation { get; set; }

        /// <summary>
        /// New location; may be null
        /// </summary>
        public ChatLocation NewLocation { get; set; }

    }

    /// <summary>
    /// The is_all_history_available setting of a supergroup was toggled
    /// </summary>
    public partial class ChatEventIsAllHistoryAvailableToggled : ChatEventAction
    {
        /// <summary>
        /// New value of is_all_history_available
        /// </summary>
        public bool IsAllHistoryAvailable { get; set; }

    }

    /// <summary>
    /// A chat invite link was edited
    /// </summary>
    public partial class ChatEventInviteLinkEdited : ChatEventAction
    {
        /// <summary>
        /// Previous information about the invite link
        /// </summary>
        public ChatInviteLink OldInviteLink { get; set; }

        /// <summary>
        /// New information about the invite link
        /// </summary>
        public ChatInviteLink NewInviteLink { get; set; }

    }

    /// <summary>
    /// A chat invite link was revoked
    /// </summary>
    public partial class ChatEventInviteLinkRevoked : ChatEventAction
    {
        /// <summary>
        /// The invite link
        /// </summary>
        public ChatInviteLink InviteLink { get; set; }

    }

    /// <summary>
    /// A revoked chat invite link was deleted
    /// </summary>
    public partial class ChatEventInviteLinkDeleted : ChatEventAction
    {
        /// <summary>
        /// The invite link
        /// </summary>
        public ChatInviteLink InviteLink { get; set; }

    }

    /// <summary>
    /// A video chat was created
    /// </summary>
    public partial class ChatEventVideoChatCreated : ChatEventAction
    {
        /// <summary>
        /// Identifier of the video chat. The video chat can be received through the method getGroupCall
        /// </summary>
        public int GroupCallId { get; set; }

    }

    /// <summary>
    /// A video chat was discarded
    /// </summary>
    public partial class ChatEventVideoChatDiscarded : ChatEventAction
    {
        /// <summary>
        /// Identifier of the video chat. The video chat can be received through the method getGroupCall
        /// </summary>
        public int GroupCallId { get; set; }

    }

    /// <summary>
    /// A video chat participant was muted or unmuted
    /// </summary>
    public partial class ChatEventVideoChatParticipantIsMutedToggled : ChatEventAction
    {
        /// <summary>
        /// Identifier of the affected group call participant
        /// </summary>
        public MessageSender ParticipantId { get; set; }

        /// <summary>
        /// New value of is_muted
        /// </summary>
        public bool IsMuted { get; set; }

    }

    /// <summary>
    /// A video chat participant volume level was changed
    /// </summary>
    public partial class ChatEventVideoChatParticipantVolumeLevelChanged : ChatEventAction
    {
        /// <summary>
        /// Identifier of the affected group call participant
        /// </summary>
        public MessageSender ParticipantId { get; set; }

        /// <summary>
        /// New value of volume_level; 1-20000 in hundreds of percents
        /// </summary>
        public int VolumeLevel { get; set; }

    }

    /// <summary>
    /// The mute_new_participants setting of a video chat was toggled
    /// </summary>
    public partial class ChatEventVideoChatMuteNewParticipantsToggled : ChatEventAction
    {
        /// <summary>
        /// New value of the mute_new_participants setting
        /// </summary>
        public bool MuteNewParticipants { get; set; }

    }

    /// <summary>
    /// Represents a chat event
    /// </summary>
    public partial class ChatEvent : TLObject
    {
        /// <summary>
        /// Chat event identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the event happened
        /// </summary>
        public int Date { get; set; }

        /// <summary>
        /// Identifier of the user who performed the action that triggered the event
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Action performed by the user
        /// </summary>
        public ChatEventAction Action { get; set; }

    }

    /// <summary>
    /// Contains a list of chat events
    /// </summary>
    public partial class ChatEvents : TLObject
    {
        /// <summary>
        /// List of events
        /// </summary>
        public ChatEvent[] Events { get; set; }

    }

    /// <summary>
    /// Represents a set of filters used to obtain a chat event log
    /// </summary>
    public partial class ChatEventLogFilters : TLObject
    {
        /// <summary>
        /// True, if message edits need to be returned
        /// </summary>
        public bool MessageEdits { get; set; }

        /// <summary>
        /// True, if message deletions need to be returned
        /// </summary>
        public bool MessageDeletions { get; set; }

        /// <summary>
        /// True, if pin/unpin events need to be returned
        /// </summary>
        public bool MessagePins { get; set; }

        /// <summary>
        /// True, if members joining events need to be returned
        /// </summary>
        public bool MemberJoins { get; set; }

        /// <summary>
        /// True, if members leaving events need to be returned
        /// </summary>
        public bool MemberLeaves { get; set; }

        /// <summary>
        /// True, if invited member events need to be returned
        /// </summary>
        public bool MemberInvites { get; set; }

        /// <summary>
        /// True, if member promotion/demotion events need to be returned
        /// </summary>
        public bool MemberPromotions { get; set; }

        /// <summary>
        /// True, if member restricted/unrestricted/banned/unbanned events need to be returned
        /// </summary>
        public bool MemberRestrictions { get; set; }

        /// <summary>
        /// True, if changes in chat information need to be returned
        /// </summary>
        public bool InfoChanges { get; set; }

        /// <summary>
        /// True, if changes in chat settings need to be returned
        /// </summary>
        public bool SettingChanges { get; set; }

        /// <summary>
        /// True, if changes to invite links need to be returned
        /// </summary>
        public bool InviteLinkChanges { get; set; }

        /// <summary>
        /// True, if video chat actions need to be returned
        /// </summary>
        public bool VideoChatChanges { get; set; }

    }

    /// <summary>
    /// An ordinary language pack string
    /// </summary>
    public partial class LanguagePackStringValueOrdinary : LanguagePackStringValue
    {
        /// <summary>
        /// String value
        /// </summary>
        public string Value { get; set; }

    }

    /// <summary>
    /// A language pack string which has different forms based on the number of some object it mentions. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info
    /// </summary>
    public partial class LanguagePackStringValuePluralized : LanguagePackStringValue
    {
        /// <summary>
        /// Value for zero objects
        /// </summary>
        public string ZeroValue { get; set; }

        /// <summary>
        /// Value for one object
        /// </summary>
        public string OneValue { get; set; }

        /// <summary>
        /// Value for two objects
        /// </summary>
        public string TwoValue { get; set; }

        /// <summary>
        /// Value for few objects
        /// </summary>
        public string FewValue { get; set; }

        /// <summary>
        /// Value for many objects
        /// </summary>
        public string ManyValue { get; set; }

        /// <summary>
        /// Default value
        /// </summary>
        public string OtherValue { get; set; }

    }

    /// <summary>
    /// A deleted language pack string, the value must be taken from the built-in English language pack
    /// </summary>
    public partial class LanguagePackStringValueDeleted : LanguagePackStringValue
    {
    }

    /// <summary>
    /// Represents one language pack string
    /// </summary>
    public partial class LanguagePackString : TLObject
    {
        /// <summary>
        /// String key
        /// </summary>
        public string Key { get; set; }

        /// <summary>
        /// String value; pass null if the string needs to be taken from the built-in English language pack
        /// </summary>
        public LanguagePackStringValue Value { get; set; }

    }

    /// <summary>
    /// Contains a list of language pack strings
    /// </summary>
    public partial class LanguagePackStrings : TLObject
    {
        /// <summary>
        /// A list of language pack strings
        /// </summary>
        public LanguagePackString[] Strings { get; set; }

    }

    /// <summary>
    /// Contains information about a language pack
    /// </summary>
    public partial class LanguagePackInfo : TLObject
    {
        /// <summary>
        /// Unique language pack identifier
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it must be fetched from base language pack. Unsupported in custom language packs
        /// </summary>
        public string BaseLanguagePackId { get; set; }

        /// <summary>
        /// Language name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Name of the language in that language
        /// </summary>
        public string NativeName { get; set; }

        /// <summary>
        /// A language code to be used to apply plural forms. See https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html for more info
        /// </summary>
        public string PluralCode { get; set; }

        /// <summary>
        /// True, if the language pack is official
        /// </summary>
        public bool IsOfficial { get; set; }

        /// <summary>
        /// True, if the language pack strings are RTL
        /// </summary>
        public bool IsRtl { get; set; }

        /// <summary>
        /// True, if the language pack is a beta language pack
        /// </summary>
        public bool IsBeta { get; set; }

        /// <summary>
        /// True, if the language pack is installed by the current user
        /// </summary>
        public bool IsInstalled { get; set; }

        /// <summary>
        /// Total number of non-deleted strings from the language pack
        /// </summary>
        public int TotalStringCount { get; set; }

        /// <summary>
        /// Total number of translated strings from the language pack
        /// </summary>
        public int TranslatedStringCount { get; set; }

        /// <summary>
        /// Total number of non-deleted strings from the language pack available locally
        /// </summary>
        public int LocalStringCount { get; set; }

        /// <summary>
        /// Link to language translation interface; empty for custom local language packs
        /// </summary>
        public string TranslationUrl { get; set; }

    }

    /// <summary>
    /// Contains information about the current localization target
    /// </summary>
    public partial class LocalizationTargetInfo : TLObject
    {
        /// <summary>
        /// List of available language packs for this application
        /// </summary>
        public LanguagePackInfo[] LanguagePacks { get; set; }

    }

    /// <summary>
    /// A token for Firebase Cloud Messaging
    /// </summary>
    public partial class DeviceTokenFirebaseCloudMessaging : DeviceToken
    {
        /// <summary>
        /// Device registration token; may be empty to de-register a device
        /// </summary>
        public string Token { get; set; }

        /// <summary>
        /// True, if push notifications must be additionally encrypted
        /// </summary>
        public bool Encrypt { get; set; }

    }

    /// <summary>
    /// A token for Apple Push Notification service
    /// </summary>
    public partial class DeviceTokenApplePush : DeviceToken
    {
        /// <summary>
        /// Device token; may be empty to de-register a device
        /// </summary>
        public string DeviceToken { get; set; }

        /// <summary>
        /// True, if App Sandbox is enabled
        /// </summary>
        public bool IsAppSandbox { get; set; }

    }

    /// <summary>
    /// A token for Apple Push Notification service VoIP notifications
    /// </summary>
    public partial class DeviceTokenApplePushVoIP : DeviceToken
    {
        /// <summary>
        /// Device token; may be empty to de-register a device
        /// </summary>
        public string DeviceToken { get; set; }

        /// <summary>
        /// True, if App Sandbox is enabled
        /// </summary>
        public bool IsAppSandbox { get; set; }

        /// <summary>
        /// True, if push notifications must be additionally encrypted
        /// </summary>
        public bool Encrypt { get; set; }

    }

    /// <summary>
    /// A token for Windows Push Notification Services
    /// </summary>
    public partial class DeviceTokenWindowsPush : DeviceToken
    {
        /// <summary>
        /// The access token that will be used to send notifications; may be empty to de-register a device
        /// </summary>
        public string AccessToken { get; set; }

    }

    /// <summary>
    /// A token for Microsoft Push Notification Service
    /// </summary>
    public partial class DeviceTokenMicrosoftPush : DeviceToken
    {
        /// <summary>
        /// Push notification channel URI; may be empty to de-register a device
        /// </summary>
        public string ChannelUri { get; set; }

    }

    /// <summary>
    /// A token for Microsoft Push Notification Service VoIP channel
    /// </summary>
    public partial class DeviceTokenMicrosoftPushVoIP : DeviceToken
    {
        /// <summary>
        /// Push notification channel URI; may be empty to de-register a device
        /// </summary>
        public string ChannelUri { get; set; }

    }

    /// <summary>
    /// A token for web Push API
    /// </summary>
    public partial class DeviceTokenWebPush : DeviceToken
    {
        /// <summary>
        /// Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device
        /// </summary>
        public string Endpoint { get; set; }

        /// <summary>
        /// Base64url-encoded P-256 elliptic curve Diffie-Hellman public key
        /// </summary>
        public string P256dhBase64url { get; set; }

        /// <summary>
        /// Base64url-encoded authentication secret
        /// </summary>
        public string AuthBase64url { get; set; }

    }

    /// <summary>
    /// A token for Simple Push API for Firefox OS
    /// </summary>
    public partial class DeviceTokenSimplePush : DeviceToken
    {
        /// <summary>
        /// Absolute URL exposed by the push service where the application server can send push messages; may be empty to de-register a device
        /// </summary>
        public string Endpoint { get; set; }

    }

    /// <summary>
    /// A token for Ubuntu Push Client service
    /// </summary>
    public partial class DeviceTokenUbuntuPush : DeviceToken
    {
        /// <summary>
        /// Token; may be empty to de-register a device
        /// </summary>
        public string Token { get; set; }

    }

    /// <summary>
    /// A token for BlackBerry Push Service
    /// </summary>
    public partial class DeviceTokenBlackBerryPush : DeviceToken
    {
        /// <summary>
        /// Token; may be empty to de-register a device
        /// </summary>
        public string Token { get; set; }

    }

    /// <summary>
    /// A token for Tizen Push Service
    /// </summary>
    public partial class DeviceTokenTizenPush : DeviceToken
    {
        /// <summary>
        /// Push service registration identifier; may be empty to de-register a device
        /// </summary>
        public string RegId { get; set; }

    }

    /// <summary>
    /// Contains a globally unique push receiver identifier, which can be used to identify which account has received a push notification
    /// </summary>
    public partial class PushReceiverId : TLObject
    {
        /// <summary>
        /// The globally unique identifier of push notification subscription
        /// </summary>
        public long Id { get; set; }

    }

    /// <summary>
    /// Describes a solid fill of a background
    /// </summary>
    public partial class BackgroundFillSolid : BackgroundFill
    {
        /// <summary>
        /// A color of the background in the RGB24 format
        /// </summary>
        public int Color { get; set; }

    }

    /// <summary>
    /// Describes a gradient fill of a background
    /// </summary>
    public partial class BackgroundFillGradient : BackgroundFill
    {
        /// <summary>
        /// A top color of the background in the RGB24 format
        /// </summary>
        public int TopColor { get; set; }

        /// <summary>
        /// A bottom color of the background in the RGB24 format
        /// </summary>
        public int BottomColor { get; set; }

        /// <summary>
        /// Clockwise rotation angle of the gradient, in degrees; 0-359. Must be always divisible by 45
        /// </summary>
        public int RotationAngle { get; set; }

    }

    /// <summary>
    /// Describes a freeform gradient fill of a background
    /// </summary>
    public partial class BackgroundFillFreeformGradient : BackgroundFill
    {
        /// <summary>
        /// A list of 3 or 4 colors of the freeform gradients in the RGB24 format
        /// </summary>
        public int[] Colors { get; set; }

    }

    /// <summary>
    /// A wallpaper in JPEG format
    /// </summary>
    public partial class BackgroundTypeWallpaper : BackgroundType
    {
        /// <summary>
        /// True, if the wallpaper must be downscaled to fit in 450x450 square and then box-blurred with radius 12
        /// </summary>
        public bool IsBlurred { get; set; }

        /// <summary>
        /// True, if the background needs to be slightly moved when device is tilted
        /// </summary>
        public bool IsMoving { get; set; }

    }

    /// <summary>
    /// A PNG or TGV (gzipped subset of SVG with MIME type "application/x-tgwallpattern") pattern to be combined with the background fill chosen by the user
    /// </summary>
    public partial class BackgroundTypePattern : BackgroundType
    {
        /// <summary>
        /// Fill of the background
        /// </summary>
        public BackgroundFill Fill { get; set; }

        /// <summary>
        /// Intensity of the pattern when it is shown above the filled background; 0-100.
        /// </summary>
        public int Intensity { get; set; }

        /// <summary>
        /// True, if the background fill must be applied only to the pattern itself. All other pixels are black in this case. For dark themes only
        /// </summary>
        public bool IsInverted { get; set; }

        /// <summary>
        /// True, if the background needs to be slightly moved when device is tilted
        /// </summary>
        public bool IsMoving { get; set; }

    }

    /// <summary>
    /// A filled background
    /// </summary>
    public partial class BackgroundTypeFill : BackgroundType
    {
        /// <summary>
        /// The background fill
        /// </summary>
        public BackgroundFill Fill { get; set; }

    }

    /// <summary>
    /// Describes a chat background
    /// </summary>
    public partial class Background : TLObject
    {
        /// <summary>
        /// Unique background identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// True, if this is one of default backgrounds
        /// </summary>
        public bool IsDefault { get; set; }

        /// <summary>
        /// True, if the background is dark and is recommended to be used with dark theme
        /// </summary>
        public bool IsDark { get; set; }

        /// <summary>
        /// Unique background name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Document with the background; may be null. Null only for filled backgrounds
        /// </summary>
        public Document Document { get; set; }

        /// <summary>
        /// Type of the background
        /// </summary>
        public BackgroundType Type { get; set; }

    }

    /// <summary>
    /// Contains a list of backgrounds
    /// </summary>
    public partial class Backgrounds : TLObject
    {
        /// <summary>
        /// A list of backgrounds
        /// </summary>
        public Background[] Backgrounds_ { get; set; }

    }

    /// <summary>
    /// A background from a local file
    /// </summary>
    public partial class InputBackgroundLocal : InputBackground
    {
        /// <summary>
        /// Background file to use. Only inputFileLocal and inputFileGenerated are supported. The file must be in JPEG format for wallpapers and in PNG format for patterns
        /// </summary>
        public InputFile Background { get; set; }

    }

    /// <summary>
    /// A background from the server
    /// </summary>
    public partial class InputBackgroundRemote : InputBackground
    {
        /// <summary>
        /// The background identifier
        /// </summary>
        public long BackgroundId { get; set; }

    }

    /// <summary>
    /// Describes theme settings
    /// </summary>
    public partial class ThemeSettings : TLObject
    {
        /// <summary>
        /// Theme accent color in ARGB format
        /// </summary>
        public int AccentColor { get; set; }

        /// <summary>
        /// The background to be used in chats; may be null
        /// </summary>
        public Background Background { get; set; }

        /// <summary>
        /// The fill to be used as a background for outgoing messages
        /// </summary>
        public BackgroundFill OutgoingMessageFill { get; set; }

        /// <summary>
        /// If true, the freeform gradient fill needs to be animated on every sent message
        /// </summary>
        public bool AnimateOutgoingMessageFill { get; set; }

        /// <summary>
        /// Accent color of outgoing messages in ARGB format
        /// </summary>
        public int OutgoingMessageAccentColor { get; set; }

    }

    /// <summary>
    /// Describes a chat theme
    /// </summary>
    public partial class ChatTheme : TLObject
    {
        /// <summary>
        /// Theme name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Theme settings for a light chat theme
        /// </summary>
        public ThemeSettings LightSettings { get; set; }

        /// <summary>
        /// Theme settings for a dark chat theme
        /// </summary>
        public ThemeSettings DarkSettings { get; set; }

    }

    /// <summary>
    /// Contains a list of hashtags
    /// </summary>
    public partial class Hashtags : TLObject
    {
        /// <summary>
        /// A list of hashtags
        /// </summary>
        public string[] Hashtags_ { get; set; }

    }

    /// <summary>
    /// The session can be used
    /// </summary>
    public partial class CanTransferOwnershipResultOk : CanTransferOwnershipResult
    {
    }

    /// <summary>
    /// The 2-step verification needs to be enabled first
    /// </summary>
    public partial class CanTransferOwnershipResultPasswordNeeded : CanTransferOwnershipResult
    {
    }

    /// <summary>
    /// The 2-step verification was enabled recently, user needs to wait
    /// </summary>
    public partial class CanTransferOwnershipResultPasswordTooFresh : CanTransferOwnershipResult
    {
        /// <summary>
        /// Time left before the session can be used to transfer ownership of a chat, in seconds
        /// </summary>
        public int RetryAfter { get; set; }

    }

    /// <summary>
    /// The session was created recently, user needs to wait
    /// </summary>
    public partial class CanTransferOwnershipResultSessionTooFresh : CanTransferOwnershipResult
    {
        /// <summary>
        /// Time left before the session can be used to transfer ownership of a chat, in seconds
        /// </summary>
        public int RetryAfter { get; set; }

    }

    /// <summary>
    /// The username can be set
    /// </summary>
    public partial class CheckChatUsernameResultOk : CheckChatUsernameResult
    {
    }

    /// <summary>
    /// The username is invalid
    /// </summary>
    public partial class CheckChatUsernameResultUsernameInvalid : CheckChatUsernameResult
    {
    }

    /// <summary>
    /// The username is occupied
    /// </summary>
    public partial class CheckChatUsernameResultUsernameOccupied : CheckChatUsernameResult
    {
    }

    /// <summary>
    /// The user has too much chats with username, one of them must be made private first
    /// </summary>
    public partial class CheckChatUsernameResultPublicChatsTooMuch : CheckChatUsernameResult
    {
    }

    /// <summary>
    /// The user can't be a member of a public supergroup
    /// </summary>
    public partial class CheckChatUsernameResultPublicGroupsUnavailable : CheckChatUsernameResult
    {
    }

    /// <summary>
    /// The name can be set
    /// </summary>
    public partial class CheckStickerSetNameResultOk : CheckStickerSetNameResult
    {
    }

    /// <summary>
    /// The name is invalid
    /// </summary>
    public partial class CheckStickerSetNameResultNameInvalid : CheckStickerSetNameResult
    {
    }

    /// <summary>
    /// The name is occupied
    /// </summary>
    public partial class CheckStickerSetNameResultNameOccupied : CheckStickerSetNameResult
    {
    }

    /// <summary>
    /// The password was reset
    /// </summary>
    public partial class ResetPasswordResultOk : ResetPasswordResult
    {
    }

    /// <summary>
    /// The password reset request is pending
    /// </summary>
    public partial class ResetPasswordResultPending : ResetPasswordResult
    {
        /// <summary>
        /// Point in time (Unix timestamp) after which the password can be reset immediately using resetPassword
        /// </summary>
        public int PendingResetDate { get; set; }

    }

    /// <summary>
    /// The password reset request was declined
    /// </summary>
    public partial class ResetPasswordResultDeclined : ResetPasswordResult
    {
        /// <summary>
        /// Point in time (Unix timestamp) when the password reset can be retried
        /// </summary>
        public int RetryDate { get; set; }

    }

    /// <summary>
    /// The messages was exported from a private chat
    /// </summary>
    public partial class MessageFileTypePrivate : MessageFileType
    {
        /// <summary>
        /// Name of the other party; may be empty if unrecognized
        /// </summary>
        public string Name { get; set; }

    }

    /// <summary>
    /// The messages was exported from a group chat
    /// </summary>
    public partial class MessageFileTypeGroup : MessageFileType
    {
        /// <summary>
        /// Title of the group chat; may be empty if unrecognized
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// The messages was exported from a chat of unknown type
    /// </summary>
    public partial class MessageFileTypeUnknown : MessageFileType
    {
    }

    /// <summary>
    /// A general message with hidden content
    /// </summary>
    public partial class PushMessageContentHidden : PushMessageContent
    {
        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// An animation message (GIF-style).
    /// </summary>
    public partial class PushMessageContentAnimation : PushMessageContent
    {
        /// <summary>
        /// Message content; may be null
        /// </summary>
        public Animation Animation { get; set; }

        /// <summary>
        /// Animation caption
        /// </summary>
        public string Caption { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// An audio message
    /// </summary>
    public partial class PushMessageContentAudio : PushMessageContent
    {
        /// <summary>
        /// Message content; may be null
        /// </summary>
        public Audio Audio { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A message with a user contact
    /// </summary>
    public partial class PushMessageContentContact : PushMessageContent
    {
        /// <summary>
        /// Contact's name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A contact has registered with Telegram
    /// </summary>
    public partial class PushMessageContentContactRegistered : PushMessageContent
    {
    }

    /// <summary>
    /// A document message (a general file)
    /// </summary>
    public partial class PushMessageContentDocument : PushMessageContent
    {
        /// <summary>
        /// Message content; may be null
        /// </summary>
        public Document Document { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A message with a game
    /// </summary>
    public partial class PushMessageContentGame : PushMessageContent
    {
        /// <summary>
        /// Game title, empty for pinned game message
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A new high score was achieved in a game
    /// </summary>
    public partial class PushMessageContentGameScore : PushMessageContent
    {
        /// <summary>
        /// Game title, empty for pinned message
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// New score, 0 for pinned message
        /// </summary>
        public int Score { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A message with an invoice from a bot
    /// </summary>
    public partial class PushMessageContentInvoice : PushMessageContent
    {
        /// <summary>
        /// Product price
        /// </summary>
        public string Price { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A message with a location
    /// </summary>
    public partial class PushMessageContentLocation : PushMessageContent
    {
        /// <summary>
        /// True, if the location is live
        /// </summary>
        public bool IsLive { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A photo message
    /// </summary>
    public partial class PushMessageContentPhoto : PushMessageContent
    {
        /// <summary>
        /// Message content; may be null
        /// </summary>
        public Photo Photo { get; set; }

        /// <summary>
        /// Photo caption
        /// </summary>
        public string Caption { get; set; }

        /// <summary>
        /// True, if the photo is secret
        /// </summary>
        public bool IsSecret { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A message with a poll
    /// </summary>
    public partial class PushMessageContentPoll : PushMessageContent
    {
        /// <summary>
        /// Poll question
        /// </summary>
        public string Question { get; set; }

        /// <summary>
        /// True, if the poll is regular and not in quiz mode
        /// </summary>
        public bool IsRegular { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A screenshot of a message in the chat has been taken
    /// </summary>
    public partial class PushMessageContentScreenshotTaken : PushMessageContent
    {
    }

    /// <summary>
    /// A message with a sticker
    /// </summary>
    public partial class PushMessageContentSticker : PushMessageContent
    {
        /// <summary>
        /// Message content; may be null
        /// </summary>
        public Sticker Sticker { get; set; }

        /// <summary>
        /// Emoji corresponding to the sticker; may be empty
        /// </summary>
        public string Emoji { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A text message
    /// </summary>
    public partial class PushMessageContentText : PushMessageContent
    {
        /// <summary>
        /// Message text
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A video message
    /// </summary>
    public partial class PushMessageContentVideo : PushMessageContent
    {
        /// <summary>
        /// Message content; may be null
        /// </summary>
        public Video Video { get; set; }

        /// <summary>
        /// Video caption
        /// </summary>
        public string Caption { get; set; }

        /// <summary>
        /// True, if the video is secret
        /// </summary>
        public bool IsSecret { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A video note message
    /// </summary>
    public partial class PushMessageContentVideoNote : PushMessageContent
    {
        /// <summary>
        /// Message content; may be null
        /// </summary>
        public VideoNote VideoNote { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A voice note message
    /// </summary>
    public partial class PushMessageContentVoiceNote : PushMessageContent
    {
        /// <summary>
        /// Message content; may be null
        /// </summary>
        public VoiceNote VoiceNote { get; set; }

        /// <summary>
        /// True, if the message is a pinned message with the specified content
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// A newly created basic group
    /// </summary>
    public partial class PushMessageContentBasicGroupChatCreate : PushMessageContent
    {
    }

    /// <summary>
    /// New chat members were invited to a group
    /// </summary>
    public partial class PushMessageContentChatAddMembers : PushMessageContent
    {
        /// <summary>
        /// Name of the added member
        /// </summary>
        public string MemberName { get; set; }

        /// <summary>
        /// True, if the current user was added to the group
        /// </summary>
        public bool IsCurrentUser { get; set; }

        /// <summary>
        /// True, if the user has returned to the group themselves
        /// </summary>
        public bool IsReturned { get; set; }

    }

    /// <summary>
    /// A chat photo was edited
    /// </summary>
    public partial class PushMessageContentChatChangePhoto : PushMessageContent
    {
    }

    /// <summary>
    /// A chat title was edited
    /// </summary>
    public partial class PushMessageContentChatChangeTitle : PushMessageContent
    {
        /// <summary>
        /// New chat title
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// A chat theme was edited
    /// </summary>
    public partial class PushMessageContentChatSetTheme : PushMessageContent
    {
        /// <summary>
        /// If non-empty, name of a new theme, set for the chat. Otherwise chat theme was reset to the default one
        /// </summary>
        public string ThemeName { get; set; }

    }

    /// <summary>
    /// A chat member was deleted
    /// </summary>
    public partial class PushMessageContentChatDeleteMember : PushMessageContent
    {
        /// <summary>
        /// Name of the deleted member
        /// </summary>
        public string MemberName { get; set; }

        /// <summary>
        /// True, if the current user was deleted from the group
        /// </summary>
        public bool IsCurrentUser { get; set; }

        /// <summary>
        /// True, if the user has left the group themselves
        /// </summary>
        public bool IsLeft { get; set; }

    }

    /// <summary>
    /// A new member joined the chat by invite link
    /// </summary>
    public partial class PushMessageContentChatJoinByLink : PushMessageContent
    {
    }

    /// <summary>
    /// A new member was accepted to the chat by an administrator
    /// </summary>
    public partial class PushMessageContentChatJoinByRequest : PushMessageContent
    {
    }

    /// <summary>
    /// A forwarded messages
    /// </summary>
    public partial class PushMessageContentMessageForwards : PushMessageContent
    {
        /// <summary>
        /// Number of forwarded messages
        /// </summary>
        public int TotalCount { get; set; }

    }

    /// <summary>
    /// A media album
    /// </summary>
    public partial class PushMessageContentMediaAlbum : PushMessageContent
    {
        /// <summary>
        /// Number of messages in the album
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// True, if the album has at least one photo
        /// </summary>
        public bool HasPhotos { get; set; }

        /// <summary>
        /// True, if the album has at least one video
        /// </summary>
        public bool HasVideos { get; set; }

        /// <summary>
        /// True, if the album has at least one audio file
        /// </summary>
        public bool HasAudios { get; set; }

        /// <summary>
        /// True, if the album has at least one document
        /// </summary>
        public bool HasDocuments { get; set; }

    }

    /// <summary>
    /// New message was received
    /// </summary>
    public partial class NotificationTypeNewMessage : NotificationType
    {
        /// <summary>
        /// The message
        /// </summary>
        public Message Message { get; set; }

    }

    /// <summary>
    /// New secret chat was created
    /// </summary>
    public partial class NotificationTypeNewSecretChat : NotificationType
    {
    }

    /// <summary>
    /// New call was received
    /// </summary>
    public partial class NotificationTypeNewCall : NotificationType
    {
        /// <summary>
        /// Call identifier
        /// </summary>
        public int CallId { get; set; }

    }

    /// <summary>
    /// New message was received through a push notification
    /// </summary>
    public partial class NotificationTypeNewPushMessage : NotificationType
    {
        /// <summary>
        /// The message identifier. The message will not be available in the chat history, but the ID can be used in viewMessages, or as reply_to_message_id
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// The sender of the message. Corresponding user or chat may be inaccessible
        /// </summary>
        public MessageSender Sender { get; set; }

        /// <summary>
        /// Name of the sender
        /// </summary>
        public string SenderName { get; set; }

        /// <summary>
        /// True, if the message is outgoing
        /// </summary>
        public bool IsOutgoing { get; set; }

        /// <summary>
        /// Push message content
        /// </summary>
        public PushMessageContent Content { get; set; }

    }

    /// <summary>
    /// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with ordinary unread messages
    /// </summary>
    public partial class NotificationGroupTypeMessages : NotificationGroupType
    {
    }

    /// <summary>
    /// A group containing notifications of type notificationTypeNewMessage and notificationTypeNewPushMessage with unread mentions of the current user, replies to their messages, or a pinned message
    /// </summary>
    public partial class NotificationGroupTypeMentions : NotificationGroupType
    {
    }

    /// <summary>
    /// A group containing a notification of type notificationTypeNewSecretChat
    /// </summary>
    public partial class NotificationGroupTypeSecretChat : NotificationGroupType
    {
    }

    /// <summary>
    /// A group containing notifications of type notificationTypeNewCall
    /// </summary>
    public partial class NotificationGroupTypeCalls : NotificationGroupType
    {
    }

    /// <summary>
    /// Contains information about a notification
    /// </summary>
    public partial class Notification : TLObject
    {
        /// <summary>
        /// Unique persistent identifier of this notification
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Notification date
        /// </summary>
        public int Date { get; set; }

        /// <summary>
        /// True, if the notification was initially silent
        /// </summary>
        public bool IsSilent { get; set; }

        /// <summary>
        /// Notification type
        /// </summary>
        public NotificationType Type { get; set; }

    }

    /// <summary>
    /// Describes a group of notifications
    /// </summary>
    public partial class NotificationGroup : TLObject
    {
        /// <summary>
        /// Unique persistent auto-incremented from 1 identifier of the notification group
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Type of the group
        /// </summary>
        public NotificationGroupType Type { get; set; }

        /// <summary>
        /// Identifier of a chat to which all notifications in the group belong
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Total number of active notifications in the group
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// The list of active notifications
        /// </summary>
        public Notification[] Notifications { get; set; }

    }

    /// <summary>
    /// Represents a boolean option
    /// </summary>
    public partial class OptionValueBoolean : OptionValue
    {
        /// <summary>
        /// The value of the option
        /// </summary>
        public bool Value { get; set; }

    }

    /// <summary>
    /// Represents an unknown option or an option which has a default value
    /// </summary>
    public partial class OptionValueEmpty : OptionValue
    {
    }

    /// <summary>
    /// Represents an integer option
    /// </summary>
    public partial class OptionValueInteger : OptionValue
    {
        /// <summary>
        /// The value of the option
        /// </summary>
        public long Value { get; set; }

    }

    /// <summary>
    /// Represents a string option
    /// </summary>
    public partial class OptionValueString : OptionValue
    {
        /// <summary>
        /// The value of the option
        /// </summary>
        public string Value { get; set; }

    }

    /// <summary>
    /// Represents one member of a JSON object
    /// </summary>
    public partial class JsonObjectMember : TLObject
    {
        /// <summary>
        /// Member's key
        /// </summary>
        public string Key { get; set; }

        /// <summary>
        /// Member's value
        /// </summary>
        public JsonValue Value { get; set; }

    }

    /// <summary>
    /// Represents a null JSON value
    /// </summary>
    public partial class JsonValueNull : JsonValue
    {
    }

    /// <summary>
    /// Represents a boolean JSON value
    /// </summary>
    public partial class JsonValueBoolean : JsonValue
    {
        /// <summary>
        /// The value
        /// </summary>
        public bool Value { get; set; }

    }

    /// <summary>
    /// Represents a numeric JSON value
    /// </summary>
    public partial class JsonValueNumber : JsonValue
    {
        /// <summary>
        /// The value
        /// </summary>
        public double Value { get; set; }

    }

    /// <summary>
    /// Represents a string JSON value
    /// </summary>
    public partial class JsonValueString : JsonValue
    {
        /// <summary>
        /// The value
        /// </summary>
        public string Value { get; set; }

    }

    /// <summary>
    /// Represents a JSON array
    /// </summary>
    public partial class JsonValueArray : JsonValue
    {
        /// <summary>
        /// The list of array elements
        /// </summary>
        public JsonValue[] Values { get; set; }

    }

    /// <summary>
    /// Represents a JSON object
    /// </summary>
    public partial class JsonValueObject : JsonValue
    {
        /// <summary>
        /// The list of object members
        /// </summary>
        public JsonObjectMember[] Members { get; set; }

    }

    /// <summary>
    /// A rule to allow all users to do something
    /// </summary>
    public partial class UserPrivacySettingRuleAllowAll : UserPrivacySettingRule
    {
    }

    /// <summary>
    /// A rule to allow all of a user's contacts to do something
    /// </summary>
    public partial class UserPrivacySettingRuleAllowContacts : UserPrivacySettingRule
    {
    }

    /// <summary>
    /// A rule to allow certain specified users to do something
    /// </summary>
    public partial class UserPrivacySettingRuleAllowUsers : UserPrivacySettingRule
    {
        /// <summary>
        /// The user identifiers, total number of users in all rules must not exceed 1000
        /// </summary>
        public long[] UserIds { get; set; }

    }

    /// <summary>
    /// A rule to allow all members of certain specified basic groups and supergroups to doing something
    /// </summary>
    public partial class UserPrivacySettingRuleAllowChatMembers : UserPrivacySettingRule
    {
        /// <summary>
        /// The chat identifiers, total number of chats in all rules must not exceed 20
        /// </summary>
        public long[] ChatIds { get; set; }

    }

    /// <summary>
    /// A rule to restrict all users from doing something
    /// </summary>
    public partial class UserPrivacySettingRuleRestrictAll : UserPrivacySettingRule
    {
    }

    /// <summary>
    /// A rule to restrict all contacts of a user from doing something
    /// </summary>
    public partial class UserPrivacySettingRuleRestrictContacts : UserPrivacySettingRule
    {
    }

    /// <summary>
    /// A rule to restrict all specified users from doing something
    /// </summary>
    public partial class UserPrivacySettingRuleRestrictUsers : UserPrivacySettingRule
    {
        /// <summary>
        /// The user identifiers, total number of users in all rules must not exceed 1000
        /// </summary>
        public long[] UserIds { get; set; }

    }

    /// <summary>
    /// A rule to restrict all members of specified basic groups and supergroups from doing something
    /// </summary>
    public partial class UserPrivacySettingRuleRestrictChatMembers : UserPrivacySettingRule
    {
        /// <summary>
        /// The chat identifiers, total number of chats in all rules must not exceed 20
        /// </summary>
        public long[] ChatIds { get; set; }

    }

    /// <summary>
    /// A list of privacy rules. Rules are matched in the specified order. The first matched rule defines the privacy setting for a given user. If no rule matches, the action is not allowed
    /// </summary>
    public partial class UserPrivacySettingRules : TLObject
    {
        /// <summary>
        /// A list of rules
        /// </summary>
        public UserPrivacySettingRule[] Rules { get; set; }

    }

    /// <summary>
    /// A privacy setting for managing whether the user's online status is visible
    /// </summary>
    public partial class UserPrivacySettingShowStatus : UserPrivacySetting
    {
    }

    /// <summary>
    /// A privacy setting for managing whether the user's profile photo is visible
    /// </summary>
    public partial class UserPrivacySettingShowProfilePhoto : UserPrivacySetting
    {
    }

    /// <summary>
    /// A privacy setting for managing whether a link to the user's account is included in forwarded messages
    /// </summary>
    public partial class UserPrivacySettingShowLinkInForwardedMessages : UserPrivacySetting
    {
    }

    /// <summary>
    /// A privacy setting for managing whether the user's phone number is visible
    /// </summary>
    public partial class UserPrivacySettingShowPhoneNumber : UserPrivacySetting
    {
    }

    /// <summary>
    /// A privacy setting for managing whether the user can be invited to chats
    /// </summary>
    public partial class UserPrivacySettingAllowChatInvites : UserPrivacySetting
    {
    }

    /// <summary>
    /// A privacy setting for managing whether the user can be called
    /// </summary>
    public partial class UserPrivacySettingAllowCalls : UserPrivacySetting
    {
    }

    /// <summary>
    /// A privacy setting for managing whether peer-to-peer connections can be used for calls
    /// </summary>
    public partial class UserPrivacySettingAllowPeerToPeerCalls : UserPrivacySetting
    {
    }

    /// <summary>
    /// A privacy setting for managing whether the user can be found by their phone number. Checked only if the phone number is not known to the other user. Can be set only to "Allow contacts" or "Allow all"
    /// </summary>
    public partial class UserPrivacySettingAllowFindingByPhoneNumber : UserPrivacySetting
    {
    }

    /// <summary>
    /// Contains information about the period of inactivity after which the current user's account will automatically be deleted
    /// </summary>
    public partial class AccountTtl : TLObject
    {
        /// <summary>
        /// Number of days of inactivity before the account will be flagged for deletion; 30-366 days
        /// </summary>
        public int Days { get; set; }

    }

    /// <summary>
    /// Contains information about one session in a Telegram application used by the current user. Sessions must be shown to the user in the returned order
    /// </summary>
    public partial class Session : TLObject
    {
        /// <summary>
        /// Session identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// True, if this session is the current session
        /// </summary>
        public bool IsCurrent { get; set; }

        /// <summary>
        /// True, if a password is needed to complete authorization of the session
        /// </summary>
        public bool IsPasswordPending { get; set; }

        /// <summary>
        /// Telegram API identifier, as provided by the application
        /// </summary>
        public int ApiId { get; set; }

        /// <summary>
        /// Name of the application, as provided by the application
        /// </summary>
        public string ApplicationName { get; set; }

        /// <summary>
        /// The version of the application, as provided by the application
        /// </summary>
        public string ApplicationVersion { get; set; }

        /// <summary>
        /// True, if the application is an official application or uses the api_id of an official application
        /// </summary>
        public bool IsOfficialApplication { get; set; }

        /// <summary>
        /// Model of the device the application has been run or is running on, as provided by the application
        /// </summary>
        public string DeviceModel { get; set; }

        /// <summary>
        /// Operating system the application has been run or is running on, as provided by the application
        /// </summary>
        public string Platform { get; set; }

        /// <summary>
        /// Version of the operating system the application has been run or is running on, as provided by the application
        /// </summary>
        public string SystemVersion { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the user has logged in
        /// </summary>
        public int LogInDate { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the session was last used
        /// </summary>
        public int LastActiveDate { get; set; }

        /// <summary>
        /// IP address from which the session was created, in human-readable format
        /// </summary>
        public string Ip { get; set; }

        /// <summary>
        /// A two-letter country code for the country from which the session was created, based on the IP address
        /// </summary>
        public string Country { get; set; }

        /// <summary>
        /// Region code from which the session was created, based on the IP address
        /// </summary>
        public string Region { get; set; }

    }

    /// <summary>
    /// Contains a list of sessions
    /// </summary>
    public partial class Sessions : TLObject
    {
        /// <summary>
        /// List of sessions
        /// </summary>
        public Session[] Sessions_ { get; set; }

    }

    /// <summary>
    /// Contains information about one website the current user is logged in with Telegram
    /// </summary>
    public partial class ConnectedWebsite : TLObject
    {
        /// <summary>
        /// Website identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// The domain name of the website
        /// </summary>
        public string DomainName { get; set; }

        /// <summary>
        /// User identifier of a bot linked with the website
        /// </summary>
        public long BotUserId { get; set; }

        /// <summary>
        /// The version of a browser used to log in
        /// </summary>
        public string Browser { get; set; }

        /// <summary>
        /// Operating system the browser is running on
        /// </summary>
        public string Platform { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the user was logged in
        /// </summary>
        public int LogInDate { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when obtained authorization was last used
        /// </summary>
        public int LastActiveDate { get; set; }

        /// <summary>
        /// IP address from which the user was logged in, in human-readable format
        /// </summary>
        public string Ip { get; set; }

        /// <summary>
        /// Human-readable description of a country and a region, from which the user was logged in, based on the IP address
        /// </summary>
        public string Location { get; set; }

    }

    /// <summary>
    /// Contains a list of websites the current user is logged in with Telegram
    /// </summary>
    public partial class ConnectedWebsites : TLObject
    {
        /// <summary>
        /// List of connected websites
        /// </summary>
        public ConnectedWebsite[] Websites { get; set; }

    }

    /// <summary>
    /// The chat contains spam messages
    /// </summary>
    public partial class ChatReportReasonSpam : ChatReportReason
    {
    }

    /// <summary>
    /// The chat promotes violence
    /// </summary>
    public partial class ChatReportReasonViolence : ChatReportReason
    {
    }

    /// <summary>
    /// The chat contains pornographic messages
    /// </summary>
    public partial class ChatReportReasonPornography : ChatReportReason
    {
    }

    /// <summary>
    /// The chat has child abuse related content
    /// </summary>
    public partial class ChatReportReasonChildAbuse : ChatReportReason
    {
    }

    /// <summary>
    /// The chat contains copyrighted content
    /// </summary>
    public partial class ChatReportReasonCopyright : ChatReportReason
    {
    }

    /// <summary>
    /// The location-based chat is unrelated to its stated location
    /// </summary>
    public partial class ChatReportReasonUnrelatedLocation : ChatReportReason
    {
    }

    /// <summary>
    /// The chat represents a fake account
    /// </summary>
    public partial class ChatReportReasonFake : ChatReportReason
    {
    }

    /// <summary>
    /// A custom reason provided by the user
    /// </summary>
    public partial class ChatReportReasonCustom : ChatReportReason
    {
    }

    /// <summary>
    /// The link is a link to the active sessions section of the app. Use getActiveSessions to handle the link
    /// </summary>
    public partial class InternalLinkTypeActiveSessions : InternalLinkType
    {
    }

    /// <summary>
    /// The link contains an authentication code. Call checkAuthenticationCode with the code if the current authorization state is authorizationStateWaitCode
    /// </summary>
    public partial class InternalLinkTypeAuthenticationCode : InternalLinkType
    {
        /// <summary>
        /// The authentication code
        /// </summary>
        public string Code { get; set; }

    }

    /// <summary>
    /// The link is a link to a background. Call searchBackground with the given background name to process the link
    /// </summary>
    public partial class InternalLinkTypeBackground : InternalLinkType
    {
        /// <summary>
        /// Name of the background
        /// </summary>
        public string BackgroundName { get; set; }

    }

    /// <summary>
    /// The link is a link to a chat with a Telegram bot. Call searchPublicChat with the given bot username, check that the user is a bot, show START button in the chat with the bot, -and then call sendBotStartMessage with the given start parameter after the button is pressed
    /// </summary>
    public partial class InternalLinkTypeBotStart : InternalLinkType
    {
        /// <summary>
        /// Username of the bot
        /// </summary>
        public string BotUsername { get; set; }

        /// <summary>
        /// The parameter to be passed to sendBotStartMessage
        /// </summary>
        public string StartParameter { get; set; }

    }

    /// <summary>
    /// The link is a link to a Telegram bot, which is supposed to be added to a group chat. Call searchPublicChat with the given bot username, check that the user is a bot and can be added to groups, -ask the current user to select a group to add the bot to, and then call sendBotStartMessage with the given start parameter and the chosen group chat. Bots can be added to a public group only by administrators of the group
    /// </summary>
    public partial class InternalLinkTypeBotStartInGroup : InternalLinkType
    {
        /// <summary>
        /// Username of the bot
        /// </summary>
        public string BotUsername { get; set; }

        /// <summary>
        /// The parameter to be passed to sendBotStartMessage
        /// </summary>
        public string StartParameter { get; set; }

    }

    /// <summary>
    /// The link is a link to the change phone number section of the app
    /// </summary>
    public partial class InternalLinkTypeChangePhoneNumber : InternalLinkType
    {
    }

    /// <summary>
    /// The link is a chat invite link. Call checkChatInviteLink with the given invite link to process the link
    /// </summary>
    public partial class InternalLinkTypeChatInvite : InternalLinkType
    {
        /// <summary>
        /// Internal representation of the invite link
        /// </summary>
        public string InviteLink { get; set; }

    }

    /// <summary>
    /// The link is a link to the filter settings section of the app
    /// </summary>
    public partial class InternalLinkTypeFilterSettings : InternalLinkType
    {
    }

    /// <summary>
    /// The link is a link to a game. Call searchPublicChat with the given bot username, check that the user is a bot, ask the current user to select a chat to send the game, and then call sendMessage with inputMessageGame
    /// </summary>
    public partial class InternalLinkTypeGame : InternalLinkType
    {
        /// <summary>
        /// Username of the bot that owns the game
        /// </summary>
        public string BotUsername { get; set; }

        /// <summary>
        /// Short name of the game
        /// </summary>
        public string GameShortName { get; set; }

    }

    /// <summary>
    /// The link is a link to a language pack. Call getLanguagePackInfo with the given language pack identifier to process the link
    /// </summary>
    public partial class InternalLinkTypeLanguagePack : InternalLinkType
    {
        /// <summary>
        /// Language pack identifier
        /// </summary>
        public string LanguagePackId { get; set; }

    }

    /// <summary>
    /// The link is a link to a Telegram message. Call getMessageLinkInfo with the given URL to process the link
    /// </summary>
    public partial class InternalLinkTypeMessage : InternalLinkType
    {
        /// <summary>
        /// URL to be passed to getMessageLinkInfo
        /// </summary>
        public string Url { get; set; }

    }

    /// <summary>
    /// The link contains a message draft text. A share screen needs to be shown to the user, then the chosen chat must be opened and the text is added to the input field
    /// </summary>
    public partial class InternalLinkTypeMessageDraft : InternalLinkType
    {
        /// <summary>
        /// Message draft text
        /// </summary>
        public FormattedText Text { get; set; }

        /// <summary>
        /// True, if the first line of the text contains a link. If true, the input field needs to be focused and the text after the link must be selected
        /// </summary>
        public bool ContainsLink { get; set; }

    }

    /// <summary>
    /// The link contains a request of Telegram passport data. Call getPassportAuthorizationForm with the given parameters to process the link if the link was received from outside of the app, otherwise ignore it
    /// </summary>
    public partial class InternalLinkTypePassportDataRequest : InternalLinkType
    {
        /// <summary>
        /// User identifier of the service's bot
        /// </summary>
        public long BotUserId { get; set; }

        /// <summary>
        /// Telegram Passport element types requested by the service
        /// </summary>
        public string Scope { get; set; }

        /// <summary>
        /// Service's public key
        /// </summary>
        public string PublicKey { get; set; }

        /// <summary>
        /// Unique request identifier provided by the service
        /// </summary>
        public string Nonce { get; set; }

        /// <summary>
        /// An HTTP URL to open once the request is finished or canceled with the parameter tg_passport=success or tg_passport=cancel respectively. If empty, then the link tgbot{bot_user_id}://passport/success or tgbot{bot_user_id}://passport/cancel needs to be opened instead
        /// </summary>
        public string CallbackUrl { get; set; }

    }

    /// <summary>
    /// The link can be used to confirm ownership of a phone number to prevent account deletion. Call sendPhoneNumberConfirmationCode with the given hash and phone number to process the link
    /// </summary>
    public partial class InternalLinkTypePhoneNumberConfirmation : InternalLinkType
    {
        /// <summary>
        /// Hash value from the link
        /// </summary>
        public string Hash { get; set; }

        /// <summary>
        /// Phone number value from the link
        /// </summary>
        public string PhoneNumber { get; set; }

    }

    /// <summary>
    /// The link is a link to a proxy. Call addProxy with the given parameters to process the link and add the proxy
    /// </summary>
    public partial class InternalLinkTypeProxy : InternalLinkType
    {
        /// <summary>
        /// Proxy server IP address
        /// </summary>
        public string Server { get; set; }

        /// <summary>
        /// Proxy server port
        /// </summary>
        public int Port { get; set; }

        /// <summary>
        /// Type of the proxy
        /// </summary>
        public ProxyType Type { get; set; }

    }

    /// <summary>
    /// The link is a link to a chat by its username. Call searchPublicChat with the given chat username to process the link
    /// </summary>
    public partial class InternalLinkTypePublicChat : InternalLinkType
    {
        /// <summary>
        /// Username of the chat
        /// </summary>
        public string ChatUsername { get; set; }

    }

    /// <summary>
    /// The link can be used to login the current user on another device, but it must be scanned from QR-code using in-app camera. An alert similar to -"This code can be used to allow someone to log in to your Telegram account. To confirm Telegram login, please go to Settings &gt; Devices &gt; Scan QR and scan the code" needs to be shown
    /// </summary>
    public partial class InternalLinkTypeQrCodeAuthentication : InternalLinkType
    {
    }

    /// <summary>
    /// The link is a link to app settings
    /// </summary>
    public partial class InternalLinkTypeSettings : InternalLinkType
    {
    }

    /// <summary>
    /// The link is a link to a sticker set. Call searchStickerSet with the given sticker set name to process the link and show the sticker set
    /// </summary>
    public partial class InternalLinkTypeStickerSet : InternalLinkType
    {
        /// <summary>
        /// Name of the sticker set
        /// </summary>
        public string StickerSetName { get; set; }

    }

    /// <summary>
    /// The link is a link to a theme. TDLib has no theme support yet
    /// </summary>
    public partial class InternalLinkTypeTheme : InternalLinkType
    {
        /// <summary>
        /// Name of the theme
        /// </summary>
        public string ThemeName { get; set; }

    }

    /// <summary>
    /// The link is a link to the theme settings section of the app
    /// </summary>
    public partial class InternalLinkTypeThemeSettings : InternalLinkType
    {
    }

    /// <summary>
    /// The link is an unknown tg: link. Call getDeepLinkInfo to process the link
    /// </summary>
    public partial class InternalLinkTypeUnknownDeepLink : InternalLinkType
    {
        /// <summary>
        /// Link to be passed to getDeepLinkInfo
        /// </summary>
        public string Link { get; set; }

    }

    /// <summary>
    /// The link is a link to an unsupported proxy. An alert can be shown to the user
    /// </summary>
    public partial class InternalLinkTypeUnsupportedProxy : InternalLinkType
    {
    }

    /// <summary>
    /// The link is a link to a video chat. Call searchPublicChat with the given chat username, and then joinGoupCall with the given invite hash to process the link
    /// </summary>
    public partial class InternalLinkTypeVideoChat : InternalLinkType
    {
        /// <summary>
        /// Username of the chat with the video chat
        /// </summary>
        public string ChatUsername { get; set; }

        /// <summary>
        /// If non-empty, invite hash to be used to join the video chat without being muted by administrators
        /// </summary>
        public string InviteHash { get; set; }

        /// <summary>
        /// True, if the video chat is expected to be a live stream in a channel or a broadcast group
        /// </summary>
        public bool IsLiveStream { get; set; }

    }

    /// <summary>
    /// Contains an HTTPS link to a message in a supergroup or channel
    /// </summary>
    public partial class MessageLink : TLObject
    {
        /// <summary>
        /// Message link
        /// </summary>
        public string Link { get; set; }

        /// <summary>
        /// True, if the link will work for non-members of the chat
        /// </summary>
        public bool IsPublic { get; set; }

    }

    /// <summary>
    /// Contains information about a link to a message in a chat
    /// </summary>
    public partial class MessageLinkInfo : TLObject
    {
        /// <summary>
        /// True, if the link is a public link for a message in a chat
        /// </summary>
        public bool IsPublic { get; set; }

        /// <summary>
        /// If found, identifier of the chat to which the message belongs, 0 otherwise
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// If found, the linked message; may be null
        /// </summary>
        public Message Message { get; set; }

        /// <summary>
        /// Timestamp from which the video/audio/video note/voice note playing must start, in seconds; 0 if not specified. The media can be in the message content or in its web page preview
        /// </summary>
        public int MediaTimestamp { get; set; }

        /// <summary>
        /// True, if the whole media album to which the message belongs is linked
        /// </summary>
        public bool ForAlbum { get; set; }

        /// <summary>
        /// True, if the message is linked as a channel post comment or from a message thread
        /// </summary>
        public bool ForComment { get; set; }

    }

    /// <summary>
    /// Contains a part of a file
    /// </summary>
    public partial class FilePart : TLObject
    {
        /// <summary>
        /// File bytes
        /// </summary>
        public Memory<byte> Data { get; set; }

    }

    /// <summary>
    /// The data is not a file
    /// </summary>
    public partial class FileTypeNone : FileType
    {
    }

    /// <summary>
    /// The file is an animation
    /// </summary>
    public partial class FileTypeAnimation : FileType
    {
    }

    /// <summary>
    /// The file is an audio file
    /// </summary>
    public partial class FileTypeAudio : FileType
    {
    }

    /// <summary>
    /// The file is a document
    /// </summary>
    public partial class FileTypeDocument : FileType
    {
    }

    /// <summary>
    /// The file is a photo
    /// </summary>
    public partial class FileTypePhoto : FileType
    {
    }

    /// <summary>
    /// The file is a profile photo
    /// </summary>
    public partial class FileTypeProfilePhoto : FileType
    {
    }

    /// <summary>
    /// The file was sent to a secret chat (the file type is not known to the server)
    /// </summary>
    public partial class FileTypeSecret : FileType
    {
    }

    /// <summary>
    /// The file is a thumbnail of a file from a secret chat
    /// </summary>
    public partial class FileTypeSecretThumbnail : FileType
    {
    }

    /// <summary>
    /// The file is a file from Secure storage used for storing Telegram Passport files
    /// </summary>
    public partial class FileTypeSecure : FileType
    {
    }

    /// <summary>
    /// The file is a sticker
    /// </summary>
    public partial class FileTypeSticker : FileType
    {
    }

    /// <summary>
    /// The file is a thumbnail of another file
    /// </summary>
    public partial class FileTypeThumbnail : FileType
    {
    }

    /// <summary>
    /// The file type is not yet known
    /// </summary>
    public partial class FileTypeUnknown : FileType
    {
    }

    /// <summary>
    /// The file is a video
    /// </summary>
    public partial class FileTypeVideo : FileType
    {
    }

    /// <summary>
    /// The file is a video note
    /// </summary>
    public partial class FileTypeVideoNote : FileType
    {
    }

    /// <summary>
    /// The file is a voice note
    /// </summary>
    public partial class FileTypeVoiceNote : FileType
    {
    }

    /// <summary>
    /// The file is a wallpaper or a background pattern
    /// </summary>
    public partial class FileTypeWallpaper : FileType
    {
    }

    /// <summary>
    /// Contains the storage usage statistics for a specific file type
    /// </summary>
    public partial class StorageStatisticsByFileType : TLObject
    {
        /// <summary>
        /// File type
        /// </summary>
        public FileType FileType { get; set; }

        /// <summary>
        /// Total size of the files, in bytes
        /// </summary>
        public long Size { get; set; }

        /// <summary>
        /// Total number of files
        /// </summary>
        public int Count { get; set; }

    }

    /// <summary>
    /// Contains the storage usage statistics for a specific chat
    /// </summary>
    public partial class StorageStatisticsByChat : TLObject
    {
        /// <summary>
        /// Chat identifier; 0 if none
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Total size of the files in the chat, in bytes
        /// </summary>
        public long Size { get; set; }

        /// <summary>
        /// Total number of files in the chat
        /// </summary>
        public int Count { get; set; }

        /// <summary>
        /// Statistics split by file types
        /// </summary>
        public StorageStatisticsByFileType[] ByFileType { get; set; }

    }

    /// <summary>
    /// Contains the exact storage usage statistics split by chats and file type
    /// </summary>
    public partial class StorageStatistics : TLObject
    {
        /// <summary>
        /// Total size of files, in bytes
        /// </summary>
        public long Size { get; set; }

        /// <summary>
        /// Total number of files
        /// </summary>
        public int Count { get; set; }

        /// <summary>
        /// Statistics split by chats
        /// </summary>
        public StorageStatisticsByChat[] ByChat { get; set; }

    }

    /// <summary>
    /// Contains approximate storage usage statistics, excluding files of unknown file type
    /// </summary>
    public partial class StorageStatisticsFast : TLObject
    {
        /// <summary>
        /// Approximate total size of files, in bytes
        /// </summary>
        public long FilesSize { get; set; }

        /// <summary>
        /// Approximate number of files
        /// </summary>
        public int FileCount { get; set; }

        /// <summary>
        /// Size of the database
        /// </summary>
        public long DatabaseSize { get; set; }

        /// <summary>
        /// Size of the language pack database
        /// </summary>
        public long LanguagePackDatabaseSize { get; set; }

        /// <summary>
        /// Size of the TDLib internal log
        /// </summary>
        public long LogSize { get; set; }

    }

    /// <summary>
    /// Contains database statistics
    /// </summary>
    public partial class DatabaseStatistics : TLObject
    {
        /// <summary>
        /// Database statistics in an unspecified human-readable format
        /// </summary>
        public string Statistics { get; set; }

    }

    /// <summary>
    /// The network is not available
    /// </summary>
    public partial class NetworkTypeNone : NetworkType
    {
    }

    /// <summary>
    /// A mobile network
    /// </summary>
    public partial class NetworkTypeMobile : NetworkType
    {
    }

    /// <summary>
    /// A mobile roaming network
    /// </summary>
    public partial class NetworkTypeMobileRoaming : NetworkType
    {
    }

    /// <summary>
    /// A Wi-Fi network
    /// </summary>
    public partial class NetworkTypeWiFi : NetworkType
    {
    }

    /// <summary>
    /// A different network type (e.g., Ethernet network)
    /// </summary>
    public partial class NetworkTypeOther : NetworkType
    {
    }

    /// <summary>
    /// Contains information about the total amount of data that was used to send and receive files
    /// </summary>
    public partial class NetworkStatisticsEntryFile : NetworkStatisticsEntry
    {
        /// <summary>
        /// Type of the file the data is part of; pass null if the data isn't related to files
        /// </summary>
        public FileType FileType { get; set; }

        /// <summary>
        /// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
        /// </summary>
        public NetworkType NetworkType { get; set; }

        /// <summary>
        /// Total number of bytes sent
        /// </summary>
        public long SentBytes { get; set; }

        /// <summary>
        /// Total number of bytes received
        /// </summary>
        public long ReceivedBytes { get; set; }

    }

    /// <summary>
    /// Contains information about the total amount of data that was used for calls
    /// </summary>
    public partial class NetworkStatisticsEntryCall : NetworkStatisticsEntry
    {
        /// <summary>
        /// Type of the network the data was sent through. Call setNetworkType to maintain the actual network type
        /// </summary>
        public NetworkType NetworkType { get; set; }

        /// <summary>
        /// Total number of bytes sent
        /// </summary>
        public long SentBytes { get; set; }

        /// <summary>
        /// Total number of bytes received
        /// </summary>
        public long ReceivedBytes { get; set; }

        /// <summary>
        /// Total call duration, in seconds
        /// </summary>
        public double Duration { get; set; }

    }

    /// <summary>
    /// A full list of available network statistic entries
    /// </summary>
    public partial class NetworkStatistics : TLObject
    {
        /// <summary>
        /// Point in time (Unix timestamp) from which the statistics are collected
        /// </summary>
        public int SinceDate { get; set; }

        /// <summary>
        /// Network statistics entries
        /// </summary>
        public NetworkStatisticsEntry[] Entries { get; set; }

    }

    /// <summary>
    /// Contains auto-download settings
    /// </summary>
    public partial class AutoDownloadSettings : TLObject
    {
        /// <summary>
        /// True, if the auto-download is enabled
        /// </summary>
        public bool IsAutoDownloadEnabled { get; set; }

        /// <summary>
        /// The maximum size of a photo file to be auto-downloaded, in bytes
        /// </summary>
        public int MaxPhotoFileSize { get; set; }

        /// <summary>
        /// The maximum size of a video file to be auto-downloaded, in bytes
        /// </summary>
        public int MaxVideoFileSize { get; set; }

        /// <summary>
        /// The maximum size of other file types to be auto-downloaded, in bytes
        /// </summary>
        public int MaxOtherFileSize { get; set; }

        /// <summary>
        /// The maximum suggested bitrate for uploaded videos, in kbit/s
        /// </summary>
        public int VideoUploadBitrate { get; set; }

        /// <summary>
        /// True, if the beginning of video files needs to be preloaded for instant playback
        /// </summary>
        public bool PreloadLargeVideos { get; set; }

        /// <summary>
        /// True, if the next audio track needs to be preloaded while the user is listening to an audio file
        /// </summary>
        public bool PreloadNextAudio { get; set; }

        /// <summary>
        /// True, if "use less data for calls" option needs to be enabled
        /// </summary>
        public bool UseLessDataForCalls { get; set; }

    }

    /// <summary>
    /// Contains auto-download settings presets for the current user
    /// </summary>
    public partial class AutoDownloadSettingsPresets : TLObject
    {
        /// <summary>
        /// Preset with lowest settings; supposed to be used by default when roaming
        /// </summary>
        public AutoDownloadSettings Low { get; set; }

        /// <summary>
        /// Preset with medium settings; supposed to be used by default when using mobile data
        /// </summary>
        public AutoDownloadSettings Medium { get; set; }

        /// <summary>
        /// Preset with highest settings; supposed to be used by default when connected on Wi-Fi
        /// </summary>
        public AutoDownloadSettings High { get; set; }

    }

    /// <summary>
    /// Currently waiting for the network to become available. Use setNetworkType to change the available network type
    /// </summary>
    public partial class ConnectionStateWaitingForNetwork : ConnectionState
    {
    }

    /// <summary>
    /// Currently establishing a connection with a proxy server
    /// </summary>
    public partial class ConnectionStateConnectingToProxy : ConnectionState
    {
    }

    /// <summary>
    /// Currently establishing a connection to the Telegram servers
    /// </summary>
    public partial class ConnectionStateConnecting : ConnectionState
    {
    }

    /// <summary>
    /// Downloading data received while the application was offline
    /// </summary>
    public partial class ConnectionStateUpdating : ConnectionState
    {
    }

    /// <summary>
    /// There is a working connection to the Telegram servers
    /// </summary>
    public partial class ConnectionStateReady : ConnectionState
    {
    }

    /// <summary>
    /// A category containing frequently used private chats with non-bot users
    /// </summary>
    public partial class TopChatCategoryUsers : TopChatCategory
    {
    }

    /// <summary>
    /// A category containing frequently used private chats with bot users
    /// </summary>
    public partial class TopChatCategoryBots : TopChatCategory
    {
    }

    /// <summary>
    /// A category containing frequently used basic groups and supergroups
    /// </summary>
    public partial class TopChatCategoryGroups : TopChatCategory
    {
    }

    /// <summary>
    /// A category containing frequently used channels
    /// </summary>
    public partial class TopChatCategoryChannels : TopChatCategory
    {
    }

    /// <summary>
    /// A category containing frequently used chats with inline bots sorted by their usage in inline mode
    /// </summary>
    public partial class TopChatCategoryInlineBots : TopChatCategory
    {
    }

    /// <summary>
    /// A category containing frequently used chats used for calls
    /// </summary>
    public partial class TopChatCategoryCalls : TopChatCategory
    {
    }

    /// <summary>
    /// A category containing frequently used chats used to forward messages
    /// </summary>
    public partial class TopChatCategoryForwardChats : TopChatCategory
    {
    }

    /// <summary>
    /// A URL linking to a user
    /// </summary>
    public partial class TMeUrlTypeUser : TMeUrlType
    {
        /// <summary>
        /// Identifier of the user
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// A URL linking to a public supergroup or channel
    /// </summary>
    public partial class TMeUrlTypeSupergroup : TMeUrlType
    {
        /// <summary>
        /// Identifier of the supergroup or channel
        /// </summary>
        public long SupergroupId { get; set; }

    }

    /// <summary>
    /// A chat invite link
    /// </summary>
    public partial class TMeUrlTypeChatInvite : TMeUrlType
    {
        /// <summary>
        /// Chat invite link info
        /// </summary>
        public ChatInviteLinkInfo Info { get; set; }

    }

    /// <summary>
    /// A URL linking to a sticker set
    /// </summary>
    public partial class TMeUrlTypeStickerSet : TMeUrlType
    {
        /// <summary>
        /// Identifier of the sticker set
        /// </summary>
        public long StickerSetId { get; set; }

    }

    /// <summary>
    /// Represents a URL linking to an internal Telegram entity
    /// </summary>
    public partial class TMeUrl : TLObject
    {
        /// <summary>
        /// URL
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// Type of the URL
        /// </summary>
        public TMeUrlType Type { get; set; }

    }

    /// <summary>
    /// Contains a list of t.me URLs
    /// </summary>
    public partial class TMeUrls : TLObject
    {
        /// <summary>
        /// List of URLs
        /// </summary>
        public TMeUrl[] Urls { get; set; }

    }

    /// <summary>
    /// Suggests the user to enable "archive_and_mute_new_chats_from_unknown_users" option
    /// </summary>
    public partial class SuggestedActionEnableArchiveAndMuteNewChats : SuggestedAction
    {
    }

    /// <summary>
    /// Suggests the user to check whether 2-step verification password is still remembered
    /// </summary>
    public partial class SuggestedActionCheckPassword : SuggestedAction
    {
    }

    /// <summary>
    /// Suggests the user to check whether authorization phone number is correct and change the phone number if it is inaccessible
    /// </summary>
    public partial class SuggestedActionCheckPhoneNumber : SuggestedAction
    {
    }

    /// <summary>
    /// Suggests the user to see a hint about meaning of one and two ticks on sent message
    /// </summary>
    public partial class SuggestedActionSeeTicksHint : SuggestedAction
    {
    }

    /// <summary>
    /// Suggests the user to convert specified supergroup to a broadcast group
    /// </summary>
    public partial class SuggestedActionConvertToBroadcastGroup : SuggestedAction
    {
        /// <summary>
        /// Supergroup identifier
        /// </summary>
        public long SupergroupId { get; set; }

    }

    /// <summary>
    /// Contains a counter
    /// </summary>
    public partial class Count : TLObject
    {
        /// <summary>
        /// Count
        /// </summary>
        public int Count_ { get; set; }

    }

    /// <summary>
    /// Contains some text
    /// </summary>
    public partial class Text : TLObject
    {
        /// <summary>
        /// Text
        /// </summary>
        public string Text_ { get; set; }

    }

    /// <summary>
    /// Contains a value representing a number of seconds
    /// </summary>
    public partial class Seconds : TLObject
    {
        /// <summary>
        /// Number of seconds
        /// </summary>
        public double Seconds_ { get; set; }

    }

    /// <summary>
    /// Contains information about a tg: deep link
    /// </summary>
    public partial class DeepLinkInfo : TLObject
    {
        /// <summary>
        /// Text to be shown to the user
        /// </summary>
        public FormattedText Text { get; set; }

        /// <summary>
        /// True, if the user must be asked to update the application
        /// </summary>
        public bool NeedUpdateApplication { get; set; }

    }

    /// <summary>
    /// The text uses Markdown-style formatting
    /// </summary>
    public partial class TextParseModeMarkdown : TextParseMode
    {
        /// <summary>
        /// Version of the parser: 0 or 1 - Telegram Bot API "Markdown" parse mode, 2 - Telegram Bot API "MarkdownV2" parse mode
        /// </summary>
        public int Version { get; set; }

    }

    /// <summary>
    /// The text uses HTML-style formatting. The same as Telegram Bot API "HTML" parse mode
    /// </summary>
    public partial class TextParseModeHTML : TextParseMode
    {
    }

    /// <summary>
    /// A SOCKS5 proxy server
    /// </summary>
    public partial class ProxyTypeSocks5 : ProxyType
    {
        /// <summary>
        /// Username for logging in; may be empty
        /// </summary>
        public string Username { get; set; }

        /// <summary>
        /// Password for logging in; may be empty
        /// </summary>
        public string Password { get; set; }

    }

    /// <summary>
    /// A HTTP transparent proxy server
    /// </summary>
    public partial class ProxyTypeHttp : ProxyType
    {
        /// <summary>
        /// Username for logging in; may be empty
        /// </summary>
        public string Username { get; set; }

        /// <summary>
        /// Password for logging in; may be empty
        /// </summary>
        public string Password { get; set; }

        /// <summary>
        /// Pass true if the proxy supports only HTTP requests and doesn't support transparent TCP connections via HTTP CONNECT method
        /// </summary>
        public bool HttpOnly { get; set; }

    }

    /// <summary>
    /// An MTProto proxy server
    /// </summary>
    public partial class ProxyTypeMtproto : ProxyType
    {
        /// <summary>
        /// The proxy's secret in hexadecimal encoding
        /// </summary>
        public string Secret { get; set; }

    }

    /// <summary>
    /// Contains information about a proxy server
    /// </summary>
    public partial class Proxy : TLObject
    {
        /// <summary>
        /// Unique identifier of the proxy
        /// </summary>
        public int Id { get; set; }

        /// <summary>
        /// Proxy server IP address
        /// </summary>
        public string Server { get; set; }

        /// <summary>
        /// Proxy server port
        /// </summary>
        public int Port { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the proxy was last used; 0 if never
        /// </summary>
        public int LastUsedDate { get; set; }

        /// <summary>
        /// True, if the proxy is enabled now
        /// </summary>
        public bool IsEnabled { get; set; }

        /// <summary>
        /// Type of the proxy
        /// </summary>
        public ProxyType Type { get; set; }

    }

    /// <summary>
    /// Represents a list of proxy servers
    /// </summary>
    public partial class Proxies : TLObject
    {
        /// <summary>
        /// List of proxy servers
        /// </summary>
        public Proxy[] Proxies_ { get; set; }

    }

    /// <summary>
    /// A static sticker in PNG format, which will be converted to WEBP server-side
    /// </summary>
    public partial class InputStickerStatic : InputSticker
    {
        /// <summary>
        /// PNG image with the sticker; must be up to 512 KB in size and fit in a 512x512 square
        /// </summary>
        public InputFile Sticker { get; set; }

        /// <summary>
        /// Emojis corresponding to the sticker
        /// </summary>
        public string Emojis { get; set; }

        /// <summary>
        /// For masks, position where the mask is placed; pass null if unspecified
        /// </summary>
        public MaskPosition MaskPosition { get; set; }

    }

    /// <summary>
    /// An animated sticker in TGS format
    /// </summary>
    public partial class InputStickerAnimated : InputSticker
    {
        /// <summary>
        /// File with the animated sticker. Only local or uploaded within a week files are supported. See https://core.telegram.org/animated_stickers#technical-requirements for technical requirements
        /// </summary>
        public InputFile Sticker { get; set; }

        /// <summary>
        /// Emojis corresponding to the sticker
        /// </summary>
        public string Emojis { get; set; }

    }

    /// <summary>
    /// Represents a date range
    /// </summary>
    public partial class DateRange : TLObject
    {
        /// <summary>
        /// Point in time (Unix timestamp) at which the date range begins
        /// </summary>
        public int StartDate { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) at which the date range ends
        /// </summary>
        public int EndDate { get; set; }

    }

    /// <summary>
    /// A value with information about its recent changes
    /// </summary>
    public partial class StatisticalValue : TLObject
    {
        /// <summary>
        /// The current value
        /// </summary>
        public double Value { get; set; }

        /// <summary>
        /// The value for the previous day
        /// </summary>
        public double PreviousValue { get; set; }

        /// <summary>
        /// The growth rate of the value, as a percentage
        /// </summary>
        public double GrowthRatePercentage { get; set; }

    }

    /// <summary>
    /// A graph data
    /// </summary>
    public partial class StatisticalGraphData : StatisticalGraph
    {
        /// <summary>
        /// Graph data in JSON format
        /// </summary>
        public string JsonData { get; set; }

        /// <summary>
        /// If non-empty, a token which can be used to receive a zoomed in graph
        /// </summary>
        public string ZoomToken { get; set; }

    }

    /// <summary>
    /// The graph data to be asynchronously loaded through getStatisticalGraph
    /// </summary>
    public partial class StatisticalGraphAsync : StatisticalGraph
    {
        /// <summary>
        /// The token to use for data loading
        /// </summary>
        public string Token { get; set; }

    }

    /// <summary>
    /// An error message to be shown to the user instead of the graph
    /// </summary>
    public partial class StatisticalGraphError : StatisticalGraph
    {
        /// <summary>
        /// The error message
        /// </summary>
        public string ErrorMessage { get; set; }

    }

    /// <summary>
    /// Contains statistics about interactions with a message
    /// </summary>
    public partial class ChatStatisticsMessageInteractionInfo : TLObject
    {
        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Number of times the message was viewed
        /// </summary>
        public int ViewCount { get; set; }

        /// <summary>
        /// Number of times the message was forwarded
        /// </summary>
        public int ForwardCount { get; set; }

    }

    /// <summary>
    /// Contains statistics about messages sent by a user
    /// </summary>
    public partial class ChatStatisticsMessageSenderInfo : TLObject
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Number of sent messages
        /// </summary>
        public int SentMessageCount { get; set; }

        /// <summary>
        /// Average number of characters in sent messages; 0 if unknown
        /// </summary>
        public int AverageCharacterCount { get; set; }

    }

    /// <summary>
    /// Contains statistics about administrator actions done by a user
    /// </summary>
    public partial class ChatStatisticsAdministratorActionsInfo : TLObject
    {
        /// <summary>
        /// Administrator user identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Number of messages deleted by the administrator
        /// </summary>
        public int DeletedMessageCount { get; set; }

        /// <summary>
        /// Number of users banned by the administrator
        /// </summary>
        public int BannedUserCount { get; set; }

        /// <summary>
        /// Number of users restricted by the administrator
        /// </summary>
        public int RestrictedUserCount { get; set; }

    }

    /// <summary>
    /// Contains statistics about number of new members invited by a user
    /// </summary>
    public partial class ChatStatisticsInviterInfo : TLObject
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Number of new members invited by the user
        /// </summary>
        public int AddedMemberCount { get; set; }

    }

    /// <summary>
    /// A detailed statistics about a supergroup chat
    /// </summary>
    public partial class ChatStatisticsSupergroup : ChatStatistics
    {
        /// <summary>
        /// A period to which the statistics applies
        /// </summary>
        public DateRange Period { get; set; }

        /// <summary>
        /// Number of members in the chat
        /// </summary>
        public StatisticalValue MemberCount { get; set; }

        /// <summary>
        /// Number of messages sent to the chat
        /// </summary>
        public StatisticalValue MessageCount { get; set; }

        /// <summary>
        /// Number of users who viewed messages in the chat
        /// </summary>
        public StatisticalValue ViewerCount { get; set; }

        /// <summary>
        /// Number of users who sent messages to the chat
        /// </summary>
        public StatisticalValue SenderCount { get; set; }

        /// <summary>
        /// A graph containing number of members in the chat
        /// </summary>
        public StatisticalGraph MemberCountGraph { get; set; }

        /// <summary>
        /// A graph containing number of members joined and left the chat
        /// </summary>
        public StatisticalGraph JoinGraph { get; set; }

        /// <summary>
        /// A graph containing number of new member joins per source
        /// </summary>
        public StatisticalGraph JoinBySourceGraph { get; set; }

        /// <summary>
        /// A graph containing distribution of active users per language
        /// </summary>
        public StatisticalGraph LanguageGraph { get; set; }

        /// <summary>
        /// A graph containing distribution of sent messages by content type
        /// </summary>
        public StatisticalGraph MessageContentGraph { get; set; }

        /// <summary>
        /// A graph containing number of different actions in the chat
        /// </summary>
        public StatisticalGraph ActionGraph { get; set; }

        /// <summary>
        /// A graph containing distribution of message views per hour
        /// </summary>
        public StatisticalGraph DayGraph { get; set; }

        /// <summary>
        /// A graph containing distribution of message views per day of week
        /// </summary>
        public StatisticalGraph WeekGraph { get; set; }

        /// <summary>
        /// List of users sent most messages in the last week
        /// </summary>
        public ChatStatisticsMessageSenderInfo[] TopSenders { get; set; }

        /// <summary>
        /// List of most active administrators in the last week
        /// </summary>
        public ChatStatisticsAdministratorActionsInfo[] TopAdministrators { get; set; }

        /// <summary>
        /// List of most active inviters of new members in the last week
        /// </summary>
        public ChatStatisticsInviterInfo[] TopInviters { get; set; }

    }

    /// <summary>
    /// A detailed statistics about a channel chat
    /// </summary>
    public partial class ChatStatisticsChannel : ChatStatistics
    {
        /// <summary>
        /// A period to which the statistics applies
        /// </summary>
        public DateRange Period { get; set; }

        /// <summary>
        /// Number of members in the chat
        /// </summary>
        public StatisticalValue MemberCount { get; set; }

        /// <summary>
        /// Mean number of times the recently sent messages was viewed
        /// </summary>
        public StatisticalValue MeanViewCount { get; set; }

        /// <summary>
        /// Mean number of times the recently sent messages was shared
        /// </summary>
        public StatisticalValue MeanShareCount { get; set; }

        /// <summary>
        /// A percentage of users with enabled notifications for the chat
        /// </summary>
        public double EnabledNotificationsPercentage { get; set; }

        /// <summary>
        /// A graph containing number of members in the chat
        /// </summary>
        public StatisticalGraph MemberCountGraph { get; set; }

        /// <summary>
        /// A graph containing number of members joined and left the chat
        /// </summary>
        public StatisticalGraph JoinGraph { get; set; }

        /// <summary>
        /// A graph containing number of members muted and unmuted the chat
        /// </summary>
        public StatisticalGraph MuteGraph { get; set; }

        /// <summary>
        /// A graph containing number of message views in a given hour in the last two weeks
        /// </summary>
        public StatisticalGraph ViewCountByHourGraph { get; set; }

        /// <summary>
        /// A graph containing number of message views per source
        /// </summary>
        public StatisticalGraph ViewCountBySourceGraph { get; set; }

        /// <summary>
        /// A graph containing number of new member joins per source
        /// </summary>
        public StatisticalGraph JoinBySourceGraph { get; set; }

        /// <summary>
        /// A graph containing number of users viewed chat messages per language
        /// </summary>
        public StatisticalGraph LanguageGraph { get; set; }

        /// <summary>
        /// A graph containing number of chat message views and shares
        /// </summary>
        public StatisticalGraph MessageInteractionGraph { get; set; }

        /// <summary>
        /// A graph containing number of views of associated with the chat instant views
        /// </summary>
        public StatisticalGraph InstantViewInteractionGraph { get; set; }

        /// <summary>
        /// Detailed statistics about number of views and shares of recently sent messages
        /// </summary>
        public ChatStatisticsMessageInteractionInfo[] RecentMessageInteractions { get; set; }

    }

    /// <summary>
    /// A detailed statistics about a message
    /// </summary>
    public partial class MessageStatistics : TLObject
    {
        /// <summary>
        /// A graph containing number of message views and shares
        /// </summary>
        public StatisticalGraph MessageInteractionGraph { get; set; }

    }

    /// <summary>
    /// A point on a Cartesian plane
    /// </summary>
    public partial class Point : TLObject
    {
        /// <summary>
        /// The point's first coordinate
        /// </summary>
        public double X { get; set; }

        /// <summary>
        /// The point's second coordinate
        /// </summary>
        public double Y { get; set; }

    }

    /// <summary>
    /// A straight line to a given point
    /// </summary>
    public partial class VectorPathCommandLine : VectorPathCommand
    {
        /// <summary>
        /// The end point of the straight line
        /// </summary>
        public Point EndPoint { get; set; }

    }

    /// <summary>
    /// A cubic Bézier curve to a given point
    /// </summary>
    public partial class VectorPathCommandCubicBezierCurve : VectorPathCommand
    {
        /// <summary>
        /// The start control point of the curve
        /// </summary>
        public Point StartControlPoint { get; set; }

        /// <summary>
        /// The end control point of the curve
        /// </summary>
        public Point EndControlPoint { get; set; }

        /// <summary>
        /// The end point of the curve
        /// </summary>
        public Point EndPoint { get; set; }

    }

    /// <summary>
    /// A scope covering all users
    /// </summary>
    public partial class BotCommandScopeDefault : BotCommandScope
    {
    }

    /// <summary>
    /// A scope covering all private chats
    /// </summary>
    public partial class BotCommandScopeAllPrivateChats : BotCommandScope
    {
    }

    /// <summary>
    /// A scope covering all group and supergroup chats
    /// </summary>
    public partial class BotCommandScopeAllGroupChats : BotCommandScope
    {
    }

    /// <summary>
    /// A scope covering all group and supergroup chat administrators
    /// </summary>
    public partial class BotCommandScopeAllChatAdministrators : BotCommandScope
    {
    }

    /// <summary>
    /// A scope covering all members of a chat
    /// </summary>
    public partial class BotCommandScopeChat : BotCommandScope
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// A scope covering all administrators of a chat
    /// </summary>
    public partial class BotCommandScopeChatAdministrators : BotCommandScope
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// A scope covering a member of a chat
    /// </summary>
    public partial class BotCommandScopeChatMember : BotCommandScope
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// The user authorization state has changed
    /// </summary>
    public partial class UpdateAuthorizationState : Update
    {
        /// <summary>
        /// New authorization state
        /// </summary>
        public AuthorizationState AuthorizationState { get; set; }

    }

    /// <summary>
    /// A new message was received; can also be an outgoing message
    /// </summary>
    public partial class UpdateNewMessage : Update
    {
        /// <summary>
        /// The new message
        /// </summary>
        public Message Message { get; set; }

    }

    /// <summary>
    /// A request to send a message has reached the Telegram server. This doesn't mean that the message will be sent successfully or even that the send message request will be processed. This update will be sent only if the option "use_quick_ack" is set to true. This update may be sent multiple times for the same message
    /// </summary>
    public partial class UpdateMessageSendAcknowledged : Update
    {
        /// <summary>
        /// The chat identifier of the sent message
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// A temporary message identifier
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// A message has been successfully sent
    /// </summary>
    public partial class UpdateMessageSendSucceeded : Update
    {
        /// <summary>
        /// The sent message. Usually only the message identifier, date, and content are changed, but almost all other fields can also change
        /// </summary>
        public Message Message { get; set; }

        /// <summary>
        /// The previous temporary message identifier
        /// </summary>
        public long OldMessageId { get; set; }

    }

    /// <summary>
    /// A message failed to send. Be aware that some messages being sent can be irrecoverably deleted, in which case updateDeleteMessages will be received instead of this update
    /// </summary>
    public partial class UpdateMessageSendFailed : Update
    {
        /// <summary>
        /// The failed to send message
        /// </summary>
        public Message Message { get; set; }

        /// <summary>
        /// The previous temporary message identifier
        /// </summary>
        public long OldMessageId { get; set; }

        /// <summary>
        /// An error code
        /// </summary>
        public int ErrorCode { get; set; }

        /// <summary>
        /// Error message
        /// </summary>
        public string ErrorMessage { get; set; }

    }

    /// <summary>
    /// The message content has changed
    /// </summary>
    public partial class UpdateMessageContent : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// New message content
        /// </summary>
        public MessageContent NewContent { get; set; }

    }

    /// <summary>
    /// A message was edited. Changes in the message content will come in a separate updateMessageContent
    /// </summary>
    public partial class UpdateMessageEdited : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the message was edited
        /// </summary>
        public int EditDate { get; set; }

        /// <summary>
        /// New message reply markup; may be null
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

    }

    /// <summary>
    /// The message pinned state was changed
    /// </summary>
    public partial class UpdateMessageIsPinned : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// True, if the message is pinned
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// The information about interactions with a message has changed
    /// </summary>
    public partial class UpdateMessageInteractionInfo : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// New information about interactions with the message; may be null
        /// </summary>
        public MessageInteractionInfo InteractionInfo { get; set; }

    }

    /// <summary>
    /// The message content was opened. Updates voice note messages to "listened", video note messages to "viewed" and starts the TTL timer for self-destructing messages
    /// </summary>
    public partial class UpdateMessageContentOpened : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// A message with an unread mention was read
    /// </summary>
    public partial class UpdateMessageMentionRead : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// The new number of unread mention messages left in the chat
        /// </summary>
        public int UnreadMentionCount { get; set; }

    }

    /// <summary>
    /// A message with a live location was viewed. When the update is received, the application is supposed to update the live location
    /// </summary>
    public partial class UpdateMessageLiveLocationViewed : Update
    {
        /// <summary>
        /// Identifier of the chat with the live location message
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message with live location
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// A new chat has been loaded/created. This update is guaranteed to come before the chat identifier is returned to the application. The chat field changes will be reported through separate updates
    /// </summary>
    public partial class UpdateNewChat : Update
    {
        /// <summary>
        /// The chat
        /// </summary>
        public Chat Chat { get; set; }

    }

    /// <summary>
    /// The title of a chat was changed
    /// </summary>
    public partial class UpdateChatTitle : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The new chat title
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// A chat photo was changed
    /// </summary>
    public partial class UpdateChatPhoto : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The new chat photo; may be null
        /// </summary>
        public ChatPhotoInfo Photo { get; set; }

    }

    /// <summary>
    /// Chat permissions was changed
    /// </summary>
    public partial class UpdateChatPermissions : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The new chat permissions
        /// </summary>
        public ChatPermissions Permissions { get; set; }

    }

    /// <summary>
    /// The last message of a chat was changed. If last_message is null, then the last message in the chat became unknown. Some new unknown messages might be added to the chat in this case
    /// </summary>
    public partial class UpdateChatLastMessage : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The new last message in the chat; may be null
        /// </summary>
        public Message LastMessage { get; set; }

        /// <summary>
        /// The new chat positions in the chat lists
        /// </summary>
        public ChatPosition[] Positions { get; set; }

    }

    /// <summary>
    /// The position of a chat in a chat list has changed. Instead of this update updateChatLastMessage or updateChatDraftMessage might be sent
    /// </summary>
    public partial class UpdateChatPosition : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New chat position. If new order is 0, then the chat needs to be removed from the list
        /// </summary>
        public ChatPosition Position { get; set; }

    }

    /// <summary>
    /// A chat was marked as unread or was read
    /// </summary>
    public partial class UpdateChatIsMarkedAsUnread : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New value of is_marked_as_unread
        /// </summary>
        public bool IsMarkedAsUnread { get; set; }

    }

    /// <summary>
    /// A chat was blocked or unblocked
    /// </summary>
    public partial class UpdateChatIsBlocked : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New value of is_blocked
        /// </summary>
        public bool IsBlocked { get; set; }

    }

    /// <summary>
    /// A chat's has_scheduled_messages field has changed
    /// </summary>
    public partial class UpdateChatHasScheduledMessages : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New value of has_scheduled_messages
        /// </summary>
        public bool HasScheduledMessages { get; set; }

    }

    /// <summary>
    /// A chat video chat state has changed
    /// </summary>
    public partial class UpdateChatVideoChat : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New value of video_chat
        /// </summary>
        public VideoChat VideoChat { get; set; }

    }

    /// <summary>
    /// The value of the default disable_notification parameter, used when a message is sent to the chat, was changed
    /// </summary>
    public partial class UpdateChatDefaultDisableNotification : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The new default_disable_notification value
        /// </summary>
        public bool DefaultDisableNotification { get; set; }

    }

    /// <summary>
    /// Incoming messages were read or the number of unread messages has been changed
    /// </summary>
    public partial class UpdateChatReadInbox : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the last read incoming message
        /// </summary>
        public long LastReadInboxMessageId { get; set; }

        /// <summary>
        /// The number of unread messages left in the chat
        /// </summary>
        public int UnreadCount { get; set; }

    }

    /// <summary>
    /// Outgoing messages were read
    /// </summary>
    public partial class UpdateChatReadOutbox : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of last read outgoing message
        /// </summary>
        public long LastReadOutboxMessageId { get; set; }

    }

    /// <summary>
    /// The chat unread_mention_count has changed
    /// </summary>
    public partial class UpdateChatUnreadMentionCount : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The number of unread mention messages left in the chat
        /// </summary>
        public int UnreadMentionCount { get; set; }

    }

    /// <summary>
    /// Notification settings for a chat were changed
    /// </summary>
    public partial class UpdateChatNotificationSettings : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The new notification settings
        /// </summary>
        public ChatNotificationSettings NotificationSettings { get; set; }

    }

    /// <summary>
    /// Notification settings for some type of chats were updated
    /// </summary>
    public partial class UpdateScopeNotificationSettings : Update
    {
        /// <summary>
        /// Types of chats for which notification settings were updated
        /// </summary>
        public NotificationSettingsScope Scope { get; set; }

        /// <summary>
        /// The new notification settings
        /// </summary>
        public ScopeNotificationSettings NotificationSettings { get; set; }

    }

    /// <summary>
    /// The message Time To Live setting for a chat was changed
    /// </summary>
    public partial class UpdateChatMessageTtlSetting : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New value of message_ttl_setting
        /// </summary>
        public int MessageTtlSetting { get; set; }

    }

    /// <summary>
    /// The chat action bar was changed
    /// </summary>
    public partial class UpdateChatActionBar : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The new value of the action bar; may be null
        /// </summary>
        public ChatActionBar ActionBar { get; set; }

    }

    /// <summary>
    /// The chat theme was changed
    /// </summary>
    public partial class UpdateChatTheme : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The new name of the chat theme; may be empty if theme was reset to default
        /// </summary>
        public string ThemeName { get; set; }

    }

    /// <summary>
    /// The chat pending join requests were changed
    /// </summary>
    public partial class UpdateChatPendingJoinRequests : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The new data about pending join requests; may be null
        /// </summary>
        public ChatJoinRequestsInfo PendingJoinRequests { get; set; }

    }

    /// <summary>
    /// The default chat reply markup was changed. Can occur because new messages with reply markup were received or because an old reply markup was hidden by the user
    /// </summary>
    public partial class UpdateChatReplyMarkup : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message from which reply markup needs to be used; 0 if there is no default custom reply markup in the chat
        /// </summary>
        public long ReplyMarkupMessageId { get; set; }

    }

    /// <summary>
    /// A chat draft has changed. Be aware that the update may come in the currently opened chat but with old content of the draft. If the user has changed the content of the draft, this update mustn't be applied
    /// </summary>
    public partial class UpdateChatDraftMessage : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The new draft message; may be null
        /// </summary>
        public DraftMessage DraftMessage { get; set; }

        /// <summary>
        /// The new chat positions in the chat lists
        /// </summary>
        public ChatPosition[] Positions { get; set; }

    }

    /// <summary>
    /// The list of chat filters or a chat filter has changed
    /// </summary>
    public partial class UpdateChatFilters : Update
    {
        /// <summary>
        /// The new list of chat filters
        /// </summary>
        public ChatFilterInfo[] ChatFilters { get; set; }

    }

    /// <summary>
    /// The number of online group members has changed. This update with non-zero count is sent only for currently opened chats. There is no guarantee that it will be sent just after the count has changed
    /// </summary>
    public partial class UpdateChatOnlineMemberCount : Update
    {
        /// <summary>
        /// Identifier of the chat
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New number of online members in the chat, or 0 if unknown
        /// </summary>
        public int OnlineMemberCount { get; set; }

    }

    /// <summary>
    /// A notification was changed
    /// </summary>
    public partial class UpdateNotification : Update
    {
        /// <summary>
        /// Unique notification group identifier
        /// </summary>
        public int NotificationGroupId { get; set; }

        /// <summary>
        /// Changed notification
        /// </summary>
        public Notification Notification { get; set; }

    }

    /// <summary>
    /// A list of active notifications in a notification group has changed
    /// </summary>
    public partial class UpdateNotificationGroup : Update
    {
        /// <summary>
        /// Unique notification group identifier
        /// </summary>
        public int NotificationGroupId { get; set; }

        /// <summary>
        /// New type of the notification group
        /// </summary>
        public NotificationGroupType Type { get; set; }

        /// <summary>
        /// Identifier of a chat to which all notifications in the group belong
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Chat identifier, which notification settings must be applied to the added notifications
        /// </summary>
        public long NotificationSettingsChatId { get; set; }

        /// <summary>
        /// True, if the notifications must be shown without sound
        /// </summary>
        public bool IsSilent { get; set; }

        /// <summary>
        /// Total number of unread notifications in the group, can be bigger than number of active notifications
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// List of added group notifications, sorted by notification ID
        /// </summary>
        public Notification[] AddedNotifications { get; set; }

        /// <summary>
        /// Identifiers of removed group notifications, sorted by notification ID
        /// </summary>
        public int[] RemovedNotificationIds { get; set; }

    }

    /// <summary>
    /// Contains active notifications that was shown on previous application launches. This update is sent only if the message database is used. In that case it comes once before any updateNotification and updateNotificationGroup update
    /// </summary>
    public partial class UpdateActiveNotifications : Update
    {
        /// <summary>
        /// Lists of active notification groups
        /// </summary>
        public NotificationGroup[] Groups { get; set; }

    }

    /// <summary>
    /// Describes whether there are some pending notification updates. Can be used to prevent application from killing, while there are some pending notifications
    /// </summary>
    public partial class UpdateHavePendingNotifications : Update
    {
        /// <summary>
        /// True, if there are some delayed notification updates, which will be sent soon
        /// </summary>
        public bool HaveDelayedNotifications { get; set; }

        /// <summary>
        /// True, if there can be some yet unreceived notifications, which are being fetched from the server
        /// </summary>
        public bool HaveUnreceivedNotifications { get; set; }

    }

    /// <summary>
    /// Some messages were deleted
    /// </summary>
    public partial class UpdateDeleteMessages : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifiers of the deleted messages
        /// </summary>
        public long[] MessageIds { get; set; }

        /// <summary>
        /// True, if the messages are permanently deleted by a user (as opposed to just becoming inaccessible)
        /// </summary>
        public bool IsPermanent { get; set; }

        /// <summary>
        /// True, if the messages are deleted only from the cache and can possibly be retrieved again in the future
        /// </summary>
        public bool FromCache { get; set; }

    }

    /// <summary>
    /// User activity in the chat has changed
    /// </summary>
    public partial class UpdateUserChatAction : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// If not 0, a message thread identifier in which the action was performed
        /// </summary>
        public long MessageThreadId { get; set; }

        /// <summary>
        /// Identifier of a user performing an action
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// The action description
        /// </summary>
        public ChatAction Action { get; set; }

    }

    /// <summary>
    /// The user went online or offline
    /// </summary>
    public partial class UpdateUserStatus : Update
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// New status of the user
        /// </summary>
        public UserStatus Status { get; set; }

    }

    /// <summary>
    /// Some data of a user has changed. This update is guaranteed to come before the user identifier is returned to the application
    /// </summary>
    public partial class UpdateUser : Update
    {
        /// <summary>
        /// New data about the user
        /// </summary>
        public User User { get; set; }

    }

    /// <summary>
    /// Some data of a basic group has changed. This update is guaranteed to come before the basic group identifier is returned to the application
    /// </summary>
    public partial class UpdateBasicGroup : Update
    {
        /// <summary>
        /// New data about the group
        /// </summary>
        public BasicGroup BasicGroup { get; set; }

    }

    /// <summary>
    /// Some data of a supergroup or a channel has changed. This update is guaranteed to come before the supergroup identifier is returned to the application
    /// </summary>
    public partial class UpdateSupergroup : Update
    {
        /// <summary>
        /// New data about the supergroup
        /// </summary>
        public Supergroup Supergroup { get; set; }

    }

    /// <summary>
    /// Some data of a secret chat has changed. This update is guaranteed to come before the secret chat identifier is returned to the application
    /// </summary>
    public partial class UpdateSecretChat : Update
    {
        /// <summary>
        /// New data about the secret chat
        /// </summary>
        public SecretChat SecretChat { get; set; }

    }

    /// <summary>
    /// Some data from userFullInfo has been changed
    /// </summary>
    public partial class UpdateUserFullInfo : Update
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// New full information about the user
        /// </summary>
        public UserFullInfo UserFullInfo { get; set; }

    }

    /// <summary>
    /// Some data from basicGroupFullInfo has been changed
    /// </summary>
    public partial class UpdateBasicGroupFullInfo : Update
    {
        /// <summary>
        /// Identifier of a basic group
        /// </summary>
        public long BasicGroupId { get; set; }

        /// <summary>
        /// New full information about the group
        /// </summary>
        public BasicGroupFullInfo BasicGroupFullInfo { get; set; }

    }

    /// <summary>
    /// Some data from supergroupFullInfo has been changed
    /// </summary>
    public partial class UpdateSupergroupFullInfo : Update
    {
        /// <summary>
        /// Identifier of the supergroup or channel
        /// </summary>
        public long SupergroupId { get; set; }

        /// <summary>
        /// New full information about the supergroup
        /// </summary>
        public SupergroupFullInfo SupergroupFullInfo { get; set; }

    }

    /// <summary>
    /// Service notification from the server. Upon receiving this the application must show a popup with the content of the notification
    /// </summary>
    public partial class UpdateServiceNotification : Update
    {
        /// <summary>
        /// Notification type. If type begins with "AUTH_KEY_DROP_", then two buttons "Cancel" and "Log out" must be shown under notification; if user presses the second, all local data must be destroyed using Destroy method
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Notification content
        /// </summary>
        public MessageContent Content { get; set; }

    }

    /// <summary>
    /// Information about a file was updated
    /// </summary>
    public partial class UpdateFile : Update
    {
        /// <summary>
        /// New data about the file
        /// </summary>
        public File File { get; set; }

    }

    /// <summary>
    /// The file generation process needs to be started by the application
    /// </summary>
    public partial class UpdateFileGenerationStart : Update
    {
        /// <summary>
        /// Unique identifier for the generation process
        /// </summary>
        public long GenerationId { get; set; }

        /// <summary>
        /// The path to a file from which a new file is generated; may be empty
        /// </summary>
        public string OriginalPath { get; set; }

        /// <summary>
        /// The path to a file that must be created and where the new file is generated
        /// </summary>
        public string DestinationPath { get; set; }

        /// <summary>
        /// String specifying the conversion applied to the original file. If conversion is "#url#" than original_path contains an HTTP/HTTPS URL of a file, which must be downloaded by the application
        /// </summary>
        public string Conversion { get; set; }

    }

    /// <summary>
    /// File generation is no longer needed
    /// </summary>
    public partial class UpdateFileGenerationStop : Update
    {
        /// <summary>
        /// Unique identifier for the generation process
        /// </summary>
        public long GenerationId { get; set; }

    }

    /// <summary>
    /// New call was created or information about a call was updated
    /// </summary>
    public partial class UpdateCall : Update
    {
        /// <summary>
        /// New data about a call
        /// </summary>
        public Call Call { get; set; }

    }

    /// <summary>
    /// Information about a group call was updated
    /// </summary>
    public partial class UpdateGroupCall : Update
    {
        /// <summary>
        /// New data about a group call
        /// </summary>
        public GroupCall GroupCall { get; set; }

    }

    /// <summary>
    /// Information about a group call participant was changed. The updates are sent only after the group call is received through getGroupCall and only if the call is joined or being joined
    /// </summary>
    public partial class UpdateGroupCallParticipant : Update
    {
        /// <summary>
        /// Identifier of group call
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// New data about a participant
        /// </summary>
        public GroupCallParticipant Participant { get; set; }

    }

    /// <summary>
    /// New call signaling data arrived
    /// </summary>
    public partial class UpdateNewCallSignalingData : Update
    {
        /// <summary>
        /// The call identifier
        /// </summary>
        public int CallId { get; set; }

        /// <summary>
        /// The data
        /// </summary>
        public Memory<byte> Data { get; set; }

    }

    /// <summary>
    /// Some privacy setting rules have been changed
    /// </summary>
    public partial class UpdateUserPrivacySettingRules : Update
    {
        /// <summary>
        /// The privacy setting
        /// </summary>
        public UserPrivacySetting Setting { get; set; }

        /// <summary>
        /// New privacy rules
        /// </summary>
        public UserPrivacySettingRules Rules { get; set; }

    }

    /// <summary>
    /// Number of unread messages in a chat list has changed. This update is sent only if the message database is used
    /// </summary>
    public partial class UpdateUnreadMessageCount : Update
    {
        /// <summary>
        /// The chat list with changed number of unread messages
        /// </summary>
        public ChatList ChatList { get; set; }

        /// <summary>
        /// Total number of unread messages
        /// </summary>
        public int UnreadCount { get; set; }

        /// <summary>
        /// Total number of unread messages in unmuted chats
        /// </summary>
        public int UnreadUnmutedCount { get; set; }

    }

    /// <summary>
    /// Number of unread chats, i.e. with unread messages or marked as unread, has changed. This update is sent only if the message database is used
    /// </summary>
    public partial class UpdateUnreadChatCount : Update
    {
        /// <summary>
        /// The chat list with changed number of unread messages
        /// </summary>
        public ChatList ChatList { get; set; }

        /// <summary>
        /// Approximate total number of chats in the chat list
        /// </summary>
        public int TotalCount { get; set; }

        /// <summary>
        /// Total number of unread chats
        /// </summary>
        public int UnreadCount { get; set; }

        /// <summary>
        /// Total number of unread unmuted chats
        /// </summary>
        public int UnreadUnmutedCount { get; set; }

        /// <summary>
        /// Total number of chats marked as unread
        /// </summary>
        public int MarkedAsUnreadCount { get; set; }

        /// <summary>
        /// Total number of unmuted chats marked as unread
        /// </summary>
        public int MarkedAsUnreadUnmutedCount { get; set; }

    }

    /// <summary>
    /// An option changed its value
    /// </summary>
    public partial class UpdateOption : Update
    {
        /// <summary>
        /// The option name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The new option value
        /// </summary>
        public OptionValue Value { get; set; }

    }

    /// <summary>
    /// A sticker set has changed
    /// </summary>
    public partial class UpdateStickerSet : Update
    {
        /// <summary>
        /// The sticker set
        /// </summary>
        public StickerSet StickerSet { get; set; }

    }

    /// <summary>
    /// The list of installed sticker sets was updated
    /// </summary>
    public partial class UpdateInstalledStickerSets : Update
    {
        /// <summary>
        /// True, if the list of installed mask sticker sets was updated
        /// </summary>
        public bool IsMasks { get; set; }

        /// <summary>
        /// The new list of installed ordinary sticker sets
        /// </summary>
        public long[] StickerSetIds { get; set; }

    }

    /// <summary>
    /// The list of trending sticker sets was updated or some of them were viewed
    /// </summary>
    public partial class UpdateTrendingStickerSets : Update
    {
        /// <summary>
        /// The prefix of the list of trending sticker sets with the newest trending sticker sets
        /// </summary>
        public StickerSets StickerSets { get; set; }

    }

    /// <summary>
    /// The list of recently used stickers was updated
    /// </summary>
    public partial class UpdateRecentStickers : Update
    {
        /// <summary>
        /// True, if the list of stickers attached to photo or video files was updated, otherwise the list of sent stickers is updated
        /// </summary>
        public bool IsAttached { get; set; }

        /// <summary>
        /// The new list of file identifiers of recently used stickers
        /// </summary>
        public int[] StickerIds { get; set; }

    }

    /// <summary>
    /// The list of favorite stickers was updated
    /// </summary>
    public partial class UpdateFavoriteStickers : Update
    {
        /// <summary>
        /// The new list of file identifiers of favorite stickers
        /// </summary>
        public int[] StickerIds { get; set; }

    }

    /// <summary>
    /// The list of saved animations was updated
    /// </summary>
    public partial class UpdateSavedAnimations : Update
    {
        /// <summary>
        /// The new list of file identifiers of saved animations
        /// </summary>
        public int[] AnimationIds { get; set; }

    }

    /// <summary>
    /// The selected background has changed
    /// </summary>
    public partial class UpdateSelectedBackground : Update
    {
        /// <summary>
        /// True, if background for dark theme has changed
        /// </summary>
        public bool ForDarkTheme { get; set; }

        /// <summary>
        /// The new selected background; may be null
        /// </summary>
        public Background Background { get; set; }

    }

    /// <summary>
    /// The list of available chat themes has changed
    /// </summary>
    public partial class UpdateChatThemes : Update
    {
        /// <summary>
        /// The new list of chat themes
        /// </summary>
        public ChatTheme[] ChatThemes { get; set; }

    }

    /// <summary>
    /// Some language pack strings have been updated
    /// </summary>
    public partial class UpdateLanguagePackStrings : Update
    {
        /// <summary>
        /// Localization target to which the language pack belongs
        /// </summary>
        public string LocalizationTarget { get; set; }

        /// <summary>
        /// Identifier of the updated language pack
        /// </summary>
        public string LanguagePackId { get; set; }

        /// <summary>
        /// List of changed language pack strings
        /// </summary>
        public LanguagePackString[] Strings { get; set; }

    }

    /// <summary>
    /// The connection state has changed. This update must be used only to show a human-readable description of the connection state
    /// </summary>
    public partial class UpdateConnectionState : Update
    {
        /// <summary>
        /// The new connection state
        /// </summary>
        public ConnectionState State { get; set; }

    }

    /// <summary>
    /// New terms of service must be accepted by the user. If the terms of service are declined, then the deleteAccount method must be called with the reason "Decline ToS update"
    /// </summary>
    public partial class UpdateTermsOfService : Update
    {
        /// <summary>
        /// Identifier of the terms of service
        /// </summary>
        public string TermsOfServiceId { get; set; }

        /// <summary>
        /// The new terms of service
        /// </summary>
        public TermsOfService TermsOfService { get; set; }

    }

    /// <summary>
    /// The list of users nearby has changed. The update is guaranteed to be sent only 60 seconds after a successful searchChatsNearby request
    /// </summary>
    public partial class UpdateUsersNearby : Update
    {
        /// <summary>
        /// The new list of users nearby
        /// </summary>
        public ChatNearby[] UsersNearby { get; set; }

    }

    /// <summary>
    /// The list of supported dice emojis has changed
    /// </summary>
    public partial class UpdateDiceEmojis : Update
    {
        /// <summary>
        /// The new list of supported dice emojis
        /// </summary>
        public string[] Emojis { get; set; }

    }

    /// <summary>
    /// Some animated emoji message was clicked and a big animated sticker must be played if the message is visible on the screen. chatActionWatchingAnimations with the text of the message needs to be sent if the sticker is played
    /// </summary>
    public partial class UpdateAnimatedEmojiMessageClicked : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// The animated sticker to be played
        /// </summary>
        public Sticker Sticker { get; set; }

    }

    /// <summary>
    /// The parameters of animation search through GetOption("animation_search_bot_username") bot has changed
    /// </summary>
    public partial class UpdateAnimationSearchParameters : Update
    {
        /// <summary>
        /// Name of the animation search provider
        /// </summary>
        public string Provider { get; set; }

        /// <summary>
        /// The new list of emojis suggested for searching
        /// </summary>
        public string[] Emojis { get; set; }

    }

    /// <summary>
    /// The list of suggested to the user actions has changed
    /// </summary>
    public partial class UpdateSuggestedActions : Update
    {
        /// <summary>
        /// Added suggested actions
        /// </summary>
        public SuggestedAction[] AddedActions { get; set; }

        /// <summary>
        /// Removed suggested actions
        /// </summary>
        public SuggestedAction[] RemovedActions { get; set; }

    }

    /// <summary>
    /// A new incoming inline query; for bots only
    /// </summary>
    public partial class UpdateNewInlineQuery : Update
    {
        /// <summary>
        /// Unique query identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Identifier of the user who sent the query
        /// </summary>
        public long SenderUserId { get; set; }

        /// <summary>
        /// User location; may be null
        /// </summary>
        public Location UserLocation { get; set; }

        /// <summary>
        /// The type of the chat, from which the query originated; may be null if unknown
        /// </summary>
        public ChatType ChatType { get; set; }

        /// <summary>
        /// Text of the query
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// Offset of the first entry to return
        /// </summary>
        public string Offset { get; set; }

    }

    /// <summary>
    /// The user has chosen a result of an inline query; for bots only
    /// </summary>
    public partial class UpdateNewChosenInlineResult : Update
    {
        /// <summary>
        /// Identifier of the user who sent the query
        /// </summary>
        public long SenderUserId { get; set; }

        /// <summary>
        /// User location; may be null
        /// </summary>
        public Location UserLocation { get; set; }

        /// <summary>
        /// Text of the query
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// Identifier of the chosen result
        /// </summary>
        public string ResultId { get; set; }

        /// <summary>
        /// Identifier of the sent inline message, if known
        /// </summary>
        public string InlineMessageId { get; set; }

    }

    /// <summary>
    /// A new incoming callback query; for bots only
    /// </summary>
    public partial class UpdateNewCallbackQuery : Update
    {
        /// <summary>
        /// Unique query identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Identifier of the user who sent the query
        /// </summary>
        public long SenderUserId { get; set; }

        /// <summary>
        /// Identifier of the chat where the query was sent
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message, from which the query originated
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Identifier that uniquely corresponds to the chat to which the message was sent
        /// </summary>
        public long ChatInstance { get; set; }

        /// <summary>
        /// Query payload
        /// </summary>
        public CallbackQueryPayload Payload { get; set; }

    }

    /// <summary>
    /// A new incoming callback query from a message sent via a bot; for bots only
    /// </summary>
    public partial class UpdateNewInlineCallbackQuery : Update
    {
        /// <summary>
        /// Unique query identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Identifier of the user who sent the query
        /// </summary>
        public long SenderUserId { get; set; }

        /// <summary>
        /// Identifier of the inline message, from which the query originated
        /// </summary>
        public string InlineMessageId { get; set; }

        /// <summary>
        /// An identifier uniquely corresponding to the chat a message was sent to
        /// </summary>
        public long ChatInstance { get; set; }

        /// <summary>
        /// Query payload
        /// </summary>
        public CallbackQueryPayload Payload { get; set; }

    }

    /// <summary>
    /// A new incoming shipping query; for bots only. Only for invoices with flexible price
    /// </summary>
    public partial class UpdateNewShippingQuery : Update
    {
        /// <summary>
        /// Unique query identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Identifier of the user who sent the query
        /// </summary>
        public long SenderUserId { get; set; }

        /// <summary>
        /// Invoice payload
        /// </summary>
        public string InvoicePayload { get; set; }

        /// <summary>
        /// User shipping address
        /// </summary>
        public Address ShippingAddress { get; set; }

    }

    /// <summary>
    /// A new incoming pre-checkout query; for bots only. Contains full information about a checkout
    /// </summary>
    public partial class UpdateNewPreCheckoutQuery : Update
    {
        /// <summary>
        /// Unique query identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// Identifier of the user who sent the query
        /// </summary>
        public long SenderUserId { get; set; }

        /// <summary>
        /// Currency for the product price
        /// </summary>
        public string Currency { get; set; }

        /// <summary>
        /// Total price for the product, in the smallest units of the currency
        /// </summary>
        public long TotalAmount { get; set; }

        /// <summary>
        /// Invoice payload
        /// </summary>
        public Memory<byte> InvoicePayload { get; set; }

        /// <summary>
        /// Identifier of a shipping option chosen by the user; may be empty if not applicable
        /// </summary>
        public string ShippingOptionId { get; set; }

        /// <summary>
        /// Information about the order; may be null
        /// </summary>
        public OrderInfo OrderInfo { get; set; }

    }

    /// <summary>
    /// A new incoming event; for bots only
    /// </summary>
    public partial class UpdateNewCustomEvent : Update
    {
        /// <summary>
        /// A JSON-serialized event
        /// </summary>
        public string Event { get; set; }

    }

    /// <summary>
    /// A new incoming query; for bots only
    /// </summary>
    public partial class UpdateNewCustomQuery : Update
    {
        /// <summary>
        /// The query identifier
        /// </summary>
        public long Id { get; set; }

        /// <summary>
        /// JSON-serialized query data
        /// </summary>
        public string Data { get; set; }

        /// <summary>
        /// Query timeout
        /// </summary>
        public int Timeout { get; set; }

    }

    /// <summary>
    /// A poll was updated; for bots only
    /// </summary>
    public partial class UpdatePoll : Update
    {
        /// <summary>
        /// New data about the poll
        /// </summary>
        public Poll Poll { get; set; }

    }

    /// <summary>
    /// A user changed the answer to a poll; for bots only
    /// </summary>
    public partial class UpdatePollAnswer : Update
    {
        /// <summary>
        /// Unique poll identifier
        /// </summary>
        public long PollId { get; set; }

        /// <summary>
        /// The user, who changed the answer to the poll
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// 0-based identifiers of answer options, chosen by the user
        /// </summary>
        public int[] OptionIds { get; set; }

    }

    /// <summary>
    /// User rights changed in a chat; for bots only
    /// </summary>
    public partial class UpdateChatMember : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the user, changing the rights
        /// </summary>
        public long ActorUserId { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the user rights was changed
        /// </summary>
        public int Date { get; set; }

        /// <summary>
        /// If user has joined the chat using an invite link, the invite link; may be null
        /// </summary>
        public ChatInviteLink InviteLink { get; set; }

        /// <summary>
        /// Previous chat member
        /// </summary>
        public ChatMember OldChatMember { get; set; }

        /// <summary>
        /// New chat member
        /// </summary>
        public ChatMember NewChatMember { get; set; }

    }

    /// <summary>
    /// A user sent a join request to a chat; for bots only
    /// </summary>
    public partial class UpdateNewChatJoinRequest : Update
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Join request
        /// </summary>
        public ChatJoinRequest Request { get; set; }

        /// <summary>
        /// The invite link, which was used to send join request; may be null
        /// </summary>
        public ChatInviteLink InviteLink { get; set; }

    }

    /// <summary>
    /// Contains a list of updates
    /// </summary>
    public partial class Updates : TLObject
    {
        /// <summary>
        /// List of updates
        /// </summary>
        public Update[] Updates_ { get; set; }

    }

    /// <summary>
    /// The log is written to stderr or an OS specific log
    /// </summary>
    public partial class LogStreamDefault : LogStream
    {
    }

    /// <summary>
    /// The log is written to a file
    /// </summary>
    public partial class LogStreamFile : LogStream
    {
        /// <summary>
        /// Path to the file to where the internal TDLib log will be written
        /// </summary>
        public string Path { get; set; }

        /// <summary>
        /// The maximum size of the file to where the internal TDLib log is written before the file will be auto-rotated, in bytes
        /// </summary>
        public long MaxFileSize { get; set; }

        /// <summary>
        /// Pass true to additionally redirect stderr to the log file. Ignored on Windows
        /// </summary>
        public bool RedirectStderr { get; set; }

    }

    /// <summary>
    /// The log is written nowhere
    /// </summary>
    public partial class LogStreamEmpty : LogStream
    {
    }

    /// <summary>
    /// Contains a TDLib internal log verbosity level
    /// </summary>
    public partial class LogVerbosityLevel : TLObject
    {
        /// <summary>
        /// Log verbosity level
        /// </summary>
        public int VerbosityLevel { get; set; }

    }

    /// <summary>
    /// Contains a list of available TDLib internal log tags
    /// </summary>
    public partial class LogTags : TLObject
    {
        /// <summary>
        /// List of log tags
        /// </summary>
        public string[] Tags { get; set; }

    }

    /// <summary>
    /// A simple object containing a number; for testing only
    /// </summary>
    public partial class TestInt : TLObject
    {
        /// <summary>
        /// Number
        /// </summary>
        public int Value { get; set; }

    }

    /// <summary>
    /// A simple object containing a string; for testing only
    /// </summary>
    public partial class TestString : TLObject
    {
        /// <summary>
        /// String
        /// </summary>
        public string Value { get; set; }

    }

    /// <summary>
    /// A simple object containing a sequence of bytes; for testing only
    /// </summary>
    public partial class TestBytes : TLObject
    {
        /// <summary>
        /// Bytes
        /// </summary>
        public Memory<byte> Value { get; set; }

    }

    /// <summary>
    /// A simple object containing a vector of numbers; for testing only
    /// </summary>
    public partial class TestVectorInt : TLObject
    {
        /// <summary>
        /// Vector of numbers
        /// </summary>
        public int[] Value { get; set; }

    }

    /// <summary>
    /// A simple object containing a vector of objects that hold a number; for testing only
    /// </summary>
    public partial class TestVectorIntObject : TLObject
    {
        /// <summary>
        /// Vector of objects
        /// </summary>
        public TestInt[] Value { get; set; }

    }

    /// <summary>
    /// A simple object containing a vector of strings; for testing only
    /// </summary>
    public partial class TestVectorString : TLObject
    {
        /// <summary>
        /// Vector of strings
        /// </summary>
        public string[] Value { get; set; }

    }

    /// <summary>
    /// A simple object containing a vector of objects that hold a string; for testing only
    /// </summary>
    public partial class TestVectorStringObject : TLObject
    {
        /// <summary>
        /// Vector of objects
        /// </summary>
        public TestString[] Value { get; set; }

    }

    /// <summary>
    /// Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state. Can be called before initialization
    /// </summary>
    public partial class GetAuthorizationState : Function<AuthorizationState>
    {
    }

    /// <summary>
    /// Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
    /// </summary>
    public partial class SetTdlibParameters : Function<Ok>
    {
        /// <summary>
        /// Parameters for TDLib initialization
        /// </summary>
        public TdlibParameters Parameters { get; set; }

    }

    /// <summary>
    /// Checks the database encryption key for correctness. Works only when the current authorization state is authorizationStateWaitEncryptionKey
    /// </summary>
    public partial class CheckDatabaseEncryptionKey : Function<Ok>
    {
        /// <summary>
        /// Encryption key to check or set up
        /// </summary>
        public Memory<byte> EncryptionKey { get; set; }

    }

    /// <summary>
    /// Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber, -or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
    /// </summary>
    public partial class SetAuthenticationPhoneNumber : Function<Ok>
    {
        /// <summary>
        /// The phone number of the user, in international format
        /// </summary>
        public string PhoneNumber { get; set; }

        /// <summary>
        /// Settings for the authentication of the user's phone number; pass null to use default settings
        /// </summary>
        public PhoneNumberAuthenticationSettings Settings { get; set; }

    }

    /// <summary>
    /// Re-sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode, the next_code_type of the result is not null and the server-specified timeout has passed
    /// </summary>
    public partial class ResendAuthenticationCode : Function<Ok>
    {
    }

    /// <summary>
    /// Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
    /// </summary>
    public partial class CheckAuthenticationCode : Function<Ok>
    {
        /// <summary>
        /// The verification code received via SMS, Telegram message, phone call, or flash call
        /// </summary>
        public string Code { get; set; }

    }

    /// <summary>
    /// Requests QR code authentication by scanning a QR code on another logged in device. Works only when the current authorization state is authorizationStateWaitPhoneNumber, -or if there is no pending authentication query and the current authorization state is authorizationStateWaitCode, authorizationStateWaitRegistration, or authorizationStateWaitPassword
    /// </summary>
    public partial class RequestQrCodeAuthentication : Function<Ok>
    {
        /// <summary>
        /// List of user identifiers of other users currently using the application
        /// </summary>
        public long[] OtherUserIds { get; set; }

    }

    /// <summary>
    /// Finishes user registration. Works only when the current authorization state is authorizationStateWaitRegistration
    /// </summary>
    public partial class RegisterUser : Function<Ok>
    {
        /// <summary>
        /// The first name of the user; 1-64 characters
        /// </summary>
        public string FirstName { get; set; }

        /// <summary>
        /// The last name of the user; 0-64 characters
        /// </summary>
        public string LastName { get; set; }

    }

    /// <summary>
    /// Checks the authentication password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
    /// </summary>
    public partial class CheckAuthenticationPassword : Function<Ok>
    {
        /// <summary>
        /// The password to check
        /// </summary>
        public string Password { get; set; }

    }

    /// <summary>
    /// Requests to send a password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
    /// </summary>
    public partial class RequestAuthenticationPasswordRecovery : Function<Ok>
    {
    }

    /// <summary>
    /// Checks whether a password recovery code sent to an email address is valid. Works only when the current authorization state is authorizationStateWaitPassword
    /// </summary>
    public partial class CheckAuthenticationPasswordRecoveryCode : Function<Ok>
    {
        /// <summary>
        /// Recovery code to check
        /// </summary>
        public string RecoveryCode { get; set; }

    }

    /// <summary>
    /// Recovers the password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
    /// </summary>
    public partial class RecoverAuthenticationPassword : Function<Ok>
    {
        /// <summary>
        /// Recovery code to check
        /// </summary>
        public string RecoveryCode { get; set; }

        /// <summary>
        /// New password of the user; may be empty to remove the password
        /// </summary>
        public string NewPassword { get; set; }

        /// <summary>
        /// New password hint; may be empty
        /// </summary>
        public string NewHint { get; set; }

    }

    /// <summary>
    /// Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
    /// </summary>
    public partial class CheckAuthenticationBotToken : Function<Ok>
    {
        /// <summary>
        /// The bot token
        /// </summary>
        public string Token { get; set; }

    }

    /// <summary>
    /// Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent
    /// </summary>
    public partial class LogOut : Function<Ok>
    {
    }

    /// <summary>
    /// Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent. Can be called before initialization
    /// </summary>
    public partial class Close : Function<Ok>
    {
    }

    /// <summary>
    /// Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed. After the destruction completes updateAuthorizationState with authorizationStateClosed will be sent. Can be called before authorization
    /// </summary>
    public partial class Destroy : Function<Ok>
    {
    }

    /// <summary>
    /// Confirms QR code authentication on another device. Returns created session on success
    /// </summary>
    public partial class ConfirmQrCodeAuthentication : Function<Session>
    {
        /// <summary>
        /// A link from a QR code. The link must be scanned by the in-app camera
        /// </summary>
        public string Link { get; set; }

    }

    /// <summary>
    /// Returns all updates needed to restore current TDLib state, i.e. all actual UpdateAuthorizationState/UpdateUser/UpdateNewChat and others. This is especially useful if TDLib is run in a separate process. Can be called before initialization
    /// </summary>
    public partial class GetCurrentState : Function<Updates>
    {
    }

    /// <summary>
    /// Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
    /// </summary>
    public partial class SetDatabaseEncryptionKey : Function<Ok>
    {
        /// <summary>
        /// New encryption key
        /// </summary>
        public Memory<byte> NewEncryptionKey { get; set; }

    }

    /// <summary>
    /// Returns the current state of 2-step verification
    /// </summary>
    public partial class GetPasswordState : Function<PasswordState>
    {
    }

    /// <summary>
    /// Changes the password for the current user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed
    /// </summary>
    public partial class SetPassword : Function<PasswordState>
    {
        /// <summary>
        /// Previous password of the user
        /// </summary>
        public string OldPassword { get; set; }

        /// <summary>
        /// New password of the user; may be empty to remove the password
        /// </summary>
        public string NewPassword { get; set; }

        /// <summary>
        /// New password hint; may be empty
        /// </summary>
        public string NewHint { get; set; }

        /// <summary>
        /// Pass true if the recovery email address must be changed
        /// </summary>
        public bool SetRecoveryEmailAddress { get; set; }

        /// <summary>
        /// New recovery email address; may be empty
        /// </summary>
        public string NewRecoveryEmailAddress { get; set; }

    }

    /// <summary>
    /// Returns a 2-step verification recovery email address that was previously set up. This method can be used to verify a password provided by the user
    /// </summary>
    public partial class GetRecoveryEmailAddress : Function<RecoveryEmailAddress>
    {
        /// <summary>
        /// The password for the current user
        /// </summary>
        public string Password { get; set; }

    }

    /// <summary>
    /// Changes the 2-step verification recovery email address of the user. If a new recovery email address is specified, then the change will not be applied until the new recovery email address is confirmed. -If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation
    /// </summary>
    public partial class SetRecoveryEmailAddress : Function<PasswordState>
    {
        /// <summary>
        /// Password of the current user
        /// </summary>
        public string Password { get; set; }

        /// <summary>
        /// New recovery email address
        /// </summary>
        public string NewRecoveryEmailAddress { get; set; }

    }

    /// <summary>
    /// Checks the 2-step verification recovery email address verification code
    /// </summary>
    public partial class CheckRecoveryEmailAddressCode : Function<PasswordState>
    {
        /// <summary>
        /// Verification code
        /// </summary>
        public string Code { get; set; }

    }

    /// <summary>
    /// Resends the 2-step verification recovery email address verification code
    /// </summary>
    public partial class ResendRecoveryEmailAddressCode : Function<PasswordState>
    {
    }

    /// <summary>
    /// Requests to send a 2-step verification password recovery code to an email address that was previously set up
    /// </summary>
    public partial class RequestPasswordRecovery : Function<EmailAddressAuthenticationCodeInfo>
    {
    }

    /// <summary>
    /// Checks whether a 2-step verification password recovery code sent to an email address is valid
    /// </summary>
    public partial class CheckPasswordRecoveryCode : Function<Ok>
    {
        /// <summary>
        /// Recovery code to check
        /// </summary>
        public string RecoveryCode { get; set; }

    }

    /// <summary>
    /// Recovers the 2-step verification password using a recovery code sent to an email address that was previously set up
    /// </summary>
    public partial class RecoverPassword : Function<PasswordState>
    {
        /// <summary>
        /// Recovery code to check
        /// </summary>
        public string RecoveryCode { get; set; }

        /// <summary>
        /// New password of the user; may be empty to remove the password
        /// </summary>
        public string NewPassword { get; set; }

        /// <summary>
        /// New password hint; may be empty
        /// </summary>
        public string NewHint { get; set; }

    }

    /// <summary>
    /// Removes 2-step verification password without previous password and access to recovery email address. The password can't be reset immediately and the request needs to be repeated after the specified time
    /// </summary>
    public partial class ResetPassword : Function<ResetPasswordResult>
    {
    }

    /// <summary>
    /// Cancels reset of 2-step verification password. The method can be called if passwordState.pending_reset_date &gt; 0
    /// </summary>
    public partial class CancelPasswordReset : Function<Ok>
    {
    }

    /// <summary>
    /// Creates a new temporary password for processing payments
    /// </summary>
    public partial class CreateTemporaryPassword : Function<TemporaryPasswordState>
    {
        /// <summary>
        /// Persistent user password
        /// </summary>
        public string Password { get; set; }

        /// <summary>
        /// Time during which the temporary password will be valid, in seconds; must be between 60 and 86400
        /// </summary>
        public int ValidFor { get; set; }

    }

    /// <summary>
    /// Returns information about the current temporary password
    /// </summary>
    public partial class GetTemporaryPasswordState : Function<TemporaryPasswordState>
    {
    }

    /// <summary>
    /// Returns the current user
    /// </summary>
    public partial class GetMe : Function<User>
    {
    }

    /// <summary>
    /// Returns information about a user by their identifier. This is an offline request if the current user is not a bot
    /// </summary>
    public partial class GetUser : Function<User>
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// Returns full information about a user by their identifier
    /// </summary>
    public partial class GetUserFullInfo : Function<UserFullInfo>
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot
    /// </summary>
    public partial class GetBasicGroup : Function<BasicGroup>
    {
        /// <summary>
        /// Basic group identifier
        /// </summary>
        public long BasicGroupId { get; set; }

    }

    /// <summary>
    /// Returns full information about a basic group by its identifier
    /// </summary>
    public partial class GetBasicGroupFullInfo : Function<BasicGroupFullInfo>
    {
        /// <summary>
        /// Basic group identifier
        /// </summary>
        public long BasicGroupId { get; set; }

    }

    /// <summary>
    /// Returns information about a supergroup or a channel by its identifier. This is an offline request if the current user is not a bot
    /// </summary>
    public partial class GetSupergroup : Function<Supergroup>
    {
        /// <summary>
        /// Supergroup or channel identifier
        /// </summary>
        public long SupergroupId { get; set; }

    }

    /// <summary>
    /// Returns full information about a supergroup or a channel by its identifier, cached for up to 1 minute
    /// </summary>
    public partial class GetSupergroupFullInfo : Function<SupergroupFullInfo>
    {
        /// <summary>
        /// Supergroup or channel identifier
        /// </summary>
        public long SupergroupId { get; set; }

    }

    /// <summary>
    /// Returns information about a secret chat by its identifier. This is an offline request
    /// </summary>
    public partial class GetSecretChat : Function<SecretChat>
    {
        /// <summary>
        /// Secret chat identifier
        /// </summary>
        public int SecretChatId { get; set; }

    }

    /// <summary>
    /// Returns information about a chat by its identifier, this is an offline request if the current user is not a bot
    /// </summary>
    public partial class GetChat : Function<Chat>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Returns information about a message
    /// </summary>
    public partial class GetMessage : Function<Message>
    {
        /// <summary>
        /// Identifier of the chat the message belongs to
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message to get
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// Returns information about a message, if it is available locally without sending network request. This is an offline request
    /// </summary>
    public partial class GetMessageLocally : Function<Message>
    {
        /// <summary>
        /// Identifier of the chat the message belongs to
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message to get
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// Returns information about a message that is replied by a given message. Also returns the pinned message, the game message, and the invoice message for messages of the types messagePinMessage, messageGameScore, and messagePaymentSuccessful respectively
    /// </summary>
    public partial class GetRepliedMessage : Function<Message>
    {
        /// <summary>
        /// Identifier of the chat the message belongs to
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the reply message
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// Returns information about a newest pinned message in the chat
    /// </summary>
    public partial class GetChatPinnedMessage : Function<Message>
    {
        /// <summary>
        /// Identifier of the chat the message belongs to
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Returns information about a message with the callback button that originated a callback query; for bots only
    /// </summary>
    public partial class GetCallbackQueryMessage : Function<Message>
    {
        /// <summary>
        /// Identifier of the chat the message belongs to
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Identifier of the callback query
        /// </summary>
        public long CallbackQueryId { get; set; }

    }

    /// <summary>
    /// Returns information about messages. If a message is not found, returns null on the corresponding position of the result
    /// </summary>
    public partial class GetMessages : Function<Messages>
    {
        /// <summary>
        /// Identifier of the chat the messages belong to
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifiers of the messages to get
        /// </summary>
        public long[] MessageIds { get; set; }

    }

    /// <summary>
    /// Returns information about a message thread. Can be used only if message.can_get_message_thread == true
    /// </summary>
    public partial class GetMessageThread : Function<MessageThreadInfo>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// Returns viewers of a recent outgoing message in a basic group or a supergroup chat. For video notes and voice notes only users, opened content of the message, are returned. The method can be called if message.can_get_viewers == true
    /// </summary>
    public partial class GetMessageViewers : Function<Users>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// Returns information about a file; this is an offline request
    /// </summary>
    public partial class GetFile : Function<File>
    {
        /// <summary>
        /// Identifier of the file to get
        /// </summary>
        public int FileId { get; set; }

    }

    /// <summary>
    /// Returns information about a file by its remote ID; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message. Even the request succeeds, the file can be used only if it is still accessible to the user. -For example, if the file is from a message, then the message must be not deleted and accessible to the user. If the file database is disabled, then the corresponding object with the file must be preloaded by the application
    /// </summary>
    public partial class GetRemoteFile : Function<File>
    {
        /// <summary>
        /// Remote identifier of the file to get
        /// </summary>
        public string RemoteFileId { get; set; }

        /// <summary>
        /// File type; pass null if unknown
        /// </summary>
        public FileType FileType { get; set; }

    }

    /// <summary>
    /// Loads more chats from a chat list. The loaded chats and their positions in the chat list will be sent through updates. Chats are sorted by the pair (chat.position.order, chat.id) in descending order. Returns a 404 error if all chats have been loaded
    /// </summary>
    public partial class LoadChats : Function<Ok>
    {
        /// <summary>
        /// The chat list in which to load chats; pass null to load chats from the main chat list
        /// </summary>
        public ChatList ChatList { get; set; }

        /// <summary>
        /// The maximum number of chats to be loaded. For optimal performance, the number of loaded chats is chosen by TDLib and can be smaller than the specified limit, even if the end of the list is not reached
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Returns an ordered list of chats from the beginning of a chat list. For informational purposes only. Use loadChats and updates processing instead to maintain chat lists in a consistent state
    /// </summary>
    public partial class GetChats : Function<Chats>
    {
        /// <summary>
        /// The chat list in which to return chats; pass null to get chats from the main chat list
        /// </summary>
        public ChatList ChatList { get; set; }

        /// <summary>
        /// The maximum number of chats to be returned
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Searches a public chat by its username. Currently only private chats, supergroups and channels can be public. Returns the chat if found; otherwise an error is returned
    /// </summary>
    public partial class SearchPublicChat : Function<Chat>
    {
        /// <summary>
        /// Username to be resolved
        /// </summary>
        public string Username { get; set; }

    }

    /// <summary>
    /// Searches public chats by looking for specified query in their username and title. Currently only private chats, supergroups and channels can be public. Returns a meaningful number of results. -Excludes private chats with contacts and chats from the chat list from the results
    /// </summary>
    public partial class SearchPublicChats : Function<Chats>
    {
        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

    }

    /// <summary>
    /// Searches for the specified query in the title and username of already known chats, this is an offline request. Returns chats in the order seen in the main chat list
    /// </summary>
    public partial class SearchChats : Function<Chats>
    {
        /// <summary>
        /// Query to search for. If the query is empty, returns up to 50 recently found chats
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// The maximum number of chats to be returned
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the main chat list
    /// </summary>
    public partial class SearchChatsOnServer : Function<Chats>
    {
        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// The maximum number of chats to be returned
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Returns a list of users and location-based supergroups nearby. The list of users nearby will be updated for 60 seconds after the request by the updates updateUsersNearby. The request must be sent again every 25 seconds with adjusted location to not miss new chats
    /// </summary>
    public partial class SearchChatsNearby : Function<ChatsNearby>
    {
        /// <summary>
        /// Current user location
        /// </summary>
        public Location Location { get; set; }

    }

    /// <summary>
    /// Returns a list of frequently used chats. Supported only if the chat info database is enabled
    /// </summary>
    public partial class GetTopChats : Function<Chats>
    {
        /// <summary>
        /// Category of chats to be returned
        /// </summary>
        public TopChatCategory Category { get; set; }

        /// <summary>
        /// The maximum number of chats to be returned; up to 30
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
    /// </summary>
    public partial class RemoveTopChat : Function<Ok>
    {
        /// <summary>
        /// Category of frequently used chats
        /// </summary>
        public TopChatCategory Category { get; set; }

        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
    /// </summary>
    public partial class AddRecentlyFoundChat : Function<Ok>
    {
        /// <summary>
        /// Identifier of the chat to add
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Removes a chat from the list of recently found chats
    /// </summary>
    public partial class RemoveRecentlyFoundChat : Function<Ok>
    {
        /// <summary>
        /// Identifier of the chat to be removed
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Clears the list of recently found chats
    /// </summary>
    public partial class ClearRecentlyFoundChats : Function<Ok>
    {
    }

    /// <summary>
    /// Returns recently opened chats, this is an offline request. Returns chats in the order of last opening
    /// </summary>
    public partial class GetRecentlyOpenedChats : Function<Chats>
    {
        /// <summary>
        /// The maximum number of chats to be returned
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Checks whether a username can be set for a chat
    /// </summary>
    public partial class CheckChatUsername : Function<CheckChatUsernameResult>
    {
        /// <summary>
        /// Chat identifier; must be identifier of a supergroup chat, or a channel chat, or a private chat with self, or zero if the chat is being created
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Username to be checked
        /// </summary>
        public string Username { get; set; }

    }

    /// <summary>
    /// Returns a list of public chats of the specified type, owned by the user
    /// </summary>
    public partial class GetCreatedPublicChats : Function<Chats>
    {
        /// <summary>
        /// Type of the public chats to return
        /// </summary>
        public PublicChatType Type { get; set; }

    }

    /// <summary>
    /// Checks whether the maximum number of owned public chats has been reached. Returns corresponding error if the limit was reached
    /// </summary>
    public partial class CheckCreatedPublicChatsLimit : Function<Ok>
    {
        /// <summary>
        /// Type of the public chats, for which to check the limit
        /// </summary>
        public PublicChatType Type { get; set; }

    }

    /// <summary>
    /// Returns a list of basic group and supergroup chats, which can be used as a discussion group for a channel. Returned basic group chats must be first upgraded to supergroups before they can be set as a discussion group. To set a returned supergroup as a discussion group, access to its old messages must be enabled using toggleSupergroupIsAllHistoryAvailable first
    /// </summary>
    public partial class GetSuitableDiscussionChats : Function<Chats>
    {
    }

    /// <summary>
    /// Returns a list of recently inactive supergroups and channels. Can be used when user reaches limit on the number of joined supergroups and channels and receives CHANNELS_TOO_MUCH error
    /// </summary>
    public partial class GetInactiveSupergroupChats : Function<Chats>
    {
    }

    /// <summary>
    /// Returns a list of common group chats with a given user. Chats are sorted by their type and creation date
    /// </summary>
    public partial class GetGroupsInCommon : Function<Chats>
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Chat identifier starting from which to return chats; use 0 for the first request
        /// </summary>
        public long OffsetChatId { get; set; }

        /// <summary>
        /// The maximum number of chats to be returned; up to 100
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). -For optimal performance, the number of returned messages is chosen by TDLib. This is an offline request if only_local is true
    /// </summary>
    public partial class GetChatHistory : Function<Messages>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
        /// </summary>
        public long FromMessageId { get; set; }

        /// <summary>
        /// Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
        /// </summary>
        public int Limit { get; set; }

        /// <summary>
        /// If true, returns only messages that are available locally without sending network requests
        /// </summary>
        public bool OnlyLocal { get; set; }

    }

    /// <summary>
    /// Returns messages in a message thread of a message. Can be used only if message.can_get_message_thread == true. Message thread of a channel message is in the channel's linked supergroup. -The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
    /// </summary>
    public partial class GetMessageThreadHistory : Function<Messages>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier, which thread history needs to be returned
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
        /// </summary>
        public long FromMessageId { get; set; }

        /// <summary>
        /// Specify 0 to get results from exactly the from_message_id or a negative offset up to 99 to get additionally some newer messages
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than or equal to -offset. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Deletes all messages in the chat. Use chat.can_be_deleted_only_for_self and chat.can_be_deleted_for_all_users fields to find whether and how the method can be applied to the chat
    /// </summary>
    public partial class DeleteChatHistory : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Pass true if the chat needs to be removed from the chat list
        /// </summary>
        public bool RemoveFromChatList { get; set; }

        /// <summary>
        /// Pass true to try to delete chat history for all users
        /// </summary>
        public bool Revoke { get; set; }

    }

    /// <summary>
    /// Deletes a chat along with all messages in the corresponding chat for all chat members; requires owner privileges. For group chats this will release the username and remove all members. Chats with more than 1000 members can't be deleted using this method
    /// </summary>
    public partial class DeleteChat : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query -(searchSecretMessages must be used instead), or without an enabled message database. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
    /// </summary>
    public partial class SearchChatMessages : Function<Messages>
    {
        /// <summary>
        /// Identifier of the chat in which to search messages
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// Sender of messages to search for; pass null to search for messages from any sender. Not supported in secret chats
        /// </summary>
        public MessageSender Sender { get; set; }

        /// <summary>
        /// Identifier of the message starting from which history must be fetched; use 0 to get results from the last message
        /// </summary>
        public long FromMessageId { get; set; }

        /// <summary>
        /// Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
        /// </summary>
        public int Limit { get; set; }

        /// <summary>
        /// Additional filter for messages to search; pass null to search for all messages
        /// </summary>
        public SearchMessagesFilter Filter { get; set; }

        /// <summary>
        /// If not 0, only messages in the specified thread will be returned; supergroups only
        /// </summary>
        public long MessageThreadId { get; set; }

    }

    /// <summary>
    /// Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)). -For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
    /// </summary>
    public partial class SearchMessages : Function<Messages>
    {
        /// <summary>
        /// Chat list in which to search messages; pass null to search in all chats regardless of their chat list. Only Main and Archive chat lists are supported
        /// </summary>
        public ChatList ChatList { get; set; }

        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// The date of the message starting from which the results need to be fetched. Use 0 or any date in the future to get results from the last message
        /// </summary>
        public int OffsetDate { get; set; }

        /// <summary>
        /// The chat identifier of the last found message, or 0 for the first request
        /// </summary>
        public long OffsetChatId { get; set; }

        /// <summary>
        /// The message identifier of the last found message, or 0 for the first request
        /// </summary>
        public long OffsetMessageId { get; set; }

        /// <summary>
        /// The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
        /// </summary>
        public int Limit { get; set; }

        /// <summary>
        /// Additional filter for messages to search; pass null to search for all messages. Filters searchMessagesFilterCall, searchMessagesFilterMissedCall, searchMessagesFilterMention, searchMessagesFilterUnreadMention, searchMessagesFilterFailedToSend and searchMessagesFilterPinned are unsupported in this function
        /// </summary>
        public SearchMessagesFilter Filter { get; set; }

        /// <summary>
        /// If not 0, the minimum date of the messages to return
        /// </summary>
        public int MinDate { get; set; }

        /// <summary>
        /// If not 0, the maximum date of the messages to return
        /// </summary>
        public int MaxDate { get; set; }

    }

    /// <summary>
    /// Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance, the number of returned messages is chosen by TDLib
    /// </summary>
    public partial class SearchSecretMessages : Function<FoundMessages>
    {
        /// <summary>
        /// Identifier of the chat in which to search. Specify 0 to search in all secret chats
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Query to search for. If empty, searchChatMessages must be used instead
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// Offset of the first entry to return as received from the previous request; use empty string to get first chunk of results
        /// </summary>
        public string Offset { get; set; }

        /// <summary>
        /// The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
        /// </summary>
        public int Limit { get; set; }

        /// <summary>
        /// Additional filter for messages to search; pass null to search for all messages
        /// </summary>
        public SearchMessagesFilter Filter { get; set; }

    }

    /// <summary>
    /// Searches for call messages. Returns the results in reverse chronological order (i. e., in order of decreasing message_id). For optimal performance, the number of returned messages is chosen by TDLib
    /// </summary>
    public partial class SearchCallMessages : Function<Messages>
    {
        /// <summary>
        /// Identifier of the message from which to search; use 0 to get results from the last message
        /// </summary>
        public long FromMessageId { get; set; }

        /// <summary>
        /// The maximum number of messages to be returned; up to 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
        /// </summary>
        public int Limit { get; set; }

        /// <summary>
        /// If true, returns only messages with missed calls
        /// </summary>
        public bool OnlyMissed { get; set; }

    }

    /// <summary>
    /// Deletes all call messages
    /// </summary>
    public partial class DeleteAllCallMessages : Function<Ok>
    {
        /// <summary>
        /// Pass true to delete the messages for all users
        /// </summary>
        public bool Revoke { get; set; }

    }

    /// <summary>
    /// Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user
    /// </summary>
    public partial class SearchChatRecentLocationMessages : Function<Messages>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The maximum number of messages to be returned
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Returns all active live locations that need to be updated by the application. The list is persistent across application restarts only if the message database is used
    /// </summary>
    public partial class GetActiveLiveLocationMessages : Function<Messages>
    {
    }

    /// <summary>
    /// Returns the last message sent in a chat no later than the specified date
    /// </summary>
    public partial class GetChatMessageByDate : Function<Message>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) relative to which to search for messages
        /// </summary>
        public int Date { get; set; }

    }

    /// <summary>
    /// Returns sparse positions of messages of the specified type in the chat to be used for shared media scroll implementation. Returns the results in reverse chronological order (i.e., in order of decreasing message_id). -Cannot be used in secret chats or with searchMessagesFilterFailedToSend filter without an enabled message database
    /// </summary>
    public partial class GetChatSparseMessagePositions : Function<MessagePositions>
    {
        /// <summary>
        /// Identifier of the chat in which to return information about message positions
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterCall, searchMessagesFilterMissedCall, searchMessagesFilterMention and searchMessagesFilterUnreadMention are unsupported in this function
        /// </summary>
        public SearchMessagesFilter Filter { get; set; }

        /// <summary>
        /// The message identifier from which to return information about message positions
        /// </summary>
        public long FromMessageId { get; set; }

        /// <summary>
        /// The expected number of message positions to be returned; 50-2000. A smaller number of positions can be returned, if there are not enough appropriate messages
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Returns information about the next messages of the specified type in the chat splitted by days. Returns the results in reverse chronological order. Can return partial result for the last returned day. Behavior of this method depends on the value of the option "utc_time_offset"
    /// </summary>
    public partial class GetChatMessageCalendar : Function<MessageCalendar>
    {
        /// <summary>
        /// Identifier of the chat in which to return information about messages
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Filter for message content. Filters searchMessagesFilterEmpty, searchMessagesFilterCall, searchMessagesFilterMissedCall, searchMessagesFilterMention and searchMessagesFilterUnreadMention are unsupported in this function
        /// </summary>
        public SearchMessagesFilter Filter { get; set; }

        /// <summary>
        /// The message identifier from which to return information about messages; use 0 to get results from the last message
        /// </summary>
        public long FromMessageId { get; set; }

    }

    /// <summary>
    /// Returns approximate number of messages of the specified type in the chat
    /// </summary>
    public partial class GetChatMessageCount : Function<Count>
    {
        /// <summary>
        /// Identifier of the chat in which to count messages
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Filter for message content; searchMessagesFilterEmpty is unsupported in this function
        /// </summary>
        public SearchMessagesFilter Filter { get; set; }

        /// <summary>
        /// If true, returns count that is available locally without sending network requests, returning -1 if the number of messages is unknown
        /// </summary>
        public bool ReturnLocal { get; set; }

    }

    /// <summary>
    /// Returns all scheduled messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id)
    /// </summary>
    public partial class GetChatScheduledMessages : Function<Messages>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Returns forwarded copies of a channel message to different public channels. For optimal performance, the number of returned messages is chosen by TDLib
    /// </summary>
    public partial class GetMessagePublicForwards : Function<FoundMessages>
    {
        /// <summary>
        /// Chat identifier of the message
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Offset of the first entry to return as received from the previous request; use empty string to get first chunk of results
        /// </summary>
        public string Offset { get; set; }

        /// <summary>
        /// The maximum number of messages to be returned; must be positive and can't be greater than 100. For optimal performance, the number of returned messages is chosen by TDLib and can be smaller than the specified limit
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Returns sponsored messages to be shown in a chat; for channel chats only
    /// </summary>
    public partial class GetChatSponsoredMessages : Function<SponsoredMessages>
    {
        /// <summary>
        /// Identifier of the chat
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Informs TDLib that a sponsored message was viewed by the user
    /// </summary>
    public partial class ViewSponsoredMessage : Function<Ok>
    {
        /// <summary>
        /// Identifier of the chat with the sponsored message
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The identifier of the sponsored message being viewed
        /// </summary>
        public int SponsoredMessageId { get; set; }

    }

    /// <summary>
    /// Removes an active notification from notification list. Needs to be called only if the notification is removed by the current user
    /// </summary>
    public partial class RemoveNotification : Function<Ok>
    {
        /// <summary>
        /// Identifier of notification group to which the notification belongs
        /// </summary>
        public int NotificationGroupId { get; set; }

        /// <summary>
        /// Identifier of removed notification
        /// </summary>
        public int NotificationId { get; set; }

    }

    /// <summary>
    /// Removes a group of active notifications. Needs to be called only if the notification group is removed by the current user
    /// </summary>
    public partial class RemoveNotificationGroup : Function<Ok>
    {
        /// <summary>
        /// Notification group identifier
        /// </summary>
        public int NotificationGroupId { get; set; }

        /// <summary>
        /// The maximum identifier of removed notifications
        /// </summary>
        public int MaxNotificationId { get; set; }

    }

    /// <summary>
    /// Returns an HTTPS link to a message in a chat. Available only for already sent messages in supergroups and channels, or if message.can_get_media_timestamp_links and a media timestamp link is generated. This is an offline request
    /// </summary>
    public partial class GetMessageLink : Function<MessageLink>
    {
        /// <summary>
        /// Identifier of the chat to which the message belongs
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// If not 0, timestamp from which the video/audio/video note/voice note playing must start, in seconds. The media can be in the message content or in its web page preview
        /// </summary>
        public int MediaTimestamp { get; set; }

        /// <summary>
        /// Pass true to create a link for the whole media album
        /// </summary>
        public bool ForAlbum { get; set; }

        /// <summary>
        /// Pass true to create a link to the message as a channel post comment, or from a message thread
        /// </summary>
        public bool ForComment { get; set; }

    }

    /// <summary>
    /// Returns an HTML code for embedding the message. Available only for messages in supergroups and channels with a username
    /// </summary>
    public partial class GetMessageEmbeddingCode : Function<Text>
    {
        /// <summary>
        /// Identifier of the chat to which the message belongs
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Pass true to return an HTML code for embedding of the whole media album
        /// </summary>
        public bool ForAlbum { get; set; }

    }

    /// <summary>
    /// Returns information about a public or private message link. Can be called for any internal link of the type internalLinkTypeMessage
    /// </summary>
    public partial class GetMessageLinkInfo : Function<MessageLinkInfo>
    {
        /// <summary>
        /// The message link
        /// </summary>
        public string Url { get; set; }

    }

    /// <summary>
    /// Sends a message. Returns the sent message
    /// </summary>
    public partial class SendMessage : Function<Message>
    {
        /// <summary>
        /// Target chat
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// If not 0, a message thread identifier in which the message will be sent
        /// </summary>
        public long MessageThreadId { get; set; }

        /// <summary>
        /// Identifier of the message to reply to or 0
        /// </summary>
        public long ReplyToMessageId { get; set; }

        /// <summary>
        /// Options to be used to send the message; pass null to use default options
        /// </summary>
        public MessageSendOptions Options { get; set; }

        /// <summary>
        /// Markup for replying to the message; pass null if none; for bots only
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// The content of the message to be sent
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Sends 2-10 messages grouped together into an album. Currently only audio, document, photo and video messages can be grouped into an album. Documents and audio files can be only grouped in an album with messages of the same type. Returns sent messages
    /// </summary>
    public partial class SendMessageAlbum : Function<Messages>
    {
        /// <summary>
        /// Target chat
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// If not 0, a message thread identifier in which the messages will be sent
        /// </summary>
        public long MessageThreadId { get; set; }

        /// <summary>
        /// Identifier of a message to reply to or 0
        /// </summary>
        public long ReplyToMessageId { get; set; }

        /// <summary>
        /// Options to be used to send the messages; pass null to use default options
        /// </summary>
        public MessageSendOptions Options { get; set; }

        /// <summary>
        /// Contents of messages to be sent. At most 10 messages can be added to an album
        /// </summary>
        public InputMessageContent[] InputMessageContents { get; set; }

    }

    /// <summary>
    /// Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
    /// </summary>
    public partial class SendBotStartMessage : Function<Message>
    {
        /// <summary>
        /// Identifier of the bot
        /// </summary>
        public long BotUserId { get; set; }

        /// <summary>
        /// Identifier of the target chat
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// A hidden parameter sent to the bot for deep linking purposes (https://core.telegram.org/bots#deep-linking)
        /// </summary>
        public string Parameter { get; set; }

    }

    /// <summary>
    /// Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
    /// </summary>
    public partial class SendInlineQueryResultMessage : Function<Message>
    {
        /// <summary>
        /// Target chat
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// If not 0, a message thread identifier in which the message will be sent
        /// </summary>
        public long MessageThreadId { get; set; }

        /// <summary>
        /// Identifier of a message to reply to or 0
        /// </summary>
        public long ReplyToMessageId { get; set; }

        /// <summary>
        /// Options to be used to send the message; pass null to use default options
        /// </summary>
        public MessageSendOptions Options { get; set; }

        /// <summary>
        /// Identifier of the inline query
        /// </summary>
        public long QueryId { get; set; }

        /// <summary>
        /// Identifier of the inline result
        /// </summary>
        public string ResultId { get; set; }

        /// <summary>
        /// If true, there will be no mention of a bot, via which the message is sent. Can be used only for bots GetOption("animation_search_bot_username"), GetOption("photo_search_bot_username") and GetOption("venue_search_bot_username")
        /// </summary>
        public bool HideViaBot { get; set; }

    }

    /// <summary>
    /// Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message
    /// </summary>
    public partial class ForwardMessages : Function<Messages>
    {
        /// <summary>
        /// Identifier of the chat to which to forward messages
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the chat from which to forward messages
        /// </summary>
        public long FromChatId { get; set; }

        /// <summary>
        /// Identifiers of the messages to forward. Message identifiers must be in a strictly increasing order. At most 100 messages can be forwarded simultaneously
        /// </summary>
        public long[] MessageIds { get; set; }

        /// <summary>
        /// Options to be used to send the messages; pass null to use default options
        /// </summary>
        public MessageSendOptions Options { get; set; }

        /// <summary>
        /// If true, content of the messages will be copied without reference to the original sender. Always true if the messages are forwarded to a secret chat or are local
        /// </summary>
        public bool SendCopy { get; set; }

        /// <summary>
        /// If true, media caption of message copies will be removed. Ignored if send_copy is false
        /// </summary>
        public bool RemoveCaption { get; set; }

        /// <summary>
        /// If true, messages will not be forwarded and instead fake messages will be returned
        /// </summary>
        public bool OnlyPreview { get; set; }

    }

    /// <summary>
    /// Resends messages which failed to send. Can be called only for messages for which messageSendingStateFailed.can_retry is true and after specified in messageSendingStateFailed.retry_after time passed. -If a message is re-sent, the corresponding failed to send message is deleted. Returns the sent messages in the same order as the message identifiers passed in message_ids. If a message can't be re-sent, null will be returned instead of the message
    /// </summary>
    public partial class ResendMessages : Function<Messages>
    {
        /// <summary>
        /// Identifier of the chat to send messages
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifiers of the messages to resend. Message identifiers must be in a strictly increasing order
        /// </summary>
        public long[] MessageIds { get; set; }

    }

    /// <summary>
    /// Sends a notification about a screenshot taken in a chat. Supported only in private and secret chats
    /// </summary>
    public partial class SendChatScreenshotTakenNotification : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Adds a local message to a chat. The message is persistent across application restarts only if the message database is used. Returns the added message
    /// </summary>
    public partial class AddLocalMessage : Function<Message>
    {
        /// <summary>
        /// Target chat
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The sender of the message
        /// </summary>
        public MessageSender Sender { get; set; }

        /// <summary>
        /// Identifier of the message to reply to or 0
        /// </summary>
        public long ReplyToMessageId { get; set; }

        /// <summary>
        /// Pass true to disable notification for the message
        /// </summary>
        public bool DisableNotification { get; set; }

        /// <summary>
        /// The content of the message to be added
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Deletes messages
    /// </summary>
    public partial class DeleteMessages : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifiers of the messages to be deleted
        /// </summary>
        public long[] MessageIds { get; set; }

        /// <summary>
        /// Pass true to try to delete messages for all chat members. Always true for supergroups, channels and secret chats
        /// </summary>
        public bool Revoke { get; set; }

    }

    /// <summary>
    /// Deletes all messages sent by the specified user to a chat. Supported only for supergroups; requires can_delete_messages administrator privileges
    /// </summary>
    public partial class DeleteChatMessagesFromUser : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// Deletes all messages between the specified dates in a chat. Supported only for private chats and basic groups. Messages sent in the last 30 seconds will not be deleted
    /// </summary>
    public partial class DeleteChatMessagesByDate : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The minimum date of the messages to delete
        /// </summary>
        public int MinDate { get; set; }

        /// <summary>
        /// The maximum date of the messages to delete
        /// </summary>
        public int MaxDate { get; set; }

        /// <summary>
        /// Pass true to try to delete chat messages for all users; private chats only
        /// </summary>
        public bool Revoke { get; set; }

    }

    /// <summary>
    /// Edits the text of a message (or a text of a game message). Returns the edited message after the edit is completed on the server side
    /// </summary>
    public partial class EditMessageText : Function<Message>
    {
        /// <summary>
        /// The chat the message belongs to
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// The new message reply markup; pass null if none; for bots only
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// New text content of the message. Must be of type inputMessageText
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed on the server side
    /// </summary>
    public partial class EditMessageLiveLocation : Function<Message>
    {
        /// <summary>
        /// The chat the message belongs to
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// The new message reply markup; pass null if none; for bots only
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// New location content of the message; pass null to stop sharing the live location
        /// </summary>
        public Location Location { get; set; }

        /// <summary>
        /// The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
        /// </summary>
        public int Heading { get; set; }

        /// <summary>
        /// The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled
        /// </summary>
        public int ProximityAlertRadius { get; set; }

    }

    /// <summary>
    /// Edits the content of a message with an animation, an audio, a document, a photo or a video, including message caption. If only the caption needs to be edited, use editMessageCaption instead. -The media can't be edited if the message was set to self-destruct or to a self-destructing media. The type of message content in an album can't be changed with exception of replacing a photo with a video or vice versa. Returns the edited message after the edit is completed on the server side
    /// </summary>
    public partial class EditMessageMedia : Function<Message>
    {
        /// <summary>
        /// The chat the message belongs to
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// The new message reply markup; pass null if none; for bots only
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Edits the message content caption. Returns the edited message after the edit is completed on the server side
    /// </summary>
    public partial class EditMessageCaption : Function<Message>
    {
        /// <summary>
        /// The chat the message belongs to
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// The new message reply markup; pass null if none; for bots only
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// New message content caption; 0-GetOption("message_caption_length_max") characters; pass null to remove caption
        /// </summary>
        public FormattedText Caption { get; set; }

    }

    /// <summary>
    /// Edits the message reply markup; for bots only. Returns the edited message after the edit is completed on the server side
    /// </summary>
    public partial class EditMessageReplyMarkup : Function<Message>
    {
        /// <summary>
        /// The chat the message belongs to
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// The new message reply markup; pass null if none
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

    }

    /// <summary>
    /// Edits the text of an inline text or game message sent via a bot; for bots only
    /// </summary>
    public partial class EditInlineMessageText : Function<Ok>
    {
        /// <summary>
        /// Inline message identifier
        /// </summary>
        public string InlineMessageId { get; set; }

        /// <summary>
        /// The new message reply markup; pass null if none
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// New text content of the message. Must be of type inputMessageText
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Edits the content of a live location in an inline message sent via a bot; for bots only
    /// </summary>
    public partial class EditInlineMessageLiveLocation : Function<Ok>
    {
        /// <summary>
        /// Inline message identifier
        /// </summary>
        public string InlineMessageId { get; set; }

        /// <summary>
        /// The new message reply markup; pass null if none
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// New location content of the message; pass null to stop sharing the live location
        /// </summary>
        public Location Location { get; set; }

        /// <summary>
        /// The new direction in which the location moves, in degrees; 1-360. Pass 0 if unknown
        /// </summary>
        public int Heading { get; set; }

        /// <summary>
        /// The new maximum distance for proximity alerts, in meters (0-100000). Pass 0 if the notification is disabled
        /// </summary>
        public int ProximityAlertRadius { get; set; }

    }

    /// <summary>
    /// Edits the content of a message with an animation, an audio, a document, a photo or a video in an inline message sent via a bot; for bots only
    /// </summary>
    public partial class EditInlineMessageMedia : Function<Ok>
    {
        /// <summary>
        /// Inline message identifier
        /// </summary>
        public string InlineMessageId { get; set; }

        /// <summary>
        /// The new message reply markup; pass null if none; for bots only
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// New content of the message. Must be one of the following types: inputMessageAnimation, inputMessageAudio, inputMessageDocument, inputMessagePhoto or inputMessageVideo
        /// </summary>
        public InputMessageContent InputMessageContent { get; set; }

    }

    /// <summary>
    /// Edits the caption of an inline message sent via a bot; for bots only
    /// </summary>
    public partial class EditInlineMessageCaption : Function<Ok>
    {
        /// <summary>
        /// Inline message identifier
        /// </summary>
        public string InlineMessageId { get; set; }

        /// <summary>
        /// The new message reply markup; pass null if none
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

        /// <summary>
        /// New message content caption; pass null to remove caption; 0-GetOption("message_caption_length_max") characters
        /// </summary>
        public FormattedText Caption { get; set; }

    }

    /// <summary>
    /// Edits the reply markup of an inline message sent via a bot; for bots only
    /// </summary>
    public partial class EditInlineMessageReplyMarkup : Function<Ok>
    {
        /// <summary>
        /// Inline message identifier
        /// </summary>
        public string InlineMessageId { get; set; }

        /// <summary>
        /// The new message reply markup; pass null if none
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

    }

    /// <summary>
    /// Edits the time when a scheduled message will be sent. Scheduling state of all messages in the same album or forwarded together with the message will be also changed
    /// </summary>
    public partial class EditMessageSchedulingState : Function<Ok>
    {
        /// <summary>
        /// The chat the message belongs to
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// The new message scheduling state; pass null to send the message immediately
        /// </summary>
        public MessageSchedulingState SchedulingState { get; set; }

    }

    /// <summary>
    /// Returns all entities (mentions, hashtags, cashtags, bot commands, bank card numbers, URLs, and email addresses) contained in the text. Can be called synchronously
    /// </summary>
    public partial class GetTextEntities : Function<TextEntities>
    {
        /// <summary>
        /// The text in which to look for entites
        /// </summary>
        public string Text { get; set; }

    }

    /// <summary>
    /// Parses Bold, Italic, Underline, Strikethrough, Code, Pre, PreCode, TextUrl and MentionName entities contained in the text. Can be called synchronously
    /// </summary>
    public partial class ParseTextEntities : Function<FormattedText>
    {
        /// <summary>
        /// The text to parse
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// Text parse mode
        /// </summary>
        public TextParseMode ParseMode { get; set; }

    }

    /// <summary>
    /// Parses Markdown entities in a human-friendly format, ignoring markup errors. Can be called synchronously
    /// </summary>
    public partial class ParseMarkdown : Function<FormattedText>
    {
        /// <summary>
        /// The text to parse. For example, "__italic__ ~~strikethrough~~ **bold** `code` ```pre``` __[italic__ text_url](telegram.org) __italic**bold italic__bold**"
        /// </summary>
        public FormattedText Text { get; set; }

    }

    /// <summary>
    /// Replaces text entities with Markdown formatting in a human-friendly format. Entities that can't be represented in Markdown unambiguously are kept as is. Can be called synchronously
    /// </summary>
    public partial class GetMarkdownText : Function<FormattedText>
    {
        /// <summary>
        /// The text
        /// </summary>
        public FormattedText Text { get; set; }

    }

    /// <summary>
    /// Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. Can be called synchronously
    /// </summary>
    public partial class GetFileMimeType : Function<Text>
    {
        /// <summary>
        /// The name of the file or path to the file
        /// </summary>
        public string FileName { get; set; }

    }

    /// <summary>
    /// Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. Can be called synchronously
    /// </summary>
    public partial class GetFileExtension : Function<Text>
    {
        /// <summary>
        /// The MIME type of the file
        /// </summary>
        public string MimeType { get; set; }

    }

    /// <summary>
    /// Removes potentially dangerous characters from the name of a file. The encoding of the file name is supposed to be UTF-8. Returns an empty string on failure. Can be called synchronously
    /// </summary>
    public partial class CleanFileName : Function<Text>
    {
        /// <summary>
        /// File name or path to the file
        /// </summary>
        public string FileName { get; set; }

    }

    /// <summary>
    /// Returns a string stored in the local database from the specified localization target and language pack by its key. Returns a 404 error if the string is not found. Can be called synchronously
    /// </summary>
    public partial class GetLanguagePackString : Function<LanguagePackStringValue>
    {
        /// <summary>
        /// Path to the language pack database in which strings are stored
        /// </summary>
        public string LanguagePackDatabasePath { get; set; }

        /// <summary>
        /// Localization target to which the language pack belongs
        /// </summary>
        public string LocalizationTarget { get; set; }

        /// <summary>
        /// Language pack identifier
        /// </summary>
        public string LanguagePackId { get; set; }

        /// <summary>
        /// Language pack key of the string to be returned
        /// </summary>
        public string Key { get; set; }

    }

    /// <summary>
    /// Converts a JSON-serialized string to corresponding JsonValue object. Can be called synchronously
    /// </summary>
    public partial class GetJsonValue : Function<JsonValue>
    {
        /// <summary>
        /// The JSON-serialized string
        /// </summary>
        public string Json { get; set; }

    }

    /// <summary>
    /// Converts a JsonValue object to corresponding JSON-serialized string. Can be called synchronously
    /// </summary>
    public partial class GetJsonString : Function<Text>
    {
        /// <summary>
        /// The JsonValue object
        /// </summary>
        public JsonValue JsonValue { get; set; }

    }

    /// <summary>
    /// Changes the user answer to a poll. A poll in quiz mode can be answered only once
    /// </summary>
    public partial class SetPollAnswer : Function<Ok>
    {
        /// <summary>
        /// Identifier of the chat to which the poll belongs
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message containing the poll
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// 0-based identifiers of answer options, chosen by the user. User can choose more than 1 answer option only is the poll allows multiple answers
        /// </summary>
        public int[] OptionIds { get; set; }

    }

    /// <summary>
    /// Returns users voted for the specified option in a non-anonymous polls. For optimal performance, the number of returned users is chosen by TDLib
    /// </summary>
    public partial class GetPollVoters : Function<Users>
    {
        /// <summary>
        /// Identifier of the chat to which the poll belongs
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message containing the poll
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// 0-based identifier of the answer option
        /// </summary>
        public int OptionId { get; set; }

        /// <summary>
        /// Number of users to skip in the result; must be non-negative
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// The maximum number of users to be returned; must be positive and can't be greater than 50. For optimal performance, the number of returned users is chosen by TDLib and can be smaller than the specified limit, even if the end of the voter list has not been reached
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Stops a poll. A poll in a message can be stopped when the message has can_be_edited flag set
    /// </summary>
    public partial class StopPoll : Function<Ok>
    {
        /// <summary>
        /// Identifier of the chat to which the poll belongs
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message containing the poll
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// The new message reply markup; pass null if none; for bots only
        /// </summary>
        public ReplyMarkup ReplyMarkup { get; set; }

    }

    /// <summary>
    /// Hides a suggested action
    /// </summary>
    public partial class HideSuggestedAction : Function<Ok>
    {
        /// <summary>
        /// Suggested action to hide
        /// </summary>
        public SuggestedAction Action { get; set; }

    }

    /// <summary>
    /// Returns information about a button of type inlineKeyboardButtonTypeLoginUrl. The method needs to be called when the user presses the button
    /// </summary>
    public partial class GetLoginUrlInfo : Function<LoginUrlInfo>
    {
        /// <summary>
        /// Chat identifier of the message with the button
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier of the message with the button
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Button identifier
        /// </summary>
        public long ButtonId { get; set; }

    }

    /// <summary>
    /// Returns an HTTP URL which can be used to automatically authorize the user on a website after clicking an inline button of type inlineKeyboardButtonTypeLoginUrl. -Use the method getLoginUrlInfo to find whether a prior user confirmation is needed. If an error is returned, then the button must be handled as an ordinary URL button
    /// </summary>
    public partial class GetLoginUrl : Function<HttpUrl>
    {
        /// <summary>
        /// Chat identifier of the message with the button
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier of the message with the button
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Button identifier
        /// </summary>
        public long ButtonId { get; set; }

        /// <summary>
        /// True, if the user allowed the bot to send them messages
        /// </summary>
        public bool AllowWriteAccess { get; set; }

    }

    /// <summary>
    /// Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
    /// </summary>
    public partial class GetInlineQueryResults : Function<InlineQueryResults>
    {
        /// <summary>
        /// The identifier of the target bot
        /// </summary>
        public long BotUserId { get; set; }

        /// <summary>
        /// Identifier of the chat where the query was sent
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Location of the user; pass null if unknown or the bot doesn't need user's location
        /// </summary>
        public Location UserLocation { get; set; }

        /// <summary>
        /// Text of the query
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// Offset of the first entry to return
        /// </summary>
        public string Offset { get; set; }

    }

    /// <summary>
    /// Sets the result of an inline query; for bots only
    /// </summary>
    public partial class AnswerInlineQuery : Function<Ok>
    {
        /// <summary>
        /// Identifier of the inline query
        /// </summary>
        public long InlineQueryId { get; set; }

        /// <summary>
        /// True, if the result of the query can be cached for the specified user
        /// </summary>
        public bool IsPersonal { get; set; }

        /// <summary>
        /// The results of the query
        /// </summary>
        public InputInlineQueryResult[] Results { get; set; }

        /// <summary>
        /// Allowed time to cache the results of the query, in seconds
        /// </summary>
        public int CacheTime { get; set; }

        /// <summary>
        /// Offset for the next inline query; pass an empty string if there are no more results
        /// </summary>
        public string NextOffset { get; set; }

        /// <summary>
        /// If non-empty, this text must be shown on the button that opens a private chat with the bot and sends a start message to the bot with the parameter switch_pm_parameter
        /// </summary>
        public string SwitchPmText { get; set; }

        /// <summary>
        /// The parameter for the bot start message
        /// </summary>
        public string SwitchPmParameter { get; set; }

    }

    /// <summary>
    /// Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
    /// </summary>
    public partial class GetCallbackQueryAnswer : Function<CallbackQueryAnswer>
    {
        /// <summary>
        /// Identifier of the chat with the message
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message from which the query originated
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Query payload
        /// </summary>
        public CallbackQueryPayload Payload { get; set; }

    }

    /// <summary>
    /// Sets the result of a callback query; for bots only
    /// </summary>
    public partial class AnswerCallbackQuery : Function<Ok>
    {
        /// <summary>
        /// Identifier of the callback query
        /// </summary>
        public long CallbackQueryId { get; set; }

        /// <summary>
        /// Text of the answer
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// If true, an alert must be shown to the user instead of a toast notification
        /// </summary>
        public bool ShowAlert { get; set; }

        /// <summary>
        /// URL to be opened
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// Time during which the result of the query can be cached, in seconds
        /// </summary>
        public int CacheTime { get; set; }

    }

    /// <summary>
    /// Sets the result of a shipping query; for bots only
    /// </summary>
    public partial class AnswerShippingQuery : Function<Ok>
    {
        /// <summary>
        /// Identifier of the shipping query
        /// </summary>
        public long ShippingQueryId { get; set; }

        /// <summary>
        /// Available shipping options
        /// </summary>
        public ShippingOption[] ShippingOptions { get; set; }

        /// <summary>
        /// An error message, empty on success
        /// </summary>
        public string ErrorMessage { get; set; }

    }

    /// <summary>
    /// Sets the result of a pre-checkout query; for bots only
    /// </summary>
    public partial class AnswerPreCheckoutQuery : Function<Ok>
    {
        /// <summary>
        /// Identifier of the pre-checkout query
        /// </summary>
        public long PreCheckoutQueryId { get; set; }

        /// <summary>
        /// An error message, empty on success
        /// </summary>
        public string ErrorMessage { get; set; }

    }

    /// <summary>
    /// Updates the game score of the specified user in the game; for bots only
    /// </summary>
    public partial class SetGameScore : Function<Message>
    {
        /// <summary>
        /// The chat to which the message with the game belongs
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// True, if the message needs to be edited
        /// </summary>
        public bool EditMessage { get; set; }

        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// The new score
        /// </summary>
        public int Score { get; set; }

        /// <summary>
        /// Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
        /// </summary>
        public bool Force { get; set; }

    }

    /// <summary>
    /// Updates the game score of the specified user in a game; for bots only
    /// </summary>
    public partial class SetInlineGameScore : Function<Ok>
    {
        /// <summary>
        /// Inline message identifier
        /// </summary>
        public string InlineMessageId { get; set; }

        /// <summary>
        /// True, if the message needs to be edited
        /// </summary>
        public bool EditMessage { get; set; }

        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// The new score
        /// </summary>
        public int Score { get; set; }

        /// <summary>
        /// Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
        /// </summary>
        public bool Force { get; set; }

    }

    /// <summary>
    /// Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only
    /// </summary>
    public partial class GetGameHighScores : Function<GameHighScores>
    {
        /// <summary>
        /// The chat that contains the message with the game
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// Returns game high scores and some part of the high score table in the range of the specified user; for bots only
    /// </summary>
    public partial class GetInlineGameHighScores : Function<GameHighScores>
    {
        /// <summary>
        /// Inline message identifier
        /// </summary>
        public string InlineMessageId { get; set; }

        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if the reply markup is changed
    /// </summary>
    public partial class DeleteChatReplyMarkup : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The message identifier of the used keyboard
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// Sends a notification about user activity in a chat
    /// </summary>
    public partial class SendChatAction : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// If not 0, a message thread identifier in which the action was performed
        /// </summary>
        public long MessageThreadId { get; set; }

        /// <summary>
        /// The action description; pass null to cancel the currently active action
        /// </summary>
        public ChatAction Action { get; set; }

    }

    /// <summary>
    /// Informs TDLib that the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
    /// </summary>
    public partial class OpenChat : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Informs TDLib that the chat is closed by the user. Many useful activities depend on the chat being opened or closed
    /// </summary>
    public partial class CloseChat : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Informs TDLib that messages are being viewed by the user. Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels)
    /// </summary>
    public partial class ViewMessages : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// If not 0, a message thread identifier in which the messages are being viewed
        /// </summary>
        public long MessageThreadId { get; set; }

        /// <summary>
        /// The identifiers of the messages being viewed
        /// </summary>
        public long[] MessageIds { get; set; }

        /// <summary>
        /// True, if messages in closed chats must be marked as read by the request
        /// </summary>
        public bool ForceRead { get; set; }

    }

    /// <summary>
    /// Informs TDLib that the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message). An updateMessageContentOpened update will be generated if something has changed
    /// </summary>
    public partial class OpenMessageContent : Function<Ok>
    {
        /// <summary>
        /// Chat identifier of the message
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the message with the opened content
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// Informs TDLib that a message with an animated emoji was clicked by the user. Returns a big animated sticker to be played or a 404 error if usual animation needs to be played
    /// </summary>
    public partial class ClickAnimatedEmojiMessage : Function<Sticker>
    {
        /// <summary>
        /// Chat identifier of the message
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the clicked message
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// Returns information about the type of an internal link. Returns a 404 error if the link is not internal. Can be called before authorization
    /// </summary>
    public partial class GetInternalLinkType : Function<InternalLinkType>
    {
        /// <summary>
        /// The link
        /// </summary>
        public string Link { get; set; }

    }

    /// <summary>
    /// Returns information about an action to be done when the current user clicks an external link. Don't use this method for links from secret chats if web page preview is disabled in secret chats
    /// </summary>
    public partial class GetExternalLinkInfo : Function<LoginUrlInfo>
    {
        /// <summary>
        /// The link
        /// </summary>
        public string Link { get; set; }

    }

    /// <summary>
    /// Returns an HTTP URL which can be used to automatically authorize the current user on a website after clicking an HTTP link. Use the method getExternalLinkInfo to find whether a prior user confirmation is needed
    /// </summary>
    public partial class GetExternalLink : Function<HttpUrl>
    {
        /// <summary>
        /// The HTTP link
        /// </summary>
        public string Link { get; set; }

        /// <summary>
        /// True, if the current user allowed the bot, returned in getExternalLinkInfo, to send them messages
        /// </summary>
        public bool AllowWriteAccess { get; set; }

    }

    /// <summary>
    /// Marks all mentions in a chat as read
    /// </summary>
    public partial class ReadAllChatMentions : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Returns an existing chat corresponding to a given user
    /// </summary>
    public partial class CreatePrivateChat : Function<Chat>
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect
        /// </summary>
        public bool Force { get; set; }

    }

    /// <summary>
    /// Returns an existing chat corresponding to a known basic group
    /// </summary>
    public partial class CreateBasicGroupChat : Function<Chat>
    {
        /// <summary>
        /// Basic group identifier
        /// </summary>
        public long BasicGroupId { get; set; }

        /// <summary>
        /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect
        /// </summary>
        public bool Force { get; set; }

    }

    /// <summary>
    /// Returns an existing chat corresponding to a known supergroup or channel
    /// </summary>
    public partial class CreateSupergroupChat : Function<Chat>
    {
        /// <summary>
        /// Supergroup or channel identifier
        /// </summary>
        public long SupergroupId { get; set; }

        /// <summary>
        /// If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect
        /// </summary>
        public bool Force { get; set; }

    }

    /// <summary>
    /// Returns an existing chat corresponding to a known secret chat
    /// </summary>
    public partial class CreateSecretChat : Function<Chat>
    {
        /// <summary>
        /// Secret chat identifier
        /// </summary>
        public int SecretChatId { get; set; }

    }

    /// <summary>
    /// Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
    /// </summary>
    public partial class CreateNewBasicGroupChat : Function<Chat>
    {
        /// <summary>
        /// Identifiers of users to be added to the basic group
        /// </summary>
        public long[] UserIds { get; set; }

        /// <summary>
        /// Title of the new basic group; 1-128 characters
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
    /// </summary>
    public partial class CreateNewSupergroupChat : Function<Chat>
    {
        /// <summary>
        /// Title of the new chat; 1-128 characters
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// True, if a channel chat needs to be created
        /// </summary>
        public bool IsChannel { get; set; }

        /// <summary>
        /// Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Chat location if a location-based supergroup is being created; pass null to create an ordinary supergroup chat
        /// </summary>
        public ChatLocation Location { get; set; }

        /// <summary>
        /// True, if the supergroup is created for importing messages using importMessage
        /// </summary>
        public bool ForImport { get; set; }

    }

    /// <summary>
    /// Creates a new secret chat. Returns the newly created chat
    /// </summary>
    public partial class CreateNewSecretChat : Function<Chat>
    {
        /// <summary>
        /// Identifier of the target user
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom; requires creator privileges. Deactivates the original basic group
    /// </summary>
    public partial class UpgradeBasicGroupChatToSupergroupChat : Function<Chat>
    {
        /// <summary>
        /// Identifier of the chat to upgrade
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Returns chat lists to which the chat can be added. This is an offline request
    /// </summary>
    public partial class GetChatListsToAddChat : Function<ChatLists>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Adds a chat to a chat list. A chat can't be simultaneously in Main and Archive chat lists, so it is automatically removed from another one if needed
    /// </summary>
    public partial class AddChatToList : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The chat list. Use getChatListsToAddChat to get suitable chat lists
        /// </summary>
        public ChatList ChatList { get; set; }

    }

    /// <summary>
    /// Returns information about a chat filter by its identifier
    /// </summary>
    public partial class GetChatFilter : Function<ChatFilter>
    {
        /// <summary>
        /// Chat filter identifier
        /// </summary>
        public int ChatFilterId { get; set; }

    }

    /// <summary>
    /// Creates new chat filter. Returns information about the created chat filter
    /// </summary>
    public partial class CreateChatFilter : Function<ChatFilterInfo>
    {
        /// <summary>
        /// Chat filter
        /// </summary>
        public ChatFilter Filter { get; set; }

    }

    /// <summary>
    /// Edits existing chat filter. Returns information about the edited chat filter
    /// </summary>
    public partial class EditChatFilter : Function<ChatFilterInfo>
    {
        /// <summary>
        /// Chat filter identifier
        /// </summary>
        public int ChatFilterId { get; set; }

        /// <summary>
        /// The edited chat filter
        /// </summary>
        public ChatFilter Filter { get; set; }

    }

    /// <summary>
    /// Deletes existing chat filter
    /// </summary>
    public partial class DeleteChatFilter : Function<Ok>
    {
        /// <summary>
        /// Chat filter identifier
        /// </summary>
        public int ChatFilterId { get; set; }

    }

    /// <summary>
    /// Changes the order of chat filters
    /// </summary>
    public partial class ReorderChatFilters : Function<Ok>
    {
        /// <summary>
        /// Identifiers of chat filters in the new correct order
        /// </summary>
        public int[] ChatFilterIds { get; set; }

    }

    /// <summary>
    /// Returns recommended chat filters for the current user
    /// </summary>
    public partial class GetRecommendedChatFilters : Function<RecommendedChatFilters>
    {
    }

    /// <summary>
    /// Returns default icon name for a filter. Can be called synchronously
    /// </summary>
    public partial class GetChatFilterDefaultIconName : Function<Text>
    {
        /// <summary>
        /// Chat filter
        /// </summary>
        public ChatFilter Filter { get; set; }

    }

    /// <summary>
    /// Changes the chat title. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
    /// </summary>
    public partial class SetChatTitle : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New title of the chat; 1-128 characters
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires can_change_info administrator right
    /// </summary>
    public partial class SetChatPhoto : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New chat photo; pass null to delete the chat photo
        /// </summary>
        public InputChatPhoto Photo { get; set; }

    }

    /// <summary>
    /// Changes the message TTL setting (sets a new self-destruct timer) in a chat. Requires can_delete_messages administrator right in basic groups, supergroups and channels -Message TTL setting of a chat with the current user (Saved Messages) and the chat 777000 (Telegram) can't be changed
    /// </summary>
    public partial class SetChatMessageTtlSetting : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New TTL value, in seconds; must be one of 0, 86400, 7 * 86400, or 31 * 86400 unless the chat is secret
        /// </summary>
        public int Ttl { get; set; }

    }

    /// <summary>
    /// Changes the chat members permissions. Supported only for basic groups and supergroups. Requires can_restrict_members administrator right
    /// </summary>
    public partial class SetChatPermissions : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New non-administrator members permissions in the chat
        /// </summary>
        public ChatPermissions Permissions { get; set; }

    }

    /// <summary>
    /// Changes the chat theme. Supported only in private and secret chats
    /// </summary>
    public partial class SetChatTheme : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Name of the new chat theme; pass an empty string to return the default theme
        /// </summary>
        public string ThemeName { get; set; }

    }

    /// <summary>
    /// Changes the draft message in a chat
    /// </summary>
    public partial class SetChatDraftMessage : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// If not 0, a message thread identifier in which the draft was changed
        /// </summary>
        public long MessageThreadId { get; set; }

        /// <summary>
        /// New draft message; pass null to remove the draft
        /// </summary>
        public DraftMessage DraftMessage { get; set; }

    }

    /// <summary>
    /// Changes the notification settings of a chat. Notification settings of a chat with the current user (Saved Messages) can't be changed
    /// </summary>
    public partial class SetChatNotificationSettings : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New notification settings for the chat. If the chat is muted for more than 1 week, it is considered to be muted forever
        /// </summary>
        public ChatNotificationSettings NotificationSettings { get; set; }

    }

    /// <summary>
    /// Changes the marked as unread state of a chat
    /// </summary>
    public partial class ToggleChatIsMarkedAsUnread : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New value of is_marked_as_unread
        /// </summary>
        public bool IsMarkedAsUnread { get; set; }

    }

    /// <summary>
    /// Changes the value of the default disable_notification parameter, used when a message is sent to a chat
    /// </summary>
    public partial class ToggleChatDefaultDisableNotification : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New value of default_disable_notification
        /// </summary>
        public bool DefaultDisableNotification { get; set; }

    }

    /// <summary>
    /// Changes application-specific data associated with a chat
    /// </summary>
    public partial class SetChatClientData : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New value of client_data
        /// </summary>
        public string ClientData { get; set; }

    }

    /// <summary>
    /// Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
    /// </summary>
    public partial class SetChatDescription : Function<Ok>
    {
        /// <summary>
        /// Identifier of the chat
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Changes information about a chat. Available for basic groups, supergroups, and channels. Requires can_change_info administrator right
        /// </summary>
        public string Description { get; set; }

    }

    /// <summary>
    /// Changes the discussion group of a channel chat; requires can_change_info administrator right in the channel if it is specified
    /// </summary>
    public partial class SetChatDiscussionGroup : Function<Ok>
    {
        /// <summary>
        /// Identifier of the channel chat. Pass 0 to remove a link from the supergroup passed in the second argument to a linked channel chat (requires can_pin_messages rights in the supergroup)
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of a new channel's discussion group. Use 0 to remove the discussion group. -Use the method getSuitableDiscussionChats to find all suitable groups. Basic group chats must be first upgraded to supergroup chats. If new chat members don't have access to old messages in the supergroup, then toggleSupergroupIsAllHistoryAvailable must be used first to change that
        /// </summary>
        public long DiscussionChatId { get; set; }

    }

    /// <summary>
    /// Changes the location of a chat. Available only for some location-based supergroups, use supergroupFullInfo.can_set_location to check whether the method is allowed to use
    /// </summary>
    public partial class SetChatLocation : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New location for the chat; must be valid and not null
        /// </summary>
        public ChatLocation Location { get; set; }

    }

    /// <summary>
    /// Changes the slow mode delay of a chat. Available only for supergroups; requires can_restrict_members rights
    /// </summary>
    public partial class SetChatSlowModeDelay : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// New slow mode delay for the chat, in seconds; must be one of 0, 10, 30, 60, 300, 900, 3600
        /// </summary>
        public int SlowModeDelay { get; set; }

    }

    /// <summary>
    /// Pins a message in a chat; requires can_pin_messages rights or can_edit_messages rights in the channel
    /// </summary>
    public partial class PinChatMessage : Function<Ok>
    {
        /// <summary>
        /// Identifier of the chat
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the new pinned message
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// True, if there must be no notification about the pinned message. Notifications are always disabled in channels and private chats
        /// </summary>
        public bool DisableNotification { get; set; }

        /// <summary>
        /// True, if the message needs to be pinned for one side only; private chats only
        /// </summary>
        public bool OnlyForSelf { get; set; }

    }

    /// <summary>
    /// Removes a pinned message from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
    /// </summary>
    public partial class UnpinChatMessage : Function<Ok>
    {
        /// <summary>
        /// Identifier of the chat
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the removed pinned message
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// Removes all pinned messages from a chat; requires can_pin_messages rights in the group or can_edit_messages rights in the channel
    /// </summary>
    public partial class UnpinAllChatMessages : Function<Ok>
    {
        /// <summary>
        /// Identifier of the chat
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Adds the current user as a new member to a chat. Private and secret chats can't be joined using this method
    /// </summary>
    public partial class JoinChat : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Removes the current user from chat members. Private and secret chats can't be left using this method
    /// </summary>
    public partial class LeaveChat : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Adds a new member to a chat. Members can't be added to private or secret chats
    /// </summary>
    public partial class AddChatMember : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the user
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// The number of earlier messages from the chat to be forwarded to the new member; up to 100. Ignored for supergroups and channels, or if the added user is a bot
        /// </summary>
        public int ForwardLimit { get; set; }

    }

    /// <summary>
    /// Adds multiple new members to a chat. Currently this method is only available for supergroups and channels. This method can't be used to join a chat. Members can't be added to a channel if it has more than 200 members
    /// </summary>
    public partial class AddChatMembers : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifiers of the users to be added to the chat. The maximum number of added users is 20 for supergroups and 100 for channels
        /// </summary>
        public long[] UserIds { get; set; }

    }

    /// <summary>
    /// Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for transferring chat ownership; use transferChatOwnership instead. Use addChatMember or banChatMember if some additional parameters needs to be passed
    /// </summary>
    public partial class SetChatMemberStatus : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Member identifier. Chats can be only banned and unbanned in supergroups and channels
        /// </summary>
        public MessageSender MemberId { get; set; }

        /// <summary>
        /// The new status of the member in the chat
        /// </summary>
        public ChatMemberStatus Status { get; set; }

    }

    /// <summary>
    /// Bans a member in a chat. Members can't be banned in private or secret chats. In supergroups and channels, the user will not be able to return to the group on their own using invite links, etc., unless unbanned first
    /// </summary>
    public partial class BanChatMember : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Member identifier
        /// </summary>
        public MessageSender MemberId { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the user will be unbanned; 0 if never. If the user is banned for more than 366 days or for less than 30 seconds from the current time, the user is considered to be banned forever. Ignored in basic groups
        /// </summary>
        public int BannedUntilDate { get; set; }

        /// <summary>
        /// Pass true to delete all messages in the chat for the user that is being removed. Always true for supergroups and channels
        /// </summary>
        public bool RevokeMessages { get; set; }

    }

    /// <summary>
    /// Checks whether the current session can be used to transfer a chat ownership to another user
    /// </summary>
    public partial class CanTransferOwnership : Function<CanTransferOwnershipResult>
    {
    }

    /// <summary>
    /// Changes the owner of a chat. The current user must be a current owner of the chat. Use the method canTransferOwnership to check whether the ownership can be transferred from the current session. Available only for supergroups and channel chats
    /// </summary>
    public partial class TransferChatOwnership : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the user to which transfer the ownership. The ownership can't be transferred to a bot or to a deleted user
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// The password of the current user
        /// </summary>
        public string Password { get; set; }

    }

    /// <summary>
    /// Returns information about a single member of a chat
    /// </summary>
    public partial class GetChatMember : Function<ChatMember>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Member identifier
        /// </summary>
        public MessageSender MemberId { get; set; }

    }

    /// <summary>
    /// Searches for a specified query in the first name, last name and username of the members of a specified chat. Requires administrator rights in channels
    /// </summary>
    public partial class SearchChatMembers : Function<ChatMembers>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// The maximum number of users to be returned; up to 200
        /// </summary>
        public int Limit { get; set; }

        /// <summary>
        /// The type of users to search for; pass null to search among all chat members
        /// </summary>
        public ChatMembersFilter Filter { get; set; }

    }

    /// <summary>
    /// Returns a list of administrators of the chat with their custom titles
    /// </summary>
    public partial class GetChatAdministrators : Function<ChatAdministrators>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Clears draft messages in all chats
    /// </summary>
    public partial class ClearAllDraftMessages : Function<Ok>
    {
        /// <summary>
        /// If true, local draft messages in secret chats will not be cleared
        /// </summary>
        public bool ExcludeSecretChats { get; set; }

    }

    /// <summary>
    /// Returns list of chats with non-default notification settings
    /// </summary>
    public partial class GetChatNotificationSettingsExceptions : Function<Chats>
    {
        /// <summary>
        /// If specified, only chats from the scope will be returned; pass null to return chats from all scopes
        /// </summary>
        public NotificationSettingsScope Scope { get; set; }

        /// <summary>
        /// If true, also chats with non-default sound will be returned
        /// </summary>
        public bool CompareSound { get; set; }

    }

    /// <summary>
    /// Returns the notification settings for chats of a given type
    /// </summary>
    public partial class GetScopeNotificationSettings : Function<ScopeNotificationSettings>
    {
        /// <summary>
        /// Types of chats for which to return the notification settings information
        /// </summary>
        public NotificationSettingsScope Scope { get; set; }

    }

    /// <summary>
    /// Changes notification settings for chats of a given type
    /// </summary>
    public partial class SetScopeNotificationSettings : Function<Ok>
    {
        /// <summary>
        /// Types of chats for which to change the notification settings
        /// </summary>
        public NotificationSettingsScope Scope { get; set; }

        /// <summary>
        /// The new notification settings for the given scope
        /// </summary>
        public ScopeNotificationSettings NotificationSettings { get; set; }

    }

    /// <summary>
    /// Resets all notification settings to their default values. By default, all chats are unmuted, the sound is set to "default" and message previews are shown
    /// </summary>
    public partial class ResetAllNotificationSettings : Function<Ok>
    {
    }

    /// <summary>
    /// Changes the pinned state of a chat. There can be up to GetOption("pinned_chat_count_max")/GetOption("pinned_archived_chat_count_max") pinned non-secret chats and the same number of secret chats in the main/arhive chat list
    /// </summary>
    public partial class ToggleChatIsPinned : Function<Ok>
    {
        /// <summary>
        /// Chat list in which to change the pinned state of the chat
        /// </summary>
        public ChatList ChatList { get; set; }

        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// True, if the chat is pinned
        /// </summary>
        public bool IsPinned { get; set; }

    }

    /// <summary>
    /// Changes the order of pinned chats
    /// </summary>
    public partial class SetPinnedChats : Function<Ok>
    {
        /// <summary>
        /// Chat list in which to change the order of pinned chats
        /// </summary>
        public ChatList ChatList { get; set; }

        /// <summary>
        /// The new list of pinned chats
        /// </summary>
        public long[] ChatIds { get; set; }

    }

    /// <summary>
    /// Downloads a file from the cloud. Download progress and completion of the download will be notified through updateFile updates
    /// </summary>
    public partial class DownloadFile : Function<File>
    {
        /// <summary>
        /// Identifier of the file to download
        /// </summary>
        public int FileId { get; set; }

        /// <summary>
        /// Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile was called will be downloaded first
        /// </summary>
        public int Priority { get; set; }

        /// <summary>
        /// The starting position from which the file needs to be downloaded
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// Number of bytes which need to be downloaded starting from the "offset" position before the download will be automatically canceled; use 0 to download without a limit
        /// </summary>
        public int Limit { get; set; }

        /// <summary>
        /// If false, this request returns file state just after the download has been started. If true, this request returns file state only after -the download has succeeded, has failed, has been canceled or a new downloadFile request with different offset/limit parameters was sent
        /// </summary>
        public bool Synchronous { get; set; }

    }

    /// <summary>
    /// Returns file downloaded prefix size from a given offset, in bytes
    /// </summary>
    public partial class GetFileDownloadedPrefixSize : Function<Count>
    {
        /// <summary>
        /// Identifier of the file
        /// </summary>
        public int FileId { get; set; }

        /// <summary>
        /// Offset from which downloaded prefix size needs to be calculated
        /// </summary>
        public int Offset { get; set; }

    }

    /// <summary>
    /// Stops the downloading of a file. If a file has already been downloaded, does nothing
    /// </summary>
    public partial class CancelDownloadFile : Function<Ok>
    {
        /// <summary>
        /// Identifier of a file to stop downloading
        /// </summary>
        public int FileId { get; set; }

        /// <summary>
        /// Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server
        /// </summary>
        public bool OnlyIfPending { get; set; }

    }

    /// <summary>
    /// Returns suggested name for saving a file in a given directory
    /// </summary>
    public partial class GetSuggestedFileName : Function<Text>
    {
        /// <summary>
        /// Identifier of the file
        /// </summary>
        public int FileId { get; set; }

        /// <summary>
        /// Directory in which the file is supposed to be saved
        /// </summary>
        public string Directory { get; set; }

    }

    /// <summary>
    /// Asynchronously uploads a file to the cloud without sending it in a message. updateFile will be used to notify about upload progress and successful completion of the upload. The file will not have a persistent remote identifier until it will be sent in a message
    /// </summary>
    public partial class UploadFile : Function<File>
    {
        /// <summary>
        /// File to upload
        /// </summary>
        public InputFile File { get; set; }

        /// <summary>
        /// File type; pass null if unknown
        /// </summary>
        public FileType FileType { get; set; }

        /// <summary>
        /// Priority of the upload (1-32). The higher the priority, the earlier the file will be uploaded. If the priorities of two files are equal, then the first one for which uploadFile was called will be uploaded first
        /// </summary>
        public int Priority { get; set; }

    }

    /// <summary>
    /// Stops the uploading of a file. Supported only for files uploaded by using uploadFile. For other files the behavior is undefined
    /// </summary>
    public partial class CancelUploadFile : Function<Ok>
    {
        /// <summary>
        /// Identifier of the file to stop uploading
        /// </summary>
        public int FileId { get; set; }

    }

    /// <summary>
    /// Writes a part of a generated file. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct write to the destination file
    /// </summary>
    public partial class WriteGeneratedFilePart : Function<Ok>
    {
        /// <summary>
        /// The identifier of the generation process
        /// </summary>
        public long GenerationId { get; set; }

        /// <summary>
        /// The offset from which to write the data to the file
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// The data to write
        /// </summary>
        public Memory<byte> Data { get; set; }

    }

    /// <summary>
    /// Informs TDLib on a file generation progress
    /// </summary>
    public partial class SetFileGenerationProgress : Function<Ok>
    {
        /// <summary>
        /// The identifier of the generation process
        /// </summary>
        public long GenerationId { get; set; }

        /// <summary>
        /// Expected size of the generated file, in bytes; 0 if unknown
        /// </summary>
        public int ExpectedSize { get; set; }

        /// <summary>
        /// The number of bytes already generated
        /// </summary>
        public int LocalPrefixSize { get; set; }

    }

    /// <summary>
    /// Finishes the file generation
    /// </summary>
    public partial class FinishFileGeneration : Function<Ok>
    {
        /// <summary>
        /// The identifier of the generation process
        /// </summary>
        public long GenerationId { get; set; }

        /// <summary>
        /// If passed, the file generation has failed and must be terminated; pass null if the file generation succeeded
        /// </summary>
        public Error Error { get; set; }

    }

    /// <summary>
    /// Reads a part of a file from the TDLib file cache and returns read bytes. This method is intended to be used only if the application has no direct access to TDLib's file system, because it is usually slower than a direct read from the file
    /// </summary>
    public partial class ReadFilePart : Function<FilePart>
    {
        /// <summary>
        /// Identifier of the file. The file must be located in the TDLib file cache
        /// </summary>
        public int FileId { get; set; }

        /// <summary>
        /// The offset from which to read the file
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// Number of bytes to read. An error will be returned if there are not enough bytes available in the file from the specified position. Pass 0 to read all available data from the specified position
        /// </summary>
        public int Count { get; set; }

    }

    /// <summary>
    /// Deletes a file from the TDLib file cache
    /// </summary>
    public partial class DeleteFile : Function<Ok>
    {
        /// <summary>
        /// Identifier of the file to delete
        /// </summary>
        public int FileId { get; set; }

    }

    /// <summary>
    /// Returns information about a file with messages exported from another app
    /// </summary>
    public partial class GetMessageFileType : Function<MessageFileType>
    {
        /// <summary>
        /// Beginning of the message file; up to 100 first lines
        /// </summary>
        public string MessageFileHead { get; set; }

    }

    /// <summary>
    /// Returns a confirmation text to be shown to the user before starting message import
    /// </summary>
    public partial class GetMessageImportConfirmationText : Function<Text>
    {
        /// <summary>
        /// Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Imports messages exported from another app
    /// </summary>
    public partial class ImportMessages : Function<Ok>
    {
        /// <summary>
        /// Identifier of a chat to which the messages will be imported. It must be an identifier of a private chat with a mutual contact or an identifier of a supergroup chat with can_change_info administrator right
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// File with messages to import. Only inputFileLocal and inputFileGenerated are supported. The file must not be previously uploaded
        /// </summary>
        public InputFile MessageFile { get; set; }

        /// <summary>
        /// Files used in the imported messages. Only inputFileLocal and inputFileGenerated are supported. The files must not be previously uploaded
        /// </summary>
        public InputFile[] AttachedFiles { get; set; }

    }

    /// <summary>
    /// Replaces current primary invite link for a chat with a new primary invite link. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right
    /// </summary>
    public partial class ReplacePrimaryChatInviteLink : Function<ChatInviteLink>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Creates a new invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat
    /// </summary>
    public partial class CreateChatInviteLink : Function<ChatInviteLink>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Invite link name; 0-32 characters
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the link will expire; pass 0 if never
        /// </summary>
        public int ExpireDate { get; set; }

        /// <summary>
        /// The maximum number of chat members that can join the chat by the link simultaneously; 0-99999; pass 0 if not limited
        /// </summary>
        public int MemberLimit { get; set; }

        /// <summary>
        /// True, if the link only creates join request. If true, member_limit must not be specified
        /// </summary>
        public bool CreatesJoinRequest { get; set; }

    }

    /// <summary>
    /// Edits a non-primary invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
    /// </summary>
    public partial class EditChatInviteLink : Function<ChatInviteLink>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Invite link to be edited
        /// </summary>
        public string InviteLink { get; set; }

        /// <summary>
        /// Invite link name; 0-32 characters
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the link will expire; pass 0 if never
        /// </summary>
        public int ExpireDate { get; set; }

        /// <summary>
        /// The maximum number of chat members that can join the chat by the link simultaneously; 0-99999; pass 0 if not limited
        /// </summary>
        public int MemberLimit { get; set; }

        /// <summary>
        /// True, if the link only creates join request. If true, member_limit must not be specified
        /// </summary>
        public bool CreatesJoinRequest { get; set; }

    }

    /// <summary>
    /// Returns information about an invite link. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
    /// </summary>
    public partial class GetChatInviteLink : Function<ChatInviteLink>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Invite link to get
        /// </summary>
        public string InviteLink { get; set; }

    }

    /// <summary>
    /// Returns list of chat administrators with number of their invite links. Requires owner privileges in the chat
    /// </summary>
    public partial class GetChatInviteLinkCounts : Function<ChatInviteLinkCounts>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Returns invite links for a chat created by specified administrator. Requires administrator privileges and can_invite_users right in the chat to get own links and owner privileges to get other links
    /// </summary>
    public partial class GetChatInviteLinks : Function<ChatInviteLinks>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// User identifier of a chat administrator. Must be an identifier of the current user for non-owner
        /// </summary>
        public long CreatorUserId { get; set; }

        /// <summary>
        /// Pass true if revoked links needs to be returned instead of active or expired
        /// </summary>
        public bool IsRevoked { get; set; }

        /// <summary>
        /// Creation date of an invite link starting after which to return invite links; use 0 to get results from the beginning
        /// </summary>
        public int OffsetDate { get; set; }

        /// <summary>
        /// Invite link starting after which to return invite links; use empty string to get results from the beginning
        /// </summary>
        public string OffsetInviteLink { get; set; }

        /// <summary>
        /// The maximum number of invite links to return; up to 100
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Returns chat members joined a chat by an invite link. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
    /// </summary>
    public partial class GetChatInviteLinkMembers : Function<ChatInviteLinkMembers>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Invite link for which to return chat members
        /// </summary>
        public string InviteLink { get; set; }

        /// <summary>
        /// A chat member from which to return next chat members; pass null to get results from the beginning
        /// </summary>
        public ChatInviteLinkMember OffsetMember { get; set; }

        /// <summary>
        /// The maximum number of chat members to return; up to 100
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Revokes invite link for a chat. Available for basic groups, supergroups, and channels. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links. -If a primary link is revoked, then additionally to the revoked link returns new primary link
    /// </summary>
    public partial class RevokeChatInviteLink : Function<ChatInviteLinks>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Invite link to be revoked
        /// </summary>
        public string InviteLink { get; set; }

    }

    /// <summary>
    /// Deletes revoked chat invite links. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
    /// </summary>
    public partial class DeleteRevokedChatInviteLink : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Invite link to revoke
        /// </summary>
        public string InviteLink { get; set; }

    }

    /// <summary>
    /// Deletes all revoked chat invite links created by a given chat administrator. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
    /// </summary>
    public partial class DeleteAllRevokedChatInviteLinks : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// User identifier of a chat administrator, which links will be deleted. Must be an identifier of the current user for non-owner
        /// </summary>
        public long CreatorUserId { get; set; }

    }

    /// <summary>
    /// Checks the validity of an invite link for a chat and returns information about the corresponding chat
    /// </summary>
    public partial class CheckChatInviteLink : Function<ChatInviteLinkInfo>
    {
        /// <summary>
        /// Invite link to be checked
        /// </summary>
        public string InviteLink { get; set; }

    }

    /// <summary>
    /// Uses an invite link to add the current user to the chat if possible
    /// </summary>
    public partial class JoinChatByInviteLink : Function<Chat>
    {
        /// <summary>
        /// Invite link to use
        /// </summary>
        public string InviteLink { get; set; }

    }

    /// <summary>
    /// Returns pending join requests in a chat
    /// </summary>
    public partial class GetChatJoinRequests : Function<ChatJoinRequests>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Invite link for which to return join requests. If empty, all join requests will be returned. Requires administrator privileges and can_invite_users right in the chat for own links and owner privileges for other links
        /// </summary>
        public string InviteLink { get; set; }

        /// <summary>
        /// A query to search for in the first names, last names and usernames of the users to return
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// A chat join request from which to return next requests; pass null to get results from the beginning
        /// </summary>
        public ChatJoinRequest OffsetRequest { get; set; }

        /// <summary>
        /// The maximum number of chat join requests to return
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Approves pending join request in a chat
    /// </summary>
    public partial class ApproveChatJoinRequest : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the user, which request will be approved
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// Declines pending join request in a chat
    /// </summary>
    public partial class DeclineChatJoinRequest : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the user, which request will be declined
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// Creates a new call
    /// </summary>
    public partial class CreateCall : Function<CallId>
    {
        /// <summary>
        /// Identifier of the user to be called
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// The call protocols supported by the application
        /// </summary>
        public CallProtocol Protocol { get; set; }

        /// <summary>
        /// True, if a video call needs to be created
        /// </summary>
        public bool IsVideo { get; set; }

    }

    /// <summary>
    /// Accepts an incoming call
    /// </summary>
    public partial class AcceptCall : Function<Ok>
    {
        /// <summary>
        /// Call identifier
        /// </summary>
        public int CallId { get; set; }

        /// <summary>
        /// The call protocols supported by the application
        /// </summary>
        public CallProtocol Protocol { get; set; }

    }

    /// <summary>
    /// Sends call signaling data
    /// </summary>
    public partial class SendCallSignalingData : Function<Ok>
    {
        /// <summary>
        /// Call identifier
        /// </summary>
        public int CallId { get; set; }

        /// <summary>
        /// The data
        /// </summary>
        public Memory<byte> Data { get; set; }

    }

    /// <summary>
    /// Discards a call
    /// </summary>
    public partial class DiscardCall : Function<Ok>
    {
        /// <summary>
        /// Call identifier
        /// </summary>
        public int CallId { get; set; }

        /// <summary>
        /// True, if the user was disconnected
        /// </summary>
        public bool IsDisconnected { get; set; }

        /// <summary>
        /// The call duration, in seconds
        /// </summary>
        public int Duration { get; set; }

        /// <summary>
        /// True, if the call was a video call
        /// </summary>
        public bool IsVideo { get; set; }

        /// <summary>
        /// Identifier of the connection used during the call
        /// </summary>
        public long ConnectionId { get; set; }

    }

    /// <summary>
    /// Sends a call rating
    /// </summary>
    public partial class SendCallRating : Function<Ok>
    {
        /// <summary>
        /// Call identifier
        /// </summary>
        public int CallId { get; set; }

        /// <summary>
        /// Call rating; 1-5
        /// </summary>
        public int Rating { get; set; }

        /// <summary>
        /// An optional user comment if the rating is less than 5
        /// </summary>
        public string Comment { get; set; }

        /// <summary>
        /// List of the exact types of problems with the call, specified by the user
        /// </summary>
        public CallProblem[] Problems { get; set; }

    }

    /// <summary>
    /// Sends debug information for a call
    /// </summary>
    public partial class SendCallDebugInformation : Function<Ok>
    {
        /// <summary>
        /// Call identifier
        /// </summary>
        public int CallId { get; set; }

        /// <summary>
        /// Debug information in application-specific format
        /// </summary>
        public string DebugInformation { get; set; }

    }

    /// <summary>
    /// Returns list of participant identifiers, which can be used to join video chats in a chat
    /// </summary>
    public partial class GetVideoChatAvailableParticipants : Function<MessageSenders>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Changes default participant identifier, which can be used to join video chats in a chat
    /// </summary>
    public partial class SetVideoChatDefaultParticipant : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Default group call participant identifier to join the video chats
        /// </summary>
        public MessageSender DefaultParticipantId { get; set; }

    }

    /// <summary>
    /// Creates a video chat (a group call bound to a chat). Available only for basic groups, supergroups and channels; requires can_manage_video_chats rights
    /// </summary>
    public partial class CreateVideoChat : Function<GroupCallId>
    {
        /// <summary>
        /// Chat identifier, in which the video chat will be created
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Group call title; if empty, chat title will be used
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Point in time (Unix timestamp) when the group call is supposed to be started by an administrator; 0 to start the video chat immediately. The date must be at least 10 seconds and at most 8 days in the future
        /// </summary>
        public int StartDate { get; set; }

    }

    /// <summary>
    /// Returns information about a group call
    /// </summary>
    public partial class GetGroupCall : Function<GroupCall>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

    }

    /// <summary>
    /// Starts a scheduled group call
    /// </summary>
    public partial class StartScheduledGroupCall : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

    }

    /// <summary>
    /// Toggles whether the current user will receive a notification when the group call will start; scheduled group calls only
    /// </summary>
    public partial class ToggleGroupCallEnabledStartNotification : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// New value of the enabled_start_notification setting
        /// </summary>
        public bool EnabledStartNotification { get; set; }

    }

    /// <summary>
    /// Joins an active group call. Returns join response payload for tgcalls
    /// </summary>
    public partial class JoinGroupCall : Function<Text>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Identifier of a group call participant, which will be used to join the call; pass null to join as self; video chats only
        /// </summary>
        public MessageSender ParticipantId { get; set; }

        /// <summary>
        /// Caller audio channel synchronization source identifier; received from tgcalls
        /// </summary>
        public int AudioSourceId { get; set; }

        /// <summary>
        /// Group call join payload; received from tgcalls
        /// </summary>
        public string Payload { get; set; }

        /// <summary>
        /// True, if the user's microphone is muted
        /// </summary>
        public bool IsMuted { get; set; }

        /// <summary>
        /// True, if the user's video is enabled
        /// </summary>
        public bool IsMyVideoEnabled { get; set; }

        /// <summary>
        /// If non-empty, invite hash to be used to join the group call without being muted by administrators
        /// </summary>
        public string InviteHash { get; set; }

    }

    /// <summary>
    /// Starts screen sharing in a joined group call. Returns join response payload for tgcalls
    /// </summary>
    public partial class StartGroupCallScreenSharing : Function<Text>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Screen sharing audio channel synchronization source identifier; received from tgcalls
        /// </summary>
        public int AudioSourceId { get; set; }

        /// <summary>
        /// Group call join payload; received from tgcalls
        /// </summary>
        public string Payload { get; set; }

    }

    /// <summary>
    /// Pauses or unpauses screen sharing in a joined group call
    /// </summary>
    public partial class ToggleGroupCallScreenSharingIsPaused : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// True if screen sharing is paused
        /// </summary>
        public bool IsPaused { get; set; }

    }

    /// <summary>
    /// Ends screen sharing in a joined group call
    /// </summary>
    public partial class EndGroupCallScreenSharing : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

    }

    /// <summary>
    /// Sets group call title. Requires groupCall.can_be_managed group call flag
    /// </summary>
    public partial class SetGroupCallTitle : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// New group call title; 1-64 characters
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// Toggles whether new participants of a group call can be unmuted only by administrators of the group call. Requires groupCall.can_toggle_mute_new_participants group call flag
    /// </summary>
    public partial class ToggleGroupCallMuteNewParticipants : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// New value of the mute_new_participants setting
        /// </summary>
        public bool MuteNewParticipants { get; set; }

    }

    /// <summary>
    /// Revokes invite link for a group call. Requires groupCall.can_be_managed group call flag
    /// </summary>
    public partial class RevokeGroupCallInviteLink : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

    }

    /// <summary>
    /// Invites users to an active group call. Sends a service message of type messageInviteToGroupCall for video chats
    /// </summary>
    public partial class InviteGroupCallParticipants : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// User identifiers. At most 10 users can be invited simultaneously
        /// </summary>
        public long[] UserIds { get; set; }

    }

    /// <summary>
    /// Returns invite link to a video chat in a public chat
    /// </summary>
    public partial class GetGroupCallInviteLink : Function<HttpUrl>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Pass true if the invite link needs to contain an invite hash, passing which to joinGroupCall would allow the invited user to unmute themselves. Requires groupCall.can_be_managed group call flag
        /// </summary>
        public bool CanSelfUnmute { get; set; }

    }

    /// <summary>
    /// Starts recording of an active group call. Requires groupCall.can_be_managed group call flag
    /// </summary>
    public partial class StartGroupCallRecording : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Group call recording title; 0-64 characters
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Pass true to record a video file instead of an audio file
        /// </summary>
        public bool RecordVideo { get; set; }

        /// <summary>
        /// Pass true to use portrait orientation for video instead of landscape one
        /// </summary>
        public bool UsePortraitOrientation { get; set; }

    }

    /// <summary>
    /// Ends recording of an active group call. Requires groupCall.can_be_managed group call flag
    /// </summary>
    public partial class EndGroupCallRecording : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

    }

    /// <summary>
    /// Toggles whether current user's video is paused
    /// </summary>
    public partial class ToggleGroupCallIsMyVideoPaused : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Pass true if the current user's video is paused
        /// </summary>
        public bool IsMyVideoPaused { get; set; }

    }

    /// <summary>
    /// Toggles whether current user's video is enabled
    /// </summary>
    public partial class ToggleGroupCallIsMyVideoEnabled : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Pass true if the current user's video is enabled
        /// </summary>
        public bool IsMyVideoEnabled { get; set; }

    }

    /// <summary>
    /// Informs TDLib that speaking state of a participant of an active group has changed
    /// </summary>
    public partial class SetGroupCallParticipantIsSpeaking : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Group call participant's synchronization audio source identifier, or 0 for the current user
        /// </summary>
        public int AudioSource { get; set; }

        /// <summary>
        /// True, if the user is speaking
        /// </summary>
        public bool IsSpeaking { get; set; }

    }

    /// <summary>
    /// Toggles whether a participant of an active group call is muted, unmuted, or allowed to unmute themselves
    /// </summary>
    public partial class ToggleGroupCallParticipantIsMuted : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Participant identifier
        /// </summary>
        public MessageSender ParticipantId { get; set; }

        /// <summary>
        /// Pass true if the user must be muted and false otherwise
        /// </summary>
        public bool IsMuted { get; set; }

    }

    /// <summary>
    /// Changes volume level of a participant of an active group call. If the current user can manage the group call, then the participant's volume level will be changed for all users with the default volume level
    /// </summary>
    public partial class SetGroupCallParticipantVolumeLevel : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Participant identifier
        /// </summary>
        public MessageSender ParticipantId { get; set; }

        /// <summary>
        /// New participant's volume level; 1-20000 in hundreds of percents
        /// </summary>
        public int VolumeLevel { get; set; }

    }

    /// <summary>
    /// Toggles whether a group call participant hand is rased
    /// </summary>
    public partial class ToggleGroupCallParticipantIsHandRaised : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Participant identifier
        /// </summary>
        public MessageSender ParticipantId { get; set; }

        /// <summary>
        /// Pass true if the user's hand needs to be raised. Only self hand can be raised. Requires groupCall.can_be_managed group call flag to lower other's hand
        /// </summary>
        public bool IsHandRaised { get; set; }

    }

    /// <summary>
    /// Loads more participants of a group call. The loaded participants will be received through updates. Use the field groupCall.loaded_all_participants to check whether all participants have already been loaded
    /// </summary>
    public partial class LoadGroupCallParticipants : Function<Ok>
    {
        /// <summary>
        /// Group call identifier. The group call must be previously received through getGroupCall and must be joined or being joined
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// The maximum number of participants to load; up to 100
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Leaves a group call
    /// </summary>
    public partial class LeaveGroupCall : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

    }

    /// <summary>
    /// Discards a group call. Requires groupCall.can_be_managed
    /// </summary>
    public partial class DiscardGroupCall : Function<Ok>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

    }

    /// <summary>
    /// Returns a file with a segment of a group call stream in a modified OGG format for audio or MPEG-4 format for video
    /// </summary>
    public partial class GetGroupCallStreamSegment : Function<FilePart>
    {
        /// <summary>
        /// Group call identifier
        /// </summary>
        public int GroupCallId { get; set; }

        /// <summary>
        /// Point in time when the stream segment begins; Unix timestamp in milliseconds
        /// </summary>
        public long TimeOffset { get; set; }

        /// <summary>
        /// Segment duration scale; 0-1. Segment's duration is 1000/(2**scale) milliseconds
        /// </summary>
        public int Scale { get; set; }

        /// <summary>
        /// Identifier of an audio/video channel to get as received from tgcalls
        /// </summary>
        public int ChannelId { get; set; }

        /// <summary>
        /// Video quality as received from tgcalls; pass null to get the worst available quality
        /// </summary>
        public GroupCallVideoQuality VideoQuality { get; set; }

    }

    /// <summary>
    /// Changes the block state of a message sender. Currently, only users and supergroup chats can be blocked
    /// </summary>
    public partial class ToggleMessageSenderIsBlocked : Function<Ok>
    {
        /// <summary>
        /// Message Sender
        /// </summary>
        public MessageSender Sender { get; set; }

        /// <summary>
        /// New value of is_blocked
        /// </summary>
        public bool IsBlocked { get; set; }

    }

    /// <summary>
    /// Blocks an original sender of a message in the Replies chat
    /// </summary>
    public partial class BlockMessageSenderFromReplies : Function<Ok>
    {
        /// <summary>
        /// The identifier of an incoming message in the Replies chat
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Pass true if the message must be deleted
        /// </summary>
        public bool DeleteMessage { get; set; }

        /// <summary>
        /// Pass true if all messages from the same sender must be deleted
        /// </summary>
        public bool DeleteAllMessages { get; set; }

        /// <summary>
        /// Pass true if the sender must be reported to the Telegram moderators
        /// </summary>
        public bool ReportSpam { get; set; }

    }

    /// <summary>
    /// Returns users and chats that were blocked by the current user
    /// </summary>
    public partial class GetBlockedMessageSenders : Function<MessageSenders>
    {
        /// <summary>
        /// Number of users and chats to skip in the result; must be non-negative
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// The maximum number of users and chats to return; up to 100
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Adds a user to the contact list or edits an existing contact by their user identifier
    /// </summary>
    public partial class AddContact : Function<Ok>
    {
        /// <summary>
        /// The contact to add or edit; phone number can be empty and needs to be specified only if known, vCard is ignored
        /// </summary>
        public Contact Contact { get; set; }

        /// <summary>
        /// True, if the new contact needs to be allowed to see current user's phone number. A corresponding rule to userPrivacySettingShowPhoneNumber will be added if needed. Use the field userFullInfo.need_phone_number_privacy_exception to check whether the current user needs to be asked to share their phone number
        /// </summary>
        public bool SharePhoneNumber { get; set; }

    }

    /// <summary>
    /// Adds new contacts or edits existing contacts by their phone numbers; contacts' user identifiers are ignored
    /// </summary>
    public partial class ImportContacts : Function<ImportedContacts>
    {
        /// <summary>
        /// The list of contacts to import or edit; contacts' vCard are ignored and are not imported
        /// </summary>
        public Contact[] Contacts { get; set; }

    }

    /// <summary>
    /// Returns all user contacts
    /// </summary>
    public partial class GetContacts : Function<Users>
    {
    }

    /// <summary>
    /// Searches for the specified query in the first names, last names and usernames of the known user contacts
    /// </summary>
    public partial class SearchContacts : Function<Users>
    {
        /// <summary>
        /// Query to search for; may be empty to return all contacts
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// The maximum number of users to be returned
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Removes users from the contact list
    /// </summary>
    public partial class RemoveContacts : Function<Ok>
    {
        /// <summary>
        /// Identifiers of users to be deleted
        /// </summary>
        public long[] UserIds { get; set; }

    }

    /// <summary>
    /// Returns the total number of imported contacts
    /// </summary>
    public partial class GetImportedContactCount : Function<Count>
    {
    }

    /// <summary>
    /// Changes imported contacts using the list of contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts. -Query result depends on the result of the previous query, so only one query is possible at the same time
    /// </summary>
    public partial class ChangeImportedContacts : Function<ImportedContacts>
    {
        /// <summary>
        /// The new list of contacts, contact's vCard are ignored and are not imported
        /// </summary>
        public Contact[] Contacts { get; set; }

    }

    /// <summary>
    /// Clears all imported contacts, contact list remains unchanged
    /// </summary>
    public partial class ClearImportedContacts : Function<Ok>
    {
    }

    /// <summary>
    /// Shares the phone number of the current user with a mutual contact. Supposed to be called when the user clicks on chatActionBarSharePhoneNumber
    /// </summary>
    public partial class SharePhoneNumber : Function<Ok>
    {
        /// <summary>
        /// Identifier of the user with whom to share the phone number. The user must be a mutual contact
        /// </summary>
        public long UserId { get; set; }

    }

    /// <summary>
    /// Returns the profile photos of a user. The result of this query may be outdated: some photos might have been deleted already
    /// </summary>
    public partial class GetUserProfilePhotos : Function<ChatPhotos>
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// The number of photos to skip; must be non-negative
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// The maximum number of photos to be returned; up to 100
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Returns stickers from the installed sticker sets that correspond to a given emoji. If the emoji is non-empty, favorite and recently used stickers may also be returned
    /// </summary>
    public partial class GetStickers : Function<Stickers>
    {
        /// <summary>
        /// String representation of emoji. If empty, returns all known installed stickers
        /// </summary>
        public string Emoji { get; set; }

        /// <summary>
        /// The maximum number of stickers to be returned
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Searches for stickers from public sticker sets that correspond to a given emoji
    /// </summary>
    public partial class SearchStickers : Function<Stickers>
    {
        /// <summary>
        /// String representation of emoji; must be non-empty
        /// </summary>
        public string Emoji { get; set; }

        /// <summary>
        /// The maximum number of stickers to be returned
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Returns a list of installed sticker sets
    /// </summary>
    public partial class GetInstalledStickerSets : Function<StickerSets>
    {
        /// <summary>
        /// Pass true to return mask sticker sets; pass false to return ordinary sticker sets
        /// </summary>
        public bool IsMasks { get; set; }

    }

    /// <summary>
    /// Returns a list of archived sticker sets
    /// </summary>
    public partial class GetArchivedStickerSets : Function<StickerSets>
    {
        /// <summary>
        /// Pass true to return mask stickers sets; pass false to return ordinary sticker sets
        /// </summary>
        public bool IsMasks { get; set; }

        /// <summary>
        /// Identifier of the sticker set from which to return the result
        /// </summary>
        public long OffsetStickerSetId { get; set; }

        /// <summary>
        /// The maximum number of sticker sets to return; up to 100
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Returns a list of trending sticker sets. For optimal performance, the number of returned sticker sets is chosen by TDLib
    /// </summary>
    public partial class GetTrendingStickerSets : Function<StickerSets>
    {
        /// <summary>
        /// The offset from which to return the sticker sets; must be non-negative
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// The maximum number of sticker sets to be returned; up to 100. For optimal performance, the number of returned sticker sets is chosen by TDLib and can be smaller than the specified limit, even if the end of the list has not been reached
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Returns a list of sticker sets attached to a file. Currently only photos and videos can have attached sticker sets
    /// </summary>
    public partial class GetAttachedStickerSets : Function<StickerSets>
    {
        /// <summary>
        /// File identifier
        /// </summary>
        public int FileId { get; set; }

    }

    /// <summary>
    /// Returns information about a sticker set by its identifier
    /// </summary>
    public partial class GetStickerSet : Function<StickerSet>
    {
        /// <summary>
        /// Identifier of the sticker set
        /// </summary>
        public long SetId { get; set; }

    }

    /// <summary>
    /// Searches for a sticker set by its name
    /// </summary>
    public partial class SearchStickerSet : Function<StickerSet>
    {
        /// <summary>
        /// Name of the sticker set
        /// </summary>
        public string Name { get; set; }

    }

    /// <summary>
    /// Searches for installed sticker sets by looking for specified query in their title and name
    /// </summary>
    public partial class SearchInstalledStickerSets : Function<StickerSets>
    {
        /// <summary>
        /// Pass true to return mask sticker sets; pass false to return ordinary sticker sets
        /// </summary>
        public bool IsMasks { get; set; }

        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// The maximum number of sticker sets to return
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results
    /// </summary>
    public partial class SearchStickerSets : Function<StickerSets>
    {
        /// <summary>
        /// Query to search for
        /// </summary>
        public string Query { get; set; }

    }

    /// <summary>
    /// Installs/uninstalls or activates/archives a sticker set
    /// </summary>
    public partial class ChangeStickerSet : Function<Ok>
    {
        /// <summary>
        /// Identifier of the sticker set
        /// </summary>
        public long SetId { get; set; }

        /// <summary>
        /// The new value of is_installed
        /// </summary>
        public bool IsInstalled { get; set; }

        /// <summary>
        /// The new value of is_archived. A sticker set can't be installed and archived simultaneously
        /// </summary>
        public bool IsArchived { get; set; }

    }

    /// <summary>
    /// Informs the server that some trending sticker sets have been viewed by the user
    /// </summary>
    public partial class ViewTrendingStickerSets : Function<Ok>
    {
        /// <summary>
        /// Identifiers of viewed trending sticker sets
        /// </summary>
        public long[] StickerSetIds { get; set; }

    }

    /// <summary>
    /// Changes the order of installed sticker sets
    /// </summary>
    public partial class ReorderInstalledStickerSets : Function<Ok>
    {
        /// <summary>
        /// Pass true to change the order of mask sticker sets; pass false to change the order of ordinary sticker sets
        /// </summary>
        public bool IsMasks { get; set; }

        /// <summary>
        /// Identifiers of installed sticker sets in the new correct order
        /// </summary>
        public long[] StickerSetIds { get; set; }

    }

    /// <summary>
    /// Returns a list of recently used stickers
    /// </summary>
    public partial class GetRecentStickers : Function<Stickers>
    {
        /// <summary>
        /// Pass true to return stickers and masks that were recently attached to photos or video files; pass false to return recently sent stickers
        /// </summary>
        public bool IsAttached { get; set; }

    }

    /// <summary>
    /// Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list
    /// </summary>
    public partial class AddRecentSticker : Function<Stickers>
    {
        /// <summary>
        /// Pass true to add the sticker to the list of stickers recently attached to photo or video files; pass false to add the sticker to the list of recently sent stickers
        /// </summary>
        public bool IsAttached { get; set; }

        /// <summary>
        /// Sticker file to add
        /// </summary>
        public InputFile Sticker { get; set; }

    }

    /// <summary>
    /// Removes a sticker from the list of recently used stickers
    /// </summary>
    public partial class RemoveRecentSticker : Function<Ok>
    {
        /// <summary>
        /// Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers
        /// </summary>
        public bool IsAttached { get; set; }

        /// <summary>
        /// Sticker file to delete
        /// </summary>
        public InputFile Sticker { get; set; }

    }

    /// <summary>
    /// Clears the list of recently used stickers
    /// </summary>
    public partial class ClearRecentStickers : Function<Ok>
    {
        /// <summary>
        /// Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers
        /// </summary>
        public bool IsAttached { get; set; }

    }

    /// <summary>
    /// Returns favorite stickers
    /// </summary>
    public partial class GetFavoriteStickers : Function<Stickers>
    {
    }

    /// <summary>
    /// Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list
    /// </summary>
    public partial class AddFavoriteSticker : Function<Ok>
    {
        /// <summary>
        /// Sticker file to add
        /// </summary>
        public InputFile Sticker { get; set; }

    }

    /// <summary>
    /// Removes a sticker from the list of favorite stickers
    /// </summary>
    public partial class RemoveFavoriteSticker : Function<Ok>
    {
        /// <summary>
        /// Sticker file to delete from the list
        /// </summary>
        public InputFile Sticker { get; set; }

    }

    /// <summary>
    /// Returns emoji corresponding to a sticker. The list is only for informational purposes, because a sticker is always sent with a fixed emoji from the corresponding Sticker object
    /// </summary>
    public partial class GetStickerEmojis : Function<Emojis>
    {
        /// <summary>
        /// Sticker file identifier
        /// </summary>
        public InputFile Sticker { get; set; }

    }

    /// <summary>
    /// Searches for emojis by keywords. Supported only if the file database is enabled
    /// </summary>
    public partial class SearchEmojis : Function<Emojis>
    {
        /// <summary>
        /// Text to search for
        /// </summary>
        public string Text { get; set; }

        /// <summary>
        /// True, if only emojis, which exactly match text needs to be returned
        /// </summary>
        public bool ExactMatch { get; set; }

        /// <summary>
        /// List of possible IETF language tags of the user's input language; may be empty if unknown
        /// </summary>
        public string[] InputLanguageCodes { get; set; }

    }

    /// <summary>
    /// Returns an animated emoji corresponding to a given emoji. Returns a 404 error if the emoji has no animated emoji
    /// </summary>
    public partial class GetAnimatedEmoji : Function<AnimatedEmoji>
    {
        /// <summary>
        /// The emoji
        /// </summary>
        public string Emoji { get; set; }

    }

    /// <summary>
    /// Returns an HTTP URL which can be used to automatically log in to the translation platform and suggest new emoji replacements. The URL will be valid for 30 seconds after generation
    /// </summary>
    public partial class GetEmojiSuggestionsUrl : Function<HttpUrl>
    {
        /// <summary>
        /// Language code for which the emoji replacements will be suggested
        /// </summary>
        public string LanguageCode { get; set; }

    }

    /// <summary>
    /// Returns saved animations
    /// </summary>
    public partial class GetSavedAnimations : Function<Animations>
    {
    }

    /// <summary>
    /// Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
    /// </summary>
    public partial class AddSavedAnimation : Function<Ok>
    {
        /// <summary>
        /// The animation file to be added. Only animations known to the server (i.e., successfully sent via a message) can be added to the list
        /// </summary>
        public InputFile Animation { get; set; }

    }

    /// <summary>
    /// Removes an animation from the list of saved animations
    /// </summary>
    public partial class RemoveSavedAnimation : Function<Ok>
    {
        /// <summary>
        /// Animation file to be removed
        /// </summary>
        public InputFile Animation { get; set; }

    }

    /// <summary>
    /// Returns up to 20 recently used inline bots in the order of their last usage
    /// </summary>
    public partial class GetRecentInlineBots : Function<Users>
    {
    }

    /// <summary>
    /// Searches for recently used hashtags by their prefix
    /// </summary>
    public partial class SearchHashtags : Function<Hashtags>
    {
        /// <summary>
        /// Hashtag prefix to search for
        /// </summary>
        public string Prefix { get; set; }

        /// <summary>
        /// The maximum number of hashtags to be returned
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Removes a hashtag from the list of recently used hashtags
    /// </summary>
    public partial class RemoveRecentHashtag : Function<Ok>
    {
        /// <summary>
        /// Hashtag to delete
        /// </summary>
        public string Hashtag { get; set; }

    }

    /// <summary>
    /// Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview
    /// </summary>
    public partial class GetWebPagePreview : Function<WebPage>
    {
        /// <summary>
        /// Message text with formatting
        /// </summary>
        public FormattedText Text { get; set; }

    }

    /// <summary>
    /// Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page
    /// </summary>
    public partial class GetWebPageInstantView : Function<WebPageInstantView>
    {
        /// <summary>
        /// The web page URL
        /// </summary>
        public string Url { get; set; }

        /// <summary>
        /// If true, the full instant view for the web page will be returned
        /// </summary>
        public bool ForceFull { get; set; }

    }

    /// <summary>
    /// Changes a profile photo for the current user
    /// </summary>
    public partial class SetProfilePhoto : Function<Ok>
    {
        /// <summary>
        /// Profile photo to set
        /// </summary>
        public InputChatPhoto Photo { get; set; }

    }

    /// <summary>
    /// Deletes a profile photo
    /// </summary>
    public partial class DeleteProfilePhoto : Function<Ok>
    {
        /// <summary>
        /// Identifier of the profile photo to delete
        /// </summary>
        public long ProfilePhotoId { get; set; }

    }

    /// <summary>
    /// Changes the first and last name of the current user
    /// </summary>
    public partial class SetName : Function<Ok>
    {
        /// <summary>
        /// The new value of the first name for the current user; 1-64 characters
        /// </summary>
        public string FirstName { get; set; }

        /// <summary>
        /// The new value of the optional last name for the current user; 0-64 characters
        /// </summary>
        public string LastName { get; set; }

    }

    /// <summary>
    /// Changes the bio of the current user
    /// </summary>
    public partial class SetBio : Function<Ok>
    {
        /// <summary>
        /// The new value of the user bio; 0-70 characters without line feeds
        /// </summary>
        public string Bio { get; set; }

    }

    /// <summary>
    /// Changes the username of the current user
    /// </summary>
    public partial class SetUsername : Function<Ok>
    {
        /// <summary>
        /// The new value of the username. Use an empty string to remove the username
        /// </summary>
        public string Username { get; set; }

    }

    /// <summary>
    /// Changes the location of the current user. Needs to be called if GetOption("is_location_visible") is true and location changes for more than 1 kilometer
    /// </summary>
    public partial class SetLocation : Function<Ok>
    {
        /// <summary>
        /// The new location of the user
        /// </summary>
        public Location Location { get; set; }

    }

    /// <summary>
    /// Changes the phone number of the user and sends an authentication code to the user's new phone number. On success, returns information about the sent code
    /// </summary>
    public partial class ChangePhoneNumber : Function<AuthenticationCodeInfo>
    {
        /// <summary>
        /// The new phone number of the user in international format
        /// </summary>
        public string PhoneNumber { get; set; }

        /// <summary>
        /// Settings for the authentication of the user's phone number; pass null to use default settings
        /// </summary>
        public PhoneNumberAuthenticationSettings Settings { get; set; }

    }

    /// <summary>
    /// Re-sends the authentication code sent to confirm a new phone number for the current user. Works only if the previously received authenticationCodeInfo next_code_type was not null and the server-specified timeout has passed
    /// </summary>
    public partial class ResendChangePhoneNumberCode : Function<AuthenticationCodeInfo>
    {
    }

    /// <summary>
    /// Checks the authentication code sent to confirm a new phone number of the user
    /// </summary>
    public partial class CheckChangePhoneNumberCode : Function<Ok>
    {
        /// <summary>
        /// Verification code received by SMS, phone call or flash call
        /// </summary>
        public string Code { get; set; }

    }

    /// <summary>
    /// Sets the list of commands supported by the bot for the given user scope and language; for bots only
    /// </summary>
    public partial class SetCommands : Function<Ok>
    {
        /// <summary>
        /// The scope to which the commands are relevant; pass null to change commands in the default bot command scope
        /// </summary>
        public BotCommandScope Scope { get; set; }

        /// <summary>
        /// A two-letter ISO 639-1 country code. If empty, the commands will be applied to all users from the given scope, for which language there are no dedicated commands
        /// </summary>
        public string LanguageCode { get; set; }

        /// <summary>
        /// List of the bot's commands
        /// </summary>
        public BotCommand[] Commands { get; set; }

    }

    /// <summary>
    /// Deletes commands supported by the bot for the given user scope and language; for bots only
    /// </summary>
    public partial class DeleteCommands : Function<Ok>
    {
        /// <summary>
        /// The scope to which the commands are relevant; pass null to delete commands in the default bot command scope
        /// </summary>
        public BotCommandScope Scope { get; set; }

        /// <summary>
        /// A two-letter ISO 639-1 country code or an empty string
        /// </summary>
        public string LanguageCode { get; set; }

    }

    /// <summary>
    /// Returns the list of commands supported by the bot for the given user scope and language; for bots only
    /// </summary>
    public partial class GetCommands : Function<BotCommands>
    {
        /// <summary>
        /// The scope to which the commands are relevant; pass null to get commands in the default bot command scope
        /// </summary>
        public BotCommandScope Scope { get; set; }

        /// <summary>
        /// A two-letter ISO 639-1 country code or an empty string
        /// </summary>
        public string LanguageCode { get; set; }

    }

    /// <summary>
    /// Returns all active sessions of the current user
    /// </summary>
    public partial class GetActiveSessions : Function<Sessions>
    {
    }

    /// <summary>
    /// Terminates a session of the current user
    /// </summary>
    public partial class TerminateSession : Function<Ok>
    {
        /// <summary>
        /// Session identifier
        /// </summary>
        public long SessionId { get; set; }

    }

    /// <summary>
    /// Terminates all other sessions of the current user
    /// </summary>
    public partial class TerminateAllOtherSessions : Function<Ok>
    {
    }

    /// <summary>
    /// Returns all website where the current user used Telegram to log in
    /// </summary>
    public partial class GetConnectedWebsites : Function<ConnectedWebsites>
    {
    }

    /// <summary>
    /// Disconnects website from the current user's Telegram account
    /// </summary>
    public partial class DisconnectWebsite : Function<Ok>
    {
        /// <summary>
        /// Website identifier
        /// </summary>
        public long WebsiteId { get; set; }

    }

    /// <summary>
    /// Disconnects all websites from the current user's Telegram account
    /// </summary>
    public partial class DisconnectAllWebsites : Function<Ok>
    {
    }

    /// <summary>
    /// Changes the username of a supergroup or channel, requires owner privileges in the supergroup or channel
    /// </summary>
    public partial class SetSupergroupUsername : Function<Ok>
    {
        /// <summary>
        /// Identifier of the supergroup or channel
        /// </summary>
        public long SupergroupId { get; set; }

        /// <summary>
        /// New value of the username. Use an empty string to remove the username
        /// </summary>
        public string Username { get; set; }

    }

    /// <summary>
    /// Changes the sticker set of a supergroup; requires can_change_info administrator right
    /// </summary>
    public partial class SetSupergroupStickerSet : Function<Ok>
    {
        /// <summary>
        /// Identifier of the supergroup
        /// </summary>
        public long SupergroupId { get; set; }

        /// <summary>
        /// New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set
        /// </summary>
        public long StickerSetId { get; set; }

    }

    /// <summary>
    /// Toggles sender signatures messages sent in a channel; requires can_change_info administrator right
    /// </summary>
    public partial class ToggleSupergroupSignMessages : Function<Ok>
    {
        /// <summary>
        /// Identifier of the channel
        /// </summary>
        public long SupergroupId { get; set; }

        /// <summary>
        /// New value of sign_messages
        /// </summary>
        public bool SignMessages { get; set; }

    }

    /// <summary>
    /// Toggles whether the message history of a supergroup is available to new members; requires can_change_info administrator right
    /// </summary>
    public partial class ToggleSupergroupIsAllHistoryAvailable : Function<Ok>
    {
        /// <summary>
        /// The identifier of the supergroup
        /// </summary>
        public long SupergroupId { get; set; }

        /// <summary>
        /// The new value of is_all_history_available
        /// </summary>
        public bool IsAllHistoryAvailable { get; set; }

    }

    /// <summary>
    /// Upgrades supergroup to a broadcast group; requires owner privileges in the supergroup
    /// </summary>
    public partial class ToggleSupergroupIsBroadcastGroup : Function<Ok>
    {
        /// <summary>
        /// Identifier of the supergroup
        /// </summary>
        public long SupergroupId { get; set; }

    }

    /// <summary>
    /// Reports some messages from a user in a supergroup as spam; requires administrator rights in the supergroup
    /// </summary>
    public partial class ReportSupergroupSpam : Function<Ok>
    {
        /// <summary>
        /// Supergroup identifier
        /// </summary>
        public long SupergroupId { get; set; }

        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Identifiers of messages sent in the supergroup by the user. This list must be non-empty
        /// </summary>
        public long[] MessageIds { get; set; }

    }

    /// <summary>
    /// Returns information about members or banned users in a supergroup or channel. Can be used only if supergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters
    /// </summary>
    public partial class GetSupergroupMembers : Function<ChatMembers>
    {
        /// <summary>
        /// Identifier of the supergroup or channel
        /// </summary>
        public long SupergroupId { get; set; }

        /// <summary>
        /// The type of users to return; pass null to use supergroupMembersFilterRecent
        /// </summary>
        public SupergroupMembersFilter Filter { get; set; }

        /// <summary>
        /// Number of users to skip
        /// </summary>
        public int Offset { get; set; }

        /// <summary>
        /// The maximum number of users be returned; up to 200
        /// </summary>
        public int Limit { get; set; }

    }

    /// <summary>
    /// Closes a secret chat, effectively transferring its state to secretChatStateClosed
    /// </summary>
    public partial class CloseSecretChat : Function<Ok>
    {
        /// <summary>
        /// Secret chat identifier
        /// </summary>
        public int SecretChatId { get; set; }

    }

    /// <summary>
    /// Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only for supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i. e., in order of decreasing event_id)
    /// </summary>
    public partial class GetChatEventLog : Function<ChatEvents>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Search query by which to filter events
        /// </summary>
        public string Query { get; set; }

        /// <summary>
        /// Identifier of an event from which to return results. Use 0 to get results from the latest events
        /// </summary>
        public long FromEventId { get; set; }

        /// <summary>
        /// The maximum number of events to return; up to 100
        /// </summary>
        public int Limit { get; set; }

        /// <summary>
        /// The types of events to return; pass null to get chat events of all types
        /// </summary>
        public ChatEventLogFilters Filters { get; set; }

        /// <summary>
        /// User identifiers by which to filter events. By default, events relating to all users will be returned
        /// </summary>
        public long[] UserIds { get; set; }

    }

    /// <summary>
    /// Returns an invoice payment form. This method must be called when the user presses inlineKeyboardButtonBuy
    /// </summary>
    public partial class GetPaymentForm : Function<PaymentForm>
    {
        /// <summary>
        /// Chat identifier of the Invoice message
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Preferred payment form theme; pass null to use the default theme
        /// </summary>
        public PaymentFormTheme Theme { get; set; }

    }

    /// <summary>
    /// Validates the order information provided by a user and returns the available shipping options for a flexible invoice
    /// </summary>
    public partial class ValidateOrderInfo : Function<ValidatedOrderInfo>
    {
        /// <summary>
        /// Chat identifier of the Invoice message
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// The order information, provided by the user; pass null if empty
        /// </summary>
        public OrderInfo OrderInfo { get; set; }

        /// <summary>
        /// True, if the order information can be saved
        /// </summary>
        public bool AllowSave { get; set; }

    }

    /// <summary>
    /// Sends a filled-out payment form to the bot for final verification
    /// </summary>
    public partial class SendPaymentForm : Function<PaymentResult>
    {
        /// <summary>
        /// Chat identifier of the Invoice message
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Payment form identifier returned by getPaymentForm
        /// </summary>
        public long PaymentFormId { get; set; }

        /// <summary>
        /// Identifier returned by validateOrderInfo, or an empty string
        /// </summary>
        public string OrderInfoId { get; set; }

        /// <summary>
        /// Identifier of a chosen shipping option, if applicable
        /// </summary>
        public string ShippingOptionId { get; set; }

        /// <summary>
        /// The credentials chosen by user for payment
        /// </summary>
        public InputCredentials Credentials { get; set; }

        /// <summary>
        /// Chosen by the user amount of tip in the smallest units of the currency
        /// </summary>
        public long TipAmount { get; set; }

    }

    /// <summary>
    /// Returns information about a successful payment
    /// </summary>
    public partial class GetPaymentReceipt : Function<PaymentReceipt>
    {
        /// <summary>
        /// Chat identifier of the PaymentSuccessful message
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

    }

    /// <summary>
    /// Returns saved order info, if any
    /// </summary>
    public partial class GetSavedOrderInfo : Function<OrderInfo>
    {
    }

    /// <summary>
    /// Deletes saved order info
    /// </summary>
    public partial class DeleteSavedOrderInfo : Function<Ok>
    {
    }

    /// <summary>
    /// Deletes saved credentials for all payment provider bots
    /// </summary>
    public partial class DeleteSavedCredentials : Function<Ok>
    {
    }

    /// <summary>
    /// Returns a user that can be contacted to get support
    /// </summary>
    public partial class GetSupportUser : Function<User>
    {
    }

    /// <summary>
    /// Returns backgrounds installed by the user
    /// </summary>
    public partial class GetBackgrounds : Function<Backgrounds>
    {
        /// <summary>
        /// True, if the backgrounds must be ordered for dark theme
        /// </summary>
        public bool ForDarkTheme { get; set; }

    }

    /// <summary>
    /// Constructs a persistent HTTP URL for a background
    /// </summary>
    public partial class GetBackgroundUrl : Function<HttpUrl>
    {
        /// <summary>
        /// Background name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Background type
        /// </summary>
        public BackgroundType Type { get; set; }

    }

    /// <summary>
    /// Searches for a background by its name
    /// </summary>
    public partial class SearchBackground : Function<Background>
    {
        /// <summary>
        /// The name of the background
        /// </summary>
        public string Name { get; set; }

    }

    /// <summary>
    /// Changes the background selected by the user; adds background to the list of installed backgrounds
    /// </summary>
    public partial class SetBackground : Function<Background>
    {
        /// <summary>
        /// The input background to use; pass null to create a new filled backgrounds or to remove the current background
        /// </summary>
        public InputBackground Background { get; set; }

        /// <summary>
        /// Background type; pass null to use the default type of the remote background or to remove the current background
        /// </summary>
        public BackgroundType Type { get; set; }

        /// <summary>
        /// True, if the background is chosen for dark theme
        /// </summary>
        public bool ForDarkTheme { get; set; }

    }

    /// <summary>
    /// Removes background from the list of installed backgrounds
    /// </summary>
    public partial class RemoveBackground : Function<Ok>
    {
        /// <summary>
        /// The background identifier
        /// </summary>
        public long BackgroundId { get; set; }

    }

    /// <summary>
    /// Resets list of installed backgrounds to its default value
    /// </summary>
    public partial class ResetBackgrounds : Function<Ok>
    {
    }

    /// <summary>
    /// Returns information about the current localization target. This is an offline request if only_local is true. Can be called before authorization
    /// </summary>
    public partial class GetLocalizationTargetInfo : Function<LocalizationTargetInfo>
    {
        /// <summary>
        /// If true, returns only locally available information without sending network requests
        /// </summary>
        public bool OnlyLocal { get; set; }

    }

    /// <summary>
    /// Returns information about a language pack. Returned language pack identifier may be different from a provided one. Can be called before authorization
    /// </summary>
    public partial class GetLanguagePackInfo : Function<LanguagePackInfo>
    {
        /// <summary>
        /// Language pack identifier
        /// </summary>
        public string LanguagePackId { get; set; }

    }

    /// <summary>
    /// Returns strings from a language pack in the current localization target by their keys. Can be called before authorization
    /// </summary>
    public partial class GetLanguagePackStrings : Function<LanguagePackStrings>
    {
        /// <summary>
        /// Language pack identifier of the strings to be returned
        /// </summary>
        public string LanguagePackId { get; set; }

        /// <summary>
        /// Language pack keys of the strings to be returned; leave empty to request all available strings
        /// </summary>
        public string[] Keys { get; set; }

    }

    /// <summary>
    /// Fetches the latest versions of all strings from a language pack in the current localization target from the server. This method doesn't need to be called explicitly for the current used/base language packs. Can be called before authorization
    /// </summary>
    public partial class SynchronizeLanguagePack : Function<Ok>
    {
        /// <summary>
        /// Language pack identifier
        /// </summary>
        public string LanguagePackId { get; set; }

    }

    /// <summary>
    /// Adds a custom server language pack to the list of installed language packs in current localization target. Can be called before authorization
    /// </summary>
    public partial class AddCustomServerLanguagePack : Function<Ok>
    {
        /// <summary>
        /// Identifier of a language pack to be added; may be different from a name that is used in an "https://t.me/setlanguage/" link
        /// </summary>
        public string LanguagePackId { get; set; }

    }

    /// <summary>
    /// Adds or changes a custom local language pack to the current localization target
    /// </summary>
    public partial class SetCustomLanguagePack : Function<Ok>
    {
        /// <summary>
        /// Information about the language pack. Language pack ID must start with 'X', consist only of English letters, digits and hyphens, and must not exceed 64 characters. Can be called before authorization
        /// </summary>
        public LanguagePackInfo Info { get; set; }

        /// <summary>
        /// Strings of the new language pack
        /// </summary>
        public LanguagePackString[] Strings { get; set; }

    }

    /// <summary>
    /// Edits information about a custom local language pack in the current localization target. Can be called before authorization
    /// </summary>
    public partial class EditCustomLanguagePackInfo : Function<Ok>
    {
        /// <summary>
        /// New information about the custom local language pack
        /// </summary>
        public LanguagePackInfo Info { get; set; }

    }

    /// <summary>
    /// Adds, edits or deletes a string in a custom local language pack. Can be called before authorization
    /// </summary>
    public partial class SetCustomLanguagePackString : Function<Ok>
    {
        /// <summary>
        /// Identifier of a previously added custom local language pack in the current localization target
        /// </summary>
        public string LanguagePackId { get; set; }

        /// <summary>
        /// New language pack string
        /// </summary>
        public LanguagePackString NewString { get; set; }

    }

    /// <summary>
    /// Deletes all information about a language pack in the current localization target. The language pack which is currently in use (including base language pack) or is being synchronized can't be deleted. Can be called before authorization
    /// </summary>
    public partial class DeleteLanguagePack : Function<Ok>
    {
        /// <summary>
        /// Identifier of the language pack to delete
        /// </summary>
        public string LanguagePackId { get; set; }

    }

    /// <summary>
    /// Registers the currently used device for receiving push notifications. Returns a globally unique identifier of the push notification subscription
    /// </summary>
    public partial class RegisterDevice : Function<PushReceiverId>
    {
        /// <summary>
        /// Device token
        /// </summary>
        public DeviceToken DeviceToken { get; set; }

        /// <summary>
        /// List of user identifiers of other users currently using the application
        /// </summary>
        public long[] OtherUserIds { get; set; }

    }

    /// <summary>
    /// Handles a push notification. Returns error with code 406 if the push notification is not supported and connection to the server is required to fetch new data. Can be called before authorization
    /// </summary>
    public partial class ProcessPushNotification : Function<Ok>
    {
        /// <summary>
        /// JSON-encoded push notification payload with all fields sent by the server, and "google.sent_time" and "google.notification.sound" fields added
        /// </summary>
        public string Payload { get; set; }

    }

    /// <summary>
    /// Returns a globally unique push notification subscription identifier for identification of an account, which has received a push notification. Can be called synchronously
    /// </summary>
    public partial class GetPushReceiverId : Function<PushReceiverId>
    {
        /// <summary>
        /// JSON-encoded push notification payload
        /// </summary>
        public string Payload { get; set; }

    }

    /// <summary>
    /// Returns t.me URLs recently visited by a newly registered user
    /// </summary>
    public partial class GetRecentlyVisitedTMeUrls : Function<TMeUrls>
    {
        /// <summary>
        /// Google Play referrer to identify the user
        /// </summary>
        public string Referrer { get; set; }

    }

    /// <summary>
    /// Changes user privacy settings
    /// </summary>
    public partial class SetUserPrivacySettingRules : Function<Ok>
    {
        /// <summary>
        /// The privacy setting
        /// </summary>
        public UserPrivacySetting Setting { get; set; }

        /// <summary>
        /// The new privacy rules
        /// </summary>
        public UserPrivacySettingRules Rules { get; set; }

    }

    /// <summary>
    /// Returns the current privacy settings
    /// </summary>
    public partial class GetUserPrivacySettingRules : Function<UserPrivacySettingRules>
    {
        /// <summary>
        /// The privacy setting
        /// </summary>
        public UserPrivacySetting Setting { get; set; }

    }

    /// <summary>
    /// Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization
    /// </summary>
    public partial class GetOption : Function<OptionValue>
    {
        /// <summary>
        /// The name of the option
        /// </summary>
        public string Name { get; set; }

    }

    /// <summary>
    /// Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
    /// </summary>
    public partial class SetOption : Function<Ok>
    {
        /// <summary>
        /// The name of the option
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// The new value of the option; pass null to reset option value to a default value
        /// </summary>
        public OptionValue Value { get; set; }

    }

    /// <summary>
    /// Changes the period of inactivity after which the account of the current user will automatically be deleted
    /// </summary>
    public partial class SetAccountTtl : Function<Ok>
    {
        /// <summary>
        /// New account TTL
        /// </summary>
        public AccountTtl Ttl { get; set; }

    }

    /// <summary>
    /// Returns the period of inactivity after which the account of the current user will automatically be deleted
    /// </summary>
    public partial class GetAccountTtl : Function<AccountTtl>
    {
    }

    /// <summary>
    /// Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account. Can be called before authorization when the current authorization state is authorizationStateWaitPassword
    /// </summary>
    public partial class DeleteAccount : Function<Ok>
    {
        /// <summary>
        /// The reason why the account was deleted; optional
        /// </summary>
        public string Reason { get; set; }

    }

    /// <summary>
    /// Removes a chat action bar without any other action
    /// </summary>
    public partial class RemoveChatActionBar : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Reports a chat to the Telegram moderators. A chat can be reported only from the chat action bar, or if this is a private chat with a bot, a private chat with a user sharing their location, a supergroup, or a channel, since other chats can't be checked by moderators
    /// </summary>
    public partial class ReportChat : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifiers of reported messages, if any
        /// </summary>
        public long[] MessageIds { get; set; }

        /// <summary>
        /// The reason for reporting the chat
        /// </summary>
        public ChatReportReason Reason { get; set; }

        /// <summary>
        /// Additional report details; 0-1024 characters
        /// </summary>
        public string Text { get; set; }

    }

    /// <summary>
    /// Reports a chat photo to the Telegram moderators. A chat photo can be reported only if this is a private chat with a bot, a private chat with a user sharing their location, a supergroup, or a channel, since other chats can't be checked by moderators
    /// </summary>
    public partial class ReportChatPhoto : Function<Ok>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Identifier of the photo to report. Only full photos from chatPhoto can be reported
        /// </summary>
        public int FileId { get; set; }

        /// <summary>
        /// The reason for reporting the chat photo
        /// </summary>
        public ChatReportReason Reason { get; set; }

        /// <summary>
        /// Additional report details; 0-1024 characters
        /// </summary>
        public string Text { get; set; }

    }

    /// <summary>
    /// Returns detailed statistics about a chat. Currently this method can be used only for supergroups and channels. Can be used only if supergroupFullInfo.can_get_statistics == true
    /// </summary>
    public partial class GetChatStatistics : Function<ChatStatistics>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Pass true if a dark theme is used by the application
        /// </summary>
        public bool IsDark { get; set; }

    }

    /// <summary>
    /// Returns detailed statistics about a message. Can be used only if message.can_get_statistics == true
    /// </summary>
    public partial class GetMessageStatistics : Function<MessageStatistics>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// Message identifier
        /// </summary>
        public long MessageId { get; set; }

        /// <summary>
        /// Pass true if a dark theme is used by the application
        /// </summary>
        public bool IsDark { get; set; }

    }

    /// <summary>
    /// Loads an asynchronous or a zoomed in statistical graph
    /// </summary>
    public partial class GetStatisticalGraph : Function<StatisticalGraph>
    {
        /// <summary>
        /// Chat identifier
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The token for graph loading
        /// </summary>
        public string Token { get; set; }

        /// <summary>
        /// X-value for zoomed in graph or 0 otherwise
        /// </summary>
        public long X { get; set; }

    }

    /// <summary>
    /// Returns storage usage statistics. Can be called before authorization
    /// </summary>
    public partial class GetStorageStatistics : Function<StorageStatistics>
    {
        /// <summary>
        /// The maximum number of chats with the largest storage usage for which separate statistics need to be returned. All other chats will be grouped in entries with chat_id == 0. If the chat info database is not used, the chat_limit is ignored and is always set to 0
        /// </summary>
        public int ChatLimit { get; set; }

    }

    /// <summary>
    /// Quickly returns approximate storage usage statistics. Can be called before authorization
    /// </summary>
    public partial class GetStorageStatisticsFast : Function<StorageStatisticsFast>
    {
    }

    /// <summary>
    /// Returns database statistics
    /// </summary>
    public partial class GetDatabaseStatistics : Function<DatabaseStatistics>
    {
    }

    /// <summary>
    /// Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted
    /// </summary>
    public partial class OptimizeStorage : Function<StorageStatistics>
    {
        /// <summary>
        /// Limit on the total size of files after deletion, in bytes. Pass -1 to use the default limit
        /// </summary>
        public long Size { get; set; }

        /// <summary>
        /// Limit on the time that has passed since the last time a file was accessed (or creation time for some filesystems). Pass -1 to use the default limit
        /// </summary>
        public int Ttl { get; set; }

        /// <summary>
        /// Limit on the total count of files after deletion. Pass -1 to use the default limit
        /// </summary>
        public int Count { get; set; }

        /// <summary>
        /// The amount of time after the creation of a file during which it can't be deleted, in seconds. Pass -1 to use the default value
        /// </summary>
        public int ImmunityDelay { get; set; }

        /// <summary>
        /// If non-empty, only files with the given types are considered. By default, all types except thumbnails, profile photos, stickers and wallpapers are deleted
        /// </summary>
        public FileType[] FileTypes { get; set; }

        /// <summary>
        /// If non-empty, only files from the given chats are considered. Use 0 as chat identifier to delete files not belonging to any chat (e.g., profile photos)
        /// </summary>
        public long[] ChatIds { get; set; }

        /// <summary>
        /// If non-empty, files from the given chats are excluded. Use 0 as chat identifier to exclude all files not belonging to any chat (e.g., profile photos)
        /// </summary>
        public long[] ExcludeChatIds { get; set; }

        /// <summary>
        /// Pass true if statistics about the files that were deleted must be returned instead of the whole storage usage statistics. Affects only returned statistics
        /// </summary>
        public bool ReturnDeletedFileStatistics { get; set; }

        /// <summary>
        /// Same as in getStorageStatistics. Affects only returned statistics
        /// </summary>
        public int ChatLimit { get; set; }

    }

    /// <summary>
    /// Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks, so it must be called whenever the network is changed, even if the network type remains the same. -Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics
    /// </summary>
    public partial class SetNetworkType : Function<Ok>
    {
        /// <summary>
        /// The new network type; pass null to set network type to networkTypeOther
        /// </summary>
        public NetworkType Type { get; set; }

    }

    /// <summary>
    /// Returns network data usage statistics. Can be called before authorization
    /// </summary>
    public partial class GetNetworkStatistics : Function<NetworkStatistics>
    {
        /// <summary>
        /// If true, returns only data for the current library launch
        /// </summary>
        public bool OnlyCurrent { get; set; }

    }

    /// <summary>
    /// Adds the specified data to data usage statistics. Can be called before authorization
    /// </summary>
    public partial class AddNetworkStatistics : Function<Ok>
    {
        /// <summary>
        /// The network statistics entry with the data to be added to statistics
        /// </summary>
        public NetworkStatisticsEntry Entry { get; set; }

    }

    /// <summary>
    /// Resets all network data usage statistics to zero. Can be called before authorization
    /// </summary>
    public partial class ResetNetworkStatistics : Function<Ok>
    {
    }

    /// <summary>
    /// Returns auto-download settings presets for the current user
    /// </summary>
    public partial class GetAutoDownloadSettingsPresets : Function<AutoDownloadSettingsPresets>
    {
    }

    /// <summary>
    /// Sets auto-download settings
    /// </summary>
    public partial class SetAutoDownloadSettings : Function<Ok>
    {
        /// <summary>
        /// New user auto-download settings
        /// </summary>
        public AutoDownloadSettings Settings { get; set; }

        /// <summary>
        /// Type of the network for which the new settings are relevant
        /// </summary>
        public NetworkType Type { get; set; }

    }

    /// <summary>
    /// Returns information about a bank card
    /// </summary>
    public partial class GetBankCardInfo : Function<BankCardInfo>
    {
        /// <summary>
        /// The bank card number
        /// </summary>
        public string BankCardNumber { get; set; }

    }

    /// <summary>
    /// Returns one of the available Telegram Passport elements
    /// </summary>
    public partial class GetPassportElement : Function<PassportElement>
    {
        /// <summary>
        /// Telegram Passport element type
        /// </summary>
        public PassportElementType Type { get; set; }

        /// <summary>
        /// Password of the current user
        /// </summary>
        public string Password { get; set; }

    }

    /// <summary>
    /// Returns all available Telegram Passport elements
    /// </summary>
    public partial class GetAllPassportElements : Function<PassportElements>
    {
        /// <summary>
        /// Password of the current user
        /// </summary>
        public string Password { get; set; }

    }

    /// <summary>
    /// Adds an element to the user's Telegram Passport. May return an error with a message "PHONE_VERIFICATION_NEEDED" or "EMAIL_VERIFICATION_NEEDED" if the chosen phone number or the chosen email address must be verified first
    /// </summary>
    public partial class SetPassportElement : Function<PassportElement>
    {
        /// <summary>
        /// Input Telegram Passport element
        /// </summary>
        public InputPassportElement Element { get; set; }

        /// <summary>
        /// Password of the current user
        /// </summary>
        public string Password { get; set; }

    }

    /// <summary>
    /// Deletes a Telegram Passport element
    /// </summary>
    public partial class DeletePassportElement : Function<Ok>
    {
        /// <summary>
        /// Element type
        /// </summary>
        public PassportElementType Type { get; set; }

    }

    /// <summary>
    /// Informs the user that some of the elements in their Telegram Passport contain errors; for bots only. The user will not be able to resend the elements, until the errors are fixed
    /// </summary>
    public partial class SetPassportElementErrors : Function<Ok>
    {
        /// <summary>
        /// User identifier
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// The errors
        /// </summary>
        public InputPassportElementError[] Errors { get; set; }

    }

    /// <summary>
    /// Returns an IETF language tag of the language preferred in the country, which must be used to fill native fields in Telegram Passport personal details. Returns a 404 error if unknown
    /// </summary>
    public partial class GetPreferredCountryLanguage : Function<Text>
    {
        /// <summary>
        /// A two-letter ISO 3166-1 alpha-2 country code
        /// </summary>
        public string CountryCode { get; set; }

    }

    /// <summary>
    /// Sends a code to verify a phone number to be added to a user's Telegram Passport
    /// </summary>
    public partial class SendPhoneNumberVerificationCode : Function<AuthenticationCodeInfo>
    {
        /// <summary>
        /// The phone number of the user, in international format
        /// </summary>
        public string PhoneNumber { get; set; }

        /// <summary>
        /// Settings for the authentication of the user's phone number; pass null to use default settings
        /// </summary>
        public PhoneNumberAuthenticationSettings Settings { get; set; }

    }

    /// <summary>
    /// Re-sends the code to verify a phone number to be added to a user's Telegram Passport
    /// </summary>
    public partial class ResendPhoneNumberVerificationCode : Function<AuthenticationCodeInfo>
    {
    }

    /// <summary>
    /// Checks the phone number verification code for Telegram Passport
    /// </summary>
    public partial class CheckPhoneNumberVerificationCode : Function<Ok>
    {
        /// <summary>
        /// Verification code
        /// </summary>
        public string Code { get; set; }

    }

    /// <summary>
    /// Sends a code to verify an email address to be added to a user's Telegram Passport
    /// </summary>
    public partial class SendEmailAddressVerificationCode : Function<EmailAddressAuthenticationCodeInfo>
    {
        /// <summary>
        /// Email address
        /// </summary>
        public string EmailAddress { get; set; }

    }

    /// <summary>
    /// Re-sends the code to verify an email address to be added to a user's Telegram Passport
    /// </summary>
    public partial class ResendEmailAddressVerificationCode : Function<EmailAddressAuthenticationCodeInfo>
    {
    }

    /// <summary>
    /// Checks the email address verification code for Telegram Passport
    /// </summary>
    public partial class CheckEmailAddressVerificationCode : Function<Ok>
    {
        /// <summary>
        /// Verification code
        /// </summary>
        public string Code { get; set; }

    }

    /// <summary>
    /// Returns a Telegram Passport authorization form for sharing data with a service
    /// </summary>
    public partial class GetPassportAuthorizationForm : Function<PassportAuthorizationForm>
    {
        /// <summary>
        /// User identifier of the service's bot
        /// </summary>
        public long BotUserId { get; set; }

        /// <summary>
        /// Telegram Passport element types requested by the service
        /// </summary>
        public string Scope { get; set; }

        /// <summary>
        /// Service's public key
        /// </summary>
        public string PublicKey { get; set; }

        /// <summary>
        /// Unique request identifier provided by the service
        /// </summary>
        public string Nonce { get; set; }

    }

    /// <summary>
    /// Returns already available Telegram Passport elements suitable for completing a Telegram Passport authorization form. Result can be received only once for each authorization form
    /// </summary>
    public partial class GetPassportAuthorizationFormAvailableElements : Function<PassportElementsWithErrors>
    {
        /// <summary>
        /// Authorization form identifier
        /// </summary>
        public int AutorizationFormId { get; set; }

        /// <summary>
        /// Password of the current user
        /// </summary>
        public string Password { get; set; }

    }

    /// <summary>
    /// Sends a Telegram Passport authorization form, effectively sharing data with the service. This method must be called after getPassportAuthorizationFormAvailableElements if some previously available elements are going to be reused
    /// </summary>
    public partial class SendPassportAuthorizationForm : Function<Ok>
    {
        /// <summary>
        /// Authorization form identifier
        /// </summary>
        public int AutorizationFormId { get; set; }

        /// <summary>
        /// Types of Telegram Passport elements chosen by user to complete the authorization form
        /// </summary>
        public PassportElementType[] Types { get; set; }

    }

    /// <summary>
    /// Sends phone number confirmation code to handle links of the type internalLinkTypePhoneNumberConfirmation
    /// </summary>
    public partial class SendPhoneNumberConfirmationCode : Function<AuthenticationCodeInfo>
    {
        /// <summary>
        /// Hash value from the link
        /// </summary>
        public string Hash { get; set; }

        /// <summary>
        /// Phone number value from the link
        /// </summary>
        public string PhoneNumber { get; set; }

        /// <summary>
        /// Settings for the authentication of the user's phone number; pass null to use default settings
        /// </summary>
        public PhoneNumberAuthenticationSettings Settings { get; set; }

    }

    /// <summary>
    /// Resends phone number confirmation code
    /// </summary>
    public partial class ResendPhoneNumberConfirmationCode : Function<AuthenticationCodeInfo>
    {
    }

    /// <summary>
    /// Checks phone number confirmation code
    /// </summary>
    public partial class CheckPhoneNumberConfirmationCode : Function<Ok>
    {
        /// <summary>
        /// The phone number confirmation code
        /// </summary>
        public string Code { get; set; }

    }

    /// <summary>
    /// Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
    /// </summary>
    public partial class SetBotUpdatesStatus : Function<Ok>
    {
        /// <summary>
        /// The number of pending updates
        /// </summary>
        public int PendingUpdateCount { get; set; }

        /// <summary>
        /// The last error message
        /// </summary>
        public string ErrorMessage { get; set; }

    }

    /// <summary>
    /// Uploads a PNG image with a sticker; returns the uploaded file
    /// </summary>
    public partial class UploadStickerFile : Function<File>
    {
        /// <summary>
        /// Sticker file owner; ignored for regular users
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Sticker file to upload
        /// </summary>
        public InputSticker Sticker { get; set; }

    }

    /// <summary>
    /// Returns a suggested name for a new sticker set with a given title
    /// </summary>
    public partial class GetSuggestedStickerSetName : Function<Text>
    {
        /// <summary>
        /// Sticker set title; 1-64 characters
        /// </summary>
        public string Title { get; set; }

    }

    /// <summary>
    /// Checks whether a name can be used for a new sticker set
    /// </summary>
    public partial class CheckStickerSetName : Function<CheckStickerSetNameResult>
    {
        /// <summary>
        /// Name to be checked
        /// </summary>
        public string Name { get; set; }

    }

    /// <summary>
    /// Creates a new sticker set. Returns the newly created sticker set
    /// </summary>
    public partial class CreateNewStickerSet : Function<StickerSet>
    {
        /// <summary>
        /// Sticker set owner; ignored for regular users
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Sticker set title; 1-64 characters
        /// </summary>
        public string Title { get; set; }

        /// <summary>
        /// Sticker set name. Can contain only English letters, digits and underscores. Must end with *"_by_&lt;bot username&gt;"* (*&lt;bot_username&gt;* is case insensitive) for bots; 1-64 characters
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// True, if stickers are masks. Animated stickers can't be masks
        /// </summary>
        public bool IsMasks { get; set; }

        /// <summary>
        /// List of stickers to be added to the set; must be non-empty. All stickers must be of the same type. For animated stickers, uploadStickerFile must be used before the sticker is shown
        /// </summary>
        public InputSticker[] Stickers { get; set; }

        /// <summary>
        /// Source of the sticker set; may be empty if unknown
        /// </summary>
        public string Source { get; set; }

    }

    /// <summary>
    /// Adds a new sticker to a set; for bots only. Returns the sticker set
    /// </summary>
    public partial class AddStickerToSet : Function<StickerSet>
    {
        /// <summary>
        /// Sticker set owner
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Sticker set name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Sticker to add to the set
        /// </summary>
        public InputSticker Sticker { get; set; }

    }

    /// <summary>
    /// Sets a sticker set thumbnail; for bots only. Returns the sticker set
    /// </summary>
    public partial class SetStickerSetThumbnail : Function<StickerSet>
    {
        /// <summary>
        /// Sticker set owner
        /// </summary>
        public long UserId { get; set; }

        /// <summary>
        /// Sticker set name
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Thumbnail to set in PNG or TGS format; pass null to remove the sticker set thumbnail. Animated thumbnail must be set for animated sticker sets and only for them
        /// </summary>
        public InputFile Thumbnail { get; set; }

    }

    /// <summary>
    /// Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
    /// </summary>
    public partial class SetStickerPositionInSet : Function<Ok>
    {
        /// <summary>
        /// Sticker
        /// </summary>
        public InputFile Sticker { get; set; }

        /// <summary>
        /// New position of the sticker in the set, zero-based
        /// </summary>
        public int Position { get; set; }

    }

    /// <summary>
    /// Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
    /// </summary>
    public partial class RemoveStickerFromSet : Function<Ok>
    {
        /// <summary>
        /// Sticker
        /// </summary>
        public InputFile Sticker { get; set; }

    }

    /// <summary>
    /// Returns information about a file with a map thumbnail in PNG format. Only map thumbnail files with size less than 1MB can be downloaded
    /// </summary>
    public partial class GetMapThumbnailFile : Function<File>
    {
        /// <summary>
        /// Location of the map center
        /// </summary>
        public Location Location { get; set; }

        /// <summary>
        /// Map zoom level; 13-20
        /// </summary>
        public int Zoom { get; set; }

        /// <summary>
        /// Map width in pixels before applying scale; 16-1024
        /// </summary>
        public int Width { get; set; }

        /// <summary>
        /// Map height in pixels before applying scale; 16-1024
        /// </summary>
        public int Height { get; set; }

        /// <summary>
        /// Map scale; 1-3
        /// </summary>
        public int Scale { get; set; }

        /// <summary>
        /// Identifier of a chat, in which the thumbnail will be shown. Use 0 if unknown
        /// </summary>
        public long ChatId { get; set; }

    }

    /// <summary>
    /// Accepts Telegram terms of services
    /// </summary>
    public partial class AcceptTermsOfService : Function<Ok>
    {
        /// <summary>
        /// Terms of service identifier
        /// </summary>
        public string TermsOfServiceId { get; set; }

    }

    /// <summary>
    /// Sends a custom request; for bots only
    /// </summary>
    public partial class SendCustomRequest : Function<CustomRequestResult>
    {
        /// <summary>
        /// The method name
        /// </summary>
        public string Method { get; set; }

        /// <summary>
        /// JSON-serialized method parameters
        /// </summary>
        public string Parameters { get; set; }

    }

    /// <summary>
    /// Answers a custom query; for bots only
    /// </summary>
    public partial class AnswerCustomQuery : Function<Ok>
    {
        /// <summary>
        /// Identifier of a custom query
        /// </summary>
        public long CustomQueryId { get; set; }

        /// <summary>
        /// JSON-serialized answer to the query
        /// </summary>
        public string Data { get; set; }

    }

    /// <summary>
    /// Succeeds after a specified amount of time has passed. Can be called before initialization
    /// </summary>
    public partial class SetAlarm : Function<Ok>
    {
        /// <summary>
        /// Number of seconds before the function returns
        /// </summary>
        public double Seconds { get; set; }

    }

    /// <summary>
    /// Returns information about existing countries. Can be called before authorization
    /// </summary>
    public partial class GetCountries : Function<Countries>
    {
    }

    /// <summary>
    /// Uses the current IP address to find the current country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization
    /// </summary>
    public partial class GetCountryCode : Function<Text>
    {
    }

    /// <summary>
    /// Returns information about a phone number by its prefix. Can be called before authorization
    /// </summary>
    public partial class GetPhoneNumberInfo : Function<PhoneNumberInfo>
    {
        /// <summary>
        /// The phone number prefix
        /// </summary>
        public string PhoneNumberPrefix { get; set; }

    }

    /// <summary>
    /// Returns information about a phone number by its prefix synchronously. getCountries must be called at least once after changing localization to the specified language if properly localized country information is expected. Can be called synchronously
    /// </summary>
    public partial class GetPhoneNumberInfoSync : Function<PhoneNumberInfo>
    {
        /// <summary>
        /// A two-letter ISO 639-1 country code for country information localization
        /// </summary>
        public string LanguageCode { get; set; }

        /// <summary>
        /// The phone number prefix
        /// </summary>
        public string PhoneNumberPrefix { get; set; }

    }

    /// <summary>
    /// Returns the link for downloading official Telegram application to be used when the current user invites friends to Telegram
    /// </summary>
    public partial class GetApplicationDownloadLink : Function<HttpUrl>
    {
    }

    /// <summary>
    /// Returns information about a tg:// deep link. Use "tg://need_update_for_some_feature" or "tg:some_unsupported_feature" for testing. Returns a 404 error for unknown links. Can be called before authorization
    /// </summary>
    public partial class GetDeepLinkInfo : Function<DeepLinkInfo>
    {
        /// <summary>
        /// The link
        /// </summary>
        public string Link { get; set; }

    }

    /// <summary>
    /// Returns application config, provided by the server. Can be called before authorization
    /// </summary>
    public partial class GetApplicationConfig : Function<JsonValue>
    {
    }

    /// <summary>
    /// Saves application log event on the server. Can be called before authorization
    /// </summary>
    public partial class SaveApplicationLogEvent : Function<Ok>
    {
        /// <summary>
        /// Event type
        /// </summary>
        public string Type { get; set; }

        /// <summary>
        /// Optional chat identifier, associated with the event
        /// </summary>
        public long ChatId { get; set; }

        /// <summary>
        /// The log event data
        /// </summary>
        public JsonValue Data { get; set; }

    }

    /// <summary>
    /// Adds a proxy server for network requests. Can be called before authorization
    /// </summary>
    public partial class AddProxy : Function<Proxy>
    {
        /// <summary>
        /// Proxy server IP address
        /// </summary>
        public string Server { get; set; }

        /// <summary>
        /// Proxy server port
        /// </summary>
        public int Port { get; set; }

        /// <summary>
        /// True, if the proxy needs to be enabled
        /// </summary>
        public bool Enable { get; set; }

        /// <summary>
        /// Proxy type
        /// </summary>
        public ProxyType Type { get; set; }

    }

    /// <summary>
    /// Edits an existing proxy server for network requests. Can be called before authorization
    /// </summary>
    public partial class EditProxy : Function<Proxy>
    {
        /// <summary>
        /// Proxy identifier
        /// </summary>
        public int ProxyId { get; set; }

        /// <summary>
        /// Proxy server IP address
        /// </summary>
        public string Server { get; set; }

        /// <summary>
        /// Proxy server port
        /// </summary>
        public int Port { get; set; }

        /// <summary>
        /// True, if the proxy needs to be enabled
        /// </summary>
        public bool Enable { get; set; }

        /// <summary>
        /// Proxy type
        /// </summary>
        public ProxyType Type { get; set; }

    }

    /// <summary>
    /// Enables a proxy. Only one proxy can be enabled at a time. Can be called before authorization
    /// </summary>
    public partial class EnableProxy : Function<Ok>
    {
        /// <summary>
        /// Proxy identifier
        /// </summary>
        public int ProxyId { get; set; }

    }

    /// <summary>
    /// Disables the currently enabled proxy. Can be called before authorization
    /// </summary>
    public partial class DisableProxy : Function<Ok>
    {
    }

    /// <summary>
    /// Removes a proxy server. Can be called before authorization
    /// </summary>
    public partial class RemoveProxy : Function<Ok>
    {
        /// <summary>
        /// Proxy identifier
        /// </summary>
        public int ProxyId { get; set; }

    }

    /// <summary>
    /// Returns list of proxies that are currently set up. Can be called before authorization
    /// </summary>
    public partial class GetProxies : Function<Proxies>
    {
    }

    /// <summary>
    /// Returns an HTTPS link, which can be used to add a proxy. Available only for SOCKS5 and MTProto proxies. Can be called before authorization
    /// </summary>
    public partial class GetProxyLink : Function<HttpUrl>
    {
        /// <summary>
        /// Proxy identifier
        /// </summary>
        public int ProxyId { get; set; }

    }

    /// <summary>
    /// Computes time needed to receive a response from a Telegram server through a proxy. Can be called before authorization
    /// </summary>
    public partial class PingProxy : Function<Seconds>
    {
        /// <summary>
        /// Proxy identifier. Use 0 to ping a Telegram server without a proxy
        /// </summary>
        public int ProxyId { get; set; }

    }

    /// <summary>
    /// Sets new log stream for internal logging of TDLib. Can be called synchronously
    /// </summary>
    public partial class SetLogStream : Function<Ok>
    {
        /// <summary>
        /// New log stream
        /// </summary>
        public LogStream LogStream { get; set; }

    }

    /// <summary>
    /// Returns information about currently used log stream for internal logging of TDLib. Can be called synchronously
    /// </summary>
    public partial class GetLogStream : Function<LogStream>
    {
    }

    /// <summary>
    /// Sets the verbosity level of the internal logging of TDLib. Can be called synchronously
    /// </summary>
    public partial class SetLogVerbosityLevel : Function<Ok>
    {
        /// <summary>
        /// New value of the verbosity level for logging. Value 0 corresponds to fatal errors, value 1 corresponds to errors, value 2 corresponds to warnings and debug warnings, value 3 corresponds to informational, value 4 corresponds to debug, value 5 corresponds to verbose debug, value greater than 5 and up to 1023 can be used to enable even more logging
        /// </summary>
        public int NewVerbosityLevel { get; set; }

    }

    /// <summary>
    /// Returns current verbosity level of the internal logging of TDLib. Can be called synchronously
    /// </summary>
    public partial class GetLogVerbosityLevel : Function<LogVerbosityLevel>
    {
    }

    /// <summary>
    /// Returns list of available TDLib internal log tags, for example, ["actor", "binlog", "connections", "notifications", "proxy"]. Can be called synchronously
    /// </summary>
    public partial class GetLogTags : Function<LogTags>
    {
    }

    /// <summary>
    /// Sets the verbosity level for a specified TDLib internal log tag. Can be called synchronously
    /// </summary>
    public partial class SetLogTagVerbosityLevel : Function<Ok>
    {
        /// <summary>
        /// Logging tag to change verbosity level
        /// </summary>
        public string Tag { get; set; }

        /// <summary>
        /// New verbosity level; 1-1024
        /// </summary>
        public int NewVerbosityLevel { get; set; }

    }

    /// <summary>
    /// Returns current verbosity level for a specified TDLib internal log tag. Can be called synchronously
    /// </summary>
    public partial class GetLogTagVerbosityLevel : Function<LogVerbosityLevel>
    {
        /// <summary>
        /// Logging tag to change verbosity level
        /// </summary>
        public string Tag { get; set; }

    }

    /// <summary>
    /// Adds a message to TDLib internal log. Can be called synchronously
    /// </summary>
    public partial class AddLogMessage : Function<Ok>
    {
        /// <summary>
        /// The minimum verbosity level needed for the message to be logged; 0-1023
        /// </summary>
        public int VerbosityLevel { get; set; }

        /// <summary>
        /// Text of a message to log
        /// </summary>
        public string Text { get; set; }

    }

    /// <summary>
    /// Does nothing; for testing only. This is an offline method. Can be called before authorization
    /// </summary>
    public partial class TestCallEmpty : Function<Ok>
    {
    }

    /// <summary>
    /// Returns the received string; for testing only. This is an offline method. Can be called before authorization
    /// </summary>
    public partial class TestCallString : Function<TestString>
    {
        /// <summary>
        /// String to return
        /// </summary>
        public string X { get; set; }

    }

    /// <summary>
    /// Returns the received bytes; for testing only. This is an offline method. Can be called before authorization
    /// </summary>
    public partial class TestCallBytes : Function<TestBytes>
    {
        /// <summary>
        /// Bytes to return
        /// </summary>
        public Memory<byte> X { get; set; }

    }

    /// <summary>
    /// Returns the received vector of numbers; for testing only. This is an offline method. Can be called before authorization
    /// </summary>
    public partial class TestCallVectorInt : Function<TestVectorInt>
    {
        /// <summary>
        /// Vector of numbers to return
        /// </summary>
        public int[] X { get; set; }

    }

    /// <summary>
    /// Returns the received vector of objects containing a number; for testing only. This is an offline method. Can be called before authorization
    /// </summary>
    public partial class TestCallVectorIntObject : Function<TestVectorIntObject>
    {
        /// <summary>
        /// Vector of objects to return
        /// </summary>
        public TestInt[] X { get; set; }

    }

    /// <summary>
    /// Returns the received vector of strings; for testing only. This is an offline method. Can be called before authorization
    /// </summary>
    public partial class TestCallVectorString : Function<TestVectorString>
    {
        /// <summary>
        /// Vector of strings to return
        /// </summary>
        public string[] X { get; set; }

    }

    /// <summary>
    /// Returns the received vector of objects containing a string; for testing only. This is an offline method. Can be called before authorization
    /// </summary>
    public partial class TestCallVectorStringObject : Function<TestVectorStringObject>
    {
        /// <summary>
        /// Vector of objects to return
        /// </summary>
        public TestString[] X { get; set; }

    }

    /// <summary>
    /// Returns the squared received number; for testing only. This is an offline method. Can be called before authorization
    /// </summary>
    public partial class TestSquareInt : Function<TestInt>
    {
        /// <summary>
        /// Number to square
        /// </summary>
        public int X { get; set; }

    }

    /// <summary>
    /// Sends a simple network request to the Telegram servers; for testing only. Can be called before authorization
    /// </summary>
    public partial class TestNetwork : Function<Ok>
    {
    }

    /// <summary>
    /// Sends a simple network request to the Telegram servers via proxy; for testing only. Can be called before authorization
    /// </summary>
    public partial class TestProxy : Function<Ok>
    {
        /// <summary>
        /// Proxy server IP address
        /// </summary>
        public string Server { get; set; }

        /// <summary>
        /// Proxy server port
        /// </summary>
        public int Port { get; set; }

        /// <summary>
        /// Proxy type
        /// </summary>
        public ProxyType Type { get; set; }

        /// <summary>
        /// Identifier of a datacenter, with which to test connection
        /// </summary>
        public int DcId { get; set; }

        /// <summary>
        /// The maximum overall timeout for the request
        /// </summary>
        public double Timeout { get; set; }

    }

    /// <summary>
    /// Forces an updates.getDifference call to the Telegram servers; for testing only
    /// </summary>
    public partial class TestGetDifference : Function<Ok>
    {
    }

    /// <summary>
    /// Does nothing and ensures that the Update object is used; for testing only. This is an offline method. Can be called before authorization
    /// </summary>
    public partial class TestUseUpdate : Function<Update>
    {
    }

    /// <summary>
    /// Returns the specified error and ensures that the Error object is used; for testing only. Can be called synchronously
    /// </summary>
    public partial class TestReturnError : Function<Error>
    {
        /// <summary>
        /// The error to be returned
        /// </summary>
        public Error Error { get; set; }

    }

}
